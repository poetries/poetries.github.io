<!DOCTYPE html>


  <html class="dark page-post">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Linux与Docker系统运维总结 | 前端进阶之旅</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Linux,">
  

  <meta name="description" content="Linux简单介绍 Linux 是一套开源操作系统，它有稳定、消耗资源小、功能很强、安全性高等特点，让它在 服务器领域有庞大的用户群体 目前市面上较知名的发行版有：RedHat、Ubuntu、CentOS、Debian、Fedora、SuSE、OpenSUSE、 Arch Linux、SolusOS 等 常见的服务器操作系统主要有 CentOS 、Ubuntu、Debian,CentOS 现在市场">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux与Docker系统运维总结">
<meta property="og:url" content="http://blog.poetries.top/2022/06/30/linux-summary/index.html">
<meta property="og:site_name" content="前端进阶之旅">
<meta property="og:description" content="Linux简单介绍 Linux 是一套开源操作系统，它有稳定、消耗资源小、功能很强、安全性高等特点，让它在 服务器领域有庞大的用户群体 目前市面上较知名的发行版有：RedHat、Ubuntu、CentOS、Debian、Fedora、SuSE、OpenSUSE、 Arch Linux、SolusOS 等 常见的服务器操作系统主要有 CentOS 、Ubuntu、Debian,CentOS 现在市场">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/366a505fdb77ca61.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/2e64b45acc69230d.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/f3bd51d6f4acf247.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/34c70c7723b1c5b3.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/2025927792fe986a.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/2977a3d908a6b1b3.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/7bdc4513afb0e8c5.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/99bc3d74f889990a.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/d475d80c46a6b836.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/5f8aa431399633c4.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/82cdc649caaa9a4d.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/e0f4f8f2621b11c0.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/0b017f9a76914c6e.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/717f82025ea75291.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/dacef356b4101fd5.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/311938585465b33b.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/4c1ecee2ce96588b.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/a524edcdba080105.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/2681b9ce8eeab9d5.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/59d83f0139c878de.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/7b993abfdc8f07b6.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/df79f11b704aae4d.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/566d2f2270c40840.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/129f0a59b6d7c5d4.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/49bb3cc9f49c2dd1.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/1f9aea9f1c9a18fc.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/691129b326f9fb23.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/6d9b07b85c22e0b5.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/d0ded5a28d96ce59.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/cb0109ef19b551e4.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/a6a34ed8d66f7cdc.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/f7e34f9ea2331ffb.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/5ba00266271ef558.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/16c4541cf84b6e48.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/65357b17bf38f12e.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/639c44fb75dfe354.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/2ce28bda82ab01d4.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/b38b5f228f3bcafe.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/57a4ce88939753b0.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/b6183fc0a23c353d.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/ab4cf5d68cdd846b.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/c40b78b7f3a083f7.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/ee188453d7a2fa5d.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/c7bda56df3a23c53.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/34f02c9235be1c72.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/5e31f8c9d31961df.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/7be573b2aa974fb0.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/dcd42440f0686a39.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/26463dace73153a0.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/d994954b9bc09429.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/c6301becc0c6096b.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/eb659e57bfedb72b.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/9edcca445e5df197.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/69625851feead1f2.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/06/a45d6c71c3c73341.png">
<meta property="og:updated_time" content="2025-03-30T13:54:29.486Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux与Docker系统运维总结">
<meta name="twitter:description" content="Linux简单介绍 Linux 是一套开源操作系统，它有稳定、消耗资源小、功能很强、安全性高等特点，让它在 服务器领域有庞大的用户群体 目前市面上较知名的发行版有：RedHat、Ubuntu、CentOS、Debian、Fedora、SuSE、OpenSUSE、 Arch Linux、SolusOS 等 常见的服务器操作系统主要有 CentOS 、Ubuntu、Debian,CentOS 现在市场">
<meta name="twitter:image" content="https://s.poetries.work/uploads/2022/06/366a505fdb77ca61.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">
<link href="/css/other.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?5081f3afc8d94338e79d319c8b632b31";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  <!-- 聊天系统 -->
  
    
   <link type="text/css" rel="stylesheet" href="/renxi/default.css">
   <style>
      #modal {
        position: static !important;
      }
      .filter {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        background: #fe5757;
        animation: colorChange 30s ease-in-out infinite;
        animation-fill-mode: both;
        mix-blend-mode: overlay;
      }
  
      @keyframes colorChange {
        0%, 100% {
            opacity: 0;
        }
        50% {
            opacity: .9;
        }
      }
   </style>
</head>
</html>
<body>
  
  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/categories/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录<i class="iconfont toc-title" style="display:inline-block;color:#87998d;width:20px;height:20px;">&#xf004b;</i></strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux简单介绍"><span class="toc-text">Linux简单介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux常用命令"><span class="toc-text">Linux常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置服务器的免密码快捷登录"><span class="toc-text">配置服务器的免密码快捷登录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#登录服务器-ssh"><span class="toc-text">登录服务器: ssh</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置别名快速登录：ssh-config"><span class="toc-text">配置别名快速登录：ssh-config</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#免密登录：public-key-与-ssh-copy-id"><span class="toc-text">免密登录：public-key 与 ssh-copy-id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保持连接，防止断掉"><span class="toc-text">保持连接，防止断掉</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux环境变量"><span class="toc-text">Linux环境变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-rsync进行文件拷贝"><span class="toc-text">使用 rsync进行文件拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务安装"><span class="toc-text">服务安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mongodb4-x的安装配置"><span class="toc-text">mongodb4.x的安装配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mongodb的安装"><span class="toc-text">Mongodb的安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#远程连接mongodb"><span class="toc-text">远程连接mongodb</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mongodb4-x卸载"><span class="toc-text">Mongodb4.x卸载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql安装配置"><span class="toc-text">mysql安装配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安装redis"><span class="toc-text">安装redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nginx-nodejs-一台服务器站架多个网站"><span class="toc-text">nginx+nodejs 一台服务器站架多个网站</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#搭建-Nodejs-生产环境"><span class="toc-text">搭建 Nodejs 生产环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nodejs-进程管理器-pm2-的使用"><span class="toc-text">nodejs 进程管理器 pm2 的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx-的安装"><span class="toc-text">Nginx 的安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx-反向代理配置"><span class="toc-text">Nginx 反向代理配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相关防火墙配置"><span class="toc-text">相关防火墙配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nginx-nodejs多台服务器负载均衡"><span class="toc-text">nginx+nodejs多台服务器负载均衡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#云服务器部署node项目"><span class="toc-text">云服务器部署node项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nginx配置https"><span class="toc-text">nginx配置https</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker系统管理"><span class="toc-text">docker系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker简介与安装"><span class="toc-text">docker简介与安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么要使用-Docker"><span class="toc-text">为什么要使用 Docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mac-docker安装"><span class="toc-text">mac docker安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-中安装-docker"><span class="toc-text">Linux 中安装 docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安装指定版本的-docker"><span class="toc-text">安装指定版本的 docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卸载-docker"><span class="toc-text">卸载 docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阿里云-Docker-镜像加速器"><span class="toc-text">阿里云 Docker 镜像加速器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker镜像容器仓库"><span class="toc-text">docker镜像容器仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#镜像"><span class="toc-text">镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器"><span class="toc-text">容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#仓库"><span class="toc-text">仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-镜像以及仓库"><span class="toc-text">Docker 镜像以及仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-容器"><span class="toc-text">Docker 容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker应用"><span class="toc-text">docker应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装node"><span class="toc-text">安装node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安装Nginx"><span class="toc-text">安装Nginx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安装mysql"><span class="toc-text">安装mysql</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安装redis-1"><span class="toc-text">安装redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安装MongoDB"><span class="toc-text">安装MongoDB</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile"><span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile-构建一个-nginx-镜像"><span class="toc-text">Dockerfile 构建一个 nginx 镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile-详解"><span class="toc-text">Dockerfile 详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile-构建-Centos-并安装-net-tools-yum-软件"><span class="toc-text">Dockerfile 构建 Centos 并安装 net-tools yum 软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile-自动部署-Nodejs-程序"><span class="toc-text">Dockerfile 自动部署 Nodejs 程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置docker网络"><span class="toc-text">配置docker网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Network-详解"><span class="toc-text">Docker Network 详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-网络的四种模式"><span class="toc-text">Docker 网络的四种模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器直接网络连接演示"><span class="toc-text">容器直接网络连接演示</span></a></li></ol></li></ol></li></ol>
  </div>
  




<div class="content content-post CENTER">
   <!-- canvas 彩带 -->
<canvas id="evanyou" width="1302" height="678" style="position: fixed;width: 100%;height: 100%;top: 0;left:0;z-index:-1;"></canvas>

<div class="qrcode_container">
  <div class="tencent_code">
    <h4>关注作者公众号</h4> 
    <p>和万千小伙伴一起学习</p> 
    <img src="https://interview.poetries.top/qrcode.jpg" alt="公众号：前端进价之旅">
  </div> 
</div>

<article id="post-linux-summary" class="article article-type-post" itemprop="blogPost">
  <header class="article-header" style="position:relative;">
    <h1 class="post-title">Linux与Docker系统运维总结</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2022.06.30</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Poetry</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Back-end/">Back-end</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
       
          <span class="post-count">
            <i class="fa fa-file-word-o"></i>&nbsp
            <span>字数统计 14.6k字</span>
          </span>

          <span class="post-count">
            <i class="fa fa-columns"></i>&nbsp
            <span>阅读时长 62分</span>
          </span>
      
      
    </div>

    <i class="iconfont" id="toc-eye" style="display:inline-block;color:#b36619;position:absolute;top:20px;right:-11px;cursor:pointer;
    font-size: 24px;">&#xe61c;</i>

  </header>

  <div class="article-content">
    
      <div id="container">
        <h2 id="Linux简单介绍"><a href="#Linux简单介绍" class="headerlink" title="Linux简单介绍"></a>Linux简单介绍</h2><ul>
<li>Linux 是一套开源操作系统，它有稳定、消耗资源小、功能很强、安全性高等特点，让它在 服务器领域有庞大的用户群体</li>
<li>目前市面上较知名的发行版有：RedHat、Ubuntu、CentOS、Debian、Fedora、SuSE、OpenSUSE、 Arch Linux、SolusOS 等</li>
<li>常见的服务器操作系统主要有 <code>CentOS</code> 、<code>Ubuntu</code>、<code>Debian</code>,<code>CentOS</code> 现在市场占有率第一</li>
</ul>
<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><ul>
<li><code>init 0</code>  关机 </li>
<li><code>init 6</code>   重启   </li>
<li><code>ls</code>  、 <code>ls -l</code>  、  <code>ll</code> 列出出当前目录下的文件 </li>
<li><code>cd</code>  切换目录</li>
<li><code>pwd</code> 查看当前路径</li>
<li><code>ctrl+c</code>     中断当前程序</li>
<li><code>ctrl+l  / (clear)</code>   清屏</li>
<li><code>ifconfig/ipconfig</code>    查看网卡信息</li>
<li><code>ping 127.0.0.1</code>   看网络是否通畅</li>
<li>Linux 创建用户修改密码<ul>
<li>添加用户 <code>useradd zhangsan</code></li>
<li>设置密码 <code>passwd zhangsan</code></li>
<li>删除用户 <code>userdel -rf zhangsan</code>  <code>-r</code>：递归的删除目录下面文件以及子目录下文件。</li>
</ul>
</li>
<li>文件管理<ul>
<li>创建文件 <code>touch file</code></li>
<li>删除文件 <code>rm -rf file</code><ul>
<li><code>-r</code>：递归的删除目录下面文件以及子目录下文件。<ul>
<li><code>-f</code>：强制删除，忽略不存在的文件，从不给出提示    </li>
</ul>
</li>
</ul>
</li>
<li>修改文件名 <code>mv file1 file11</code></li>
<li>查看文件内容 <code>cat file1</code></li>
<li>复制文件 <code>cp file2 file22</code></li>
<li>移动文件 <code>mv file1 file11</code></li>
<li>编辑文件 <code>vi file1</code></li>
<li>批量创建文件 <code>touch file{1..10}</code>     <code>rm -rf file{1..10}</code></li>
<li>查看文件前3行 <code>cat file1 | head -3</code></li>
<li>查看文件后3行    <code>cat file1 | tail -3</code></li>
<li>liunx服务器上面查找文件<ul>
<li><code>find</code> 查找文件<ul>
<li><code>find / -name httpd.conf</code> 查找当前目录下的文件名为 <code>httpd.conf</code> 的文件</li>
<li><code>find</code> 目录 <code>-name</code>  文件名</li>
</ul>
</li>
</ul>
</li>
<li>查找文件里面内容找到<code>httpd.conf</code> 里面有<code>listen</code><ul>
<li><code>cat httpd.conf | grep listen</code></li>
<li><code>cat httpd.conf | grep -ignore listen   /  cat httpd.conf | grep -i listen</code>  忽略大小写</li>
</ul>
</li>
<li>查找文件里面内容  vi搜索 <ul>
<li><code>vi  httpd.conf</code></li>
<li>输入 <code>/Listen</code> 搜索<code>Listen</code> <code>N</code>下一个</li>
</ul>
</li>
</ul>
</li>
<li>Linux 目录管理<ul>
<li>创建目录 <code>mkdir dir1 dir2 dir3</code></li>
<li>删除目录 <code>rm -rf dir1 dir2</code><ul>
<li><code>-r</code>：递归的删除目录下面文件以及子目录下文件。<ul>
<li><code>-f</code>：强制删除，忽略不存在的文件，从不给出提示</li>
<li><code>rm -rf  dir*</code> 以<code>dir</code>开头的所有文件删除</li>
</ul>
</li>
</ul>
</li>
<li>重命名目录或移动目录    <code>mv dir1 dir11</code></li>
<li>查看目录 <code>ls  / ll</code></li>
<li>递归创建目录 <code>mkdir -p a/b/c/d/e/f/g</code> 创建多层级目录</li>
<li>递归查看目录 <code>tree a</code>  tree命令不存在的话需要安装 <code>yum install tree -y</code></li>
<li>复制目录 <code>cp  -rf  wwwroot/ mywwwroot/</code></li>
</ul>
</li>
<li>Linux 打包压缩别名管理<ul>
<li>zip压缩包<ul>
<li>安装zip减压软件 <code>yum install -y unzip zip</code></li>
<li>zip压缩包 <code>zip -r public.zip public</code> <code>-r</code> 递归 表示将指定的目录下的所有子目录以及文件一起处理</li>
<li>解压 <code>unzip public.zip</code> <code>unzip public.zip -d dir</code></li>
<li>查看 <code>unzip -l public.zip</code></li>
</ul>
</li>
<li>gz压缩包:  (源代码压缩)<ul>
<li>Linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲tar命令的基本用法</li>
<li>制作gz包 <code>tar czvf public.tar.gz public</code></li>
<li>解压gz包 <code>tar xzvf public.tar.gz</code></li>
<li>查看gz包 <code>tar tf public.tar.gz</code></li>
</ul>
</li>
<li>tar包<ul>
<li><code>tar cvf wwwroot.tar wwwroot</code> 仅打包，不压缩！</li>
<li>解压tar包 <code>tar xvf wwwroot.tar</code> </li>
</ul>
</li>
<li>xz压缩包<ul>
<li>对于xz这个压缩相信很多人陌生，但xz是绝大数linux默认就带的一个压缩工具，xz格式比7z还要小。</li>
<li>制作<pre><code>- `tar  cvf xxx.tar xxx`  这样创建xxx.tar文件先，
- `xz  xxx.tar`      将 xxx.tar压缩成为 xxx.tar.xz       删除原来的tar包
- `xz  -k xxx.tar`     将 xxx.tar压缩成为 xxx.tar.xz      保留原来的tar包
</code></pre></li>
<li>解压<pre><code>- `xz   -d  ***.tar.xz`   先解压xz   删除原来的xz包
- `xz  -dk  ***.tar.xz`   先解压xz  保留原来的xz包
- `tar  -xvf  ***.tar` 再解压tar
</code></pre><ul>
<li>查看 <code>xz  -l  ***.tar.xz</code>   先解压xz</li>
</ul>
</li>
</ul>
</li>
<li>别名管理<ul>
<li>添加别名<pre><code>- `alias chttp=&apos;cat /etc/httpd/conf/httpd.conf&apos;`
  - `chttp`
</code></pre></li>
<li>删除别名 <code>unalias chttp</code></li>
<li>查看别名 <code>alias</code></li>
</ul>
</li>
</ul>
</li>
<li>用户管理、用户权限管理<ul>
<li>用户管理<ul>
<li>添加用户 <code>useradd lisi</code></li>
<li>设置密码 <code>passwd lisi</code></li>
<li>删除用户<ul>
<li><code>userdel -r lisi</code></li>
<li><code>-r</code>：递归的删除目录下面文件以及子目录下文件。<pre><code>- 备注：删除用户的时候用户组被删除
</code></pre></li>
</ul>
</li>
<li>查看用户 <code>id user</code></li>
<li>把用户加入组 <ul>
<li><code>gpasswd -a testuser root</code></li>
<li>把用户<code>testuser</code>加入到<code>root</code>组，加入组后<code>testuser</code>获取到<code>user</code>组及<code>root</code>组所有权限</li>
</ul>
</li>
<li>把用户移出租 <code>gpasswd -d testuser root</code></li>
</ul>
</li>
<li>用户权限管理<ul>
<li>drwxr-xr-x.   2 root root 6 4月  11 2022 mnt<ul>
<li><code>rwx</code>   当前用户对mnt有读写执行权限      <code>u</code></li>
<li><code>r-x</code>   当前用户的组对mnt文件有读和执行  <code>g</code></li>
<li><code>r-x</code>   其他用户对mnt也具有读和执行      <code>o</code></li>
</ul>
</li>
<li>权限:<br><code>r</code> 读<br><code>w</code> 写<br><code>x</code> 执行</li>
<li>用户:<ul>
<li>所有者   <code>user u</code></li>
<li>所属组   <code>group  g</code></li>
<li>其他用户 <code>other  o</code></li>
<li>所有用户 <code>all     a</code>  <code>u+g+o=a</code>(表示所有人) </li>
</ul>
</li>
<li>目录的rwx<ul>
<li><code>r</code>  查看目录里面的文件(4)</li>
<li><code>w</code> 在目录里创建或删除文件(2)</li>
<li><code>x</code>  切换进目录(1)</li>
</ul>
</li>
<li>文件的rwx<ul>
<li><code>r</code> 查看文件内容</li>
<li><code>w</code> 在文件里写内容</li>
<li><code>x</code> 执行该文件(文件不是普通文件，是程序或脚本)</li>
</ul>
</li>
<li>chmod权限分配<ul>
<li><code>+</code>增加权限         -删除权限</li>
<li><code>chmod u+x my.sh</code>   给当前用户分配执行<code>my.sh</code>的权限</li>
<li><code>chmod o+r,o+w file.txt</code>    给其他用户分配对<code>file.txt</code>的读写权限</li>
<li><code>chmod o+r,o+w,o+x mnt/</code>     给所有其他用户分配对mnt目录的进入、读取、写入权限</li>
<li><code>chmod -R o+r,o+w,o+x mnt/</code>       修改目录下的所有文件的权限为可读、可修改、可执行</li>
<li><code>chmod 755 file</code></li>
<li><code>chmod -R 777 wwwroot/</code>  修改目录下的所有文件的权限为可读、可修改、可执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>rpm软件安装卸载<ul>
<li>rpm命令安装卸载查找rpm包<ul>
<li>挂载光盘<ul>
<li><code>mount dev/cdrom /media</code>  挂载</li>
<li><code>df</code>  查看光盘是否挂载<pre><code>- 卸载`umount /media`
</code></pre></li>
</ul>
</li>
<li>rpm安装<pre><code>- `rpm -ivh` `rpm`软件包
</code></pre><ul>
<li><code>rpm</code>卸载软件<ul>
<li><code>rpm -e net-tools</code> <code>net-tools</code>表示要卸载的软件包</li>
</ul>
</li>
<li>查看<code>rpm</code>软件包的安装位置 / 软件包是否安装 <code>rpm -ql net-tools</code></li>
</ul>
</li>
</ul>
</li>
<li>Yum安装rpm 卸载rpm 查看rpm包<ul>
<li>yum安装rpm包<pre><code>- `yum install -y net-tools`              包括 `netstat` `ifconfig`等命令
- `yum install -y unzip zip`               `zip`压缩减压
- `yum install -y mlocate`                 `updatedb`
- `yum install -y wget`                    下载文件包
- `yum -y install psmisc`                   `pstree | grep httpd`   查看进程    `pstree -p`   显示进程以及子进程
</code></pre><ul>
<li><code>yum</code>卸载<code>rpm</code>包<ul>
<li><code>yum -y remove wget</code></li>
</ul>
</li>
<li><code>yum</code>搜索<code>npm</code>包<ul>
<li><code>yum search</code> 名称</li>
</ul>
</li>
<li><code>yum</code>查看<code>rpm</code>包<ul>
<li><code>yum list</code></li>
<li><code>yum list | grep httpd</code></li>
<li><code>yum list updates</code>  列出所有可更新的软件包</li>
<li><code>yum list installed</code>   列出所有已安装的软件包</li>
</ul>
</li>
<li>yum显示rpm包信息<ul>
<li><code>yum info package1</code></li>
<li><code>yum info httpd</code>   </li>
<li><code>yum info zip</code></li>
<li><code>yum info unzip</code></li>
</ul>
</li>
</ul>
</li>
<li>yum 安装Apache <pre><code>- `yum -y install httpd`  `service httpd start`   安装启动`apache`
- 启动`apache`
- 关闭防火墙  `systemctl stop firewalld`
</code></pre><ul>
<li><code>yum</code>的主配置文件 <code>etc/yum.conf</code></li>
<li><code>yum</code>的仓库配置文件 <code>/etc/yum.repo.d/*.repo</code></li>
</ul>
</li>
<li>Yum 安装Nginx：<ul>
<li>安装nginx源<ul>
<li><code>sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></li>
</ul>
</li>
<li>查看Nginx源是否配置成功　<ul>
<li>通过<code>yum search nginx</code>看看是否已经添加源成功。如果成功则执行下列命令安装Nginx。</li>
<li>或者 <code>npm info nginx</code>也可以看看<code>nginx</code>源是否添加成功</li>
</ul>
</li>
<li>安装Nginx <code>sudo yum install -y nginx</code></li>
<li>启动Nginx并设置开机自动运行 <ul>
<li><code>sudo systemctl start nginx.service</code></li>
<li><code>sudo systemctl enable nginx.service</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>源代码包的安装<ul>
<li>先安装源代码编译的软件<code>gcc</code>，<code>make</code>，<code>openssl</code> 如下：</li>
<li><code>yum install -y gcc make gcc-c++ openssl-devel</code></li>
<li>检查系统中是否已经安装 gcc：<code>rpm -qa | grep gcc  /  rpm -ql  gcc</code> </li>
<li>编译安装源代码包<pre><code>- 生成编译配置文件(`Makefile`)
- 开始编译(`make`)
- 开始安装(`make install`)
</code></pre><ul>
<li>安装<code>httpd-2.2.9.tar.gz</code>源代码:<ul>
<li>减压并cd到对应目录</li>
<li><code>./configure --prefix=/usr/local/nodejs</code>              安装路径设置为<code>/usr/local/apache</code></li>
<li><code>make   /  make -j4</code></li>
<li><code>make install</code></li>
</ul>
</li>
</ul>
</li>
<li>删除源代码包<pre><code>- 结束当前源代码进程
- 删除源代码
  - 如：结束进程
      - `pstree|grep httpd`
        - `pkill httpd`
    - 删除源代码
      - `cd  /usr/local/`
      - 直接删除源代码 `rm -rf apache/`
</code></pre><ul>
<li>linux下源代码安装nodejs:<ul>
<li>下载nodejs源码包</li>
<li>减压到<code>usr/local/nodejs</code> 目录</li>
<li><code>./configure</code></li>
<li><code>make   /  make -j4</code></li>
<li><code>make install</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Linux 内存、cpu、进程、端口、硬盘管理 <ul>
<li>top命令 查看内存 cpu 进程 以及服务器负载<ul>
<li>top命令的第一行：<pre><code>- `top` - 15:31:47 up  9:30,  3 users,  load average: 0.00, 0.02, 0.05
- 依次对应：系统当前时间 up 系统到目前为止i运行的时间， 当前登陆系统的用户数量， load average后面的三个数字分别表示距离现在一分钟，五分钟，十五分钟的负载情况。
</code></pre><ul>
<li>top命令的第二行：<ul>
<li>Tasks: 133 total,   1 running, 132 sleeping,   0 stopped,   0 zombie</li>
<li>依次对应：tasks表示任务（进程），133 total则表示现在有133 个进程，其中处于运行中的有1个，132 个在休眠（挂起），stopped状态即停止的进程数为0，zombie状态即僵尸的进程数为0个。</li>
</ul>
</li>
<li>top命令的第三行，cpu状态：<ul>
<li>%Cpu(s):  0.2 us,  0.4 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.1 si,  0.0 st</li>
<li>只看空闲就可以了：cpu空闲率为99.3%</li>
</ul>
</li>
<li>top命令的第四行，内存状态：<ul>
<li>KiB Mem :  2897496 total,  1995628 free,   191852 used,   710016 buff/cache</li>
<li>总内存:2.76g  空闲：1995628/1024/1024=1.9g   已经使用0.18g   缓存区内存0.67g  </li>
<li>缓冲区是从主内存中特地预留出的内存，用来存放特定的一些信息，例如从磁盘中取得的文件表，程序正在读取的内容等等</li>
</ul>
</li>
</ul>
</li>
<li>看当前登录的账户who、查看最新操作电脑的用户last<ul>
<li><code>who</code>命令: 显示当前正在系统中的所有用户名字，使用终端设备号，注册时间。 </li>
<li><code>whoami</code> : 显示出当前终端上使用的用户。 </li>
<li><code>last</code>: <code>last</code>作用是显示近期用户或终端的登录情况</li>
</ul>
</li>
<li>查看进程关闭进程</li>
<li>查看进程<pre><code>  - `pstree`        查看进程树
  - `pstree -ap`     显示所有信息
  - `pstree | grep httpd`
  - `pstree -ap | grep httpd`
  - `ps -au`
  - `ps -au |grep httpd`
  - `ps -aux`
- `ps` 中`aux`的含义:
    - 显示现行终端机下的所有程序，包括其他用户的程序（`a`）
    - 以用户为主的格式来显示程序状况。 （`x`）
    - 显示所有程序，不以终端机来区分（`u`）
</code></pre><ul>
<li>关闭进程<ul>
<li><code>pkill httpd</code>   <code>pkill</code>进程的名字</li>
<li><code>kill 2245</code>    <code>kill</code>进程号</li>
<li><code>kill -9 1234</code>   <code>kill -9</code>进程号  强制杀死</li>
<li><code>kill：执行</code>kill`命令，系统会发送一个SIGTERM信号给对应的程序。当程序接收到该signal信号后，将会发生以下事情：<br>程序立刻停止</li>
<li>当程序释放相应资源后再停止</li>
<li>程序可能仍然继续运行</li>
<li>大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后再停止。但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应，我在使用wkhtmltopdf转pdf的项目中遇到这现象），也就是说，SIGTERM多半是会被阻塞的。</li>
<li><code>kill -9</code>:  <code>kill -9</code>命令，系统给对应程序发送的信号是SIGKILL，即<code>exit</code>。<code>exit</code>信号不会被系统阻塞，所以<code>kill -9</code>能顺利杀掉进程。<ul>
<li>查看端口 <code>netstat -tunpl |grep httpd</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>查看硬盘信息：<pre><code>- `df`命令作用是列出文件系统的整体磁盘空间使用情况。可以用来查看磁盘已被使用多少空间和还剩余多少空间。
- `df -h`  以人们易读的方式显示，总共多少g用了多少g
- `df /home`   查看该文件夹所在磁盘的使用情况
</code></pre></li>
</ul>
</li>
<li>Linux <code>systemctl</code>管理服务<ul>
<li><code>yum</code>安装<code>httpd</code><ul>
<li><code>yum install -y httpd</code></li>
<li><code>systemctl start httpd</code></li>
</ul>
</li>
<li><code>systemctl</code>管理服务<ul>
<li>启动服务：<code>systemctl start httpd</code></li>
<li>关闭服务：<code>systemctl stop httpd</code></li>
<li>重启服务：<code>systemctl restart httpd</code></li>
<li>查看一个服务的状态：<code>systemctl status httpd</code></li>
<li>查看一个服务是否在运行：<code>systemctl is-active httpd</code></li>
<li>查看当前已经运行的服务：<code>systemctl list-units -t service</code></li>
<li>列出所有服务：  <code>systemctl list-units -at service</code> 注意顺序 </li>
<li>设置开机自启动：    <code>systemctl enable httpd</code></li>
<li>停止开机自启动：    <code>systemctl disable httpd</code></li>
<li>列出所有自启动服务：<ul>
<li><code>systemctl list-unit-files|grep enabled`</code></li>
<li><code>systemctl list-unit-files|grep disabled`</code></li>
<li><code>systemctl list-unit-files|grep disabled | grep httpd`</code></li>
</ul>
</li>
<li>使指定服务从新加载配置：<code>systemctl reload httpd</code>    </li>
</ul>
</li>
</ul>
</li>
<li>Firewalld防火墙和SELinux防火墙的设置<ul>
<li><code>firewalld</code>的基本使用:<ul>
<li>启动： <code>systemctl start firewalld</code></li>
<li>关闭： <code>systemctl stop firewalld</code></li>
<li>查看状态： <code>systemctl status firewalld</code></li>
<li>开机禁用 ： <code>systemctl disable firewalld</code></li>
<li>开机启用 ： <code>systemctl enable firewalld</code></li>
</ul>
</li>
<li><code>firewall-cmd</code>的基本使用:<ul>
<li>那怎么开启一个端口呢: <code>firewall-cmd --zone=public --add-port=80/tcp --permanent</code> （<code>–permanent</code>永久生效，没有此参数重启后失效）</li>
<li>重新载入: <code>firewall-cmd --reload</code>  修改<code>firewall-cmd</code>配置后必须重启</li>
<li>查看: <code>firewall-cmd --zone= public --query-port=80/tcp</code></li>
<li>删除: <code>firewall-cmd --zone= public --remove-port=80/tcp --permanent</code></li>
<li>查看所有打开的端口：<code>firewall-cmd --zone=public --list-ports</code><ul>
<li>SELinux防火墙的设置</li>
</ul>
</li>
<li>修改<code>/etc/selinux/config</code> 文件</li>
<li>将<code>SELINUX=enforcing</code>改为<code>SELINUX=disabled</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="配置服务器的免密码快捷登录"><a href="#配置服务器的免密码快捷登录" class="headerlink" title="配置服务器的免密码快捷登录"></a>配置服务器的免密码快捷登录</h2><h3 id="登录服务器-ssh"><a href="#登录服务器-ssh" class="headerlink" title="登录服务器: ssh"></a>登录服务器: ssh</h3><blockquote>
<p>ssh，<code>secure shell protocol</code>，以更加安全的方式连接远程服务器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root: 用户名</span></span><br><span class="line"><span class="comment"># 192.168.13.21</span></span><br><span class="line">$ ssh root@192.168.13.21</span><br></pre></td></tr></table></figure>
<h3 id="配置别名快速登录：ssh-config"><a href="#配置别名快速登录：ssh-config" class="headerlink" title="配置别名快速登录：ssh-config"></a>配置别名快速登录：ssh-config</h3><blockquote>
<p>在本地电脑上配置 <code>ssh-config</code>，对自己管理的服务器起别名，可以更方便地登录多台云服务器</p>
</blockquote>
<p><strong>ssh-config 的配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/ssh/ssh_config</span><br><span class="line"></span><br><span class="line">~/.ssh/config</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改~/.ssh/config配置</span></span><br><span class="line">Host tencent <span class="comment"># 服务器别名</span></span><br><span class="line">  HostName 413.12.151.18</span><br><span class="line">  User root</span><br><span class="line"></span><br><span class="line">Host server <span class="comment"># 服务器别名</span></span><br><span class="line">  HostName 192.168.105.130</span><br><span class="line">  User root</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置成功之后直接 <code>ssh</code>  就可以直接登录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录服务器1</span></span><br><span class="line">ssh tencent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录服务器2</span></span><br><span class="line">ssh server</span><br></pre></td></tr></table></figure>
<h3 id="免密登录：public-key-与-ssh-copy-id"><a href="#免密登录：public-key-与-ssh-copy-id" class="headerlink" title="免密登录：public-key 与 ssh-copy-id"></a>免密登录：public-key 与 ssh-copy-id</h3><p><strong>把自己的公钥放在远程服务器的 authorized_keys 中</strong></p>
<blockquote>
<p>把本地文件 <code>~/.ssh/id_rsa.pub</code> 中内容复制粘贴到远程服务器 <code>~/.ssh/authorized_keys</code></p>
</blockquote>
<p>简单来说，就是 Ctrl-C 与 Ctrl-V 操作，不过还有一个更加有效率的工具: <code>ssh-copy-id</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在本地环境进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示你输入密码，成功之后可以直接 ssh 登录，无需密码</span></span><br><span class="line">$ ssh-copy-id tencent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登陆成功，无需密码</span></span><br><span class="line">$ ssh tencent</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录成功服务器，可以看到authorized_keys中的公钥信息</span></span><br><span class="line"></span><br><span class="line">Last login: Tue Jun 28 09:31:25 2022</span><br><span class="line">[root@VM-8-14-centos ~]<span class="comment"># cat ~/.ssh/authorized_keys</span></span><br><span class="line"></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCf4fy+KhLFADybnII3OOOI0MAghkuYgEqPLAbhQfrL+zjj1qSoX1dnaZ9PULykGU+QN4nyRrduZOgvDaUCMR+vPDJH3Nii45HUuKWBpdyA/L1sQ7pLKsBsOca7HK4U0P7lrux2IfnOmbYCz4xPsbc/RDArkYbc2uIszmwvdtgGL49fJn6VUC0TaQvRX5dQWznyC3HgarBze2NoilXfKsBr5V2Moc83QkUZdU8fFiiiolpDHf2narGwz+r1bhZrazfI72nOUTjXd5GXd+VOnZdxnk8njBeAAW87RwZ3b2Cg5FsEckzKWP5ddvVxoPEv8cmk= xx@qq.com</span><br><span class="line">[root@VM-8-14-centos ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h3 id="保持连接，防止断掉"><a href="#保持连接，防止断掉" class="headerlink" title="保持连接，防止断掉"></a>保持连接，防止断掉</h3><p>我们可以通过 <code>man ssh-config</code>，找到每一项的详细释义。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑 ~/.ssh/config</span></span><br><span class="line"></span><br><span class="line">Host *</span><br><span class="line">  ServerAliveInterval 30</span><br><span class="line">  TCPKeepAlive yes</span><br><span class="line">  ServerAliveCountMax 6</span><br><span class="line">  Compression yes</span><br></pre></td></tr></table></figure>
<h2 id="Linux环境变量"><a href="#Linux环境变量" class="headerlink" title="Linux环境变量"></a>Linux环境变量</h2><p>通过 <code>printenv</code> 可获得系统的所有环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ printenv</span><br><span class="line"></span><br><span class="line">TERM_SESSION_ID=w0t0p0:5D9702D2-F505-4D4D-B65B-745A4055x4D13</span><br><span class="line">SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.mIeXmJ4KFo/Listeners</span><br><span class="line">LC_TERMINAL_VERSION=3.4.15</span><br><span class="line">COLORFGBG=7;0</span><br><span class="line">ITERM_PROFILE=Default</span><br><span class="line">XPC_FLAGS=0x0</span><br><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">PWD=/Users/poetry</span><br><span class="line">SHELL=/bin/zsh</span><br><span class="line">TERM_PROGRAM_VERSION=3.4.15</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们也可以通过 <code>printenv</code>，来获得某个环境变量的值</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ printenv NVM_BIN</span><br><span class="line"></span><br><span class="line">/Users/poetry/.nvm/versions/node/v16.15.0/bin</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 <code>$var</code> 或者 <code>${var}</code> 可以取得环境变量，并通过 <code>echo`</code> 进行打印</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$path</span></span><br><span class="line"></span><br><span class="line">/Users/poetry/.nvm/versions/node/v16.15.0/bin /opt/anaconda3/bin /usr/<span class="built_in">local</span>/bin /usr/<span class="built_in">local</span>/sbin /usr/<span class="built_in">local</span>/bin /usr/bin /bin /usr/sbin /sbin</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$HOME</code> 当前用户目录，也就是 <code>~</code> 目录</li>
<li><code>$USER</code> 当前用户名</li>
<li><code>$PATH</code> 环境变量，指向环境变量的路径</li>
<li><code>$SHELL</code> 当前用户的 shell，比如 <code>bash</code>、<code>zsh</code>、<code>fish</code> 等</li>
<li><code>export</code> 可以用来设置环境变量，比如 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span> </span><br><span class="line">$ <span class="built_in">export</span> NODE_ENV=production</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$NODE_ENV</span></span><br><span class="line">production</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要使得配置的环境变量永久有效，需要写入 ~/.bashrc 或者 ~/.zshrc</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在执行命令之前置入环境变量，可以用以指定仅在该命令中有效的环境变量。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该环境变量仅在当前命令中有效</span></span><br><span class="line">$ NODE_ENV=production printenv NODE_ENV</span><br><span class="line">production</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有输出</span></span><br><span class="line">$ printenv NODE_ENV</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在前端中大量使用，如</span></span><br><span class="line">$ NODE_ENV=production npm run build</span><br></pre></td></tr></table></figure>
<h2 id="使用-rsync进行文件拷贝"><a href="#使用-rsync进行文件拷贝" class="headerlink" title="使用 rsync进行文件拷贝"></a>使用 rsync进行文件拷贝</h2><blockquote>
<p>快速高效，支持断点续传、按需复制的文件拷贝工具，并支持远程服务器拷贝，建议在本地也使用 <code>rsync</code> 替换 <code>cp</code> 进行文件拷贝</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将本地的test目录拷贝到服务器的/home目录</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># -l：--links，拷贝符号链接</span></span><br><span class="line"><span class="comment"># -a：--archive，归档模式</span></span><br><span class="line"><span class="comment"># -h：--human-readable，可读化格式进行输出</span></span><br><span class="line"><span class="comment"># -z：--compress，压缩传输</span></span><br><span class="line"><span class="comment"># -v：--verbose，详细输出</span></span><br><span class="line">$ rsync -lahzv ~/Download/<span class="built_in">test</span> root@192.168.12.12:/home</span><br></pre></td></tr></table></figure>
<blockquote>
<p>拷贝目录，则需要看原目录是否以 <code>/</code> 结尾</p>
</blockquote>
<ul>
<li>不以 <code>/</code> 结尾，代表将该目录连同目录名一起进行拷贝</li>
<li>以 <code>/</code> 结尾，代表将该目录下所有内容进行拷贝</li>
</ul>
<h2 id="服务安装"><a href="#服务安装" class="headerlink" title="服务安装"></a>服务安装</h2><h3 id="mongodb4-x的安装配置"><a href="#mongodb4-x的安装配置" class="headerlink" title="mongodb4.x的安装配置"></a>mongodb4.x的安装配置</h3><blockquote>
<p>官方文档：<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</a></p>
</blockquote>
<h4 id="Mongodb的安装"><a href="#Mongodb的安装" class="headerlink" title="Mongodb的安装"></a>Mongodb的安装</h4><p><strong>配置yum源</strong></p>
<ol>
<li>在路径<code>/etc/yum.repos.d/</code>下创建文件<code>mongodb-org-4.0.repo</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">touch mongodb-org-4.0.repo</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在文件<code>mongodb-org-4.0.repo</code>中写入如下内容(下面内容可以直接复制，也可以复制官方文档)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mongodb-org-4.0]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/<span class="variable">$releasever</span>/mongodb-org/4.0/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>安装mongodb  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y mongodb-org</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>开启mongodb服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start mongod </span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入mongod终端</span></span><br><span class="line">$ mongo</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/366a505fdb77ca61.png" alt></p>
<ol start="5">
<li>设置开机启动mongodb    </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable mongod</span><br></pre></td></tr></table></figure>
<h4 id="远程连接mongodb"><a href="#远程连接mongodb" class="headerlink" title="远程连接mongodb"></a>远程连接mongodb</h4><ul>
<li>修改mongo.conf文件<ul>
<li>命令：<code>sudo  vi /etc/mongod.conf</code></li>
<li>将原来bindIp: <code>127.0.0.1</code> 修改为<code>0.0.0.0</code><br><img src="https://s.poetries.work/uploads/2022/06/2e64b45acc69230d.png" alt></li>
</ul>
</li>
<li>重启动mongo服务：<code>service mongod restart</code></li>
<li>永久开放<code>27017</code>端口：<ul>
<li><code>firewall-cmd --zone=public --add-port=27017/tcp --permanent;</code> （<code>--permanent</code>永久生效，没有此参数重启后失效）</li>
<li><code>firewall-cmd --reload</code> </li>
</ul>
</li>
</ul>
<h4 id="Mongodb4-x卸载"><a href="#Mongodb4-x卸载" class="headerlink" title="Mongodb4.x卸载"></a>Mongodb4.x卸载</h4><ul>
<li>停止服务 <code>service mongod stop</code></li>
<li>删除安装的包<ul>
<li><code>rpm -qa | grep mongodb-org</code>   列出所有的包</li>
<li><code>yum remove -y $(rpm -qa | grep mongodb-org)</code></li>
<li>也可以尝试下面命令卸载 <code>yum remove -y  mongodb-org*</code></li>
</ul>
</li>
<li>删除数据及日志<ul>
<li><code>rm -r /var/log/mongodb</code></li>
<li><code>rm -r /var/lib/mongo</code></li>
</ul>
</li>
</ul>
<h3 id="mysql安装配置"><a href="#mysql安装配置" class="headerlink" title="mysql安装配置"></a>mysql安装配置</h3><p>找到<code>mysql</code>的<code>yum</code>源<code>rpm</code>包 <a href="https://dev.mysql.com/downloads/repo/yum" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum</a></p>
<blockquote>
<p>mysql安装源地址：<a href="http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm" target="_blank" rel="noopener">http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</a></p>
</blockquote>
<p>查看机器上面是否安装过mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mysql*</span><br><span class="line">yum list installed | grep mysql*</span><br></pre></td></tr></table></figure>
<p><strong>mysql的安装：</strong></p>
<ul>
<li>安装配置yum源 <code>rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</code></li>
<li>安装 <code>yum -y install mysql-server</code></li>
<li>启动 <code>mysql</code> <code>systemctl start mysqld</code></li>
<li>mysql开机启动    <code>systemctl enable mysqld</code>        </li>
<li>修改 mysql 密码    <ul>
<li>查看mysql默认安装以后的密码</li>
<li>mysql 安装完成之后，在<code>/var/log/mysqld.log</code> 文件中给 <code>root</code> 生成了一个默认密码。通过下面的方式找到 root 默认密码，然后登录 mysql 进行修改</li>
</ul>
</li>
<li><code>mysql -u root -p</code>    输入密码</li>
<li><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;MyNewPass4!&#39;</code>;</li>
<li><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></li>
<li>默认情况mysql对密码要求非常严格<ul>
<li>修改密码策略 在<code>/etc/my.cnf</code> 文件添加 <code>validate_password_policy</code> 配置，指定密码策略</li>
<li>选择 <code>0（LOW），1（MEDIUM），2（STRONG）</code>其中一种，选择 <code>2</code> 需要提供密码字典文件<ul>
<li><code>validate_password_policy=0</code><ul>
<li>如果不需要密码策略，添加 my.cnf 文件中添加如下配置禁用即可：<code>validate_password = off</code></li>
<li>重新启动 mysql 服务使配置生效：<code>systemctl restart mysqld</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>远程管理mysql  添加 <code>mysql</code> 远程登录用户</p>
<ul>
<li><p>把<code>host</code>改为<code>%</code></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user <span class="built_in">set</span> host = <span class="string">'%'</span> <span class="built_in">where</span> user = <span class="string">'root'</span>;</span><br><span class="line">mysql&gt; select host, user from user;</span><br><span class="line">mysql&gt; select host, user from user;</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| host      | user          |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| localhost | mysql.session |</span><br><span class="line">| localhost | mysql.sys     |</span><br><span class="line">| localhost | root          |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; update user <span class="built_in">set</span> host = <span class="string">'%'</span> <span class="built_in">where</span> user = <span class="string">'root'</span>;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select host, user from user;</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| host      | user          |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| %         | root          |</span><br><span class="line">| localhost | mysql.session |</span><br><span class="line">| localhost | mysql.sys     |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">   退出mysql</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置防火墙</li>
<li><code>firewall-cmd --zone=public --add-port=3306/tcp --permanent</code></li>
<li><code>firewall-cmd --reload</code><ul>
<li>最后注意：重启<code>mysql</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><ol>
<li>检查是否有 <code>redis</code> yum 源</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum search redis </span><br><span class="line">yum info redis</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装 epel 仓库</li>
</ol>
<blockquote>
<p>EPEL (Extra Packages for Enterprise Linux)是基于 Fedora 的一个项目，为“红帽系”的操作系 统提供额外的软件包，适用于 RHEL、CentOS 和 Scientific Linux.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>安装 redis 数据库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum info redis </span><br><span class="line">yum install redis -y</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>安装完毕后，使用下面的命令启动 redis 服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start redis</span><br><span class="line">systemctl restart redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure>
<p>linux 上面进入 Redis 客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure>
<h3 id="nginx-nodejs-一台服务器站架多个网站"><a href="#nginx-nodejs-一台服务器站架多个网站" class="headerlink" title="nginx+nodejs 一台服务器站架多个网站"></a>nginx+nodejs 一台服务器站架多个网站</h3><p><img src="https://s.poetries.work/uploads/2022/06/f3bd51d6f4acf247.png" alt></p>
<h4 id="搭建-Nodejs-生产环境"><a href="#搭建-Nodejs-生产环境" class="headerlink" title="搭建 Nodejs 生产环境"></a>搭建 Nodejs 生产环境</h4><ul>
<li>下载 nodejs 二进制代码包，然后减压到 <code>/usr/local/nodejs</code></li>
<li><strong>配置环境变量</strong><ul>
<li><code>vi /etc/profile</code></li>
<li>最后面添加： <ul>
<li><code>export NODE_HOME=/usr/local/nodejs/bin</code></li>
<li><code>export PATH=$NODE_HOME:$PATH</code></li>
</ul>
</li>
<li><code>:wq</code> 保存，然后运行 <code>source /etc/profile</code></li>
</ul>
</li>
</ul>
<h4 id="nodejs-进程管理器-pm2-的使用"><a href="#nodejs-进程管理器-pm2-的使用" class="headerlink" title="nodejs 进程管理器 pm2 的使用"></a>nodejs 进程管理器 pm2 的使用</h4><blockquote>
<p>PM2 是一款非常优秀的 Node 进程管理工具，它有着丰富的特性：能够充分利用多核 CPU 且能够负载均衡、能够帮助应用在崩溃后、指定时间(cluster model)和超出最大内存限制 等情况下实现自动重启。 PM2 是开源的基于 Nodejs 的进程管理器，包括守护进程，监控，日志的一整套完整的功能。</p>
</blockquote>
<p><strong>PM2 的主要特性:</strong></p>
<ul>
<li>内建负载均衡（使用 Node cluster 集群模块） </li>
<li>后台运行 </li>
<li>0 秒停机重载，我理解大概意思是维护升级的时候不需要停机. </li>
<li>具有 Ubuntu 和 CentOS 的启动脚本 </li>
<li>停止不稳定的进程（避免无限循环） </li>
<li>控制台检测</li>
</ul>
<p><strong>PM2 的常见命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行 <code>pm2</code> 的程序并指定 <code>name</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start app.js --name appName </span><br><span class="line">pm2 start app.js -i 3 --name appName 3 <span class="comment"># 启动 3 个进程 （自带负载均衡）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>显示所有进程状态 <code>pm2 list</code></li>
<li>显示所有进程状态 <code>pm2 logs</code></li>
<li>显示一个进程的日志 <code>pm2 logs appName</code></li>
<li>关闭重启所有进程<ul>
<li><code>pm2 stop all</code> # 停止所有进程</li>
<li><code>pm2 restart all</code> # 重启所有进程</li>
<li><code>pm2 reload all</code> # 0 秒停机重载进程 (用于 NETWORKED 进程)</li>
</ul>
</li>
<li>关闭重启指定进程<ul>
<li><code>pm2 stop 0</code> # 停止指定的进程 </li>
<li><code>pm2 restart 0</code> # 重启指定的进程</li>
<li><code>pm2 stop appName</code></li>
<li><code>pm2 restart appName</code></li>
</ul>
</li>
<li>杀死进程<ul>
<li><code>pm2 delete 0</code> # 杀死指定的进程</li>
<li><code>pm2 delete all</code> # 杀死全部进程</li>
<li><code>pm2 delete appName</code> # 杀死指定名字的进程</li>
</ul>
</li>
<li>显示相应进程/应用的总体信息<ul>
<li><code>pm2 show appName</code></li>
</ul>
</li>
</ul>
<h4 id="Nginx-的安装"><a href="#Nginx-的安装" class="headerlink" title="Nginx 的安装"></a>Nginx 的安装</h4><ol>
<li>安装 nginx 源</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看 Nginx 源是否配置成功</li>
</ol>
<ul>
<li>通过 <code>yum search nginx</code> 看看是否已经添加源成功。如果成功则执行下列命令安装 Nginx。 </li>
<li>或者 <code>npm info nginx</code> 也可以看看 nginx 源是否添加成功</li>
</ul>
<ol start="3">
<li>安装 Nginx</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>启动 Nginx 并设置开机自动运行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start nginx </span><br><span class="line">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure>
<h4 id="Nginx-反向代理配置"><a href="#Nginx-反向代理配置" class="headerlink" title="Nginx 反向代理配置"></a>Nginx 反向代理配置</h4><ol>
<li>关闭 Selinux</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 SELINUX=enforcing 为 SELINUX=disabled </span></span><br><span class="line">vi etc/selinux/config </span><br><span class="line"><span class="comment"># 必须重启 </span></span><br><span class="line">linux init 6</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>配置 <code>firewalld</code> 开启 <code>80</code> 端口</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>配置反向代理</li>
</ol>
<p>找到 <code>/etc/nginx/conf.d</code> 然后在里面新建对应网站的配置文件</p>
<p><img src="https://s.poetries.work/uploads/2022/06/34c70c7723b1c5b3.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">  listen 80; </span><br><span class="line">  server_name www.bbb.com; </span><br><span class="line">  location / &#123; </span><br><span class="line">    <span class="comment">#设置主机头和客户端真实地址，以便服务器获取客户端真实 IP </span></span><br><span class="line">    proxy_set_header Host <span class="variable">$host</span>; </span><br><span class="line">    proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>; </span><br><span class="line">    proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>; </span><br><span class="line">    <span class="comment">#禁用缓存 </span></span><br><span class="line">    proxy_buffering off; </span><br><span class="line">    <span class="comment">#反向代理的地址 </span></span><br><span class="line">    proxy_pass http://127.0.0.1:3001; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重启 nginx</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>
<ul>
<li><code>nginx -t</code> 看配置是否正确 </li>
<li><code>systemctl stop nginx</code>  停止nginx</li>
<li><code>systemctl start nginx</code> 启动nginx</li>
</ul>
<p><strong>域名测试</strong></p>
<p>找到 <code>C:\Windows\System32\drivers\etc\hosts</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.1.128 </span><br><span class="line">192.168.1.128 www.bbb.com</span><br></pre></td></tr></table></figure>
<blockquote>
<p>浏览器输入 <code>www.aaa.com</code> nginx 转发到了 <code>127.0.0.1:3001</code></p>
</blockquote>
<h4 id="相关防火墙配置"><a href="#相关防火墙配置" class="headerlink" title="相关防火墙配置"></a>相关防火墙配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment">#  刷新</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有打开的端口： </span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">firewall-cmd --zone= public --remove-port=3306/tcp --permanent</span><br></pre></td></tr></table></figure>
<h4 id="nginx-nodejs多台服务器负载均衡"><a href="#nginx-nodejs多台服务器负载均衡" class="headerlink" title="nginx+nodejs多台服务器负载均衡"></a>nginx+nodejs多台服务器负载均衡</h4><p><img src="https://s.poetries.work/uploads/2022/06/2025927792fe986a.png" alt></p>
<p><strong>负载均衡的种类</strong></p>
<ul>
<li>一种是通过硬件来进行解决，常见的硬件有 NetScaler、F5、Radware 和 Array 等商用的 负载均衡器，但是它们是比较昂贵的</li>
<li>一种是通过软件来进行解决的，常见的软件有 LVS、Nginx、apache 等,它们是基于 Linux 系统并且开源的负载均衡策略.</li>
</ul>
<blockquote>
<p>Nginx 的特点是占有内存少，并发能力强，事实上 nginx 的并发能力确实在同类型的网页服 务器中表现最好，中国大陆使用 nginx 网站用户有：新浪、网易、 腾讯等</p>
</blockquote>
<p><strong>nginx 的 upstream 目前支持 3 种方式的分配</strong></p>
<ul>
<li>轮询（默认）<ul>
<li>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉， 能自动剔除。</li>
</ul>
</li>
<li><code>weight 权重</code> ——you can you up<ul>
<li>指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况</li>
</ul>
</li>
<li><code>ip_hash</code> ip 哈希算法<ul>
<li>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器， 可以解决 session 的问题。</li>
</ul>
</li>
<li>配置负载均衡<ul>
<li>找到 <code>/etc/nginx/conf.d</code> 然后在里面新建对应网站的配置文件</li>
</ul>
</li>
</ul>
<p><img src="https://s.poetries.work/uploads/2022/06/2977a3d908a6b1b3.png" alt></p>
<blockquote>
<p>重启 nginx：<code>systemctl restart nginx</code></p>
</blockquote>
<p><strong>www_aaa_com.conf</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream bakeaaa &#123;</span><br><span class="line">	ip_hash;</span><br><span class="line">	server 127.0.0.1:3001; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.aaa.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      <span class="comment"># 获取客户端的 IP 地址</span></span><br><span class="line">      proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">      proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="comment"># 禁用缓存</span></span><br><span class="line">      proxy_buffering off;</span><br><span class="line">            </span><br><span class="line">      proxy_pass http://bakeaaa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>www_bbb.com.conf</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">upstream bakebbb &#123;</span><br><span class="line">	</span><br><span class="line">	ip_hash;</span><br><span class="line">	server 127.0.0.1:3002 ; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.bbb.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      <span class="comment">#获取客户端真实IP</span></span><br><span class="line">      proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">      proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="comment">#关闭缓存</span></span><br><span class="line">      proxy_buffering off;</span><br><span class="line">            </span><br><span class="line">      proxy_pass http://bakebbb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>www_ccc_com.conf</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream bakeccc &#123;	</span><br><span class="line">	ip_hash;</span><br><span class="line">	server 192.168.1.129:3001; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.ccc.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      <span class="comment"># 获取客户端真实IP</span></span><br><span class="line">      proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">      proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="comment"># 关闭缓存</span></span><br><span class="line">      proxy_buffering off;</span><br><span class="line">            </span><br><span class="line">      proxy_pass http://bakeccc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>负载均衡操作演示</strong></p>
<blockquote>
<p>我们使用docker跑三个nodejs应用程序作为演示</p>
</blockquote>
<p><img src="https://s.poetries.work/uploads/2022/06/7bdc4513afb0e8c5.png" alt></p>
<ul>
<li><strong>使用koa搭建三个服务3001,3002,3003</strong></li>
</ul>
<ol>
<li>3001服务</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World 3001'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3001</span>, ()=&gt;<span class="built_in">console</span>.log(<span class="string">'http://localhost:3001'</span>));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>3002服务</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World 3002'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3002</span>, ()=&gt;<span class="built_in">console</span>.log(<span class="string">'http://localhost:3002'</span>));</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>3003服务</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World 3003'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3003</span>, ()=&gt;<span class="built_in">console</span>.log(<span class="string">'http://localhost:3003'</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在本地启动以上三个服务</p>
</blockquote>
<ul>
<li><strong>docker运行Nginx</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx/Dockerfile</span></span><br><span class="line">FROM daocloud.io/library/nginx:1.13.0-alpine</span><br><span class="line"><span class="comment"># 拷贝配置文件到Nginx目录覆盖默认配置</span></span><br><span class="line"><span class="comment"># COPY conf/nginx.conf /etc/nginx/conf/nginx.conf</span></span><br><span class="line">COPY ./conf.d /etc/nginx/conf.d</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本机<code>conf.d/default.conf</code>文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream bakeaaa &#123;</span><br><span class="line">	ip_hash;</span><br><span class="line">	server 192.168.1.34:3001 weight=1;  <span class="comment"># 192.168.1.34本机ip</span></span><br><span class="line">	server 192.168.1.34:3002 weight=1;</span><br><span class="line">	server 192.168.1.34:3003 weight=3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    <span class="comment"># server_name  www.aaa.com;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      <span class="comment"># 获取客户端真实IP</span></span><br><span class="line">      proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">      proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="comment"># 关闭缓存</span></span><br><span class="line">      proxy_buffering off;</span><br><span class="line">            </span><br><span class="line">      proxy_pass http://bakeaaa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构建nginx镜像 <code>docker build -t nginx-demo .</code></li>
<li>运行nginx镜像 <code>ddocker run --name nginx -d -p 8666:80(本机端口:容器端口) -v /Users/poetry/Download/docker/nginx/conf.d:/etc/nginx/conf.d(本机配置文件目录:容器配置文件目录) e00b36d6975b(nginx镜像ID)</code></li>
<li>运行 <code>docker ps</code> 查看启动的服务</li>
<li>修改配置<code>nginx/conf.d</code>需要重启容器才生效 <code>docker restart nginx(容器名称)</code></li>
</ul>
<blockquote>
<p>修改<code>upstream bakeaaa</code>中的权重等，可以看到不断刷新页面，可以看到不同的服务器负载均衡的效果</p>
</blockquote>
<p><img src="https://s.poetries.work/uploads/2022/06/99bc3d74f889990a.png" alt></p>
<h3 id="云服务器部署node项目"><a href="#云服务器部署node项目" class="headerlink" title="云服务器部署node项目"></a>云服务器部署node项目</h3><ol>
<li>安装 nginx</li>
</ol>
<p>安装nginx源 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>查看 Nginx 源是否配置成功</p>
<ul>
<li>通过 <code>yum search nginx</code> 看看是否已经添加源成功。如果成功则执行下列命令安装 Nginx。 </li>
<li>或者 <code>npm info nginx</code> 也可以看看 nginx 源是否添加成功</li>
</ul>
<p>安装nginx源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure>
<p>启动 <code>Nginx</code> 并设置开机自动运行 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start nginx sudo systemctl enable nginx</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装 nodejs</li>
</ol>
<p>下载 nodejs 二进制代码包，然后减压到 <code>/usr/local/nodejs</code> </p>
<p>配置环境变量 </p>
<p><code>vi /etc/profile</code></p>
<p>最后面添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export NODE_HOME=/usr/local/nodejs/bin </span><br><span class="line">export PATH=$NODE_HOME:$PATH</span><br></pre></td></tr></table></figure>
<p><code>:wq</code> 保存，然后运行 <code>source /etc/profile</code></p>
<ol start="3">
<li>配置 nginx</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  koa.test.com;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#charset koi8-r;</span></span><br><span class="line">  <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    <span class="comment"># 获取客户端真实IP</span></span><br><span class="line">    proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">    proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="comment"># 关闭缓存</span></span><br><span class="line">    proxy_buffering off;</span><br><span class="line">          </span><br><span class="line">    proxy_pass http://127.0.0.1:3001;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  error_page   500 502 503 504  /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="nginx配置https"><a href="#nginx配置https" class="headerlink" title="nginx配置https"></a>nginx配置https</h3><p><strong>为什么要使用 https</strong></p>
<blockquote>
<p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。 </p>
</blockquote>
<p>HTTPS 是在 HTTP 的基础上添加了安全层，从原来的明文传输变成密文传输，当然加密与解 密是需要一些时间代价与开销的，不完全统计有 10 倍的差异。在当下的网络环境下可以忽 略不计，已经成为一种必然趋势。 </p>
<p>目前微信小程序请求 Api 必须用 https、Ios 请求 api 接口必须用 https</p>
<p><strong>配置 https</strong></p>
<p>证书类型 </p>
<ul>
<li>域名型 https 证书（DVSSL）：信任等级一般，只需验证网站的真实性便可颁发证书保护网站</li>
<li>企业型 https 证书（OVSSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高</li>
<li>增强型 https 证书（EVSSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高， 同时可以激活绿色网址栏</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 443; <span class="comment"># 监听443端口</span></span><br><span class="line">  server_name a.test.com;</span><br><span class="line">  ssl on; <span class="comment"># 开启ssl</span></span><br><span class="line">  ssl_certificate /root/nginxssl/1_a.expressjiaocheng.com_bundle.crt; <span class="comment"># ssl证书</span></span><br><span class="line">  ssl_certificate_key /root/nginxssl/2_a.expressjiaocheng.com.key; <span class="comment"># ssl私钥</span></span><br><span class="line">  ssl_session_timeout 5m; <span class="comment"># ssl会话超时时间</span></span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; <span class="comment"># ssl协议</span></span><br><span class="line">  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; <span class="comment"># ssl加密算法</span></span><br><span class="line">  ssl_prefer_server_ciphers on; <span class="comment"># ssl优先选择服务器端加密算法</span></span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    <span class="comment"># 获取客户端真实IP</span></span><br><span class="line">    proxy_set_header Host <span class="variable">$host</span>; <span class="comment"># 设置Host头信息</span></span><br><span class="line">    proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>; <span class="comment"># 设置客户端IP</span></span><br><span class="line">    proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>; <span class="comment"># 设置反向代理IP</span></span><br><span class="line">    <span class="comment"># 关闭缓存</span></span><br><span class="line">    proxy_buffering off;</span><br><span class="line">          </span><br><span class="line">    proxy_pass http://127.0.0.1:3001;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  error_page   500 502 503 504  /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">    root   /usr/share/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="docker系统管理"><a href="#docker系统管理" class="headerlink" title="docker系统管理"></a>docker系统管理</h2><h3 id="docker简介与安装"><a href="#docker简介与安装" class="headerlink" title="docker简介与安装"></a>docker简介与安装</h3><blockquote>
<p>Docker 是一个跨平台的开源的应用容器引擎，诞生于 2013 年初，基于 Go 语言 并遵从 Apache2.0 协议开源</p>
</blockquote>
<p>刚开始学 Docker 你可以把它理解成我们以前学过的虚拟机，但是 Docke 和传统虚拟化方式 的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系 统上再运行所需应用进程；Docker 相比传统的虚拟化技术要更轻量级，Docker 容器内的应 用程序是直接运行在宿主内核中的，容器内没有自己的内核，也没有进行硬件虚拟</p>
<p><img src="https://s.poetries.work/uploads/2022/06/d475d80c46a6b836.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/5f8aa431399633c4.png" alt></p>
<blockquote>
<p>因此 Docker 容器要比传统虚拟机占用资源更小、系统支持量更大、启动速度更快、更容易 维护和扩展。 目前 Docker 是全栈开发者必备的技能之一。 官网：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></p>
</blockquote>
<h4 id="为什么要使用-Docker"><a href="#为什么要使用-Docker" class="headerlink" title="为什么要使用 Docker"></a>为什么要使用 Docker</h4><ul>
<li>开发人员利用 Docker 快速部署 调试我们的应用</li>
<li>开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作，其他机器不能正 常工作”的问题。Docker 可以提供一致的运行环境，开发过程中一个常见的问题是环境一致 性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被 发现。</li>
<li>运维人员利用 Docker 可以在隔离容器中并行运行和管理应用</li>
<li>Serverless 也是基于 docker 容器技术</li>
</ul>
<h4 id="mac-docker安装"><a href="#mac-docker安装" class="headerlink" title="mac docker安装"></a>mac docker安装</h4><p><strong>本地docker环境搭建</strong></p>
<p>mac下安装docker: <code>brew install docker</code>，或者下载安装 <a href="https://docs.docker.com/docker-for-mac/install" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/install</a></p>
<blockquote>
<p><a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> 拉取镜像速度比较慢，我们推荐使用国内的镜像源访问速度较快 <a href="https://hub.daocloud.io" target="_blank" rel="noopener">https://hub.daocloud.io</a></p>
</blockquote>
<p>设置国内镜像源</p>
<p><img src="https://s.poetries.work/uploads/2022/06/82cdc649caaa9a4d.png" alt></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://register.docker-cn.com/"</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入该网站 <code>https://hub.daocloud.io</code> 获取镜像的下载地址</p>
<p><strong>docker命令基础</strong></p>
<ul>
<li><code>docker images</code> 查看镜像</li>
<li><code>docker ps</code> 查看启动的容器 (<code>-a</code> 查看全部)</li>
<li><code>docker rmi 镜像ID</code> 删除镜像</li>
<li><code>docker rm 容器ID</code> 删除容器</li>
<li><code>docker exec -it 1a8eca716169(容器ID:docker ps获取) sh</code> 进入容器内部</li>
<li><code>docker inspect bf70019da487(容器ID)</code> 查看容器内的信息 </li>
</ul>
<blockquote>
<p>删除none的镜像，要先删除镜像中的容器。要删除镜像中的容器，必须先停止容器。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker rmi $(docker images | grep <span class="string">"none"</span> | awk <span class="string">'&#123;print $3&#125;'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker stop $(docker ps -a | grep <span class="string">"Exited"</span> | awk <span class="string">'&#123;print $1 &#125;'</span>) //停止容器</span><br><span class="line"></span><br><span class="line">$ docker rm $(docker ps -a | grep <span class="string">"Exited"</span> | awk <span class="string">'&#123;print $1 &#125;'</span>) //删除容器</span><br><span class="line"></span><br><span class="line">$ docker rmi $(docker images | grep <span class="string">"none"</span> | awk <span class="string">'&#123;print $3&#125;'</span>) //删除镜像</span><br></pre></td></tr></table></figure>
<p><code>docker info</code> 命令可以查看 Docker 容器的配置信息，包括镜像源、网络、磁盘、内存、系统等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker info</span><br><span class="line">Client:</span><br><span class="line"> Context:    default</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Plugins:</span><br><span class="line">  buildx: Docker Buildx (Docker Inc., v0.8.2)</span><br><span class="line">  compose: Docker Compose (Docker Inc., v2.4.1)</span><br><span class="line">  sbom: View the packaged-based Software Bill Of Materials (SBOM) for an image (Anchore Inc., 0.6.0)</span><br><span class="line">  scan: Docker Scan (Docker Inc., v0.17.0)</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 3</span><br><span class="line">  Running: 1</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 2</span><br><span class="line"> Images: 5</span><br><span class="line"> Server Version: 20.10.14</span><br><span class="line"> Storage Driver: overlay2</span><br><span class="line">  Backing Filesystem: extfs</span><br><span class="line">  Supports d_type: true</span><br><span class="line">  Native Overlay Diff: true</span><br><span class="line">  userxattr: false</span><br><span class="line"> Logging Driver: json-file</span><br><span class="line"> Cgroup Driver: cgroupfs</span><br><span class="line"> Cgroup Version: 2</span><br><span class="line"> Plugins:</span><br><span class="line">  Volume: local</span><br><span class="line">  Network: bridge host ipvlan macvlan null overlay</span><br><span class="line">  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line"> Swarm: inactive</span><br><span class="line"> Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc</span><br><span class="line"> Default Runtime: runc</span><br><span class="line"> Init Binary: docker-init</span><br><span class="line"> containerd version: 3df54a852345ae127d1fa3092b95168e4a88e2f8</span><br><span class="line"> runc version: v1.0.3-0-gf46b6ba</span><br><span class="line"> init version: de40ad0</span><br><span class="line"> Security Options:</span><br><span class="line">  seccomp</span><br><span class="line">   Profile: default</span><br><span class="line">  cgroupns</span><br><span class="line"> Kernel Version: 5.10.104-linuxkit</span><br><span class="line"> Operating System: Docker Desktop</span><br><span class="line"> OSType: linux</span><br><span class="line"> Architecture: x86_64</span><br><span class="line"> CPUs: 2</span><br><span class="line"> Total Memory: 3.843GiB</span><br><span class="line"> Name: docker-desktop</span><br><span class="line"> ID: PLR7:VYHP:QZEW:EDCY:4EDN:K77K:M7H5:CHIG:VRZE:OD34:TACY:4MI5</span><br><span class="line"> Docker Root Dir: /var/lib/docker</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> HTTP Proxy: http.docker.internal:3128</span><br><span class="line"> HTTPS Proxy: http.docker.internal:3128</span><br><span class="line"> No Proxy: hubproxy.docker.internal</span><br><span class="line"> Registry: https://index.docker.io/v1/</span><br><span class="line"> Labels:</span><br><span class="line"> Experimental: false</span><br><span class="line"> Insecure Registries:</span><br><span class="line">  hubproxy.docker.internal:5000</span><br><span class="line">  127.0.0.0/8</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://register.docker-cn.com/</span><br><span class="line"> Live Restore Enabled: false</span><br></pre></td></tr></table></figure>
<h4 id="Linux-中安装-docker"><a href="#Linux-中安装-docker" class="headerlink" title="Linux 中安装 docker"></a>Linux 中安装 docker</h4><p><strong>安装工具包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install yum-utils device-mapper-persistent-data lvm2 -y</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/e0f4f8f2621b11c0.png" alt></p>
<p><strong>设置阿里镜像源</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/0b017f9a76914c6e.png" alt></p>
<p><strong>安装docker</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br></pre></td></tr></table></figure>
<p><strong>启动docker</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设为开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>
<p><strong>设置docker镜像源</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://register.docker-cn.com/"</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续拉取镜像直接从 <a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> 网站拉取速度更快</p>
<p><strong>重启docker</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h4 id="安装指定版本的-docker"><a href="#安装指定版本的-docker" class="headerlink" title="安装指定版本的 docker"></a>安装指定版本的 docker</h4><ul>
<li>要安装特定版本的 Docker Engine，请在 repo 中列出可用版本，然后选择并安装： 一种。</li>
<li>列出并排序您的存储库中可用的版本。此示例按版本号对结果进行排序，从高到低， 并被截断：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/717f82025ea75291.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.i o</span><br></pre></td></tr></table></figure>
<h4 id="卸载-docker"><a href="#卸载-docker" class="headerlink" title="卸载 docker"></a>卸载 docker</h4><ul>
<li>卸载 Docker Engine、CLI 和 Containerd 包：<code>$ sudo yum remove docker-ce docker-ce-cli containerd.io</code></li>
<li>主机上的映像、容器、卷或自定义配置文件不会自动删除。删除所有镜像、容器和卷<ul>
<li><code>$ sudo rm -rf /var/lib/docker</code></li>
<li><code>$ sudo rm -rf /var/lib/containerd</code></li>
<li>您必须手动删除任何已编辑的配置文件</li>
</ul>
</li>
</ul>
<h4 id="阿里云-Docker-镜像加速器"><a href="#阿里云-Docker-镜像加速器" class="headerlink" title="阿里云 Docker 镜像加速器"></a>阿里云 Docker 镜像加速器</h4><p>访问 <a href="https://www.aliyun.com/" target="_blank" rel="noopener">https://www.aliyun.com/</a> 搜索 “容器镜像服务”</p>
<p><img src="https://s.poetries.work/uploads/2022/06/dacef356b4101fd5.png" alt></p>
<p>您可以通过修改daemon配置文件<code>/etc/docker/daemon.json</code>来使用加速器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://l6of9ya6.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="docker镜像容器仓库"><a href="#docker镜像容器仓库" class="headerlink" title="docker镜像容器仓库"></a>docker镜像容器仓库</h3><p><img src="https://s.poetries.work/uploads/2022/06/311938585465b33b.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/4c1ecee2ce96588b.png" alt></p>
<h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><blockquote>
<p>Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运 行在 Linux 内核的程序以及相应的数据</p>
</blockquote>
<ul>
<li>镜像是分层（Layer）的：即一个镜像可以多个中间层组成，多个镜像可以共享同一中 间层，我们也可以通过在镜像添加多一层来生成一个新的镜像。</li>
<li>镜像是只读的（read-only）：镜像在构建完成之后，便不可以再修改，而上面我们所说 的添加一层构建新的镜像，这中间实际是通过创建一个临时的容器，在容器上增加或 删除文件，从而形成新的镜像，因为容器是可以动态改变的</li>
</ul>
<p><img src="https://s.poetries.work/uploads/2022/06/a524edcdba080105.png" alt></p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><blockquote>
<p>类似 linux 系统环境，运行和隔离应用。容器从镜像启动的时候，docker 会在镜像的最上一 层创建一个可写层，镜像本身是只读的，保持不变。容器与镜像的关系，就如同面向编程中 对象与类之间的关系。</p>
</blockquote>
<ul>
<li>因为容器是通过镜像来创建的，所以必须先有镜像才能创建容器，而生成的容器是一个独立 于宿主机的隔离进程，并且有属于容器自己的网络和命名空间</li>
<li>镜像由多个中间层（layer）组成，生成的镜像是只读的，但容器却是可读 可写的，这是因为容器是在镜像上面添一层读写层（writer/read layer）来实现的，如下图所 示：</li>
</ul>
<p><img src="https://s.poetries.work/uploads/2022/06/2681b9ce8eeab9d5.png" alt></p>
<h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><blockquote>
<p>仓库（Repository）是集中存储镜像的地方，这里有个概念要区分一下，那就是仓库与仓库 服务器(Registry)是两回事，像我们上面说的 Docker Hub，就是 Docker 官方提供的一个仓库 服务器，不过其实有时候我们不太需要太过区分这两个概念。</p>
</blockquote>
<p><strong>公共仓库</strong></p>
<ul>
<li>公共仓库一般是指 Docker Hub，除了 获取镜像外，我们也可以将自己构建的镜像存放到 Docker Hub，这样，别人也可以使用我们 构建的镜像。</li>
<li>不过要将镜像上传到 Docker Hub，必须先在 Docker 的官方网站上注册一个账号</li>
</ul>
<p><strong>私有仓库</strong></p>
<p>有时候自己部门内部有一些镜像要共享时，如果直接导出镜像拿给别人又比较麻烦，使用像 Docker Hub 这样的公共仓库又不是很方便，这时候我们可以自己搭建属于自己的私有仓库服 务，用于存储和分布我们的镜像。</p>
<h4 id="Docker-镜像以及仓库"><a href="#Docker-镜像以及仓库" class="headerlink" title="Docker 镜像以及仓库"></a>Docker 镜像以及仓库</h4><blockquote>
<p>Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运 行在 Linux 内核的程序以及相应的数据</p>
</blockquote>
<p>镜像结构: <code>registryname/repositoryname/imagename:tagname</code> 例如：<code>docker.io/library/centos:8.3.2011</code></p>
<ul>
<li><code>docker search</code> 搜索镜像 <code>docker search centos</code></li>
<li><code>docker pull</code> 下载镜像 <code>docker pull centos</code><ul>
<li>下载指定的 tag <code>docker pull centos:8.3.2011</code></li>
</ul>
</li>
<li><code>docker images</code> 查看本地镜像</li>
<li><code>docker tag</code> 给镜像打标签<ul>
<li>给镜像打标签可以创建自己的镜像</li>
<li>镜像结构: <code>registryname/repositoryname/imagename:tagname</code></li>
<li>例如：<code>docker.io/library/centos:8.3.2011</code></li>
</ul>
</li>
<li><code>docker rmi 镜像ID -f(强制删除)</code> 删除镜像<ul>
<li>这样删除只会删除对应的标签<code>docker images | grep centos</code></li>
</ul>
</li>
<li>把本地镜像推送到<code>dockerHub</code>仓库<ul>
<li>需要在 dockerHub 上面注册一个账户：<code>https://hub.docker.com/</code></li>
<li>使用<code>docker login</code>本地登录<code>dockerHub</code></li>
<li><code>docker login</code></li>
<li>查看保存的账户信息 <code>cat .docker/config.json</code></li>
</ul>
</li>
<li><code>docker push</code> 镜像名称 把本地镜像推送到远程</li>
</ul>
<h4 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h4><blockquote>
<p>类似 linux 系统环境，运行和隔离应用。容器从镜像启动的时候，docker 会在镜像的最上一 层创建一个可写层，镜像本身是只读的，保持不变。容器与镜像的关系，就如同面向编程中 对象与类之间的关系。</p>
</blockquote>
<p>因为容器是通过镜像来创建的，所以必须先有镜像才能创建容器，而生成的容器是一个独立 于宿主机的隔离进程，并且有属于容器自己的网络和命名空间</p>
<ul>
<li>查看所的容器<ul>
<li><code>docker ps</code></li>
<li><code>docker ps -a</code> 查看所有容器</li>
</ul>
</li>
<li><code>docker run</code> 参数<ul>
<li><code>docker run</code> ：创建一个新的容器并运行一个命令</li>
<li><code>docker run</code> 是日常用的最频繁用的命令之一，同样也是较为复杂的命令之一 命令格式：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code><ul>
<li>参数<ul>
<li><strong>OPTIONS :选项</strong><ul>
<li><code>-i</code>:表示启动一个可交互的容器，并持续打开标准输入</li>
<li><code>-t</code>: 表示使用终端关联到容器的标准输入输出上</li>
<li><code>-d</code>:表示容器放置后台运行</li>
<li><code>--rm</code>:退出后即删除容器</li>
<li><code>--name</code> :表示定义容器唯一名称</li>
<li><code>-p</code> 映射端口</li>
<li><code>-v</code> 指定路径挂载数据卷</li>
<li><code>-e</code> 运行容器传递环境变量</li>
</ul>
</li>
<li><code>IMAGE</code> :表示要运行的镜像</li>
<li><code>COMMAND</code> :表示启动容器时要运行的命令</li>
</ul>
</li>
</ul>
</li>
<li><code>-it</code> 启动一个交互式容器<ul>
<li><code>docker run</code> 启动一个交互式容器在容器内执行<code>/bin/bash</code> 命令</li>
<li><code>docker run -it nginx(镜像ID或名称) /bin/bash</code></li>
</ul>
</li>
</ul>
</li>
<li>删除容器 <code>docker rm 容器ID -f</code></li>
<li>停止容器 <code>docker stop 容器ID</code></li>
<li>启动容器 <code>docker start 容器ID</code></li>
<li>重启容器 <code>docker restart 容器ID</code></li>
<li>进入容器内部<ul>
<li>进入容器内部 <code>docker exec -it 容器ID /bin/bash</code></li>
<li><code>docker exec</code>：进入容器开启一个新的终端（常用） 执行 <code>exit</code> 退出的时候不会停止容器</li>
<li><code>docker attach</code>：进入容器正在执行的终端 <code>exit</code> 退出会停止容器 </li>
</ul>
</li>
<li>查看容器日志 <code>docker logs 容器ID</code><ul>
<li>语法<code>docker logs [OPTIONS] CONTAINER</code></li>
<li><code>-f</code> : 跟踪日志输出</li>
<li><code>--since</code> :显示某个开始时间的所有日志 </li>
<li><code>-t</code> : 显示时间戳 </li>
<li><code>--tail</code> :仅列出最新 <code>N</code> 条容器日志</li>
</ul>
</li>
<li><code>docker commit</code> 容器转换为镜像<ul>
<li>镜像是没有写入权限的，但是我们可以修改容器把容器制作为镜像 </li>
<li>启动一个容器 给容器写入内容</li>
<li><code>docker exec -it 容器ID /bin/bash</code> 进入容器内部，写入内容 <code>echo test &gt; 1.txt</code></li>
<li><code>docker commit 容器ID 自定义镜像名称</code> 将容器转换为镜像</li>
</ul>
</li>
</ul>
<h3 id="docker应用"><a href="#docker应用" class="headerlink" title="docker应用"></a>docker应用</h3><h4 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h4><p>进入<code>https://hub.daocloud.io</code> 搜索node，切换到版本获取下载地址</p>
<ul>
<li><code>docker pull daocloud.io/library/node:12.18</code></li>
<li><code>docker tag 28faf336034d node</code> 重命名镜像</li>
</ul>
<p>重命名镜像后IMAGE ID都是一样的</p>
<p><img src="https://s.poetries.work/uploads/2022/06/59d83f0139c878de.png" alt></p>
<p>也可以导出镜像到本地备份 <code>docker save -o node.image(导出镜像要起的名称) 28faf336034d(要导出的镜像的ID)</code></p>
<p><img src="https://s.poetries.work/uploads/2022/06/7b993abfdc8f07b6.png" alt></p>
<p>我们先删除之前的镜像 <code>docker rmi 28faf336034d -f</code> 强制删除</p>
<p><img src="https://s.poetries.work/uploads/2022/06/df79f11b704aae4d.png" alt></p>
<p>再次导入本地镜像</p>
<p><code>docker load -i node.image(导入的镜像名称)</code></p>
<p><img src="https://s.poetries.work/uploads/2022/06/566d2f2270c40840.png" alt></p>
<p>然后再次重命名镜像即可</p>
<p><code>docker tag 28faf336034d node:v1.0(版本v1.0)</code></p>
<p><img src="https://s.poetries.work/uploads/2022/06/129f0a59b6d7c5d4.png" alt></p>
<h4 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h4><p><img src="https://s.poetries.work/uploads/2022/06/49bb3cc9f49c2dd1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull daocloud.io/library/nginx:1.13.0-alpine</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/1f9aea9f1c9a18fc.png" alt></p>
<p><strong>启动Nginx镜像</strong></p>
<p>服务器上启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name nginx(起一个容器名称) -d(后台运行) -p 80:80(本机:容器) -v(映射Nginx容器的运行目录本机) /root/nginx/log:/var/log/nginx(本机目录:容器目录) -v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf(本机目录:容器内nginx配置所在目录) -v /root/nginx/conf.d:/etc/nginx/conf.d -v /root/nginx/html:/usr/share/nginx/html f00ab1b3ac6d(nginx镜像ID)</span><br></pre></td></tr></table></figure>
<p>本地电脑启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name nginx -d -p 8666:80 -v /Users/poetry/Downloads/docker/nginx/log:/var/log/nginx -v /Users/poetry/Downloads/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /Users/poetry/Downloads/docker/nginx/conf.d:/etc/nginx/conf.d -v /Users/poetry/Downloads/docker/nginx/html:/usr/share/nginx/html f00ab1b3ac6d</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把docker容器中的Nginx服务配置映射本地方便管理</p>
</blockquote>
<p><img src="https://s.poetries.work/uploads/2022/06/691129b326f9fb23.png" alt></p>
<p>访问docker暴露的8666端口即可</p>
<p><img src="https://s.poetries.work/uploads/2022/06/6d9b07b85c22e0b5.png" alt></p>
<p>当我们修改了html中的文件，无需重启容器即可看到效果</p>
<p><img src="https://s.poetries.work/uploads/2022/06/d0ded5a28d96ce59.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/cb0109ef19b551e4.png" alt></p>
<h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h4><p>进入<code>https://hub.daocloud.io</code> 搜索mysql，切换到版本获取下载地址</p>
<p><img src="https://s.poetries.work/uploads/2022/06/a6a34ed8d66f7cdc.png" alt></p>
<ul>
<li><code>docker pull daocloud.io/library/mysql:8.0.20</code></li>
</ul>
<p><img src="https://s.poetries.work/uploads/2022/06/f7e34f9ea2331ffb.png" alt></p>
<p><strong>启动MySQL镜像</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d(后台运行) -p 3307:3306(本机端口:MySQL运行端口) --name mysql(容器名称) -e MYSQL_ROOT_PASSWORD=123456(设置mysql密码) be0dbf01a0f3(mysql镜像ID)</span><br></pre></td></tr></table></figure>
<p><strong>查看当前正在运行的镜像</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a(正在运行和停止的镜像-a都可见)</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/5ba00266271ef558.png" alt></p>
<p><strong>删除容器</strong></p>
<p>删除之前需要stop：<code>docker stop bac2692e2b9a(容器ID)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm bac2692e2b9a(容器ID：docker ps获取)</span><br></pre></td></tr></table></figure>
<p><strong>进入容器内部</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it bac2692e2b9a(容器ID) sh(指定进入方式)</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/16c4541cf84b6e48.png" alt></p>
<p>我们使用Navicat新建一个连接测试一下</p>
<p><img src="https://s.poetries.work/uploads/2022/06/65357b17bf38f12e.png" alt></p>
<p>说明我们使用docker安装MySQL的方式是没问题的</p>
<p><strong>查看MySQL容器日志</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs -f(查看最后几条)  bac2692e2b9a(容器ID)</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/639c44fb75dfe354.png" alt></p>
<p><strong>重启容器</strong></p>
<p>如果修改了容器配置，我们需要重新启动容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart bac2692e2b9a(容器ID)</span><br></pre></td></tr></table></figure>
<p><strong>设置MySQL权限</strong></p>
<blockquote>
<p>mysql8.0后，需要设置，否则node连接不上</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it bac2692e2b9a sh</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 远程连接权限</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新加密规则</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'password'</span> PASSWORD EXPIRE NEVER;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新用户密码</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/2ce28bda82ab01d4.png" alt></p>
<p><strong>挂载配置文件目录</strong></p>
<blockquote>
<p>默认数据库的数据是放在容器里面的，这样的话当容器删除会导致数据丢失。我们想的是删 除容器的时候不删除容器里面的 mysql 数据，这个时候启动容器的时候就可以把 mysql 数据 挂载到外部。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d(后台运行) -p 3307:3306(本机端口:MySQL运行端口) -v v /mysql/conf.d:/etc/mysql/conf.d -v /mysql/data:/var/lib/mysql  --name mysql(容器名称) -e MYSQL_ROOT_PASSWORD=123456(设置mysql密码) be0dbf01a0f3(mysql镜像ID)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>docker inspect bac2692e2b9a(容器ID) </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect bac2692e2b9a | grep mysql</span><br></pre></td></tr></table></figure>
<h4 id="安装redis-1"><a href="#安装redis-1" class="headerlink" title="安装redis"></a>安装redis</h4><p><img src="https://s.poetries.work/uploads/2022/06/b38b5f228f3bcafe.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull daocloud.io/library/redis:6.0.3-alpine3.11</span><br></pre></td></tr></table></figure>
<p><strong>启动Redis镜像</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6380:6379 --name redis 29c713657d31(镜像ID) --requirepass 123456(redis登录密码)</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/57a4ce88939753b0.png" alt></p>
<p>或进入redis镜像后在输入密码</p>
<p><img src="https://s.poetries.work/uploads/2022/06/b6183fc0a23c353d.png" alt></p>
<p><strong>交互式进入redis容器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 9751cbc96861(容器ID) sh</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/ab4cf5d68cdd846b.png" alt></p>
<h4 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/c40b78b7f3a083f7.png" alt></p>
<p>启动容器 映射端口 挂载目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name mongoTest -p 27018:27017 -v ~/Downloads/docker/mongo:/data/db -d mongo(镜像ID或名称)</span><br></pre></td></tr></table></figure>
<p><img src="https://s.poetries.work/uploads/2022/06/ee188453d7a2fa5d.png" alt></p>
<p>可以看到通过 <code>-v</code>挂载到本地的数据</p>
<p><img src="https://s.poetries.work/uploads/2022/06/c7bda56df3a23c53.png" alt></p>
<p>进入容器内部 <code>docker exec -it mongoTest(镜像ID或名称) sh</code></p>
<p><img src="https://s.poetries.work/uploads/2022/06/34f02c9235be1c72.png" alt></p>
<p>输入mongo，可以看到mongo已经安装成功了，我们从容器外连接容器的mongo</p>
<p><img src="https://s.poetries.work/uploads/2022/06/5e31f8c9d31961df.png" alt></p>
<p><strong>连接需要密码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name authMongo -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=123456 -p 27019:27017 -v ~/Downloads/docker/authMongo:/data/db mongo(镜像名称或者ID) --auth</span><br></pre></td></tr></table></figure>
<p>进入容器内部</p>
<p><img src="https://s.poetries.work/uploads/2022/06/7be573b2aa974fb0.png" alt></p>
<p>远程连接</p>
<p><img src="https://s.poetries.work/uploads/2022/06/dcd42440f0686a39.png" alt></p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h4 id="Dockerfile-构建一个-nginx-镜像"><a href="#Dockerfile-构建一个-nginx-镜像" class="headerlink" title="Dockerfile 构建一个 nginx 镜像"></a>Dockerfile 构建一个 nginx 镜像</h4><blockquote>
<p>Dockerfile 构建一个 nginx 镜像,构建好的镜像内会有一个 <code>/usr/share/nginx/html/index.html</code> 文件</p>
</blockquote>
<p>新建一个名为 Dockerfile 文件，并在文件内添加以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM nginx </span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'你好 docker'</span> &gt; /usr/share/nginx/html/index.html </span><br><span class="line">WORKDIR /usr/share/nginx/html</span><br></pre></td></tr></table></figure>
<ul>
<li>构建镜像 <code>docker build -t nginx:v1 .</code></li>
<li>进入容器 <code>docker run -it -d -p 8900:80 容器ID</code></li>
<li>[root@localhost ~]# <code>curl 127.0.0.1</code> 你好 docker</li>
</ul>
<h4 id="Dockerfile-详解"><a href="#Dockerfile-详解" class="headerlink" title="Dockerfile 详解"></a>Dockerfile 详解</h4><ul>
<li><code>Dockerfile</code> 文件的文件名建议使用 <code>Dockerfile</code> ，如果是其他文件构建的时候需要指定文件 名</li>
<li>Dockerfile 构建镜像的执行顺序是从上往下</li>
<li>每一个指令都会创建一个新的镜像层，并提交</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM <span class="comment"># 基础境像,一切从这里开始构建 </span></span><br><span class="line">MAINTAINER <span class="comment"># 镜像是谁写的,姓名+邮箱 </span></span><br><span class="line">LABEL <span class="comment"># LABEL 指令用来给镜像添加一些元数据 </span></span><br><span class="line">RUN <span class="comment"># 编译镜像时运行的脚本 </span></span><br><span class="line">COPY <span class="comment"># 编译镜像时复制文件到镜像中 不会解压 </span></span><br><span class="line">ADD <span class="comment"># 编译镜像时复制文件到镜像中 tar.gz 文件会自动解压 </span></span><br><span class="line">WORKDIR <span class="comment"># 镜像的工作目录 </span></span><br><span class="line">CMD <span class="comment"># 设置容器启动的命令 </span></span><br><span class="line">ENTRYPOINT <span class="comment"># 设置容器启动的命令 </span></span><br><span class="line">EXPOSE <span class="comment"># 设置镜像暴露的端口 </span></span><br><span class="line">VOLUME <span class="comment"># 设置容器挂载的卷 </span></span><br><span class="line">ENV <span class="comment"># 设置容器的环境变量</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>FROM</code> 指定哪种镜像作为新镜像的基础镜像，如：<code>FROM ubuntu:14.04</code></li>
<li><code>MAINTAINER</code> 指明该镜像的作者和其电子邮件，如：<code>MAINTAINER &quot;xxxxxxx@qq.com&quot;</code></li>
<li><code>LABEL</code> 给镜像添加信息。使用 <code>docker inspect</code> 可查看镜像的相关信息，如：<ul>
<li><code>LABEL maintainer=&quot;xx@qq.com&quot;</code></li>
<li><code>LABEL version=&quot;1.0&quot;</code></li>
<li><code>LABEL description=&quot;This is description&quot;</code></li>
</ul>
</li>
<li><code>RUN</code> 在新镜像内部执行的命令<ul>
<li>比如安装一些软件、配置一些基础环境，可使用<code>\</code>来换行，如： <code>RUN apt-get update &amp;&amp; apt-get install -y vim</code></li>
<li>也可以使用 <code>exec</code> 格式 <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>的命令，如<ul>
<li><code>RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot;]</code></li>
<li><code>RUN [&quot;yum&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot;]</code></li>
</ul>
</li>
</ul>
</li>
<li><code>COPY</code><ul>
<li>将主机的文件复制到镜像内，如果目的位置不存在，Docker 会自动创建所有需要的目录结 构，但是它只是单纯的复制，并不会去做文件提取和解压工作。如：</li>
<li><code>COPY ./src/ /usr/share/nginx/html/</code></li>
</ul>
</li>
<li><code>ADD</code><ul>
<li>将主机的文件复制到镜像内，如果目的位置不存在，Docker 会自动创建所有需要的目录结 构，并且会解压文件。如：</li>
<li><code>ADD ./src.tar.gz /usr/share/nginx/html/</code></li>
</ul>
</li>
<li><code>WORKDIR</code><ul>
<li>在构建镜像时，指定镜像的工作目录，之后的命令都是基于此工作目录，如果不存在，则会 创建目录</li>
<li><code>WORKDIR /usr/share/nginx/html</code></li>
</ul>
</li>
<li><code>CMD</code><ul>
<li>在构建镜像时，指定容器启动的命令，如果不存在，则会使用镜像的默认启动命令</li>
<li><code>CMD [&quot;/bin/bash&quot;]</code></li>
</ul>
</li>
<li><code>ENTRYPOINT</code><ul>
<li>在构建镜像时，指定容器启动的命令，如果不存在，则会使用镜像的默认启动命令</li>
<li><code>ENTRYPOINT [&quot;/bin/bash&quot;]</code></li>
<li><code>CMD</code> 和 <code>ENTRYPOINT</code> 同样作为容器启动时执行的命令，区别有以下几点<ul>
<li><code>CMD</code> 的命令会被 <code>docker run</code> 的命令覆盖而 <code>ENTRYPOINT</code> 不会</li>
<li>如使用 <code>CMD [&quot;/bin/bash&quot;]</code>或 <code>ENTRYPOINT [&quot;/bin/bash&quot;]</code>后，再使用 <code>docker run -it image</code> 启动容 器，它会自动进入容器内部的交互终端，如同使用 <code>docker run -it image /bin/bash</code></li>
<li>但是如果启动镜像的命令为 <code>docker run -it image /bin/ps</code>，使用 <code>CMD</code> 后面的命令就会被覆盖 转而执行 <code>bin/ps</code> 命令，而 <code>ENTRYPOINT</code> 的则不会，而是会把 <code>docker run</code> 后面的命令当做 <code>ENTRYPOINT</code> 执行命令的参数</li>
</ul>
</li>
</ul>
</li>
<li><code>EXPOSE 暴露端口</code><ul>
<li>在构建镜像时，指定暴露的端口，如果不存在，则会使用镜像的默认端口</li>
<li><code>EXPOSE 8080</code></li>
<li>仅仅是声明了一个暴露的端口</li>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射端口</li>
<li>在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</li>
</ul>
</li>
<li><code>VOLUME</code><ul>
<li>在构建镜像时，指定挂载的卷，如果不存在，则会使用镜像的默认卷</li>
<li><code>VOLUME /usr/share/nginx/html</code></li>
<li>帮助镜像使用者理解这个镜像服务的守护卷，以方便配置映射卷</li>
<li>在运行时使用随机卷映射时，也就是 <code>docker run -v</code> 时，会自动随机映射 <code>VOLUME</code> 的卷。</li>
<li>我们通过 <code>docker inspect</code> 查看通过该 <code>dockerfile</code> 创建的镜像生成的容器</li>
</ul>
</li>
<li><code>ENV</code><ul>
<li>在构建镜像时，指定环境变量，如果不存在，则会使用镜像的默认环境变量</li>
<li><code>ENV PATH=/usr/bin</code></li>
<li>帮助镜像使用者理解这个镜像服务的守护环境变量，以方便配置映射环境变量</li>
<li>在运行时使用随机环境变量映射时，也就是 <code>docker run -e</code> 时，会自动随机映射 <code>ENV</code> 的环境变量。</li>
</ul>
</li>
</ul>
<h4 id="Dockerfile-构建-Centos-并安装-net-tools-yum-软件"><a href="#Dockerfile-构建-Centos-并安装-net-tools-yum-软件" class="headerlink" title="Dockerfile 构建 Centos 并安装 net-tools yum 软件"></a>Dockerfile 构建 Centos 并安装 net-tools yum 软件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dockerfile_centos</span></span><br><span class="line">FROM centos </span><br><span class="line">MAINTAINER xx.com </span><br><span class="line">ENV MyLocal /usr/<span class="built_in">local</span> </span><br><span class="line">WORKDIR <span class="variable">$MyLocal</span> </span><br><span class="line">EXPOSE 80 </span><br><span class="line">VOLUME [<span class="string">"volume1"</span>,<span class="string">"volume2"</span>] </span><br><span class="line">RUN yum install -y net-tools </span><br><span class="line">RUN yum install -y vim </span><br><span class="line">ADD test.tar.gz /root </span><br><span class="line">COPY test.tar.gz /usr/<span class="built_in">local</span> </span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>
<p>编译 编译的时候注意最后面的<code>.</code></p>
<p><code>docker build -f Dockerfile_centos -t centos:v1.0 .</code></p>
<p>查看执行的历史 <code>docker history 镜像名称或者id</code></p>
<h4 id="Dockerfile-自动部署-Nodejs-程序"><a href="#Dockerfile-自动部署-Nodejs-程序" class="headerlink" title="Dockerfile 自动部署 Nodejs 程序"></a>Dockerfile 自动部署 Nodejs 程序</h4><p>项目目录中新建 <code>Dockerfile</code> <code>COPY . /root/wwwroot/</code>表示把项目目录中的代码复制到容器里面的<code>/root/wwwroot</code> 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM node </span><br><span class="line"></span><br><span class="line">COPY . /root/wwwroot/ </span><br><span class="line"></span><br><span class="line">WORKDIR /root/wwwroot/ </span><br><span class="line"></span><br><span class="line">EXPOSE 3000 </span><br><span class="line"></span><br><span class="line">RUN npm install cnpm -g --registry=https://registry.nlark.com </span><br><span class="line"></span><br><span class="line">RUN cnpm install </span><br><span class="line"></span><br><span class="line">CMD node app.js</span><br></pre></td></tr></table></figure>
<p>构建 <code>docker build -t nodeimg:v1.0.1 .</code></p>
<p>运行镜像并且进入容器 <code>docker run -tid --name nodeDemo -p 3000:3000 nodeimg:v1.0.1</code></p>
<h3 id="配置docker网络"><a href="#配置docker网络" class="headerlink" title="配置docker网络"></a>配置docker网络</h3><p>多个容器之间如何通信，是否可以直接连接</p>
<p><img src="https://s.poetries.work/uploads/2022/06/26463dace73153a0.png" alt></p>
<p>首先看看网卡信息</p>
<p><img src="https://s.poetries.work/uploads/2022/06/d994954b9bc09429.png" alt></p>
<blockquote>
<p>：默认情况同一台主机上面的容器是可以互相通信的，默认情况同一台主机上面的容器 和主机之间是可以互相通信的</p>
</blockquote>
<p><strong>通信原理</strong></p>
<blockquote>
<p>我们每启动一个Docker容器，Docker就会给Docker容器分配一个ip，我们只要安装了Docker， 就会有一个网卡 <code>Docker0</code>，<code>Docker0</code> 使用的是桥接模式，使用的技术是 evth-pair 技术</p>
</blockquote>
<h4 id="Docker-Network-详解"><a href="#Docker-Network-详解" class="headerlink" title="Docker Network 详解"></a>Docker Network 详解</h4><ul>
<li>关于 docker network 命令 <code>docker network --help</code></li>
<li><code>docker network ls</code> 查看网络 </li>
<li><code>docker network inspect 网络ID(docker network ls获取)</code> 查看网络详情</li>
</ul>
<h4 id="Docker-网络的四种模式"><a href="#Docker-网络的四种模式" class="headerlink" title="Docker 网络的四种模式"></a>Docker 网络的四种模式</h4><table>
<thead>
<tr>
<th>Docker 网络模式</th>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>host</code> 模式</td>
<td><code>--net=host</code></td>
<td>容器和宿主机共享 <code>Network namespace</code></td>
</tr>
<tr>
<td><code>container</code> 模式</td>
<td><code>--net=container:NAMEorID</code></td>
<td>容器和另外一个容器共享 <code>Network namespace</code>。 <code>kubernetes</code> 中的 <code>pod</code> 就是多个容器共享一个 <code>Network namespace</code>。</td>
</tr>
<tr>
<td><code>none</code> 模式</td>
<td><code>--net=none</code></td>
<td>容器有独立的 <code>Network namespace</code>，但并没有对其 进行任何网络设置，如分配 <code>veth pair</code>和网桥连 接，配置 <code>IP</code> 等。</td>
</tr>
<tr>
<td><code>bridge</code> 模式</td>
<td><code>--net=bridge</code></td>
<td>（默认为该模式）</td>
</tr>
</tbody>
</table>
<p><strong>host 模式</strong></p>
<blockquote>
<p>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡， 配置自己的 IP 等，而是使用宿主机的 IP 和端口。但是，容器的其他方面，如文件系统、进 程列表等还是和宿主机隔离的</p>
</blockquote>
<p>使用 host 模式的容器可以直接使用宿主机的 IP 地址与外界通信，容器内部的服务端口也可 以使用宿主机的端口，不需要进行 NAT，host 最大的优势就是网络性能比较好，但是 docker host 上已经使用的端口就不能再用了，网络的隔离性不好</p>
<p><img src="https://s.poetries.work/uploads/2022/06/c6301becc0c6096b.png" alt></p>
<p><strong>container 模式</strong></p>
<blockquote>
<p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和 宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器 共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还 是隔离的。两个容器的进程可以通过 lo 网卡设备通信</p>
</blockquote>
<p><img src="https://s.poetries.work/uploads/2022/06/eb659e57bfedb72b.png" alt></p>
<p><strong>none 模式</strong></p>
<blockquote>
<p>使用 none 模式，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker 容器进 行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己 为 Docker 容器添加网卡、配置 IP 等。</p>
</blockquote>
<p>这种网络模式下容器只有 lo 回环网络，没有其他网卡。none 模式可以在容器创建时通过 <code>--network=none</code> 来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安 全性</p>
<p><img src="https://s.poetries.work/uploads/2022/06/9edcca445e5df197.png" alt></p>
<p><strong>bridge 模式</strong></p>
<blockquote>
<p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有 容器就通过交换机连在了一个二层网络中</p>
</blockquote>
<p><img src="https://s.poetries.work/uploads/2022/06/69625851feead1f2.png" alt></p>
<p><strong>docker network create 创建网络以及启动容器指定网络</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create --help</span><br></pre></td></tr></table></figure>
<h4 id="容器直接网络连接演示"><a href="#容器直接网络连接演示" class="headerlink" title="容器直接网络连接演示"></a>容器直接网络连接演示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>
<p><strong>创建一个 mysqlNet网络</strong></p>
<ul>
<li><code>--driver bridge</code> 配置网络类型 <code>bridge</code> 桥接</li>
<li><code>--subnet 192.168.1.0/24</code> 配置子网 建议每个网络的范围尽量小</li>
<li><code>--gateway 192.168.1.1</code> 配置网关</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create --driver bridge --subnet 192.168.1.0/24 --gateway 192.168.1.1 mysql Net</span><br></pre></td></tr></table></figure>
<p><strong>启动容器指定网络</strong></p>
<p>我们启动容器的时候可以加上 <code>--net</code> 参数可以指定启动容器的时候使用的网络，如果不加表 示默认使用 <code>docker0</code> 网络</p>
<blockquote>
<p><code>--net bridge</code> 表示使用 <code>docker0</code> 网络</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -tid --name centos01 centos /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker run -tid --name centos01 --net bridge centos /bin/bash</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--net mysqlNet</code> 表示使用我们自定义网络 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -tid --name centos04 --net mysqlNet centos /bin/bash</span><br><span class="line">docker run -tid --name centos05 --net mysqlNet centos /bin/bash</span><br></pre></td></tr></table></figure>
<p>使用主机名称可以 ping 通</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入centos05</span><br><span class="line">docker exec -it centos05 /bin/bash</span><br><span class="line"></span><br><span class="line">$ ping centos04</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it centos05 /bin/bash</span><br><span class="line">[root@5d8bd8036698 /]<span class="comment"># ping centos04</span></span><br><span class="line"></span><br><span class="line">PING centos04 (192.168.1.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos04.mysqlNet (192.168.1.2): icmp_seq=1 ttl=64 time=1.58 ms</span><br><span class="line">64 bytes from centos04.mysqlNet (192.168.1.2): icmp_seq=2 ttl=64 time=0.177 ms</span><br><span class="line">64 bytes from centos04.mysqlNet (192.168.1.2): icmp_seq=3 ttl=64 time=0.123 ms</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不同网络的容器默认没法通信</p>
</blockquote>
<p>我们在<code>centos05</code>容器内<code>ping centos01</code>容器，结果是不成功的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入centos05</span></span><br><span class="line">docker <span class="built_in">exec</span> -it centos05 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># ping centos01容器网络 (172.17.0.2是centos01网络ip `ip addr`获取)</span></span><br><span class="line">ping 172.17.0.2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样我们就把 centos04 和 centos05 加入了我们自定义的 mysqlNet 网络，这样的话 centos04 和 centos05 是互通的，但是 mysqlNet 网络和 docker0 网络默认是不互通的</p>
</blockquote>
<p><img src="https://s.poetries.work/uploads/2022/06/a45d6c71c3c73341.png" alt></p>
<p><strong>docker network connect 实现不同网络之间的连通</strong></p>
<blockquote>
<p>如上图，我们想的是 centos01 可以 访问 mysqlNet 里面的 centos04 和 centos05，这个时候 我们就需要使用 docker network connect 实现网络连通</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network connect mysqlNet centos01</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地网络</span></span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看网络详情</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker network inspect mysqlNet</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"mysqlNet"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"854913f194cab31417f3f589a7970bf0d14a88d74d67bbfbfd15acd79ce774f1"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2022-06-30T03:13:47.053474447Z"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"192.168.1.0/24"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"192.168.1.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"ConfigFrom"</span>: &#123;</span><br><span class="line">            <span class="string">"Network"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ConfigOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"56c1371a31196943da831b3e938d4c0c750e0654d8f103e0745baa125dd6ec81"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"centos01"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"22c7b14acbd9c4ded534e80bd248486a19ccba56a80445788457df1fd8e2e018"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:01:04"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.1.4/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"5d8bd803669872ed21488f6b61077933d50e8009d105c1798da30fd0fcb0ad65"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"centos05"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"bc016cfdfdaa01288d33aa33ad08ff687e32b720c654396bda4d068852c1330c"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:01:03"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.1.3/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"c34b6f27e3a7a8c4956cb3ca965fe63fbabab99c22a3846c8b5aaaa7643de905"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"centos04"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"daf09599773b09cbfd7b92fd14a426dc030c2ce5250277b0726366e2b2c79806"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:01:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.1.2/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>可以看到是ping成功的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> centos01 ping centos05</span><br><span class="line"></span><br><span class="line">PING centos05 (192.168.1.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=1 ttl=64 time=2.28 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=2 ttl=64 time=0.093 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=3 ttl=64 time=0.112 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=4 ttl=64 time=0.105 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=5 ttl=64 time=0.154 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=6 ttl=64 time=0.077 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=7 ttl=64 time=0.158 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=8 ttl=64 time=0.099 ms</span><br></pre></td></tr></table></figure>

      </div>
    
  </div>

</article>

<!-- <button class="assist-btn2 circle" id="assist_btn2" title="点亮屏幕" style="left: 27px; top: 152px;">
  <i class="iconfont" style="display:inline-block;color:red;width:20px;height:20px;">&#xe61d;</i>
</button>
<button class="assist-btn1 circle" id="assist_btn1" title="关闭屏幕亮度" style="left: 27px; top: 152px;">
  <i class="iconfont toc-title" style="display:inline-block;color:red;width:20px;height:20px;">&#xe61d;</i>
</button> -->


<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>	

<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
<script>
  function getCookie(key) {
    if (document.cookie.length > 0) {
      var start = document.cookie.indexOf(key + "=");
      if (start !== -1) {
        start = start + key.length + 1;
        var end = document.cookie.indexOf(";", start);
        if (end === -1) end = document.cookie.length;
        return unescape(document.cookie.substring(start, end));
      }
    }
    return "";
  }
  const feToken = getCookie('fe-token');
  const btw = new BTWPlugin();
  console.log('ft', feToken)
  if(!feToken) {
    btw.init({
      id: "container",
      blogId: "22699-1592137983091-414",
      name: "前端进阶之旅",
      qrcode: "https://poetries1.gitee.io/img-repo/2020/06/qrcode.jpg",
      keyword: "3a3b3c",
    });
  }
</script>

<script type="text/javascript">

// white theme
var body = {color: "#555", background: "#000"};
var a_tag = {color: "#222"};
var header = { background: "#222"};
var logo_line_i = {background: "#222"};
// var post_code = {background: "#eee", color: "#222"};

function switch_theme() {
 $("body").css(body);
 $("a:not('.links-of-author-item a, .site-state-item a, .site-state-posts a, .feed-link a, .motion-element a, .post-tags a, .show-commit-cls a, #donate_board a')").css(a_tag);
 $(".header, .footer").css(header);
 $(".logo-line-before i, .logo-line-after i").css(logo_line_i);
 //$(".post code").css(post_code);
 $("#idhyt-surprise-ball #idhyt-surprise-ball-animation .drag").css(a_tag);
 $(".post-title-link, .posts-expand .post-meta, .post-comments-count, .disqus-comment-count, .post-category a, .post-nav-next a, .post-nav-item a").css(a_tag);
 
 // $("code").css({color: '#c5c8c6', background: '#1d1f21'});
 //$("#assist_btn1").hide(1500);
}

$(function () {
$("#assist_btn2").css("display","none");
 $("#assist_btn1").click(function() {
     switch_theme();
$("div#toc.toc-article").css({
 "background":"#eaeaea",
 "opacity":1
});
$(".toc-article ol").show();
$("#toc.toc-article .toc-title").css("color","#a98602");
$("#assist_btn1").css("display","none");
$("#assist_btn2").css("display","block");
 });
$("#assist_btn2").click(function() {
$("#assist_btn2").css("display","none");
$("#assist_btn1").css("display","block");
$("body").css("background","url(http://www.miaov.com/static/ie/images/news/bg.png)")
     $(".header, .footer").css("background","url(http://www.miaov.com/static/ie/images/news/bg.png)")
$(".toc-article ol").toggle(1000);
 });
});


//背景随机

var Y, O, E, L, B, C, T, z, N, S, A, I;
!function() {
var e = function() {
for (O.clearRect(0, 0, L, B), T = [{
x: 0,
y: .7 * B + C
}, {
x: 0,
y: .7 * B - C
}]; T[1].x < L + C;) t(T[0], T[1])
}, t = function(e, t) {
O.beginPath(), O.moveTo(e.x, e.y), O.lineTo(t.x, t.y);
var n = t.x + (2 * I() - .25) * C,
 r = a(t.y);
O.lineTo(n, r), O.closePath(), N -= S / -50, O.fillStyle = "#" + (127 * A(N) + 128 << 16 | 127 * A(N + S / 3) + 128 << 8 | 127 * A(N + S / 3 * 2) + 128).toString(16), O.fill(), T[0] = T[1], T[1] = {
 x: n,
 y: r
}
}, a = function n(e) {
var t = e + (2 * I() - 1.1) * C;
return t > B || t < 0 ? n(e) : t
};
Y = document.getElementById("evanyou"), O = Y.getContext("2d"), E = window.devicePixelRatio || 1, L = window.innerWidth, B = window.innerHeight, C = 90, z = Math, N = 0, S = 2 * z.PI, A = z.cos, I = z.random, Y.width = L * E, Y.height = B * E, O.scale(E, E), O.globalAlpha = .6, document.onclick = e, document.ontouchstart = e, e()
}()

   
$("#toc-eye").click(function(){
$("#toc.toc-article").toggle(1000);
});

</script>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持poetries</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/weixin.jpg" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/zhifubao.jpg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2022/06/25/cloudbase-summary/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2022/07/01/graphql-koa2-apollo-vue/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/categories/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '5567a2c4abb858009d96',
  clientSecret: 'b9039ec056cf5c2346b3cdb63308a28c163f91e5',
  repo: 'poetries.github.io',
  owner: 'poetries',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: location.pathname,
  admin: ['poetries'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>


  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/clicklove.js"></script>
 
  
</body>
</html>
