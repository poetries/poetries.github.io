<!DOCTYPE html>


  <html class="dark page-post">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>serverless简介及应用 | 前端进阶之旅</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="serverless,">
  

  <meta name="description" content="一、什么是Serverless Serverless 能解决什么问题？理清 Serverless 要解决的问题其实很简单，我们可以从字面上把它拆开来看。Server 这里指服务端，它是 Serverless 解决问题的边界；而 less 我们可以理解为较少关心，它是 Serverless 解决问题的目的。组合在一起就是“较少关心服务端”   第一种：狭义 Serverless（最常见）= Serv">
<meta name="keywords" content="serverless">
<meta property="og:type" content="article">
<meta property="og:title" content="serverless简介及应用">
<meta property="og:url" content="http://blog.poetries.top/2021/04/16/serverless-intro/index.html">
<meta property="og:site_name" content="前端进阶之旅">
<meta property="og:description" content="一、什么是Serverless Serverless 能解决什么问题？理清 Serverless 要解决的问题其实很简单，我们可以从字面上把它拆开来看。Server 这里指服务端，它是 Serverless 解决问题的边界；而 less 我们可以理解为较少关心，它是 Serverless 解决问题的目的。组合在一起就是“较少关心服务端”   第一种：狭义 Serverless（最常见）= Serv">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416155216.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418151945.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418152334.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418152415.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418152436.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418152600.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416155334.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416155401.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418151354.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416155824.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418151433.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418151527.png">
<meta property="og:image" content="https://files.mdnice.com/user/6541/5d7d3769-4fc0-4036-bd1b-91e9a650c2c3.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416160251.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418152848.png">
<meta property="og:image" content="https://files.mdnice.com/user/6541/d63653ac-0a1d-4dfa-9a2a-879f23aa803e.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416161014.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416161535.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416161621.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416161653.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416161728.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416161748.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416161906.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416162735.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416162612.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210416162045.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418165707.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418165751.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418165833.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418171452.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418171543.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418172230.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418172448.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418173047.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418173248.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418174418.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418174139.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418174151.png">
<meta property="og:image" content="https://s0.lgstatic.com/i/image/M00/94/3B/Ciqc1GAXxoiANTROADtU9yybMQY209.gif">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418174309.png">
<meta property="og:image" content="https://blog.poetries.top/img/static/images/20210418174323.png">
<meta property="og:updated_time" content="2025-03-30T13:54:29.500Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="serverless简介及应用">
<meta name="twitter:description" content="一、什么是Serverless Serverless 能解决什么问题？理清 Serverless 要解决的问题其实很简单，我们可以从字面上把它拆开来看。Server 这里指服务端，它是 Serverless 解决问题的边界；而 less 我们可以理解为较少关心，它是 Serverless 解决问题的目的。组合在一起就是“较少关心服务端”   第一种：狭义 Serverless（最常见）= Serv">
<meta name="twitter:image" content="https://blog.poetries.top/img/static/images/20210416155216.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">
<link href="/css/other.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?5081f3afc8d94338e79d319c8b632b31";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  <!-- 聊天系统 -->
  
    
   <link type="text/css" rel="stylesheet" href="/renxi/default.css">
   <style>
      #modal {
        position: static !important;
      }
      .filter {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        background: #fe5757;
        animation: colorChange 30s ease-in-out infinite;
        animation-fill-mode: both;
        mix-blend-mode: overlay;
      }
  
      @keyframes colorChange {
        0%, 100% {
            opacity: 0;
        }
        50% {
            opacity: .9;
        }
      }
   </style>
</head>
</html>
<body>
  
  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/categories/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录<i class="iconfont toc-title" style="display:inline-block;color:#87998d;width:20px;height:20px;">&#xf004b;</i></strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、什么是Serverless"><span class="toc-text">一、什么是Serverless</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、编写你的第一个-Serverless-应用"><span class="toc-text">二、编写你的第一个 Serverless 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#触发器及事件对象"><span class="toc-text">触发器及事件对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#日志输出"><span class="toc-text">日志输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Serverless-应用是怎么运行的"><span class="toc-text">三、Serverless 应用是怎么运行的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用链路：事件驱动函数执行"><span class="toc-text">函数调用链路：事件驱动函数执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数生命周期：冷启动与热启动"><span class="toc-text">函数生命周期：冷启动与热启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FaaS-是怎么分层的"><span class="toc-text">FaaS 是怎么分层的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、如何提高应用开发调试和部署效率"><span class="toc-text">四、如何提高应用开发调试和部署效率</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#应用管理"><span class="toc-text">应用管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用开发"><span class="toc-text">应用开发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、serverless应用"><span class="toc-text">五、serverless应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#阿里云函数计算"><span class="toc-text">阿里云函数计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#腾讯云函数"><span class="toc-text">腾讯云函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用vercel部署你的应用-推荐"><span class="toc-text">使用vercel部署你的应用-推荐</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、场景案例"><span class="toc-text">六、场景案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-使用-Serverless-实现登录注册功能"><span class="toc-text">1 使用 Serverless 实现登录注册功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-身份认证的技术方案"><span class="toc-text">1.1 身份认证的技术方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-从-0-到-1-实现一个登录注册应用"><span class="toc-text">1.2 从 0 到 1 实现一个登录注册应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-实现注册功能"><span class="toc-text">1.3 实现注册功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-实现登录功能"><span class="toc-text">1.4 实现登录功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-验证用户身份"><span class="toc-text">1.5 验证用户身份</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-基于-Serveless-构建弹性可扩展的-Restful-API"><span class="toc-text">2 基于 Serveless 构建弹性可扩展的 Restful API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-内容管理系统的架构设计"><span class="toc-text">2.1 内容管理系统的架构设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-内容管理系统的实现"><span class="toc-text">2.2 内容管理系统的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-用户注册"><span class="toc-text">2.3 用户注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-用户登录"><span class="toc-text">2.4 用户登录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-身份认证"><span class="toc-text">2.5 身份认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-发布文章"><span class="toc-text">2.6 发布文章</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-查询文章"><span class="toc-text">2.7 查询文章</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-更新文章"><span class="toc-text">2.8 更新文章</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-删除文章"><span class="toc-text">2.9 删除文章</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-总结"><span class="toc-text">2.10 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-基于-Serverless-开发高可用音视频处理系统"><span class="toc-text">3 基于 Serverless 开发高可用音视频处理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-传统音视频处理方案"><span class="toc-text">3.1 传统音视频处理方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-基于-Serverless-的音视频处理系统"><span class="toc-text">3.2 基于 Serverless 的音视频处理系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-获取视频时长函数的实现"><span class="toc-text">3.3 获取视频时长函数的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-音视频处理系统的部署"><span class="toc-text">3.4 音视频处理系统的部署</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-使用-React-js-开发-Serverless-服务端渲染应用"><span class="toc-text">4 使用 React.js 开发 Serverless 服务端渲染应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-基于-Serverless-的服务端渲染架构"><span class="toc-text">5 基于 Serverless 的服务端渲染架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-实现一个-Serverless-的服务端渲染应用"><span class="toc-text">5.1 实现一个 Serverless 的服务端渲染应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-首页接口的实现"><span class="toc-text">5.2 首页接口的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-首页页面的实现"><span class="toc-text">5.3 首页页面的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-详情页接口的实现"><span class="toc-text">5.4 详情页接口的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-详情页页面的实现"><span class="toc-text">5.5 详情页页面的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-应用部署"><span class="toc-text">5.6 应用部署</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-总结"><span class="toc-text">5.7 总结</span></a></li></ol></li></ol></li></ol>
  </div>
  




<div class="content content-post CENTER">
   <!-- canvas 彩带 -->
<canvas id="evanyou" width="1302" height="678" style="position: fixed;width: 100%;height: 100%;top: 0;left:0;z-index:-1;"></canvas>

<div class="qrcode_container">
  <div class="tencent_code">
    <h4>关注作者公众号</h4> 
    <p>和万千小伙伴一起学习</p> 
    <img src="https://interview.poetries.top/qrcode.jpg" alt="公众号：前端进价之旅">
  </div> 
</div>

<article id="post-serverless-intro" class="article article-type-post" itemprop="blogPost">
  <header class="article-header" style="position:relative;">
    <h1 class="post-title">serverless简介及应用</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2021.04.16</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Poetry</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Front-End/">Front-End</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
       
          <span class="post-count">
            <i class="fa fa-file-word-o"></i>&nbsp
            <span>字数统计 19.4k字</span>
          </span>

          <span class="post-count">
            <i class="fa fa-columns"></i>&nbsp
            <span>阅读时长 79分</span>
          </span>
      
      
    </div>

    <i class="iconfont" id="toc-eye" style="display:inline-block;color:#b36619;position:absolute;top:20px;right:-11px;cursor:pointer;
    font-size: 24px;">&#xe61c;</i>

  </header>

  <div class="article-content">
    
      <div id="container">
        <h2 id="一、什么是Serverless"><a href="#一、什么是Serverless" class="headerlink" title="一、什么是Serverless"></a>一、什么是Serverless</h2><blockquote>
<p>Serverless 能解决什么问题？理清 Serverless 要解决的问题其实很简单，我们可以从字面上把它拆开来看。Server 这里指服务端，它是 Serverless 解决问题的边界；而 less 我们可以理解为较少关心，它是 Serverless 解决问题的目的。组合在一起就是“较少关心服务端”</p>
</blockquote>
<ul>
<li>第一种：<code>狭义 Serverless</code>（最常见）= <code>Serverless computing 架构</code> = <code>FaaS 架构</code> = <code>Trigger（事件驱动）+ FaaS（函数即服务）+ BaaS</code>（后端即服务，持久化或第三方服务）= <code>FaaS + BaaS</code></li>
<li>第二种：广义 <code>Serverless</code> = <code>服务端免运维</code> = <code>具备 Serverless 特性的云服务</code></li>
</ul>
<p><img src="https://blog.poetries.top/img/static/images/20210416155216.png" alt></p>
<h2 id="二、编写你的第一个-Serverless-应用"><a href="#二、编写你的第一个-Serverless-应用" class="headerlink" title="二、编写你的第一个 Serverless 应用"></a>二、编写你的第一个 Serverless 应用</h2><p><img src="https://blog.poetries.top/img/static/images/20210418151945.png" alt></p>
<ul>
<li>FaaS 平台都支持 Node.js、Python 、Java 等编程语言；</li>
<li>FaaS 平台都支持 HTTP 和定时触发器（这两个触发器最常用）。此外各厂商的 FaaS 支持与自己云产品相关的触发器，函数计算支持阿里云表格存储等触发器；</li>
<li>FaaS 的计费都差不多，且每个月都提供一定的免费额度。其中 GB-s 是指函数每秒消耗的内存大小，比如1G-s 的含义就是函数以 1G 内存执行 1 秒钟。超出免费额度后，费用基本都是 0.0133元/万次，0.00003167元/GB-s。所以，用 FaaS 整体费用非常便宜，对一个小应用来说，几乎是免费的。</li>
</ul>
<p><strong>以阿里云函数为例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// logic.js</span></span><br><span class="line">exports.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> logic = <span class="built_in">require</span>(<span class="string">'./logic'</span>);</span><br><span class="line">exports.handler = <span class="function">(<span class="params">request, response, context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 从 request 中获取</span></span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = request.queries;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理业务逻辑</span></span><br><span class="line">  <span class="keyword">const</span> message = logic.sayHello(name)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 HTTP 响应</span></span><br><span class="line">  response.setStatusCode(<span class="number">200</span>);</span><br><span class="line">  response.setHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">  response.send(<span class="built_in">JSON</span>.stringify(&#123; message &#125;)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把业务逻辑拆分到入口函数之外</p>
</blockquote>
<h3 id="触发器及事件对象"><a href="#触发器及事件对象" class="headerlink" title="触发器及事件对象"></a>触发器及事件对象</h3><ol>
<li>HTTP 触发器</li>
</ol>
<blockquote>
<p>在众多 FaaS 平台中，函数计算直接提供了 HTTP 触发器，HTTP 触发器通过发送 HTTP 请求来触发函数执行，一般都会支持 POST、GET、PUT、HEAD 等方法。所以你可以用 HTTP 触发器来构建 Restful 接口或 Web 系统。</p>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/20210418152334.png" alt></p>
<p>HTTP 触发器会根据 HTTP 请求和请求参数生成事件，然后以参数形式传递给函数。那么 HTTP 触发器的入口函数参数中的 request 和 response 参数具体有哪些属性呢？</p>
<p>其实， request 和 response 参数本质上与 Express.js 框架的 request 和 response 类似</p>
<ol start="2">
<li>API 网关触发器</li>
</ol>
<p>API 网关触发器与 HTTP 触发器类似，它主要用于构建 Web 系统。本质是利用 API 网关接收 HTTP 请求，然后再产生事件，将事件传递给 FaaS。FaaS 将函数执行完毕后将函数返回值传递给 API 网关，API 网关再将返回值包装为 HTTP 响应返回给用户。</p>
<p><img src="https://blog.poetries.top/img/static/images/20210418152415.png" alt></p>
<ol start="3">
<li>定时触发器</li>
</ol>
<blockquote>
<p>定时触发器就是定时执行函数，它经常用来做一些周期任务，比如每天定时查询天气并给自己发送通知、每小时定时处理分析日志等等。</p>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/20210418152436.png" alt></p>
<h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>无论你用什么编写语言开发 Serverless 应用，你都要在合适的时候输出合适的日志信息，方便调试应用、排查问题。在 Serverless 中，日志输出和传统应用的日志输出没有太大区别，只是日志的存储和查询方式变了。</p>
<p>以函数计算为例，如果你在控制台创建函数，则函数计算默认会使用日志服务来为你存储日志。在 “日志查询” 标签下可以查看函数调用日志。日志服务是一个日志采集、分析产品，所以如果你要实现业务监控，则可以将日志输出到日志服务，然后在日志服务中对日志进行分析，并设置报警项。</p>
<p><img src="https://blog.poetries.top/img/static/images/20210418152600.png" alt></p>
<h2 id="三、Serverless-应用是怎么运行的"><a href="#三、Serverless-应用是怎么运行的" class="headerlink" title="三、Serverless 应用是怎么运行的"></a>三、Serverless 应用是怎么运行的</h2><blockquote>
<p>Serverless 应用本质上是由一个个 FaaS 函数组成的，Serverless 应用的每一次运行，其实是单个或多个函数的运行，所以 <code>Serverelss 的运行原理，本质上就是函数的运行原理</code></p>
</blockquote>
<p><strong>FaaS 是怎么运行的</strong></p>
<p><img src="https://blog.poetries.top/img/static/images/20210416155334.png" alt></p>
<p><img src="https://blog.poetries.top/img/static/images/20210416155401.png" alt></p>
<h3 id="函数调用链路：事件驱动函数执行"><a href="#函数调用链路：事件驱动函数执行" class="headerlink" title="函数调用链路：事件驱动函数执行"></a>函数调用链路：事件驱动函数执行</h3><blockquote>
<p>对于 FaaS 函数来说，一方面可以通过事件来触发执行，另一方面也可以直接调用 API 来执行。FaaS 平台都提供了执行函数的 API</p>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/20210418151354.png" alt></p>
<h3 id="函数生命周期：冷启动与热启动"><a href="#函数生命周期：冷启动与热启动" class="headerlink" title="函数生命周期：冷启动与热启动"></a>函数生命周期：冷启动与热启动</h3><blockquote>
<p>FaaS 中的冷启动是指从调用函数开始到函数实例准备完成的整个过程。冷启动我们关注的是启动时间，启动时间越短，我们对资源的利用率就越高。现在的云服务商，基于不同的语言特性，冷启动平均耗时基本在 <code>100～700 毫秒</code>之间。得益于 Google 的 JavaScript 引擎 Just In Time 特性，Node.js 在冷启动方面速度是最快的。</p>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/20210416155824.png" alt></p>
<blockquote>
<p>注意，FaaS 服务从 0 开始，启动并执行完一个函数，只需要 100 毫秒。这也是为什么 FaaS 敢缩容到 0 的主要原因。通常我们打开一个网页有个关键指标，响应时间在 1 秒以内，都算优秀。这么一对比，100 毫秒的启动时间，对于网页的秒开率影响真的极小</p>
</blockquote>
<blockquote>
<p>在 FaaS 平台中，函数默认是不运行的，也不会分配任何资源。甚至 FaaS 中都不会保存函数代码。只有当 FaaS 接收到触发器的事件后，才会启动并运行函数。整个函数的运行过程可以分为四个阶段</p>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/20210418151433.png" alt></p>
<ul>
<li>下载代码： FaaS 平台本身不会存储代码，而是将代码放在对象存储中，需要执行函数的时候，再从对象存储中将函数代码下载下来并解压，因此 FaaS 平台一般都会对代码包的大小进行限制，通常代码包不能超过 50MB。</li>
<li>启动容器： 代码下载完成后，FaaS 会根据函数的配置，启动对应容器，FaaS 使用容器进行资源隔离。</li>
<li>初始化运行环境： 分析代码依赖、执行用户初始化逻辑、初始化入口函数之外的代码等。</li>
<li>运行代码： 调用入口函数执行代码。</li>
</ul>
<blockquote>
<p>当函数第一次执行时，会经过完整的四个步骤，前三个过程统称为“冷启动”，最后一步称为 “热启动”。</p>
</blockquote>
<p>整个冷启动流程耗时可能达到百毫秒级别。函数运行完毕后，运行环境会保留一段时间，可能 2 ~ 5 分钟，这和具体云厂商有关。如果这段时间内函数需要再次执行，则 FaaS 平台就会使用上一次的运行环境，这就是“执行上下文重用”，函数的这个启动过程也叫“热启动”。“热启动” 的耗时就完全是启动函数的耗时了。当一段时间内没有请求时，函数运行环境就会被释放，直到下一次事件到来，再重新从冷启动开始初始化。</p>
<p>下面是一个函数的请求示意图，其中 “请求1” “请求3” 是冷启动，“请求2” 是热启动</p>
<p><img src="https://blog.poetries.top/img/static/images/20210418151527.png" alt></p>
<blockquote>
<p>函数执行完毕后销毁运行环境，虽然对首次函数执行的性能有损耗，但极大提高了资源利用效率，只有需要执行代码的时候才初始化环境、消耗硬件资源。并且如果你的应用请求量比较大，则大部分时候函数的执行可能都是热启动</p>
</blockquote>
<h3 id="FaaS-是怎么分层的"><a href="#FaaS-是怎么分层的" class="headerlink" title="FaaS 是怎么分层的"></a>FaaS 是怎么分层的</h3><p><img src="https://files.mdnice.com/user/6541/5d7d3769-4fc0-4036-bd1b-91e9a650c2c3.png" alt></p>
<blockquote>
<p>你的 FaaS 实例执行时，就如上图所示，至少是 3 层结构：容器、运行时 Runtime、具体函数代码。</p>
</blockquote>
<p>容器你可以理解为操作系统 OS。代码要运行，总需要和硬件打交道，容器就是模拟出内核和硬件信息，让你的代码和 Runtime 可以在里面运行。容器的信息包括内存大小、OS 版本、CPU 信息、环境变量等等。目前的 FaaS 实现方案中，容器方案可能是 Docker 容器、VM 虚拟机，甚至 Sandbox 沙盒环境。运行时 Runtime，就是你的函数执行时的上下文 context。Runtime 的信息包括代码运行的语言和版本，例如 Node.js v10，Python3.6；可调用对象，例如 aliyun SDK；系统信息，例如环境变量等等。</p>
<blockquote>
<ul>
<li>这样分层有什么好处呢？容器层适用性更广，云服务商可以预热大量的容器实例，将物理服务器的计算资源碎片化。Runtime 的实例适用性较低，可以少量预热；容器和 Runtime 固定后，下载你的代码就可以执行了。通过分层，我们可以做到资源统筹优化，这样就能让你的代码快速低成本地被执行。</li>
<li>理解了分层，我们再回想一下 FaaS 分层对应冷启动的过程，其实你就不难理解云服务商负责的就是容器和 Runtime 的准备阶段了。而开发者自己负责的则是函数执行阶段。一旦容器 &amp;Runtime 启动后，就会维持一段时间，这段时间内的这个函数实例就可以直接处理用户数据请求。当一段时间内没有用户请求事件发生（各个云服务商维持实例的时间和策略不同），则会销毁这个函数实例。</li>
</ul>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/20210416160251.png" alt></p>
<ul>
<li>纯 FaaS 应用调用链路由函数触发器、函数服务和函数代码三部分组成，它们分别替代了传统服务端运维的负载均衡 &amp; 反向代理，服务器 &amp; 应用运行环境，应用代码部署</li>
<li>对比传统应用托管 PaaS 平台，FaaS 应用最大的不同就是，FaaS 应用可以缩容到 0，在事件到来时极速启动，Node.js 的函数甚至可以做到 100ms 启动并执行。</li>
<li>FaaS 在设计上牺牲了用户的可控性和应用场景，来简化代码模型，并且通过分层结构进一步提升资源的利用率，这也是为什么 FaaS 冷启动时间能这么短的主要原因。关于 FaaS 的 3 层结构，你可以这么想象：容器层就像是 Windows 操作系统；Runtime 就像是 Windows 里面的播放器暴风影音；你的代码就像是放在 U 盘里的电影</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>组成 Serverless 应用的函数是事件驱动的，但你也可以直接同 API 调用函数；</li>
<li>函数可以同步调用或异步调用，定时触发器函数是异步调用的，异步调用函数建议主动记录并处理异步调用结果；</li>
<li>函数的启动过程分为下载代码、启动容器、启动运行环境、执行代码四个步骤，前三个步骤称为冷启动，最后一个步骤称为热启动</li>
</ul>
<h2 id="四、如何提高应用开发调试和部署效率"><a href="#四、如何提高应用开发调试和部署效率" class="headerlink" title="四、如何提高应用开发调试和部署效率"></a>四、如何提高应用开发调试和部署效率</h2><h3 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h3><blockquote>
<p>Serverless 应用是由函数组成的，所以应用的管理主要就是函数的管理。各个 FaaS 平台其实也考虑到了这一点，比如函数计算的 “服务”功能或 Lambda 的 “应用” 功能。你可以把一个应用的函数都创建在同一个 “服务” 下，一个 “服务” 即代表一个应用。</p>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/20210418152848.png" alt></p>
<blockquote>
<p>那么如何去描述 “服务” 和 “函数” 的关系呢？因为二者是静态的，不会在代码运行时改变，所以你可以用 YAML 或 JSON 配置文件来表示（我推荐 YAML，因为它可以编写注释，可读性更好）。在创建函数时，你还要指定函数的入口、编程语言、触发器等信息。所以 YAML 文件的内容可能是这样的：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># serverless.yaml</span></span><br><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line">service: myservice</span><br><span class="line"><span class="comment"># 函数列表</span></span><br><span class="line"><span class="built_in">functions</span>:</span><br><span class="line">    <span class="comment"># 函数1</span></span><br><span class="line">  hello:</span><br><span class="line">    handler: hello.main <span class="comment"># 函数入口</span></span><br><span class="line">    runtime: nodejs12</span><br><span class="line">    events: <span class="comment"># 函数触发器，一个函数可能有多个触发器</span></span><br><span class="line">        - http</span><br><span class="line">        - timer</span><br><span class="line">  <span class="comment"># 函数2</span></span><br><span class="line">  goodbye:</span><br><span class="line">    handler: goodbye.main</span><br><span class="line">    runtime: nodejs12</span><br><span class="line">    events:</span><br><span class="line">        - http</span><br></pre></td></tr></table></figure>
<h3 id="应用开发"><a href="#应用开发" class="headerlink" title="应用开发"></a>应用开发</h3><p>有了应用配置文件之后，开发者就可以开始开发代码了。为了进一步简化用户操作，你甚至可以提供一些代码模板，然后提供 init 命令让开发者基于模板一键生成一个 Serverless 应用。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ serverless init --template hello-world</span><br><span class="line">|-- hello.js</span><br><span class="line">|-- serverless.yaml</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># serverless.yaml</span></span><br><span class="line">service: myservice</span><br><span class="line"><span class="built_in">functions</span>:</span><br><span class="line">  hello:</span><br><span class="line">    handler: hello.main</span><br><span class="line">    events:</span><br><span class="line">        - http</span><br></pre></td></tr></table></figure>
<h2 id="五、serverless应用"><a href="#五、serverless应用" class="headerlink" title="五、serverless应用"></a>五、serverless应用</h2><h3 id="阿里云函数计算"><a href="#阿里云函数计算" class="headerlink" title="阿里云函数计算"></a>阿里云函数计算</h3><blockquote>
<p><a href="https://fc.console.aliyun.com/fc/overview" target="_blank" rel="noopener">https://fc.console.aliyun.com/fc/overview</a></p>
</blockquote>
<p>选择一个模板，体验一下</p>
<p><img src="https://files.mdnice.com/user/6541/d63653ac-0a1d-4dfa-9a2a-879f23aa803e.png" alt></p>
<blockquote>
<p>云函数使用指南 <a href="https://help.aliyun.com/product/50980.html" target="_blank" rel="noopener">https://help.aliyun.com/product/50980.html</a></p>
</blockquote>
<h3 id="腾讯云函数"><a href="#腾讯云函数" class="headerlink" title="腾讯云函数"></a>腾讯云函数</h3><p><img src="https://blog.poetries.top/img/static/images/20210416161014.png" alt></p>
<blockquote>
<p>云函数使用指南 <a href="https://cloud.tencent.com/document/product/876/41762" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/876/41762</a></p>
</blockquote>
<h3 id="使用vercel部署你的应用-推荐"><a href="#使用vercel部署你的应用-推荐" class="headerlink" title="使用vercel部署你的应用-推荐"></a>使用vercel部署你的应用-推荐</h3><p>vercel是用过的最好用的网站托管服务，我们可以在上面部署api、静态页面等。可以和GitHub深度绑定，推送代码，vercel会帮我们检测自动部署</p>
<p><strong>新建项目</strong></p>
<p><img src="https://blog.poetries.top/img/static/images/20210416161535.png" alt></p>
<p>导入GitHub的某一个项目部署</p>
<p><img src="https://blog.poetries.top/img/static/images/20210416161621.png" alt></p>
<p><img src="https://blog.poetries.top/img/static/images/20210416161653.png" alt></p>
<p><img src="https://blog.poetries.top/img/static/images/20210416161728.png" alt></p>
<p><img src="https://blog.poetries.top/img/static/images/20210416161748.png" alt></p>
<blockquote>
<p>部署完成后，可以在控制面板看到，vercel每次部署都动态帮我生成一个地址，可以直接访问你的应用</p>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/20210416161906.png" alt></p>
<p><strong>绑定GitHub应用</strong></p>
<p><img src="https://blog.poetries.top/img/static/images/20210416162735.png" alt></p>
<blockquote>
<p>每次提交代码到GitHub，vercel都会自动帮我们构建发布</p>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/20210416162612.png" alt></p>
<p><strong>绑定域名</strong></p>
<p>我们可以绑定自己的自定义域名</p>
<p><img src="https://blog.poetries.top/img/static/images/20210416162045.png" alt></p>
<blockquote>
<p>我们还可以使用vercel部署node小型应用，非常的方便。更多参考文档 <a href="https://vercel.com/docs" target="_blank" rel="noopener">https://vercel.com/docs</a></p>
</blockquote>
<h2 id="六、场景案例"><a href="#六、场景案例" class="headerlink" title="六、场景案例"></a>六、场景案例</h2><h3 id="1-使用-Serverless-实现登录注册功能"><a href="#1-使用-Serverless-实现登录注册功能" class="headerlink" title="1 使用 Serverless 实现登录注册功能"></a>1 使用 Serverless 实现登录注册功能</h3><h4 id="1-1-身份认证的技术方案"><a href="#1-1-身份认证的技术方案" class="headerlink" title="1.1 身份认证的技术方案"></a>1.1 身份认证的技术方案</h4><p><strong>Cookie-Session</strong></p>
<blockquote>
<p>Cookie-Session 方式是早期最常用的身份认证方式，直到现在很多 Web 网站依然使用这种方式。其认证流程是</p>
</blockquote>
<ul>
<li>用户在浏览器中输入账号密码登录；</li>
<li>服务端验证通过后，将用户信息保存在 Session 中并生成一个 Session ID；</li>
<li>然后服务端将 Session ID 放在 HTTP 响应头的 cookie 字段中；</li>
<li>浏览器收到 HTTP 响应后，将 cookie 保存在浏览器中，cookie 内容就是之前登录时生成的 Session ID；</li>
<li>用户再访问网站时，浏览器请求头就会自动带上 cookie 信息；</li>
<li>服务端接收到请求后，从 cookie 获取到 Session ID，然后根据 Session ID 解析出用户信息。</li>
</ul>
<p><img src="https://blog.poetries.top/img/static/images/20210418165707.png" alt></p>
<p><strong>这种方案存在两个主要问题：</strong></p>
<ul>
<li>服务端的 Session ID 是直接存储在内存中的，在分布式系统中无法共享登录状态；</li>
<li>cookie 是浏览器的功能，手机 App 等客户端并不支持 cookie，所以该方案不适用于非浏览器的应用。</li>
</ul>
<p>第一个问题也是 Cookie-Session 方案应用于 Serverless 架构的主要问题，因为 Serverless 应用是无状态的，内存中的数据用完即销毁，多个请求间无法共享 Session。解决该问题也比较容易， 就是用一个共享存储来保存 Session 信息，最常见的就是 Redis，因为 Redis 是一个内存数据库，读写速度很快。</p>
<blockquote>
<p>于是 Cookie-Session 的身份认证方案就发生了变化：</p>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/20210418165751.png" alt></p>
<blockquote>
<p>与早期方案不同，用户登录时，该方案会把用户信息保存在 Redis 中，而不是内存中，然后服务端依然会将 Session ID 返回给浏览器，浏览器将其保存在 cookie 中。而之后非登录的请求，浏览器依然会将包含 Session ID 的 cookie 放在请求头中发送给服务端，服务端拿到 Session ID 后，从 Redis 中查询出用户信息。这样就可以解决分布式、无状态的系统中用户登录状态共享问题。</p>
</blockquote>
<p>不过这个方案依旧无法解决非浏览器场景的身份认证问题，所以 JWT 方案诞生了。</p>
<p><strong>JWT</strong></p>
<blockquote>
<p>JWT 是（JSON Web Token）的简称，其原理是：</p>
</blockquote>
<ul>
<li>服务端认证通过后，根据用户信息生成一个 token 返回给客户端；</li>
<li>客户端将 token 存储在 cookie 或 localStorage 中；</li>
<li>之后客户端每次请求都需要带上 token，通常是将 token 放在 HTTP 请求头的 Authorization 字段中；</li>
<li>服务端接收到 token 后，验证 token 的合法性，并从 token 中解析出用户信息。</li>
</ul>
<p><img src="https://blog.poetries.top/img/static/images/20210418165833.png" alt></p>
<blockquote>
<p>token 是个比较长字符串，格式为 <code>Header.Payload.Signature</code>，由<code>.</code>分隔为三部分。下面是一个实际的 token 示例：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJqYWNrIiwiaWF0IjoxNjEwODg1MTcxfQ.KIduc-undaZ0z-Bt4wjGZIK5fMlx1auVHl_G1DvGDCw</span><br></pre></td></tr></table></figure>
<p>可能有同学会担忧： token 是根据用户信息生成的，这样会不会泄露用户信息呢？其实不用担心，因为生成 token 的加密算法是不可逆的，并且 token 也可以设置过期时间，所以 token 字符串本身不会泄露用户信息。</p>
<blockquote>
<p>基于 JWT ，客户端可以使用自己特有的存储来保存 token，不依赖 cookie，所以 JWT 可以适用于任意客户端。并且使用 JWT 进行身份认证，服务端就不用存储用户信息了，这样服务端就是无状态的。因此 JWT 这种身份认证方案，也非常适合 Serverless 应用。</p>
</blockquote>
<p>接下来，就基于 JWT ，带你从 0 到 1实现一个登录注册应用</p>
<h4 id="1-2-从-0-到-1-实现一个登录注册应用"><a href="#1-2-从-0-到-1-实现一个登录注册应用" class="headerlink" title="1.2 从 0 到 1 实现一个登录注册应用"></a>1.2 从 0 到 1 实现一个登录注册应用</h4><p><strong>应用初始化</strong></p>
<blockquote>
<p>首先安装 <code>express</code>、<code>body-parser</code> 和 <code>@webserverless/fc-express</code> 等依赖：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i express body-parser @webserverless/fc-express -S</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@webserverless/fc-express 的作用是将函数计算的 HTTP 或 API 网关触发器参数转换为 Express.js 框架的参数，这样你就可以很方便在函数计算中使用 Express.js 了</p>
</blockquote>
<p>然后我们初始化一个 template.yaml 模板，该模板定义了 auth-app 这个函数，函数触发器为 HTTP 触发器，支持 GET 和 POST 请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROSTemplateFormatVersion: &apos;2015-09-01&apos;</span><br><span class="line">Transform: &apos;Aliyun::Serverless-2018-04-03&apos;</span><br><span class="line">Resources:</span><br><span class="line">  serverless:</span><br><span class="line">    Type: &apos;Aliyun::Serverless::Service&apos;</span><br><span class="line">    Properties:</span><br><span class="line">      Description: &apos;Serverless Authorization App&apos;</span><br><span class="line">    auth-app:</span><br><span class="line">      Type: &apos;Aliyun::Serverless::Function&apos;</span><br><span class="line">      Properties:</span><br><span class="line">        Handler: index.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: &apos;./&apos;</span><br><span class="line">        Timeout: 10</span><br><span class="line">      Events:</span><br><span class="line">        httpTrigger:</span><br><span class="line">          Type: HTTP</span><br><span class="line">          Properties:</span><br><span class="line">            AuthType: ANONYMOUS</span><br><span class="line">            Methods: [&apos;POST&apos;, &apos;GET&apos;]</span><br></pre></td></tr></table></figure>
<p>接下来在 index.js 中编写初始化代码，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'@webserverless/fc-express'</span>)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;</span><br><span class="line">  extended: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 / 路由，返回 Hello Serverless!</span></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        success: <span class="literal">true</span>,</span><br><span class="line">        data: <span class="string">'Hello Serverless!'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> proxy.Server(app);</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 @webserverless/fc-express 来将函数计算的请求转发给 Express.js 应用</span></span><br><span class="line">    <span class="comment">// @webserverless/fc-express 可以将函数参数转换为 Express.js 的路由参数</span></span><br><span class="line">    server.httpProxy(req, res, context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>这段代码主要实现两个功能：</strong></p>
<ul>
<li>定义了 <code>/</code>  路由，该路由返回了 <code>Hello Serverless!</code> 字符串，我们之后可以用它来测试代码是否正常运行；</li>
<li>使用 <code>@webserverless/fc-express</code> 将函数计算的请求转发给 <code>Express.js</code> 应用<code>@webserverless/fc-express 可以将函数参数转换为</code>Express.js` 的路由参数。</li>
</ul>
<p>然后通过 <code>fun deploy</code> 部署应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署应用</span></span><br><span class="line">$ fun deploy -y</span><br><span class="line">Waiting <span class="keyword">for</span> service serverless to be deployed...</span><br><span class="line">        Waiting <span class="keyword">for</span> <span class="keyword">function</span> auth-app to be deployed...</span><br><span class="line">                Waiting <span class="keyword">for</span> packaging <span class="keyword">function</span> auth-app code...</span><br><span class="line">                The <span class="keyword">function</span> auth-app has been packaged. A total of 419 files were compressed and the final size was 724.49 KB</span><br><span class="line">                Waiting <span class="keyword">for</span> HTTP trigger httpTrigger to be deployed...</span><br><span class="line">                triggerName: httpTrigger</span><br><span class="line">                methods: [ <span class="string">'POST'</span>, <span class="string">'GET'</span> ]</span><br><span class="line">                url: https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/</span><br><span class="line">                trigger httpTrigger deploy success</span><br><span class="line">        <span class="keyword">function</span> auth-app deploy success</span><br><span class="line">service serverless deploy success</span><br><span class="line">$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/</span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">true</span>,<span class="string">"data"</span>:<span class="string">"Hello Serverless!"</span>&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>部署成功后，我们就可以获取到函数计算提供的测试 HTTP Endpoint，然后就可以通过 curl 命令进行测试应用是否正常运行：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/</span><br><span class="line">&#123;&quot;success&quot;:true,&quot;data&quot;:&quot;Hello Serverless!&quot;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-实现注册功能"><a href="#1-3-实现注册功能" class="headerlink" title="1.3 实现注册功能"></a>1.3 实现注册功能</h4><blockquote>
<p>注册的逻辑是：先获取用户输入的用户名和密码，然后判断用户是否存在，如果不存在就将其存入表格存储数据库</p>
</blockquote>
<p>这里我们使用的数据库是表格存储。 可能你使用的比较多的是 MySQL，之所以选用表格存储而不是 MySQL，是因为表格存储可以直接通过 Restful API 进行读写，并且弹性可扩展，更适合 Serverless 应用。使用表格存储时，你要先创建一个表格存储实例，然后创建一个 user 表。为了方便，我也给你提供了一个创建 user 表的脚本：<a href="https://github.com/nodejh/serverless-class/tree/master/15/create-table" target="_blank" rel="noopener">create-table</a>。</p>
<blockquote>
<p>接下来继续编写代码。由于要使用表格存储，所以首先需要安装 tablestore 依赖，然后在 index.js 中初始化表格存储 client：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 tablestore 依赖</span></span><br><span class="line"><span class="comment"># tablestore 封装了表格存储的 API</span></span><br><span class="line">$ npm i tablestore -S</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> TableStore = <span class="built_in">require</span>(<span class="string">'tablestore'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 TableStore client</span></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> TableStore.Client(&#123;</span><br><span class="line">  accessKeyId: <span class="string">'&lt;your access key&gt;'</span>,</span><br><span class="line">  accessKeySecret: <span class="string">'your access secret'</span>,</span><br><span class="line">  endpoint: <span class="string">'https://serverless-app.cn-shanghai.ots.aliyuncs.com'</span>,</span><br><span class="line">  instancename: <span class="string">'serverless-app'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在我们就可以定义一个路由来处理用户的注册请求了。代码如下所示，首先我们根据 name 从表格存储中查询用户信息，如果用户已存在，则直接返回；如果用户不存在，则将用户信息写入表格存储。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 /register 路由，处理注册请求</span></span><br><span class="line">app.post(<span class="string">'/register'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 从请求体中获取用户信息</span></span><br><span class="line">  <span class="keyword">const</span> name = req.body.name;</span><br><span class="line">  <span class="keyword">const</span> password = req.body.password;</span><br><span class="line">  <span class="keyword">const</span> age = req.body.age;</span><br><span class="line">  <span class="comment">// 判断用户是否已经存在</span></span><br><span class="line">  <span class="keyword">const</span> &#123; row &#125; = <span class="keyword">await</span> client.getRow(&#123;</span><br><span class="line">    tableName: <span class="string">"user"</span>,</span><br><span class="line">    primaryKey: [&#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (row.primaryKey) &#123;</span><br><span class="line">    <span class="comment">// 如果用户已存在，则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      message: <span class="string">'用户已存在'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建用户，将用户信息写入到表格存储中</span></span><br><span class="line">  <span class="keyword">await</span> client.putRow(&#123;</span><br><span class="line">    tableName: <span class="string">"user"</span>,</span><br><span class="line">    condition: <span class="keyword">new</span> TableStore.Condition(TableStore.RowExistenceExpectation.EXPECT_NOT_EXIST, <span class="literal">null</span>),</span><br><span class="line">    primaryKey: [&#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;],</span><br><span class="line">    attributeColumns: [&#123;</span><br><span class="line">      password</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      age</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 返回创建成功</span></span><br><span class="line">  <span class="keyword">return</span> res.send(&#123;</span><br><span class="line">    success: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>至此注册功能就完成了，你可以将代码部署到函数计算上，像下面这样通过 curl 命令来模拟用户请求，验证功能是否正常：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth/login \</span><br><span class="line">-d <span class="string">"name=jack&amp;password=123456&amp;age=18"</span> \</span><br><span class="line">-X POST</span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth/login \</span><br><span class="line">-d <span class="string">"name=jack&amp;password=123456&amp;age=18"</span> \</span><br><span class="line">-X POST</span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">false</span>,<span class="string">"message"</span>:<span class="string">"用户已存在"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>注册功能完成后，就可以继续实现登录功能了。</p>
<h4 id="1-4-实现登录功能"><a href="#1-4-实现登录功能" class="headerlink" title="1.4 实现登录功能"></a>1.4 实现登录功能</h4><p>登录就是验证用户输入的用户名密码是否正确。</p>
<blockquote>
<p>首先根据用户输入的 name 从表格存储中查询出用户信息，然后对比用户密码与数据库中的用户密码是否一致，如果一致，则登录成功；否则登录失败。登录成功后，还需要根据用户信息生成一个 token 返回给用户。具体怎么实现呢？</p>
</blockquote>
<p>前面我们提到，Serverless 中最通用的身份认证方案是 JWT，所以我们首先需要安装 Node.js 中的 JWT 依赖包 jsonwebtoken：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install jsonwebtoken -S</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后在代码中引入 jsonwebtoken ，并定义 SECRET。SECRET 是用来加密和解密 token 的密钥，非常重要，且不能泄露。</p>
</blockquote>
<blockquote>
<p>接下来在代码中定义 <code>/login</code> 路由来处理用户请求。这段代码中，我们首先验证了用户密码是否正确，密码正确后，再使用 <code>jwt.sign()</code> 方法，根据用户信息生成了 token，最后将 token 返回给客户端，客户端需要将 token 保存下来。之后客户端每次请求，都需要带上 token 进行身份认证。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>)</span><br><span class="line"><span class="comment">// 设置密钥，非常重要，不能泄露</span></span><br><span class="line"><span class="keyword">const</span> SECRET = <span class="string">'token_secret_xd2dasf19df='</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 定义 /login 路由，用来实现登录功能</span></span><br><span class="line">app.post(<span class="string">'/login'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 从请求体中获取用户名和密码</span></span><br><span class="line">  <span class="keyword">const</span> name = req.body.name;</span><br><span class="line">  <span class="keyword">const</span> password = req.body.password;</span><br><span class="line">  <span class="comment">// 根据用户名查询用户信息</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    row</span><br><span class="line">  &#125; = <span class="keyword">await</span> client.getRow(&#123;</span><br><span class="line">    tableName: <span class="string">'user'</span>,</span><br><span class="line">    primaryKey: [&#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 如果查询结果为空，则直接返回用户不存在</span></span><br><span class="line">  <span class="keyword">if</span> (!row.primaryKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      message: <span class="string">'用户不存在'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从查询结果中构造用户信息</span></span><br><span class="line">  <span class="keyword">const</span> user = &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;;</span><br><span class="line">  row.attributes.forEach(<span class="function"><span class="params">item</span> =&gt;</span> user[item.columnName] = item.columnValue);</span><br><span class="line">  <span class="comment">// 判断密码是否正确</span></span><br><span class="line">  <span class="keyword">if</span> (password !== user.password) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      message: <span class="string">'密码错误'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  user.password = <span class="string">'******'</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成 token</span></span><br><span class="line"><span class="comment">   * jwt.sign() 接受两个参数，一个是传入的对象，一个是自定义的密钥</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> token = jwt.sign(user, SECRET)</span><br><span class="line">  <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">    success: <span class="literal">true</span>,</span><br><span class="line">    data: &#123; token &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>代码编写完成后，部署到函数计算并进行测试，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/login \</span><br><span class="line">-d <span class="string">"name=jack&amp;password=123456"</span> \ </span><br><span class="line">-X POST</span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">true</span>,<span class="string">"data"</span>:&#123;<span class="string">"token"</span>:<span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamFjayIsImFnZSI6IjE4IiwicGFzc3dvcmQiOiIqKioqKioiLCJpYXQiOjE2MTA5MDY5MTJ9.qzNZarWbpDUA8-SO6nLd4ffEUR1IVOWKGXiocHV7MkU"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用错误的密码登录</span></span><br><span class="line">$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/login \</span><br><span class="line">-d <span class="string">"name=jack&amp;password=1234561"</span> \</span><br><span class="line">-X POST</span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">false</span>,<span class="string">"message"</span>:<span class="string">"密码错误"</span>&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么问题来了：对于需要登录后才能访问的接口，应该怎么根据 token 验证用户身份呢？别急，我们继续下面的学习。</p>
</blockquote>
<h4 id="1-5-验证用户身份"><a href="#1-5-验证用户身份" class="headerlink" title="1.5 验证用户身份"></a>1.5 验证用户身份</h4><blockquote>
<p>前面提到，登录成功后，客户端需要将 token 保存下来，然后在接下来的请求中，都需要带上 token。通常会将 token 放在 HTTP 请求头中，格式通常为：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer token</span><br></pre></td></tr></table></figure>
<p>这时假设我们要实现一个新的接口，获取当前登录用户信息，该接口也只能登录后才能使用。那么代码实现就是下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 /user 路由，获取当前登录的用户信息</span></span><br><span class="line">app.get(<span class="string">'/user'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 从 HTTP 请求头中获取 token 信息</span></span><br><span class="line">  <span class="keyword">const</span> token = req</span><br><span class="line">    .headers</span><br><span class="line">    .authorization</span><br><span class="line">    .split(<span class="string">' '</span>)</span><br><span class="line">    .pop();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 验证 token 并解析出用户信息</span></span><br><span class="line">    <span class="keyword">const</span> user = jwt.verify(token, SECRET);</span><br><span class="line">    <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">      success: <span class="literal">true</span>,</span><br><span class="line">      data: user</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      data: <span class="string">'身份认证失败'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先我们定义了 /user 路由，然后通过请求头拿到 token 信息，最后使用 <code>jwt.verify()</code> 对 token 进行解密，并从中得到用户信息，如果用户传入的 token 无法解析，则说明用户身份异常。</p>
</blockquote>
<p>同样，我们可以将代码部署到函数计算并进行测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">curl https:<span class="comment">//1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/user \</span></span><br><span class="line">-H <span class="string">"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamFjayIsImFnZSI6IjE4IiwicGFzc3dvcmQiOiIqKioqKioiLCJpYXQiOjE2MTA5MDY5MTJ9.qzNZarWbpDUA8-SO6nLd4ffEUR1IVOWKGXiocHV7MkU"</span></span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">true</span>,<span class="string">"data"</span>:&#123;<span class="string">"name"</span>:<span class="string">"jack"</span>,<span class="string">"age"</span>:<span class="string">"18"</span>,<span class="string">"password"</span>:<span class="string">"******"</span>,<span class="string">"iat"</span>:<span class="number">1610905944</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"># 使用错误的 token 进行身份认证</span><br><span class="line">$ curl https:<span class="comment">//1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/user -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamFjayIsImFnZSI6IjE4IiwicGFzc3dvcmQiOiIqKioqKioiLCJpYXQiOjE2MTA5MDY5MTJ9.qzNZarWbpDUA8-SO6nLd4ffEUR1IVOWKGXiocHV7Mk"</span></span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">false</span>,<span class="string">"data"</span>:<span class="string">"身份认证失败"</span>&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到此为止，一个 Serverless 架构的登录注册功能就完成了，我们也基于 JWT 实现了 Serverless 中的身份认证。</p>
</blockquote>
<p><strong>强调这样几点：</strong></p>
<ul>
<li>Cookie-Session 的身份认证方式，是在服务端存储 Session 信息，客户端（浏览器）通过 cookie 存储 Session ID；</li>
<li>JWT 的身份认证方式，是在服务端根据用户信息生成 token，客户端保存 token；</li>
<li>Cookie-Session 的认证方案通常是有状态的，对于分布式、无状态的应用，需要将 Session 保存在共享存储中；</li>
<li>JWT 的认证方式通常是无状态的，所以比较适合 Serverless 应用。</li>
</ul>
<h3 id="2-基于-Serveless-构建弹性可扩展的-Restful-API"><a href="#2-基于-Serveless-构建弹性可扩展的-Restful-API" class="headerlink" title="2 基于 Serveless 构建弹性可扩展的 Restful API"></a>2 基于 Serveless 构建弹性可扩展的 Restful API</h3><blockquote>
<p>API 是使用 Serverless 最常见，也是最适合的场景之一。和 Serverful 架构的  API 相比，用 Serverless 开发 API 好处很多：</p>
</blockquote>
<ul>
<li>不用购买、管理服务器等基础设施，不用关心服务器的运维，节省人力成本；</li>
<li>基于 Serverless 的 API，具备自动弹性伸缩的能力，能根据请求流量弹性扩缩容，让你不再担心流量波峰、波谷；</li>
<li>基于 Serverless 的 API 按实际资源使用量来付费，节省财务成本。</li>
</ul>
<blockquote>
<p>因为好处很多，很多开发者跃跃欲试，但在实践过程中却遇到了很多问题，比如怎么设计最优的架构？怎么组织代码？怎么管理多个函数？所以今天我就以开发一个内容管理系统为例，带你学习怎么基于 Serverless 去开发一个 Restful API，解决上述共性问题。</p>
</blockquote>
<p>首先，我们需要对内容管理系统进行架构设计。</p>
<h4 id="2-1-内容管理系统的架构设计"><a href="#2-1-内容管理系统的架构设计" class="headerlink" title="2.1 内容管理系统的架构设计"></a>2.1 内容管理系统的架构设计</h4><p>在进行架构设计前，你要明确系统的需求。对于一个内容管理系统，最核心的功能（也是这一讲要实现的功能），主要有这样几个：</p>
<ul>
<li>用户注册；</li>
<li>用户登录；</li>
<li>发布文章；</li>
<li>修改文章；</li>
<li>删除文章；</li>
<li>查询文章。</li>
</ul>
<blockquote>
<p>这 6 个功能分别对应了我们要实现的 Restful API。为了方便统一管理 API，在 Serverless 架构中我们通常会用到 API 网关，通过 API 网关触发函数执行，并且基于  API 网关我们还可以实现参数控制、超时时间、IP 黑名单、流量控制等高级功能。</p>
</blockquote>
<p>对于文章管理相关的 Restful API，用户发布文章前需要先登录，你已经知道在 Serverless 中可以用 JWT 进行身份认证，咱们的管理系统中的登录注册功能也将沿用上一讲的内容。</p>
<blockquote>
<p>在传统的 Serverful 架构中，通常会用 MySQL 等关系型数据库存储数据，但因为关系型数据库要在代码中维护连接状态及连接池，且一般不能自动扩容，并不适合 Serverless 应用，所以在 Serverless 架构中，通常选用表格存储等 Serverless NoSQL 数据来存储数据。</p>
</blockquote>
<p>基于 JWT 的身份认证方案、数据存储方案，我们可以画出 Serverless 的内容管理系统架构图：</p>
<p><img src="https://blog.poetries.top/img/static/images/20210418171452.png" alt></p>
<ul>
<li>图中主要表达的意思是： 通过 API 网关承接用户请求，并驱动函数执行。每个函数分别实现一个具体功能，并通过 JWT 实现身份认证，最后表格存储作为数据库。</li>
<li>其中，数据库中存储的数据主要是用户数据和文章数据。假设用户有 username（用户名） 和 password（密码） 两个属性；文章有 <code>article_id</code>（文章 ID）、<code>username</code>（创建者）、<code>title</code>（文章标题）、<code>content</code>（文章内容）、<code>create_date</code>（创建时间）、<code>update_date</code>（更新时间）这几个属性</li>
</ul>
<p><img src="https://blog.poetries.top/img/static/images/20210418171543.png" alt></p>
<p>接下来，你可以在表格存储中创建对应的数据表（你可以在表格存储控制台创建，也可以直接用我提供的这段代码进行创建）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> TableStore = <span class="built_in">require</span>(<span class="string">"tablestore"</span>);</span><br><span class="line"><span class="comment">// 初始化 TableStore client</span></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> TableStore.Client(&#123;</span><br><span class="line">  accessKeyId: <span class="string">'&lt;your access key&gt;'</span>,</span><br><span class="line">  accessKeySecret: <span class="string">'&lt;your access secret&gt;'</span>,</span><br><span class="line">  endpoint: <span class="string">"https://serverless-app.cn-shanghai.ots.aliyuncs.com"</span>,</span><br><span class="line">  instancename: <span class="string">"serverless-cms"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 user 表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参考文档： https://help.aliyun.com/document_detail/100594.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createUserTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> table = &#123;</span><br><span class="line">    tableMeta: &#123;</span><br><span class="line">      tableName: <span class="string">"user"</span>,</span><br><span class="line">      primaryKey: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"username"</span>, <span class="comment">// 用户名</span></span><br><span class="line">          type: TableStore.PrimaryKeyType.STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      definedColumn: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"password"</span>, <span class="comment">// 密码</span></span><br><span class="line">          type: TableStore.DefinedColumnType.DCT_STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 为数据表配置预留读吞吐量或预留写吞吐量。0 表示不预留吞吐量，完全按量付费</span></span><br><span class="line">    reservedThroughput: &#123;</span><br><span class="line">      capacityUnit: &#123;</span><br><span class="line">        read: <span class="number">0</span>,</span><br><span class="line">        write: <span class="number">0</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    tableOptions: &#123;</span><br><span class="line">      <span class="comment">// 数据的过期时间，单位为秒，-1表示永不过期</span></span><br><span class="line">      timeToLive: <span class="number">-1</span>,</span><br><span class="line">      <span class="comment">// 保存的最大版本数，1 表示每列上最多保存一个版本即保存最新的版本</span></span><br><span class="line">      maxVersions: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">await</span> client.createTable(table);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建文章表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createArticleTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> table = &#123;</span><br><span class="line">    tableMeta: &#123;</span><br><span class="line">      tableName: <span class="string">"article"</span>,</span><br><span class="line">      primaryKey: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"article_id"</span>, <span class="comment">// 文章 ID，唯一字符串</span></span><br><span class="line">          type: TableStore.PrimaryKeyType.STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      definedColumn: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"title"</span>,</span><br><span class="line">          type: TableStore.DefinedColumnType.DCT_STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"username"</span>,</span><br><span class="line">          type: TableStore.DefinedColumnType.DCT_STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"content"</span>,</span><br><span class="line">          type: TableStore.DefinedColumnType.DCT_STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"create_date"</span>,</span><br><span class="line">          type: TableStore.DefinedColumnType.DCT_STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">"update_date"</span>,</span><br><span class="line">          type: TableStore.DefinedColumnType.DCT_STRING,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 为数据表配置预留读吞吐量或预留写吞吐量。0 表示不预留吞吐量，完全按量付费</span></span><br><span class="line">    reservedThroughput: &#123;</span><br><span class="line">      capacityUnit: &#123;</span><br><span class="line">        read: <span class="number">0</span>,</span><br><span class="line">        write: <span class="number">0</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    tableOptions: &#123;</span><br><span class="line">      <span class="comment">// 数据的过期时间，单位为秒，-1表示永不过期</span></span><br><span class="line">      timeToLive: <span class="number">-1</span>,</span><br><span class="line">      <span class="comment">// 保存的最大版本数，1 表示每列上最多保存一个版本即保存最新的版本</span></span><br><span class="line">      maxVersions: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">await</span> client.createTable(table);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> createUserTable();</span><br><span class="line">  <span class="keyword">await</span> createArticleTable();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码主要创建了 user 和 article 两张表，其中 user 表的主键是 username，article 表的主键是 article_id，主键的作用是方便查询。除了主键，我还定义了几个列。其实对于表格存储，默认也可以不创建列，表格存储是宽表，除主键外，数据列可以随意扩展</p>
</blockquote>
<p>在完成了数据库表的创建后，我们就可以开始进行系统实现了。</p>
<h4 id="2-2-内容管理系统的实现"><a href="#2-2-内容管理系统的实现" class="headerlink" title="2.2 内容管理系统的实现"></a>2.2 内容管理系统的实现</h4><p>为了方便你学习，为你提供了完整代码（代码地址），你可以参考着学习。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/poetries/serverless-class</span><br><span class="line">$ cd 15/cms</span><br></pre></td></tr></table></figure>
<p>整个代码目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── config</span><br><span class="line">│   │   └── index.js</span><br><span class="line">│   ├── db</span><br><span class="line">│   │   └── client.js</span><br><span class="line">│   ├── function</span><br><span class="line">│   │   ├── article</span><br><span class="line">│   │   │   ├── create.js</span><br><span class="line">│   │   │   ├── delete.js</span><br><span class="line">│   │   │   ├── detail.js</span><br><span class="line">│   │   │   └── update.js</span><br><span class="line">│   │   └── user</span><br><span class="line">│   │       ├── login.js</span><br><span class="line">│   │       └── register.js</span><br><span class="line">│   └── middleware</span><br><span class="line">│       └── auth.js</span><br><span class="line">└── template.yml</span><br></pre></td></tr></table></figure>
<p>其中，所有业务代码都放在 src 目录中：</p>
<ul>
<li><code>config/index.js</code> 是配置文件，里面包含身份凭证等配置信息；</li>
<li><code>db/client.js</code> 对表格存储的增删改查操作进行了封装，方便在函数中使用（将数据库的操作封装还有一个好处是，如果你之后想要迁移到其他数据库，只要修改 db/client.js 中的逻辑，不用修改业务代码）；</li>
<li><code>middleware</code> 目录中是一些中间件，比如 <code>auth.js</code>，用于身份认证；</li>
<li><code>functions</code> 目录中就是所有函数，登录、注册、创建文章等，每个功能分别对应一个函数；</li>
<li><code>template.yaml</code> 是应用配置文件，包括函数和 API 网关的配置。</li>
</ul>
<p>根据前面梳理的系统功能，我们需要实现以下几个 API：</p>
<table>
<thead>
<tr>
<th>用户注册</th>
<th>POST /user/register</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户登录</td>
<td>POST /user/login</td>
</tr>
<tr>
<td>发布文章</td>
<td>POST /article/create</td>
</tr>
<tr>
<td>查询文章</td>
<td>GET /article/detail/[article_id]</td>
</tr>
<tr>
<td>更新文章</td>
<td>POST /article/update</td>
</tr>
<tr>
<td>删除文章</td>
<td>PUT /article/delete/[article_id]</td>
</tr>
</tbody>
</table>
<blockquote>
<p>每个 API 对应一个具体的函数，每个函数也都有一个与之对应的 API 网关触发器。由于这些函数属于同一个应用，所以我们可以通过一个 template.yaml 来定义所有函数。同时也可以在 template.yaml 中定义函数的 API 网关触发器，这样部署函数时，就会自动创建 API 网关。</p>
</blockquote>
<p>内容管理系统的 <code>template.yaml</code> 格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROSTemplateFormatVersion: <span class="string">'2015-09-01'</span></span><br><span class="line">Transform: <span class="string">'Aliyun::Serverless-2018-04-03'</span></span><br><span class="line">Resources:</span><br><span class="line">  <span class="comment"># 函数服务，该服务中的函数都是内容管理系统的函数</span></span><br><span class="line">  serverless-cms:</span><br><span class="line">    Type: <span class="string">'Aliyun::Serverless::Service'</span></span><br><span class="line">    Properties:</span><br><span class="line">      Description: <span class="string">'Serverless 内容管理系统'</span></span><br><span class="line">    <span class="comment"># 函数名称</span></span><br><span class="line">    [functionName]:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        <span class="comment"># 函数路径</span></span><br><span class="line">        Handler: &lt;functionPath&gt;.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">  <span class="comment"># API 网关分组，分钟中的所有 API 都是内容管理系统的 API</span></span><br><span class="line">  ServerlessCMSGroup: </span><br><span class="line">    Type: <span class="string">'Aliyun::Serverless::Api'</span></span><br><span class="line">    Properties:</span><br><span class="line">      StageName: RELEASE</span><br><span class="line">      DefinitionBody:</span><br><span class="line">        &lt;Path&gt;: <span class="comment"># 请求的 path</span></span><br><span class="line">          post: <span class="comment"># 请求的 method</span></span><br><span class="line">            x-aliyun-apigateway-api-name: user_register <span class="comment"># API 名称</span></span><br><span class="line">            x-aliyun-apigateway-fc: <span class="comment"># 当请求该 API 时，要触发的函数，</span></span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;&lt;functionName&gt;.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br></pre></td></tr></table></figure>
<p><strong>template.yaml  主要分为两部分</strong>： 函数定义和 API 网关定义，每个函数都有一个与之对应的 API 网关。我们用 serverless-cms 服务来表示内容管理系统这个应用，服务内的所有函数都是内容管理系统的函数。同理，ServerlessCMSGroup 这个 API 网关分组中的所有 API 都是内容管理系统的 API。</p>
<p>完整的 <code>template.yaml</code>配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROSTemplateFormatVersion: <span class="string">'2015-09-01'</span></span><br><span class="line">Transform: <span class="string">'Aliyun::Serverless-2018-04-03'</span></span><br><span class="line">Resources:</span><br><span class="line">  <span class="comment"># 函数服务</span></span><br><span class="line">  serverless-cms:</span><br><span class="line">    Type: <span class="string">'Aliyun::Serverless::Service'</span></span><br><span class="line">    Properties:</span><br><span class="line">      Description: <span class="string">'Serverless 内容管理系统'</span></span><br><span class="line">    user-register:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        Handler: src/<span class="keyword">function</span>/user/register.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">    user-login:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        Handler: src/<span class="keyword">function</span>/user/login.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">    article-create:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        Handler: src/<span class="keyword">function</span>/article/create.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">    article-detail:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        Handler: src/<span class="keyword">function</span>/article/detail.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">    article-update:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        Handler: src/<span class="keyword">function</span>/article/update.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">    article-delete:</span><br><span class="line">      Type: <span class="string">'Aliyun::Serverless::Function'</span></span><br><span class="line">      Properties:</span><br><span class="line">        Handler: src/<span class="keyword">function</span>/article/delete.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        CodeUri: <span class="string">'./'</span></span><br><span class="line">  <span class="comment"># API 网关分组</span></span><br><span class="line">  ServerlessCMSGroup: </span><br><span class="line">    Type: <span class="string">'Aliyun::Serverless::Api'</span></span><br><span class="line">    Properties:</span><br><span class="line">      StageName: RELEASE</span><br><span class="line">      DefinitionBody:</span><br><span class="line">        <span class="string">'/user/register'</span>: <span class="comment"># 请求的 path</span></span><br><span class="line">          post: <span class="comment"># 请求的 method</span></span><br><span class="line">            x-aliyun-apigateway-api-name: user_register <span class="comment"># API 名称</span></span><br><span class="line">            x-aliyun-apigateway-fc: <span class="comment"># 当请求该 API 时，要触发的函数，</span></span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;user-register.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br><span class="line">        <span class="string">'/user/login'</span>:</span><br><span class="line">          post:</span><br><span class="line">            x-aliyun-apigateway-api-name: user_login</span><br><span class="line">            x-aliyun-apigateway-fc:</span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;user-login.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br><span class="line">        <span class="string">'/article/create'</span>:</span><br><span class="line">          post:</span><br><span class="line">            x-aliyun-apigateway-api-name: article_create</span><br><span class="line">            x-aliyun-apigateway-fc:</span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;article-create.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br><span class="line">        <span class="string">'/article/detail/[article_id]'</span>:</span><br><span class="line">          GET:</span><br><span class="line">            x-aliyun-apigateway-api-name: article_detail</span><br><span class="line">            x-aliyun-apigateway-request-parameters:</span><br><span class="line">              - apiParameterName: <span class="string">'article_id'</span></span><br><span class="line">                location: <span class="string">'Path'</span></span><br><span class="line">                parameterType: <span class="string">'String'</span></span><br><span class="line">                required: <span class="string">'REQUIRED'</span></span><br><span class="line">            x-aliyun-apigateway-fc:</span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;article-detail.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br><span class="line">        <span class="string">'/article/update/[article_id]'</span>:</span><br><span class="line">          PUT:</span><br><span class="line">            x-aliyun-apigateway-api-name: article_update</span><br><span class="line">            x-aliyun-apigateway-request-parameters:</span><br><span class="line">              - apiParameterName: <span class="string">'article_id'</span></span><br><span class="line">                location: <span class="string">'Path'</span></span><br><span class="line">                parameterType: <span class="string">'String'</span></span><br><span class="line">                required: <span class="string">'REQUIRED'</span></span><br><span class="line">            x-aliyun-apigateway-fc:</span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;article-update.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br><span class="line">        <span class="string">'/article/delete/[article_id]'</span>:</span><br><span class="line">          DELETE:</span><br><span class="line">            x-aliyun-apigateway-api-name: article_update</span><br><span class="line">            x-aliyun-apigateway-request-parameters:</span><br><span class="line">              - apiParameterName: <span class="string">'article_id'</span></span><br><span class="line">                location: <span class="string">'Path'</span></span><br><span class="line">                parameterType: <span class="string">'String'</span></span><br><span class="line">                required: <span class="string">'REQUIRED'</span></span><br><span class="line">            x-aliyun-apigateway-fc:</span><br><span class="line">              arn: acs:<span class="built_in">fc</span>:::services/<span class="variable">$&#123;serverless-cms.Arn&#125;</span>/<span class="built_in">functions</span>/<span class="variable">$&#123;article-delete.Arn&#125;</span>/</span><br><span class="line">              timeout: 3000</span><br></pre></td></tr></table></figure>
<p>在这份配置中，需要注意两个地方：</p>
<p>函数的 Handler 配置，Handler 可以写函数路径，比如<code>src/function/user/register.handler</code>表示<code>src/function/user/目录中的 register.js 文件中的 handler 方法</code>；</p>
<p>API 网关配置中的<code>/article/detail/[article_id]Path</code>，这种带参数的 PATH，必须使用<code>x-aliyun-apigateway-request-parameters</code>指定 Path 参数。</p>
<p>接下来，我们就来实现内容管理系统的各个 API，也就是 template.yaml 中定义的各个函数。</p>
<h4 id="2-3-用户注册"><a href="#2-3-用户注册" class="headerlink" title="2.3 用户注册"></a>2.3 用户注册</h4><p>用户注册接口定义如下。</p>
<p>请求方法：POST。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path：/user/register</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Body参数：username 用户名、password 密码。</p>
</blockquote>
<p>整体代码很简单，在入口函数 handler 中，通过 event 得到 API 网关传递过来的 HTTP 请求 body 数据，然后从中得到 username、password，再将用户信息写入数据库。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/function/user/register</span></span><br><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">"../../db/client"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户注册</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; username 用户名</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; password 密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> client.createRow(<span class="string">"user"</span>, &#123; username &#125;, &#123; password &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从 event 中获取 API 网关传递 HTTP 请求 body 数据</span></span><br><span class="line">  <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.parse(event.toString()).body);</span><br><span class="line">  <span class="keyword">const</span> &#123; username, password &#125; = body;</span><br><span class="line">  register(username, password)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> callback(<span class="literal">null</span>, &#123; <span class="attr">success</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      callback(error, &#123; <span class="attr">success</span>: <span class="literal">false</span>, <span class="attr">message</span>: <span class="string">"用户注册失败"</span> &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码完成后，就可以将应用部署到函数计算：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署应用</span></span><br><span class="line">$ fun deploy</span><br><span class="line">Waiting <span class="keyword">for</span> service serverless-cms to be deployed...</span><br><span class="line">...</span><br><span class="line">service serverless-cms deploy success</span><br><span class="line">Waiting <span class="keyword">for</span> api gateway ServerlessCMSGroup to be deployed...</span><br><span class="line">...</span><br><span class="line">api gateway ServerlessCMSGroup deploy success</span><br></pre></td></tr></table></figure>
<p>部署过程中，如果看到函数服务 serverless-cms  和 API 网关 ServerlessCMSGroup 都成功部署了，就说明应用部署完成。部署完成后，API 网关会提供一个用来测试的 API Endpoint，当然你也可以绑定自定义域名。</p>
<p>我们可以通过 curl 测试一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/user/register \</span><br><span class="line">-X POST \</span><br><span class="line">-d &quot;username=Jack&amp;password=123456&quot;</span><br><span class="line">&#123;&quot;success&quot;:true&#125;</span><br></pre></td></tr></table></figure>
<p>返回 <code>{&quot;success&quot;: true}</code> ，说明用户注册成功。这时在表格存储控制台也可以看到刚注册的用户。</p>
<p><img src="https://blog.poetries.top/img/static/images/20210418172230.png" alt></p>
<h4 id="2-4-用户登录"><a href="#2-4-用户登录" class="headerlink" title="2.4 用户登录"></a>2.4 用户登录</h4><p>完成用户注册函数开发后，就可以接着开发登录。用户登录的接口定义如下。</p>
<ul>
<li>请求方法：POST。</li>
<li>Path：/user/login</li>
<li>Body 参数：username 用户名、password 密码。</li>
</ul>
<blockquote>
<p>登录的逻辑就是根据用户输入的密码是否正确，如果正确就生成一个 token 返回给调用方。代码实现如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/function/user/login</span></span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">"assert"</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; jwt_secret &#125; = <span class="built_in">require</span>(<span class="string">"../../config"</span>);</span><br><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">"../../db/client"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; username 用户名</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; password 密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> client.getRow(<span class="string">"user"</span>, &#123; username &#125;);</span><br><span class="line">  assert(user &amp;&amp; user.password === password);</span><br><span class="line">  <span class="keyword">const</span> token = jwt.sign(&#123; <span class="attr">username</span>: user.username &#125;, jwt_secret);</span><br><span class="line">  <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.parse(event.toString()).body);</span><br><span class="line">  <span class="keyword">const</span> &#123; username, password &#125; = body;</span><br><span class="line">  login(username, password)</span><br><span class="line">    .then(<span class="function">(<span class="params">token</span>) =&gt;</span> callback(<span class="literal">null</span>, &#123; <span class="attr">success</span>: <span class="literal">true</span>, <span class="attr">data</span>: &#123; token &#125; &#125;))</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      callback(error, &#123; <span class="attr">success</span>: <span class="literal">false</span>, <span class="attr">message</span>: <span class="string">"用户登录失败"</span> &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将其部署到函数计算后，我们也可以使用 curl 命令进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/user/login \</span><br><span class="line">-X POST \</span><br><span class="line">-d &quot;username=Jack&amp;password=123456&quot;</span><br><span class="line">&#123;&quot;success&quot;:true,&quot;data&quot;:&#123;&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-身份认证"><a href="#2-5-身份认证" class="headerlink" title="2.5 身份认证"></a>2.5 身份认证</h4><p>在完成了注册登录接口后，我们再来看一下内容管理系统中，身份认证应该怎么实现。</p>
<p>在之前，我们实现了一个 Express.js 框架的身份认证中间件，用来拦截所有请求，身份认证通过后才能进执行后面的代码逻辑。在内容管理系统中，你也可以参考 Express.js 的思想，实现一个 auth.js 专门用于身份认证，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/middleware/auth.js</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">"jsonwebtoken"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; jwt_secret &#125; = <span class="built_in">require</span>(<span class="string">"../config/index"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 身份认证</span></span><br><span class="line"><span class="comment"> * @param &#123;object&#125; event API 网关的 event 对象</span></span><br><span class="line"><span class="comment"> * @return &#123;object&#125; 认证通过后返回 user 信息；认证失败则返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> auth = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(event.toString());</span><br><span class="line">    <span class="keyword">if</span> (data.headers &amp;&amp; data.headers.Authorization) &#123;</span><br><span class="line">      <span class="keyword">const</span> token = <span class="built_in">JSON</span>.parse(event.toString())</span><br><span class="line">        .headers.Authorization.split(<span class="string">" "</span>)</span><br><span class="line">        .pop();</span><br><span class="line">      <span class="keyword">const</span> user = jwt.verify(token, jwt_secret);</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = auth;</span><br></pre></td></tr></table></figure>
<ul>
<li>其原理很简单，就是从 API 网关的 event 对象中获取 token，然后验证 token 是否正常。如果认证通过，就返回 user 信息，失败就返回 false。</li>
<li>这样在需要身份认证的函数中，你只引入 auth.js 并传入 event 对象就可以了。下面是一个简单的示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = <span class="built_in">require</span>(<span class="string">'./middleware/auth'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 auth 进行身份认证</span></span><br><span class="line">  <span class="keyword">const</span> user = auth(event);</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="comment">// 若认证失败则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> callback(<span class="string">'身份认证失败!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过身份认证后的业务逻辑</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callback(<span class="literal">null</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了登录注册，其他接口都需要身份认证，所以接下来我们就通过实现“发布文章”函数来实际使用 auth.js。</p>
</blockquote>
<h4 id="2-6-发布文章"><a href="#2-6-发布文章" class="headerlink" title="2.6 发布文章"></a>2.6 发布文章</h4><p>发布文章的接口定义如下。</p>
<ul>
<li>请求方法：POST。</li>
<li>Path：/article/create</li>
<li>Headers 参数: Authorization token。</li>
<li>Body 参数：title、content。</li>
</ul>
<blockquote>
<p>由于登录后才能发布文章，所以要先通过登录接口获取 token，然后调用 /article/create 接口时，再将 token 放在 HTTP Headers 参数中。发布文章的代码实现如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/function/article/auth</span></span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">"uuid"</span>);</span><br><span class="line"><span class="keyword">const</span> auth = <span class="built_in">require</span>(<span class="string">"../../middleware/auth"</span>);</span><br><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">"../../db/client"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建文章</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; username 用户名</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; title 文章标题</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; content 文章内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createArticle</span>(<span class="params">username, title, content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> article_id = uuid.v4();</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString();</span><br><span class="line">  <span class="keyword">await</span> client.createRow(</span><br><span class="line">    <span class="string">"article"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      article_id,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      username,</span><br><span class="line">      title,</span><br><span class="line">      content,</span><br><span class="line">      create_date: now,</span><br><span class="line">      update_date: now,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> article_id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 身份认证</span></span><br><span class="line">  <span class="keyword">const</span> user = auth(event);</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="comment">// 若认证失败则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> callback(<span class="string">"身份认证失败"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从 user 中获取 username</span></span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = user;</span><br><span class="line">  <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.parse(event.toString()).body);</span><br><span class="line">  <span class="keyword">const</span> &#123; title, content &#125; = body;</span><br><span class="line">  createArticle(username, title, content)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      callback(<span class="literal">null</span>, &#123;</span><br><span class="line">        success: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      callback(error, &#123;</span><br><span class="line">        success: <span class="literal">false</span>,</span><br><span class="line">        message: <span class="string">"创建文章失败"</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先是使用 auth.js 进行身份认证，认证通过后就可以从 user 中获取 username。然后再从请求体中获取文章标题和文章内容数据，将其存入数据库。</p>
<p>接下来我们依旧可以将函数部署和使用 curl 进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/article/create \</span><br><span class="line">-X POST \</span><br><span class="line">-d &quot;title=这是文章标题&amp;content=内容内容内容......&quot; \</span><br><span class="line">-H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;</span><br><span class="line">&#123;&quot;success&quot;:true,&quot;data&quot;:&#123;&quot;article_id&quot;:&quot;d4b9bad8-a0ed-499d-b3c6-c57f16eaa193&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>在测试时，我们需要将 token 放在 HTTP 请求头的 Authorization 属性中。文章发布成功后，你就可以在表格存储中看到对应的数据了。</p>
<p><img src="https://blog.poetries.top/img/static/images/20210418172448.png" alt></p>
<h4 id="2-7-查询文章"><a href="#2-7-查询文章" class="headerlink" title="2.7 查询文章"></a>2.7 查询文章</h4><blockquote>
<p>发布文章的接口开发完成后，我们继续开发一个查询文章的接口，这样就可以查询出刚才创建的文章。查询文章接口定义如下。</p>
</blockquote>
<ul>
<li>请求方法：GET。</li>
<li><code>Path：/article/detail/[article_id]</code></li>
<li>Headers 参数: Authorization token。</li>
</ul>
<blockquote>
<p>在查询文章接口中，我们需要在 Path 中定义文章 ID 参数，即 article_id。这样在函数代码中，你就可以通过 event 对象的 pathParameters 中获取 article_id 参数，然后根据 article_id 来查询文章详情了。完整代码如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">"uuid"</span>);</span><br><span class="line"><span class="keyword">const</span> auth = <span class="built_in">require</span>(<span class="string">"../../middleware/auth"</span>);</span><br><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">"../../db/client"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文章详情</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; title 文章 ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getArticle</span>(<span class="params">article_id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> client.getRow(</span><br><span class="line">    <span class="string">"article"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      article_id,</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 身份认证</span></span><br><span class="line">  <span class="keyword">const</span> user = auth(event);</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="comment">// 若认证失败则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> callback(<span class="string">"身份认证失败"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从 event 对象中获取文章 ID</span></span><br><span class="line">  <span class="keyword">const</span> article_id = <span class="built_in">JSON</span>.parse(event.toString()).pathParameters[<span class="string">'article_id'</span>];</span><br><span class="line">  getArticle(article_id)</span><br><span class="line">    .then(<span class="function">(<span class="params">detail</span>) =&gt;</span></span><br><span class="line">      callback(<span class="literal">null</span>, &#123;</span><br><span class="line">        success: <span class="literal">true</span>,</span><br><span class="line">        data: detail</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      callback(error, &#123;</span><br><span class="line">        success: <span class="literal">false</span>,</span><br><span class="line">        message: <span class="string">"创建文章失败"</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>开发完成后，我们可以将其部署到函数计算，再用 curl 命令进行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/article/detail/d4b9bad8-a0ed-499d-b3c6-c57f16eaa193 \</span><br><span class="line">-H <span class="string">"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA"</span></span><br><span class="line">&#123;<span class="string">"success"</span>:<span class="literal">true</span>,<span class="string">"data"</span>:&#123;<span class="string">"article_id"</span>:<span class="string">"d4b9bad8-a0ed-499d-b3c6-c57f16eaa193"</span>,<span class="string">"content"</span>:<span class="string">"内容内容内容......"</span>,<span class="string">"create_date"</span>:<span class="string">"1/24/2021, 2:05:46 PM"</span>,<span class="string">"title"</span>:<span class="string">"这是文章标题"</span>,<span class="string">"update_date"</span>:<span class="string">"1/24/2021, 2:05:46 PM"</span>,<span class="string">"username"</span>:<span class="string">"Jack"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，查询文章的接口按照预期返回了文章详情。</p>
<h4 id="2-8-更新文章"><a href="#2-8-更新文章" class="headerlink" title="2.8 更新文章"></a>2.8 更新文章</h4><blockquote>
<p>更新文章的 API Path 参数和查询文章一样，都需要 Path 中定义 article_id。而其 body 参数则与创建文章相同。此外，更新文章的请求 method 是 PUT，因为在 Restful API 规范中，我们通常使用 POST 来表示创建， 使用 PUT 来表示更新。</p>
</blockquote>
<p>更新文章的接口定义如下。</p>
<p>请求方法：PUT。</p>
<ul>
<li>Path：/article/update/[article_id]</li>
<li>Headers 参数: Authorization token。</li>
<li>Body 参数：title、content。</li>
</ul>
<p>更新文章的逻辑就是根据  article_id 去更新一行数据。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = <span class="built_in">require</span>(<span class="string">"../../middleware/auth"</span>);</span><br><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">"../../db/client"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新文章</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; article_id 待更新的文章 ID</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; title 文章标题</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; content 文章内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">updateArticle</span>(<span class="params">article_id, title, content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString();</span><br><span class="line">  <span class="keyword">await</span> client.updateRow(</span><br><span class="line">    <span class="string">"article"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      article_id,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      title,</span><br><span class="line">      content,</span><br><span class="line">      update_date: now,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 身份认证</span></span><br><span class="line">  <span class="keyword">const</span> user = auth(event);</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="comment">// 若认证失败则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> callback(<span class="string">"身份认证失败"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> eventObject = <span class="built_in">JSON</span>.parse(event.toString())</span><br><span class="line">  <span class="comment">// 从 event 对象的 pathParameters 中获取 Path 参数</span></span><br><span class="line">  <span class="keyword">const</span> article_id = eventObject.pathParameters[<span class="string">'article_id'</span>];</span><br><span class="line">  <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(eventObject.body);</span><br><span class="line">  <span class="comment">// 从 event 对象的 body 中获取请求体参数</span></span><br><span class="line">  <span class="keyword">const</span> &#123; title, content &#125; = body;</span><br><span class="line">  updateArticle(article_id, title, content)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      callback(<span class="literal">null</span>, &#123;</span><br><span class="line">        success: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      callback(error, &#123;</span><br><span class="line">        success: <span class="literal">false</span>,</span><br><span class="line">        message: <span class="string">"更新文章失败"</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>开发并部署完成后，使用 curl 命令进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/article/update/d4b9bad8-a0ed-499d-b3c6-c57f16eaa193 \</span><br><span class="line">-X PUT \</span><br><span class="line">-d &quot;title=这是文章标题&amp;content=更新的内容......&quot; \</span><br><span class="line">-H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;</span><br><span class="line">&#123;&quot;success&quot;:true&#125;</span><br></pre></td></tr></table></figure>
<p>返回 <code>{&quot;success&quot;:true}</code> 则说明更新成功。</p>
<h4 id="2-9-删除文章"><a href="#2-9-删除文章" class="headerlink" title="2.9 删除文章"></a>2.9 删除文章</h4><blockquote>
<p>最后就还是一个删除文章的 API 了。删除文章的 API 也需要在 Path 中定义 article_id 参数，并且其 HTTP method 是 DELETE。具体接口定义如下。</p>
</blockquote>
<ul>
<li>请求方法：DELETE。</li>
<li>Path：/article/delete/[article_id]</li>
<li>Headers 参数: Authorization token，</li>
<li>删除文章很简单，就是根据 article_id 删除一行数据，代码如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">"uuid"</span>);</span><br><span class="line"><span class="keyword">const</span> auth = <span class="built_in">require</span>(<span class="string">"../../middleware/auth"</span>);</span><br><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">"../../db/client"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除文章</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; title 文章 ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteArticle</span>(<span class="params">article_id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> client.deleteRow(</span><br><span class="line">    <span class="string">"article"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      article_id,</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 身份认证</span></span><br><span class="line">  <span class="keyword">const</span> user = auth(event);</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="comment">// 若认证失败则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> callback(<span class="string">"身份认证失败"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从 event 对象中获取文章 ID</span></span><br><span class="line">  <span class="keyword">const</span> article_id = <span class="built_in">JSON</span>.parse(event.toString()).pathParameters[<span class="string">'article_id'</span>];</span><br><span class="line">  deleteArticle(article_id)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      callback(<span class="literal">null</span>, &#123;</span><br><span class="line">        success: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      callback(error, &#123;</span><br><span class="line">        success: <span class="literal">false</span>,</span><br><span class="line">        message: <span class="string">"删除文章失败"</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样我们可以通过 curl 命令进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http://a88f7e84f71749958100997b77b3e2f6-cn-beijing.alicloudapi.com/article/delete/d4b9bad8-a0ed-499d-b3c6-c57f16eaa193 \</span><br><span class="line">-X DELETE \</span><br><span class="line">-H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkphY2siLCJpYXQiOjE2MTE0OTI2ODF9.c56Xm4RBLYl5yVtR_Vk0IZOL0yijofcyE-P7vjKf4nA&quot;</span><br><span class="line">&#123;&quot;success&quot;:true&#125;</span><br></pre></td></tr></table></figure>
<p>删除成功后，再去表格存储中就找不到这行记录了。至此，内容管理系统的 Restful API 就开发完毕了。</p>
<h4 id="2-10-总结"><a href="#2-10-总结" class="headerlink" title="2.10 总结"></a>2.10 总结</h4><blockquote>
<p>可以看到，基于 Serverless 开发 Restful API 的整个代码非常简单，每个函数只负责一个独立的业务，职责单一、逻辑清晰。关于这一讲，我想强调这样几个重点：</p>
</blockquote>
<ul>
<li>基于 Serverless 开发 API 时，建议你使用 API 网关进行 API 的管理；</li>
<li>对于数据库等第三方服务，建议对其基本操作进行封装，这样更方便进行扩展；</li>
<li>Serverless 函数需要保持简单、独立、单一职责。</li>
</ul>
<h3 id="3-基于-Serverless-开发高可用音视频处理系统"><a href="#3-基于-Serverless-开发高可用音视频处理系统" class="headerlink" title="3 基于 Serverless 开发高可用音视频处理系统"></a>3 基于 Serverless 开发高可用音视频处理系统</h3><p>Serverless 的应用场景非常广泛，它还可以用于大数据计算、物联网应用、音视频处理等。为了让你了解到更多的 Serverless 的应用场景，我准备了今天的内容。</p>
<p>音视频处理是一个 CPU 密集型的操作，非常消耗计算资源，以往我们处理视频就要采购大量的高性能服务器，财务成本和维护成本都很高。有了 Serverless 后，就不用再关心计算资源不足的问题，也不用担心服务器的维护，并且还能降低成本。</p>
<p>接下来，我先带你了解传统的音视频处理方案，然后在此基础上再带你学习并实践基于 Serverless 的音视频处理系统，这样你理解得会更加深入。</p>
<h4 id="3-1-传统音视频处理方案"><a href="#3-1-传统音视频处理方案" class="headerlink" title="3.1 传统音视频处理方案"></a>3.1 传统音视频处理方案</h4><p>近几年，计算机技术和通信技术日新月异，信息传播的媒介也在不断演变，从文字到图片再到视频，各种短视频、直播甚至 AR、VR 等产品百花齐放。在这些产品的背后，离不开音视频处理技术。</p>
<p>得益于云计算的发展，有些云厂商推出了对应的视频解决方案，因此你现在要搭建一个视频处理程序是很容易的（下图就是一个典型的视频处理方案）：</p>
<p><img src="https://blog.poetries.top/img/static/images/20210418173047.png" alt></p>
<p>在该方案中，我们用 OSS 来存储海量的视频内容，视频上传后用视频转码服务将不同来源的视频进行转码，以适配各种终端，然后利用 CDN 提升客户端访问视频的速度。</p>
<p>不过，虽然用了视频转码服务，但我们还是要购买大量的服务器，搭建自己的视频处理系统，对视频进行更高级的自定义处理，比如视频转码后将元数据存入数据库、生成视频前几秒的 GIF 图片用来做视频的封面，以及各种格式的音视频转换等。</p>
<p>除此之外，当我们已经在服务器上部署了一套视频处理系统后，可能还会遇到一些问题。比如，如何应对大量并发任务？能否让这个系统有更高的弹性和可用性？这些问题其实超出了视频处理本身的范围，我们的需求只是进行视频处理，但不得不面临繁重的运维工作。并且我们可能为了应对周期大量处理任务或瞬时流量，不得不购买大量的服务器，成本大幅增加，在服务器的闲置期间还造成了不必要的资源浪费。而且我们也无法 100% 利用机器的性能，这也是一种资源浪费。</p>
<p>而 Serverless 就能解决这些问题，基于 Serverless 你可以很轻松实现一个弹性、可扩展、低成本、免运维、高可用的音视频处理系统。</p>
<h4 id="3-2-基于-Serverless-的音视频处理系统"><a href="#3-2-基于-Serverless-的音视频处理系统" class="headerlink" title="3.2 基于 Serverless 的音视频处理系统"></a>3.2 基于 Serverless 的音视频处理系统</h4><ul>
<li>从基础设施的角度来看，基于 Serverless 的音视频解决方案，主要是替换了传统方案中的计算资源，也就是替换了服务器。</li>
<li>此外，我们基于 Serverless 平台提供的丰富的触发器，也能简化编程模型。比如以往我们需要用户将视频上传到 OSS 后，再通过接口主动通知服务器进行视频处理，但在 Serverless 架构中，我们可以为函数设置 OSS 触发器，这样只要有文件被上传到 OSS 中，就可以触发函数执行，进而简化了业务逻辑。</li>
</ul>
<p>下图就是基于 Serverless 的视频处理系统解决方案：</p>
<p><img src="https://blog.poetries.top/img/static/images/20210418173248.png" alt></p>
<p>用户将视频上传后 OSS 后，触发函数计算中的视频转码函数执行，该函数对视频进行转码后，将元数据存入数据库，然后将转码后的视频再保存到 OSS 中。</p>
<p>接下来我们就实现一个基于 Serverless 的音视频处理系统，系统主要有以下几个功能：</p>
<ul>
<li>获取视频时长；</li>
<li>获取视频元数据；</li>
<li>截取视频 GIF 图；</li>
<li>为视频添加水印；</li>
<li>对视频进行转码。</li>
</ul>
<p>为了方便你实践，我为你提供了一份示例代码，你可以通过 git 下载查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/poetries/serverless-class</span><br><span class="line">$ cd 18/serverless-video</span><br></pre></td></tr></table></figure>
<p>代码结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── functions</span><br><span class="line">│   ├── common</span><br><span class="line">│   │   └── utils.js</span><br><span class="line">│   ├── get_duration</span><br><span class="line">│   │   └── index.js</span><br><span class="line">│   └── get_meta</span><br><span class="line">│       └── index.js</span><br><span class="line">├── build.js</span><br><span class="line">├── ffmpeg</span><br><span class="line">├── ffprobe</span><br><span class="line">├── package.json</span><br><span class="line">└── template.yml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 functions 中是函数源代码，common/utils.js是一些公共方法，get_duration、get_meta等目录则分别对应的每个具体的功能。build.js是用来构建函数的脚本。在代码中，我们会使用 FFmpeg 进行视频处理，FFmpeg 是一款功能强大、用途广泛的开源软件，很多视频网站都在用它，比如 Youtube、Bilibili。ffmpeg 和 ffprobe 是 FFmpeg 的两个命令行工具，我们会将其作为依赖部署到 FaaS 平台（函数计算）上，这样在函数中就可以使用这两个命令来处理视频了。</p>
</blockquote>
<p>接下来就让我们学习具体如何实现。</p>
<p>由于这几个函数的逻辑基本类似，所以我主要针对“获取视频时长”函数进行讲解，学会了这个函数的实现就很容易理解其他函数了。另外，由于该视频处理系统用到了公共方法及依赖，所以我还会为你介绍如何部署这些函数。</p>
<h4 id="3-3-获取视频时长函数的实现"><a href="#3-3-获取视频时长函数的实现" class="headerlink" title="3.3 获取视频时长函数的实现"></a>3.3 获取视频时长函数的实现</h4><p>首先是获取视频时长的实现，也就是 get_duration 函数。我们可以通过 ffprobe 来获取视频时长，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ffprobe -v quiet -show_entries format=duration -print_format json -i video.mp4</span><br><span class="line">&#123;</span><br><span class="line">    &quot;format&quot;: &#123;</span><br><span class="line">        &quot;duration&quot;: &quot;170.859000&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中-print_format json是指以 JSON 格式输出结果，-i是指定文件位置，可以是本地文件，也可以是网络上的远程文件。</p>
</blockquote>
<p>所以获取视频时长的函数逻辑就是： 下载 OSS 中的文件到本地，然后运行 ffprobe 命令得到视频时长，最后返回视频时长。</p>
<p>为了让代码尽可能复用，所以我在<code>common/utils.js</code>中实现了一些公共方法，代码大致如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// common/utils.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行 Linux 命令</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; command 待运行的命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params">command</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(command)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    child_process.exec(command, (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">        <span class="keyword">return</span> reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (stderr) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(stderr)</span><br><span class="line">        <span class="keyword">return</span> reject(stderr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(stdout)</span><br><span class="line">      <span class="keyword">return</span> resolve(stdout);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 OSS Client</span></span><br><span class="line"><span class="comment"> * @param &#123;object&#125; context 函数上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOssClient</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取函数计算的临时访问凭证</span></span><br><span class="line">  <span class="keyword">const</span> accessKeyId = context.credentials.accessKeyId;</span><br><span class="line">  <span class="keyword">const</span> accessKeySecret = context.credentials.accessKeySecret;</span><br><span class="line">  <span class="keyword">const</span> securityToken = context.credentials.securityToken;</span><br><span class="line">  <span class="comment">// 初始化 OSS 客户端</span></span><br><span class="line">  <span class="keyword">const</span> client = oss(&#123;</span><br><span class="line">    accessKeyId,</span><br><span class="line">    accessKeySecret,</span><br><span class="line">    stsToken: securityToken,</span><br><span class="line">    bucket: OSS_BUCKET_NAME,</span><br><span class="line">    region: OSS_REGION,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  exec,</span><br><span class="line">  getOssClient,</span><br><span class="line">  OSS_VIDEO_NAME,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>common/utils.js的代码主要就包含两个方法：exec和getOssClient，分别用来执行 Linux 系统命令和获取 OSS 客户端。</p>
</blockquote>
<p>这样我们在functions/get_duration/index.js中就可以直接引入并使用了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functions/get_duration/index.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; exec, getOssClient, OSS_VIDEO_NAME &#125; = <span class="built_in">require</span>(<span class="string">"../common/utils"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取视频元信息</span></span><br><span class="line"><span class="comment"> * @param &#123;object&#125; client OSS client</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getDuration</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filePath = <span class="string">"/tmp/video.mp4"</span>;</span><br><span class="line">  <span class="keyword">await</span> client.get(OSS_VIDEO_NAME, filePath);</span><br><span class="line">  <span class="keyword">const</span> command = <span class="string">`./ffprobe -v quiet -show_entries format=duration -print_format json -i <span class="subst">$&#123;filePath&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> exec(command);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.handler = <span class="function"><span class="keyword">function</span> (<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 OSS 客户端</span></span><br><span class="line">  <span class="keyword">const</span> client = getOssClient(context);</span><br><span class="line">  getDuration(client)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"视频时长: \n"</span>, res);</span><br><span class="line">      callback(<span class="literal">null</span>, res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> callback(err));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先注意第 20 行，我们通过 getOssClient 获取到 OSS 客户端，然后调用 getDuration 函数执行业务逻辑，也就是获取视频时长。</p>
<p>在 getDuration 中，我们先下载视频到临时目录/tmp/video.mp4中，临时目录是可以读写的，当前代码目录只能写不能读。然后在第 13 行，通过 exec 执行了获取视频时长的命令，最后将得到的结果返回。</p>
<p>这样获取视频时长的功能就开发完成了。</p>
<p>获取视频元数据等其他函数与获取视频时长的实现是非常类似的，不同之处主要在于执行的命令，也就是第 12 行的command变量。具体实现可以参考我的示例代码，这里就不赘述。</p>
<p>由于该系统包含多个函数，且函数不仅依赖了 ffmpeg ，还依赖了公共的<code>common/utils.js</code>，所以很多同学就犯难了，这些函数应该怎么部署呢？</p>
<h4 id="3-4-音视频处理系统的部署"><a href="#3-4-音视频处理系统的部署" class="headerlink" title="3.4 音视频处理系统的部署"></a>3.4 音视频处理系统的部署</h4><p>我们需要将 ffmpeg 或 ffprobe 上传。看起来比较简单，我们直接将其放在函数代码目录并上传就可以了。</p>
<p>不过这里需要注意的是， 由于 ffmpeg 和 ffprobe 是可执行文件，最终我们需要用到这两个命令，所以在上传到 FaaS 平台之前，需要为其赋予可执行权限。</p>
<p>你可以通过ls -l来查看文件的权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">-rwxr-xr-x    1 root  staff  39000328  2  9 20:59 ffmpeg</span><br><span class="line">-rwxr-xr-x    1 root  staff  38906056  2  9 21:00 ffprobe</span><br></pre></td></tr></table></figure>
<p>-rwxr-xr-x分为四部分：</p>
<ul>
<li>第 0 位-表示文件类型；</li>
<li>第 1-3 位rwx表示文件所有者的权限；</li>
<li>第 4-6 位r-x是同组用户的权限；</li>
<li>第 7-9r-x位表示其他用户的权限。</li>
</ul>
<blockquote>
<p>r 表示读权限，w 表示写权限，x 表示执行权限。从文件权限可以看出，针对所有用户这两个文件都有可执行权限。</p>
</blockquote>
<p>如果你的这两个文件没有执行权限，则需要通过下面的命令添加权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod +x ffmpeg</span><br><span class="line">$ chmod +x ffprobe</span><br></pre></td></tr></table></figure>
<ul>
<li>这样在 FaaS 平台上，Node.js 才可以执行这两个命令。</li>
<li>解决了可执行文件的权限问题后，还有一个问题是函数的权限。</li>
</ul>
<p>由于函数需要读写 OSS，所以我们需要为函数设置角色，并为该角色添加管理 OSS 的权限。如果你不清楚如何授权，可以复习一下 “10｜访问控制：如何授权访问其他云服务？”的内容。</p>
<blockquote>
<p>在我提供的示例代码中，我在 template.yaml 的第 7 行设置了函数的角色acs:ram::1457216987974698:role/aliyunfclogexecutionrole，文件内容如下所示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROSTemplateFormatVersion: &apos;2015-09-01&apos;</span><br><span class="line">Transform: &apos;Aliyun::Serverless-2018-04-03&apos;</span><br><span class="line">Resources:</span><br><span class="line">  serverless-video:</span><br><span class="line">    Type: &apos;Aliyun::Serverless::Service&apos;</span><br><span class="line">    Properties:</span><br><span class="line">      Role: acs:ram::1457216987974698:role/aliyunfclogexecutionrole</span><br><span class="line">      Description: &apos;基于 Serverless 开发高可用音视频处理系统&apos;</span><br><span class="line">    get_duration:</span><br><span class="line">      Type: &apos;Aliyun::Serverless::Function&apos;</span><br><span class="line">      Properties:</span><br><span class="line">        Handler: index.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        Timeout: 600</span><br><span class="line">        MemorySize: 256</span><br><span class="line">        CodeUri: ./.serverless/get_duration</span><br><span class="line">    get_meta:</span><br><span class="line">      Type: &apos;Aliyun::Serverless::Function&apos;</span><br><span class="line">      Properties:</span><br><span class="line">        Handler: index.handler</span><br><span class="line">        Runtime: nodejs12</span><br><span class="line">        Timeout: 600</span><br><span class="line">        MemorySize: 256</span><br><span class="line">        CodeUri: ./.serverless/get_meta</span><br><span class="line"></span><br><span class="line">      ......</span><br></pre></td></tr></table></figure>
<p>细心的你可能发现了，在该 YAML 配置中，函数的 CodeUri 不是./functions/get_durtion，而是./.serverless/get_meta，这是为什么呢？</p>
<p>这主要是因为我们需要对函数代码进行构建，./.serverless/get_duration对应的是构建后的代码。之所以需要构建，是为了解决common/utils.js代码共用的问题。</p>
<p>如果不对代码进行构建，直接部署functions/get_duration中的代码，函数执行时就会报错：Cannot find module ‘../common/utils，因为common/utils.js不在入口函数目录中，没有部署到 FaaS 上。</p>
<p>要解决这个问题，就需要对代码进行构建，将函数及依赖的所有代码构建为单个文件，这样部署时就只需要部署一个文件，不涉及目录和依赖的问题了。</p>
<p>我们可以使用 ncc 这个工具对函数进行构建，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ncc build ./functions/get_duration/index.js -o ./.serverless/get_duration/ -e ali-oss</span><br></pre></td></tr></table></figure>
<p>该命令就会将<code>functions/get_duration/index.js</code>进行构建，最终会将<code>index.js</code>以及缩依赖的 exec、getOSSClient 等方法进行编译，最终合并为一个文件并输出到<code>./.serverless/get_duration/</code>目录中。</p>
<p><strong>这里还需要注意的是</strong><code>-e ali-oss</code>这个参数，含义是构建时，排除 ali-oss 这个依赖，也就是不将其编译到最终的<code>index.js</code>文件中。这是因为函数计算的 Node.js 运行时内置了 ali-oss 模块，所以我们的构建产物就不需要包含 ali-oss 的代码了。</p>
<p>处理对代码进行构建，我们还需要将 ffmpeg 和 ffprobe 复制到对应的函数目录中。最终我将这些步骤编写到了<code>build.js</code>中，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">"./functions/common/utils"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 清空编译目录</span></span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">"rm -rf .serverless/*"</span>);</span><br><span class="line">  <span class="comment">// 编译 get_duration 函数</span></span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">"mkdir -p ./.serverless/get_duration"</span>);</span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">`ncc build ./functions/get_duration/index.js -o ./.serverless/get_duration/ -e ali-oss`</span>);</span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">"cp ./ffprobe ./.serverless/get_duration/ffprobe"</span>);</span><br><span class="line">  <span class="comment">// 编译 get_meta 函数</span></span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">"mkdir -p ./.serverless/get_meta"</span>);</span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">`ncc build ./functions/get_meta/index.js -o ./.serverless/get_meta/ -e ali-oss`</span>);</span><br><span class="line">  <span class="keyword">await</span> exec(<span class="string">"cp ./ffprobe ./.serverless/get_meta/ffprobe"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">build();</span><br></pre></td></tr></table></figure>
<p>然后我在 package.json 中添加了两个命令：</p>
<ul>
<li>build构建函数</li>
<li>deploy构建并部署</li>
</ul>
<p>例如你开发完成后需要部署，就可以直接运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm run deploy</span><br><span class="line">&gt; serverless-video@1.0.0 deploy</span><br><span class="line">&gt; npm run build &amp;&amp; fun deploy</span><br><span class="line">&gt; serverless-video@1.0.0 build</span><br><span class="line">&gt; node build.js</span><br><span class="line">rm -rf .serverless/*</span><br><span class="line">mkdir -p ./.serverless/get_duration</span><br><span class="line">ncc build ./functions/get_duration/index.js -o ./.serverless/get_duration/ -e ali-oss</span><br><span class="line"></span><br><span class="line">using template: template.yml</span><br><span class="line">Waiting for service serverless-video to be deployed...</span><br><span class="line">    Waiting for function get_duration to be deployed...</span><br><span class="line">        Waiting for packaging function get_duration code...</span><br><span class="line">        The function get_duration has been packaged. A total of 2 files were compressed and the final size was 15.2 MB</span><br><span class="line">    function get_duration deploy success</span><br><span class="line">......</span><br><span class="line">service serverless-video deploy success</span><br></pre></td></tr></table></figure>
<p>部署成功后，我们就可以对函数进行测试了，可以直接在控制台上运行函数，也可以通过fun invoke执行函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ fun invoke get_duration</span><br><span class="line">&#123;</span><br><span class="line">    &quot;format&quot;: &#123;</span><br><span class="line">        &quot;duration&quot;: &quot;170.859000&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>强调下面几点：</strong></p>
<ul>
<li>Serverless 除了适合 Web 接口、服务端渲染等场景，还适合 CPU 密集型的任务；</li>
<li>基于 Serverless 开发的音视频处理系统，本身就具备弹性、可扩展、低成本、免运维、高可用的能力；</li>
<li>对于需要通过代码执行的命令行工具等依赖，部署到 FaaS 平台之前需要为其设置可执行权限；若函数依需要调用其他云产品的接口，需要为函数授予相应权限；</li>
<li>对于添加水印、视频转码等消耗资源的操作，需要为函数设置较大的内存和超时时间。</li>
</ul>
<h3 id="4-使用-React-js-开发-Serverless-服务端渲染应用"><a href="#4-使用-React-js-开发-Serverless-服务端渲染应用" class="headerlink" title="4 使用 React.js 开发 Serverless 服务端渲染应用"></a>4 使用 React.js 开发 Serverless 服务端渲染应用</h3><p>对前端工程师来说，Serverless 最大的应用场景之一就是开发服务端渲染（SSR）应用。因为传统的服务端渲染应用要由前端工程师负责服务器的运维，但往往前端工程师并不擅长这一点，基于 Serverless 开发服务端渲染应用的话，就可以减轻这个负担。希望你学完今天的内容之后，能够学会如何去使用 Serverless 开发一个服务端渲染应用。</p>
<h3 id="5-基于-Serverless-的服务端渲染架构"><a href="#5-基于-Serverless-的服务端渲染架构" class="headerlink" title="5 基于 Serverless 的服务端渲染架构"></a>5 基于 Serverless 的服务端渲染架构</h3><blockquote>
<p>现在的主流前端框架是 React.js、Vue.js 等，基于这些框架开发的都是单页应用，其渲染方式都是客户端渲染：代码开发完成后，构建出一个或多个 JS 资源，页面渲染时加载这些 JS 资源，然后再执行 JS 渲染页面。虽然这些框架可以极大提升前端开发效率，但也带来了一些新的问题。</p>
</blockquote>
<ul>
<li><strong>不利于 SEO：</strong> 页面源码不再是HTML，而是渲染 HTML 的 JavaScript，这就导致搜索引擎爬虫难以解析其中的内容；</li>
<li><strong>初始化性能差：</strong> 通常单元应用的 JS 文件体积都比较大、加载耗时比较长，导致页面白屏。</li>
</ul>
<p>为了解决这些问题，很多框架和开发者就开始尝试服务端渲染的方式：页面加载时，由服务端先生成 HTML 返回给浏览器，浏览器直接渲染 HTML。在传统的服务端渲染架构中，通常需要前端同学使用 Node.js 去实现一个服务端的渲染应用。在应用内，每个请求的 path 对应着服务端的每个路由，由该路由实现对应 path 的 HTML 文档渲染：</p>
<p><img src="https://blog.poetries.top/img/static/images/20210418174418.png" alt></p>
<p>传统服务端渲染架构</p>
<p>对前端工程师来说，要实现一个服务端渲染应用，通常面临着一些问题：</p>
<ul>
<li>部署服务端渲染应用需要购买服务器，并配置服务器环境，要对服务器进行运维；</li>
<li>需要关注业务量，考虑有没有高并发场景、服务器有没有扩容机制；</li>
<li>需要实现负载均衡、流量控制等复杂后端能力等。</li>
</ul>
<p>开篇我也提到，而且是服务端的工作，很多前端同学都不擅长，好在有了 Serverless。</p>
<p>用 Serverless 做服务端渲染，就是将以往的每个路由，都拆分为一个个函数，再在 FaaS 上部署对应的函数，这样用户请求的 path，对应的就是每个单独的函数。通过这种方式，就将运维操作转移到了 FaaS 平台，前端同学开发服务端渲染应用，就再也不用关心服务端程序的运维部署了。并且在 FaaS 平台中运行的函数，天然具有弹性伸缩的能力，你也不用担心流量波峰波谷了。</p>
<p><img src="https://blog.poetries.top/img/static/images/20210418174139.png" alt></p>
<p>基于 Serverless 的服务选渲染架构</p>
<p>如图所示，FaaS 函数接收请求后直接执行代码渲染出 HTML 并返回给浏览器，这是最基本的架构，虽然它可以满足大部分场景，但要追求极致的性能，你通常要加入缓存。</p>
<p><img src="https://blog.poetries.top/img/static/images/20210418174151.png" alt></p>
<p>进阶版基于 Serverless 的服务端渲染架构</p>
<p>首先我们会使用 CDN 做缓存，基于 CDN 的缓存可以减少函数执行次数，进而避免函数冷启动带来的性能损耗。如果 CDN 中没有 SSR HTML 页面的缓存，则继续由网关处理请求，网关再去触发函数执行。</p>
<p>函数首先会判读缓存数据库中是否有 SSR HTML 的缓存，如果有直接返回；如果没有再渲染出 HTML 并返回。基于数据库的缓存，可以减少函数渲染 HTML 的时间，从而页面加载提升性能。</p>
<p>讲了这么多，具体怎么基于 Serverless 实现一个服务端渲染应用呢？</p>
<h4 id="5-1-实现一个-Serverless-的服务端渲染应用"><a href="#5-1-实现一个-Serverless-的服务端渲染应用" class="headerlink" title="5.1 实现一个 Serverless 的服务端渲染应用"></a>5.1 实现一个 Serverless 的服务端渲染应用</h4><p>我们实现了一个内容管理系统的 Restful API，但没有前端界面，所以今天我们的目标就基于 Serverless 实现一个内容管理系统的前端界面（如图所示）。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/94/3B/Ciqc1GAXxoiANTROADtU9yybMQY209.gif" alt="ssr.gif"></p>
<p>该应用主要包含两个页面：</p>
<ul>
<li>首页，展示文章列表；</li>
<li>详情页，展示文章详情。</li>
</ul>
<p>为了方便你进行实践，我为你提供了一份示例代码，你可以直接下载并使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载代码</span><br><span class="line"></span><br><span class="line">$ git clone https://github.com/poetries/serverless-class</span><br><span class="line"></span><br><span class="line"># 进入服务端渲染应用目录</span><br><span class="line"></span><br><span class="line">$ cd 16/serverless-ssr-cms</span><br></pre></td></tr></table></figure>
<p>代码结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line"></span><br><span class="line">├── config.js</span><br><span class="line"></span><br><span class="line">├── f.yml</span><br><span class="line"></span><br><span class="line">├── package-lock.json</span><br><span class="line"></span><br><span class="line">├── package.json</span><br><span class="line"></span><br><span class="line">├── src</span><br><span class="line"></span><br><span class="line">│   ├── api.ts</span><br><span class="line"></span><br><span class="line">│   ├── config</span><br><span class="line"></span><br><span class="line">│   │   └── config.default.ts</span><br><span class="line"></span><br><span class="line">│   ├── configuration.ts</span><br><span class="line"></span><br><span class="line">│   ├── index.ts</span><br><span class="line"></span><br><span class="line">│   ├── interface</span><br><span class="line"></span><br><span class="line">│   │   ├── detail.ts</span><br><span class="line"></span><br><span class="line">│   │   └── index.ts</span><br><span class="line"></span><br><span class="line">│   ├── mock</span><br><span class="line"></span><br><span class="line">│   │   ├── detail.ts</span><br><span class="line"></span><br><span class="line">│   │   └── index.ts</span><br><span class="line"></span><br><span class="line">│   ├── render.ts</span><br><span class="line"></span><br><span class="line">│   └── service</span><br><span class="line"></span><br><span class="line">│       ├── detail.ts</span><br><span class="line"></span><br><span class="line">│       └── index.ts</span><br><span class="line"></span><br><span class="line">├── tsconfig.json</span><br><span class="line"></span><br><span class="line">├── tsconfig.lint.json</span><br><span class="line"></span><br><span class="line">└── web</span><br><span class="line"></span><br><span class="line">    ├── @types</span><br><span class="line"></span><br><span class="line">    │   └── global.d.ts</span><br><span class="line"></span><br><span class="line">    ├── common.less</span><br><span class="line"></span><br><span class="line">    ├── components</span><br><span class="line"></span><br><span class="line">    │   ├── layout</span><br><span class="line"></span><br><span class="line">    │   │   ├── index.less</span><br><span class="line"></span><br><span class="line">    │   │   └── index.tsx</span><br><span class="line"></span><br><span class="line">    │   └── title</span><br><span class="line"></span><br><span class="line">    │       ├── index.less</span><br><span class="line"></span><br><span class="line">    │       └── index.tsx</span><br><span class="line"></span><br><span class="line">    ├── interface</span><br><span class="line"></span><br><span class="line">    │   ├── detail-index.ts</span><br><span class="line"></span><br><span class="line">    │   ├── index.ts</span><br><span class="line"></span><br><span class="line">    │   └── page-index.ts</span><br><span class="line"></span><br><span class="line">    ├── pages</span><br><span class="line"></span><br><span class="line">    │   ├── detail</span><br><span class="line"></span><br><span class="line">    │   │   ├── fetch.ts</span><br><span class="line"></span><br><span class="line">    │   │   ├── index.less</span><br><span class="line"></span><br><span class="line">    │   │   └── render$id.tsx</span><br><span class="line"></span><br><span class="line">    │   └── index</span><br><span class="line"></span><br><span class="line">    │       ├── fetch.ts</span><br><span class="line"></span><br><span class="line">    │       ├── index.less</span><br><span class="line"></span><br><span class="line">    │       └── render.tsx</span><br><span class="line"></span><br><span class="line">    └── tsconfig.json</span><br></pre></td></tr></table></figure>
<p>文件很多，不过不用担心，你只需重点关注 web/pages/ 和 src/service 两个目录：</p>
<ul>
<li>web/ 目录中主要是前端页面的代码， web/pages/ 中的文件分别对应着我们要实现的 index（首页）和 detail（详情页）两个页面，这两个页面会使用到 components 目录中的公共组件；</li>
<li>src/ 目录中主要是后端代码，src/service 目录中的 index.ts  和 detail.ts 则定义了两个页面分别需要用到的接口，为了简单起见，接口数据我使用了 src/mock/ 目录中的 mock 数据。</li>
</ul>
<p>当我一个人又负责前端页面也负责后端接口的开发时，通常习惯先实现接口，再开发前端页面，这样方便调试。接下来就让我们看一下具体是怎么实现的。</p>
<h4 id="5-2-首页接口的实现"><a href="#5-2-首页接口的实现" class="headerlink" title="5.2 首页接口的实现"></a>5.2 首页接口的实现</h4><p>其源码在 src/service/index.ts 文件中，代码如下：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// src/service/index.ts</span><br><span class="line"></span><br><span class="line">import &#123; provide &#125; from &apos;@midwayjs/faas&apos;</span><br><span class="line"></span><br><span class="line">import &#123; IApiService &#125; from &apos;../interface&apos;</span><br><span class="line"></span><br><span class="line">import mock from &apos;../mock&apos;</span><br><span class="line"></span><br><span class="line">@provide(&apos;ApiService&apos;)</span><br><span class="line"></span><br><span class="line">export class ApiService implements IApiService &#123;</span><br><span class="line"></span><br><span class="line">  async index (): Promise&lt;any&gt; &#123;</span><br><span class="line"></span><br><span class="line">    return await Promise.resolve(mock)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码实现了一个 ApiService 类以及 index 方法，该方法会返回首页的文章列表。数据结构如下：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;data&quot;:[</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            &quot;id&quot;:&quot;3f8a198c-60a2-11eb-8932-9b95cd7afc2d&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;title&quot;:&quot;开篇词：Serverless 大热，程序员面临的新机遇与挑战&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;content&quot;:&quot;可能你会认为 Serverless 是最近两年兴起的技术......&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;date&quot;:&quot;2020-12-23&quot;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            &quot;id&quot;:&quot;5158b100-5fee-11eb-9afa-9b5f85523067&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;title&quot;:&quot;基础入门：编写你的第一个 Serverless 应用&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;content&quot;:&quot;学习一门新技术，除了了解其基础概念，更重要的是把理论转化为实践...&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;date&quot;:&quot;2020-12-29&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行服务端渲染时，你可以通过 ctx 获取到 ApiService 实例，进而调用其中的方法，获取文章列表数据。此外，ApiService 也会被 src/api.ts 调用，src/api.ts 则直接对外提供了 HTTP 接口。</p>
<h4 id="5-3-首页页面的实现"><a href="#5-3-首页页面的实现" class="headerlink" title="5.3 首页页面的实现"></a>5.3 首页页面的实现</h4><p>有了接口后，我们就可以继续实现首页的前端页面了。首页页面的代码在 web/pages/ 目录中，该目录下有三个文件：</p>
<ul>
<li>fetch.ts，获取首页数据；</li>
<li>render.tsx 首页页面 UI 组件代码；</li>
<li>index.less 样式代码。</li>
</ul>
<p>首先来看一下 fetch.ts：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// web/pages/index/fetch.ts</span><br><span class="line"></span><br><span class="line">import &#123; IFaaSContext &#125; from &apos;ssr-types&apos;</span><br><span class="line"></span><br><span class="line">import &#123; IndexData &#125; from &apos;@/interface&apos;</span><br><span class="line"></span><br><span class="line">interface IApiService &#123;</span><br><span class="line"></span><br><span class="line">  index: () =&gt; Promise&lt;IndexData&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default async (ctx: IFaaSContext&lt;&#123;</span><br><span class="line"></span><br><span class="line">  apiService?: IApiService</span><br><span class="line"></span><br><span class="line">&#125;&gt;) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const data = __isBrowser__ ? await (await window.fetch(&apos;/api/index&apos;)).json() : await ctx.apiService?.index()</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line"></span><br><span class="line">    indexData: data</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这段代码的逻辑比较简单，核心点在第 10 行</strong>，如果是浏览器，就用浏览器自带的 fetch 方法请求<code>/api/index</code>接口获取数据；如果不是浏览器，即服务端渲染，可以直接调用 apiService 中的 index 方法。获取到数据后，将其存入 state.indexData 中，这样在 UI 组件中就可以使用了。<br>首页的 UI 组件 render.tsx 代码如下：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// web/pages/index/render.tsx</span><br><span class="line"></span><br><span class="line">import React, &#123; useContext &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; SProps, IContext &#125; from &quot;ssr-types&quot;;</span><br><span class="line"></span><br><span class="line">import Navbar from &quot;@/components/navbar&quot;;</span><br><span class="line"></span><br><span class="line">import Header from &quot;@/components/header&quot;;</span><br><span class="line"></span><br><span class="line">import Item from &quot;@/components/item&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; IData &#125; from &quot;@/interface&quot;;</span><br><span class="line"></span><br><span class="line">import styles from &quot;./index.less&quot;;</span><br><span class="line"></span><br><span class="line">export default (props: SProps) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const &#123; state &#125; = useContext&lt;IContext&lt;IData&gt;&gt;(window.STORE_CONTEXT);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line"></span><br><span class="line">    &lt;div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Navbar &#123;...props&#125; isHomePage=&#123;true&#125;&gt;&lt;/Navbar&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Header&gt;&lt;/Header&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div className=&#123;styles.container&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;state?.indexData?.data.map((item) =&gt; (</span><br><span class="line"></span><br><span class="line">          &lt;Item</span><br><span class="line"></span><br><span class="line">            &#123;...props&#125;</span><br><span class="line"></span><br><span class="line">            id=&#123;item.id&#125;</span><br><span class="line"></span><br><span class="line">            key=&#123;item.id&#125;</span><br><span class="line"></span><br><span class="line">            title=&#123;item.title&#125;</span><br><span class="line"></span><br><span class="line">            content=&#123;item.content&#125;</span><br><span class="line"></span><br><span class="line">            date=&#123;item.date&#125;</span><br><span class="line"></span><br><span class="line">          &gt;&lt;/Item&gt;</span><br><span class="line"></span><br><span class="line">        ))&#125;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 UI 组件中，我们可以通过 useContext 获取刚才由 fetch.ts 存入 state 的数据，然后利用数据渲染 UI。UI 组件主要由三部分组成。</p>
<ul>
<li>Navbar：导航条。</li>
<li>Header：页面标题。</li>
<li>Item：每篇文章的简介。</li>
</ul>
<p><img src="https://blog.poetries.top/img/static/images/20210418174309.png" alt></p>
<h4 id="5-4-详情页接口的实现"><a href="#5-4-详情页接口的实现" class="headerlink" title="5.4 详情页接口的实现"></a>5.4 详情页接口的实现</h4><p>完成了首页后，就可以实现详情页了。详情页与首页整体类似，区别就在于详情页需要传入参数查询某条数据。</p>
<p>详情页接口在 src/service/detail.ts 中 ，代码如下所示：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// src/service/detail.ts</span><br><span class="line"></span><br><span class="line">import &#123; provide &#125; from &apos;@midwayjs/faas&apos;</span><br><span class="line"></span><br><span class="line">import &#123; IApiDetailService &#125; from &apos;../interface/detail&apos;</span><br><span class="line"></span><br><span class="line">import mock from &apos;../mock/detail&apos;</span><br><span class="line"></span><br><span class="line">@provide(&apos;ApiDetailService&apos;)</span><br><span class="line"></span><br><span class="line">export class ApiDetailService implements IApiDetailService &#123;</span><br><span class="line"></span><br><span class="line">  async index (id): Promise&lt;any&gt; &#123;</span><br><span class="line"></span><br><span class="line">    return await Promise.resolve(mock.data[id])</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们实现了一个 ApiDetailService 类以及 index 方法，index 方法的如参 id 即文章 ID，然后根据文章 ID 从 mock 数据中查询文章详情。</p>
<p>文章详情数据如下：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;title&quot;:&quot;Serverless 大热，程序员面临的新机遇与挑战&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;wordCount&quot;:2540,</span><br><span class="line"></span><br><span class="line">    &quot;readingTime&quot;:10,</span><br><span class="line"></span><br><span class="line">    &quot;date&quot;:&quot;2020-12-23 12:00:00&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;content&quot;:&quot;可能你会认为 Serverless 是最近两年兴起的技术，实际上，Serverless 概念从 2012 年就提出来了，随后 AWS 在 2014 年推出了第一款 Serverless 产品 Lambda，开启了 Serverless 元年... &quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-5-详情页页面的实现"><a href="#5-5-详情页页面的实现" class="headerlink" title="5.5 详情页页面的实现"></a>5.5 详情页页面的实现</h4><p>和首页一样，详情页也包含数据请求、UI 组件和样式代码三个文件。</p>
<p>数据请求代码文件的命名和首页一样，都是 fetch.ts。与首页不同的是，详情页我们需要从上下文（服务端渲染场景）或 URL 中（浏览器场景）获取到文章 ID，然后根据文章 ID 获取文章详情数据。代码如下：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; RouteComponentProps &#125; from &quot;react-router&quot;;</span><br><span class="line"></span><br><span class="line">export default async (ctx) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  let data;</span><br><span class="line"></span><br><span class="line">  if (__isBrowser__) &#123;</span><br><span class="line"></span><br><span class="line">    const id = (ctx as RouteComponentProps&lt;&#123; id: string &#125;&gt;).match.params.id;</span><br><span class="line"></span><br><span class="line">    data = await (await window.fetch(`/api/detail/$&#123;id&#125;`)).json()</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    const id = /detail\/(.*)(\?|\/)?/.exec(ctx.req.path)[1];</span><br><span class="line"></span><br><span class="line">    data = await ctx.apiDeatilservice.index(id);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line"></span><br><span class="line">    detailData: data,</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>详情页的 UI 组件名称为<code>render$id.tsx</code>的文件，<code>$id</code>表示该组件的参数是 id，这样访问 /detail/ 这个路由（id 是变量）时，就会匹配到 web/pages/detail/render$id.tsx 这个页面了。</p>
<p><code>render$id.tsx</code>详细代码如下：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useContext &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; IContext, SProps &#125; from &quot;ssr-types&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; Data &#125; from &quot;@/interface&quot;;</span><br><span class="line"></span><br><span class="line">import Navbar from &quot;@/components/navbar&quot;;</span><br><span class="line"></span><br><span class="line">import Content from &quot;@/components/content&quot;;</span><br><span class="line"></span><br><span class="line">import Title from &quot;@/components/title&quot;;</span><br><span class="line"></span><br><span class="line">import Tip from &quot;@/components/tip&quot;;</span><br><span class="line"></span><br><span class="line">import styles from &quot;./index.less&quot;;</span><br><span class="line"></span><br><span class="line">export default (props: SProps) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const &#123; state &#125; = useContext&lt;IContext&lt;Data&gt;&gt;(window.STORE_CONTEXT);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line"></span><br><span class="line">    &lt;div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Navbar &#123;...props&#125;&gt;&lt;/Navbar&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div className=&#123;styles.container&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Title&gt;&#123;state?.detailData?.title&#125;&lt;/Title&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Tip</span><br><span class="line"></span><br><span class="line">          date=&#123;state?.detailData?.date&#125;</span><br><span class="line"></span><br><span class="line">          wordCount=&#123;state?.detailData?.wordCount&#125;</span><br><span class="line"></span><br><span class="line">          readingTime=&#123;state?.detailData?.readingTime&#125;</span><br><span class="line"></span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Content&gt;&#123;state?.detailData?.content&#125;&lt;/Content&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>详情页的 UI 组件由四部分组成。</p>
<ul>
<li>Navbar：导航条。</li>
<li>Title：文章标题。</li>
<li>Tip：文章发布时间、字数等提示。</li>
<li>Content：文章内容。</li>
</ul>
<p><img src="https://blog.poetries.top/img/static/images/20210418174323.png" alt></p>
<h4 id="5-6-应用部署"><a href="#5-6-应用部署" class="headerlink" title="5.6 应用部署"></a>5.6 应用部署</h4><p>代码开发完成后，你可以通过下面的命令在本地启动应用：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm start</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[HPM] Proxy created: /asset-manifest  -&gt; http://127.0.0.1:8000</span><br><span class="line"></span><br><span class="line"> Server is listening on http://localhost:3000</span><br></pre></td></tr></table></figure>
<p>应用启动后就可以打开浏览器输入 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000</a> 查看效果了。<br>在本地开发测试完成后，接下来就需要将其部署到函数计算。你可以运行 npm run deploy 命令进部署：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm run deploy</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">service  serverless-ssr-cms deploy success</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">The assigned temporary domain is http://41506101-1457216987974698.test.functioncompute.com，expired at 2021-02-04 00:35:01, limited by 1000 per day.</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Deploy success</span><br></pre></td></tr></table></figure>
<p><code>npm run deploy</code>其实是执行了构建代码和部署应用两个步骤，这两个步骤都是在本机执行的。但这就存在一个隐藏风险，如果团队同学本地开发环境不同，就可能导致构建产物不同，进而导致部署到线上的代码存在风险。<strong>所以更好的实践是：实现一个业务的持续集成流程，统一构建部署。</strong></p>
<p>应用部署成功后，会自动创建一个测试的域名，例如<a href="http://41506101-1457216987974698.test.functioncompute.com/" target="_blank" rel="noopener">http://41506101-1457216987974698.test.functioncompute.com</a>，我们可以打开该域名查看最终效果。</p>
<p>讲到这儿，基于 Serverless 的服务端渲染应用就开发完成了。</p>
<h4 id="5-7-总结"><a href="#5-7-总结" class="headerlink" title="5.7 总结"></a>5.7 总结</h4><p>总的来说，基于 Serverless 的服务端渲染应用实现也比较简单。如果你想要追求更好的用户体验，我也建议你对核心业务做服务端渲染的优化。基于 Serverless 的服务端渲染，可以让我们不用再像以前一样担心服务器的运维和扩容，大大提高了生产力。同时有了服务端渲染后，我也建议你完善业务的持续集成流程，将整个研发链路打通，降低代码构建发布的风险，提升从开发到测试再到部署的效率。</p>
<p>当然，要达到页面的极致体验，我们还需要做很多工作，比如：</p>
<ul>
<li>将静态资源部署到 CDN，提升资源加载速度；</li>
<li>针对页面进行缓存，减少函数冷启动对性能的影响；</li>
<li>对服务端异常进行降级处理等等。</li>
</ul>
<p>但不管我们用不用 Serverless，都需要做这些工作。关于这一讲，我想要强调以下几点：</p>
<ul>
<li>基于 Serverless 的服务端渲染应用，可以让我们不用关心服务器的运维，应用也天然具有弹性；</li>
<li>基于 Serverless 开发服务端渲染应用，建议你完善业务的持续集成流程；</li>
<li>要达到页面的极致性能，还需要考虑将静态资源部署到 CDN、对页面进行缓存等技术；</li>
<li>对于服务端渲染应用，建议你完善业务的服务降级能力，进一步提高稳定性。</li>
</ul>

      </div>
    
  </div>

</article>

<!-- <button class="assist-btn2 circle" id="assist_btn2" title="点亮屏幕" style="left: 27px; top: 152px;">
  <i class="iconfont" style="display:inline-block;color:red;width:20px;height:20px;">&#xe61d;</i>
</button>
<button class="assist-btn1 circle" id="assist_btn1" title="关闭屏幕亮度" style="left: 27px; top: 152px;">
  <i class="iconfont toc-title" style="display:inline-block;color:red;width:20px;height:20px;">&#xe61d;</i>
</button> -->


<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>	

<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
<script>
  function getCookie(key) {
    if (document.cookie.length > 0) {
      var start = document.cookie.indexOf(key + "=");
      if (start !== -1) {
        start = start + key.length + 1;
        var end = document.cookie.indexOf(";", start);
        if (end === -1) end = document.cookie.length;
        return unescape(document.cookie.substring(start, end));
      }
    }
    return "";
  }
  const feToken = getCookie('fe-token');
  const btw = new BTWPlugin();
  console.log('ft', feToken)
  if(!feToken) {
    btw.init({
      id: "container",
      blogId: "22699-1592137983091-414",
      name: "前端进阶之旅",
      qrcode: "https://poetries1.gitee.io/img-repo/2020/06/qrcode.jpg",
      keyword: "3a3b3c",
    });
  }
</script>

<script type="text/javascript">

// white theme
var body = {color: "#555", background: "#000"};
var a_tag = {color: "#222"};
var header = { background: "#222"};
var logo_line_i = {background: "#222"};
// var post_code = {background: "#eee", color: "#222"};

function switch_theme() {
 $("body").css(body);
 $("a:not('.links-of-author-item a, .site-state-item a, .site-state-posts a, .feed-link a, .motion-element a, .post-tags a, .show-commit-cls a, #donate_board a')").css(a_tag);
 $(".header, .footer").css(header);
 $(".logo-line-before i, .logo-line-after i").css(logo_line_i);
 //$(".post code").css(post_code);
 $("#idhyt-surprise-ball #idhyt-surprise-ball-animation .drag").css(a_tag);
 $(".post-title-link, .posts-expand .post-meta, .post-comments-count, .disqus-comment-count, .post-category a, .post-nav-next a, .post-nav-item a").css(a_tag);
 
 // $("code").css({color: '#c5c8c6', background: '#1d1f21'});
 //$("#assist_btn1").hide(1500);
}

$(function () {
$("#assist_btn2").css("display","none");
 $("#assist_btn1").click(function() {
     switch_theme();
$("div#toc.toc-article").css({
 "background":"#eaeaea",
 "opacity":1
});
$(".toc-article ol").show();
$("#toc.toc-article .toc-title").css("color","#a98602");
$("#assist_btn1").css("display","none");
$("#assist_btn2").css("display","block");
 });
$("#assist_btn2").click(function() {
$("#assist_btn2").css("display","none");
$("#assist_btn1").css("display","block");
$("body").css("background","url(http://www.miaov.com/static/ie/images/news/bg.png)")
     $(".header, .footer").css("background","url(http://www.miaov.com/static/ie/images/news/bg.png)")
$(".toc-article ol").toggle(1000);
 });
});


//背景随机

var Y, O, E, L, B, C, T, z, N, S, A, I;
!function() {
var e = function() {
for (O.clearRect(0, 0, L, B), T = [{
x: 0,
y: .7 * B + C
}, {
x: 0,
y: .7 * B - C
}]; T[1].x < L + C;) t(T[0], T[1])
}, t = function(e, t) {
O.beginPath(), O.moveTo(e.x, e.y), O.lineTo(t.x, t.y);
var n = t.x + (2 * I() - .25) * C,
 r = a(t.y);
O.lineTo(n, r), O.closePath(), N -= S / -50, O.fillStyle = "#" + (127 * A(N) + 128 << 16 | 127 * A(N + S / 3) + 128 << 8 | 127 * A(N + S / 3 * 2) + 128).toString(16), O.fill(), T[0] = T[1], T[1] = {
 x: n,
 y: r
}
}, a = function n(e) {
var t = e + (2 * I() - 1.1) * C;
return t > B || t < 0 ? n(e) : t
};
Y = document.getElementById("evanyou"), O = Y.getContext("2d"), E = window.devicePixelRatio || 1, L = window.innerWidth, B = window.innerHeight, C = 90, z = Math, N = 0, S = 2 * z.PI, A = z.cos, I = z.random, Y.width = L * E, Y.height = B * E, O.scale(E, E), O.globalAlpha = .6, document.onclick = e, document.ontouchstart = e, e()
}()

   
$("#toc-eye").click(function(){
$("#toc.toc-article").toggle(1000);
});

</script>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持poetries</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/weixin.jpg" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/zhifubao.jpg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2021/03/29/virtual-dom-analysis/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2021/04/18/wx-weapp-summary/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/categories/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '5567a2c4abb858009d96',
  clientSecret: 'b9039ec056cf5c2346b3cdb63308a28c163f91e5',
  repo: 'poetries.github.io',
  owner: 'poetries',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: location.pathname,
  admin: ['poetries'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>


  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/clicklove.js"></script>
 
  
</body>
</html>
