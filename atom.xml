<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端进阶之旅</title>
  
  <subtitle>全网同号，分享编程经验和技术干货。更多干货只在公众号「前端进阶之旅」内分享！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.poetries.top/"/>
  <updated>2025-03-30T13:54:29.479Z</updated>
  <id>http://blog.poetries.top/</id>
  
  <author>
    <name>Poetry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RN构建iOS包发布到AppStore总结篇</title>
    <link href="http://blog.poetries.top/2023/10/22/ios-build/"/>
    <id>http://blog.poetries.top/2023/10/22/ios-build/</id>
    <published>2023-10-22T10:10:12.000Z</published>
    <updated>2025-03-30T13:54:29.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置development测试证书"><a href="#配置development测试证书" class="headerlink" title="配置development测试证书"></a>配置development测试证书</h2><blockquote><p>使用<code>xcode</code>来管理自动生成证书，不需要在管理后台创建</p></blockquote><h3 id="1、创建Identifiers"><a href="#1、创建Identifiers" class="headerlink" title="1、创建Identifiers"></a>1、创建Identifiers</h3><blockquote><p>登录 <a href="https://developer.apple.com/account" target="_blank" rel="noopener">https://developer.apple.com/account</a></p></blockquote><p><img src="https://s.poetries.work/uploads/2023/10/d3d19228ec48dfe2.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/19657900fcb37bef.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/9348e21eb02eae74.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/4c8cddc046e42324.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/68e759bd80a6b7d0.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/1c453d7171b4d71f.png" alt></p><h3 id="2、在Xcode端自动生成证书，不需要在管理后台添加证书"><a href="#2、在Xcode端自动生成证书，不需要在管理后台添加证书" class="headerlink" title="2、在Xcode端自动生成证书，不需要在管理后台添加证书"></a>2、在Xcode端自动生成证书，不需要在管理后台添加证书</h3><p><img src="https://s.poetries.work/uploads/2023/10/864c4d1828d36193.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/7ff0853d6763d1e7.png" alt></p><blockquote><p>然后到后面就看到自动创建的证书了</p></blockquote><p><img src="https://s.poetries.work/uploads/2023/10/dae17eae4f107800.png" alt></p><h3 id="3、创建Profiles"><a href="#3、创建Profiles" class="headerlink" title="3、创建Profiles"></a>3、创建Profiles</h3><p><img src="https://s.poetries.work/uploads/2023/10/43fdac62f1c4ebea.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/08dbd8f12c57cd87.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/05aab8ad8141cbab.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/543f027a5d7c2043.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/6232eacf27532221.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/31b7f6ff29a2d551.png" alt></p><h2 id="配置distribution正式环境证书"><a href="#配置distribution正式环境证书" class="headerlink" title="配置distribution正式环境证书"></a>配置distribution正式环境证书</h2><h3 id="1、生成IOS正式环境证书"><a href="#1、生成IOS正式环境证书" class="headerlink" title="1、生成IOS正式环境证书"></a>1、生成IOS正式环境证书</h3><p><img src="https://s.poetries.work/uploads/2023/10/25717985c486ad13.png" alt></p><h3 id="2、创建Profiles"><a href="#2、创建Profiles" class="headerlink" title="2、创建Profiles"></a>2、创建Profiles</h3><p><img src="https://s.poetries.work/uploads/2023/10/e7815063c626ab41.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/5df2093eb4cf289f.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/32a4e9928c21e29d.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/09602f7d4539b5df.png" alt></p><h2 id="配置Xcode"><a href="#配置Xcode" class="headerlink" title="配置Xcode"></a>配置Xcode</h2><p><img src="https://s.poetries.work/uploads/2023/10/55b307b2e260aee8.png" alt><br><img src="https://s.poetries.work/uploads/2023/10/a8e531d89de997aa.png" alt></p><h2 id="打测试包发布到蒲公英测试"><a href="#打测试包发布到蒲公英测试" class="headerlink" title="打测试包发布到蒲公英测试"></a>打测试包发布到蒲公英测试</h2><p><img src="https://s.poetries.work/uploads/2023/10/7c25b7fdd2cf1a4f.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/979bfb42f2d823c6.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/446e877b181200e4.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/c0ac19effeff23bb.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/7a9d940024ec8cad.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/e4b33263233d8db8.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/305c22c3e7b190b9.png" alt></p><blockquote><p>上传到蒲公英内测 <a href="https://www.pgyer.com" target="_blank" rel="noopener">https://www.pgyer.com</a></p></blockquote><p><img src="https://s.poetries.work/uploads/2023/10/b15ca30cd01b19fd.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/b2929e57f5f970ab.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/a99d12324dd8a872.png" alt></p><p>最后把应用地址复制发给测试人员下载即可，需要注意的是我们要添加测试手机的设备UUID才可以安装到手机上测试</p><h3 id="添加手机UDID到管理后台"><a href="#添加手机UDID到管理后台" class="headerlink" title="添加手机UDID到管理后台"></a>添加手机UDID到管理后台</h3><p><img src="https://s.poetries.work/uploads/2023/10/78653128e1967b61.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/6e003a3a0a8ef496.png" alt></p><h3 id="通过蒲公英获取UDID填入即可"><a href="#通过蒲公英获取UDID填入即可" class="headerlink" title="通过蒲公英获取UDID填入即可"></a>通过蒲公英获取UDID填入即可</h3><blockquote><p>地址：<a href="https://www.pgyer.com/tools/udid/manage" target="_blank" rel="noopener">https://www.pgyer.com/tools/udid/manage</a></p></blockquote><p><img src="https://s.poetries.work/uploads/2023/10/d91b1123872f2ca9.png" alt></p><blockquote><p>需要注意的是：设备添加超过<code>20个</code>，需要等待<code>24小时</code>才能在iPhone手机上安装APP测试。<code>添加新的额设备udid，需要重新打包ipa包才能进行安装到对应手机上</code></p></blockquote><h2 id="打正式包上传到appstore"><a href="#打正式包上传到appstore" class="headerlink" title="打正式包上传到appstore"></a>打正式包上传到appstore</h2><h3 id="进入App-Store-Connect创建应用才可以上传"><a href="#进入App-Store-Connect创建应用才可以上传" class="headerlink" title="进入App Store Connect创建应用才可以上传"></a>进入App Store Connect创建应用才可以上传</h3><blockquote><p>入口：<a href="https://developer.apple.com/account" target="_blank" rel="noopener">https://developer.apple.com/account</a></p></blockquote><p><img src="https://s.poetries.work/uploads/2023/10/098ffcfe3382883e.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/ad192fc1a02051d0.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/aa4f08b7d0b6b23d.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/2e2f5d4a13f43e57.png" alt></p><h3 id="开始上传到App-Store-Connect"><a href="#开始上传到App-Store-Connect" class="headerlink" title="开始上传到App Store Connect"></a>开始上传到App Store Connect</h3><p><img src="https://s.poetries.work/uploads/2023/10/cf408e3029539dc9.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/2a74082d89e946e8.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/64dfe89783c717ed.png" alt></p><blockquote><p>上传成功后，来到app 后台</p></blockquote><p><img src="https://s.poetries.work/uploads/2023/10/cd1a10fc38b5c201.png" alt></p><p><img src="https://s.poetries.work/uploads/2023/10/c5d55c40962f74ec.png" alt></p><h3 id="如果审核失败了，重新构建版本号需要修改"><a href="#如果审核失败了，重新构建版本号需要修改" class="headerlink" title="如果审核失败了，重新构建版本号需要修改"></a>如果审核失败了，重新构建版本号需要修改</h3><blockquote><p>打包后，在app store后台选择最近的构建版本</p></blockquote><p><img src="https://s.poetries.work/uploads/2023/10/7fc6ff00ac395145.png" alt></p><h3 id="需要注意的是权限提示信息需要修改，否则会被拒审"><a href="#需要注意的是权限提示信息需要修改，否则会被拒审" class="headerlink" title="需要注意的是权限提示信息需要修改，否则会被拒审"></a>需要注意的是权限提示信息需要修改，否则会被拒审</h3><p><img src="https://s.poetries.work/uploads/2023/10/c4bfcbf056cf7932.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置development测试证书&quot;&gt;&lt;a href=&quot;#配置development测试证书&quot; class=&quot;headerlink&quot; title=&quot;配置development测试证书&quot;&gt;&lt;/a&gt;配置development测试证书&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="react" scheme="http://blog.poetries.top/tags/react/"/>
    
      <category term="RN" scheme="http://blog.poetries.top/tags/RN/"/>
    
  </entry>
  
  <entry>
    <title>Charles+模拟器抓安卓7以上https接口过程总结</title>
    <link href="http://blog.poetries.top/2023/09/24/charles-android/"/>
    <id>http://blog.poetries.top/2023/09/24/charles-android/</id>
    <published>2023-09-24T02:09:43.000Z</published>
    <updated>2025-03-30T13:54:29.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建安卓模拟器，选择Google-APIs的包"><a href="#创建安卓模拟器，选择Google-APIs的包" class="headerlink" title="创建安卓模拟器，选择Google APIs的包"></a>创建安卓模拟器，选择Google APIs的包</h2><p><img src="https://s.poetries.work/uploads/2023/09/167b68ff97543b8f.png" alt></p><blockquote><p>这里我们使用安卓<code>9.0 Google APIs</code>的模拟器（装最新版本也可以），记得要装<code>Google APIs</code>的，否则执行<code>adb root</code>获取<code>root</code>权限会报错<code>adbd cannot run as root in production builds</code></p></blockquote><h2 id="模拟器我们通过命令行来启动"><a href="#模拟器我们通过命令行来启动" class="headerlink" title="模拟器我们通过命令行来启动"></a>模拟器我们通过命令行来启动</h2><h3 id="列出当前模拟器"><a href="#列出当前模拟器" class="headerlink" title="列出当前模拟器"></a>列出当前模拟器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">emulator -list-avds</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2023/09/8a76711c15bfcf3e.png" alt></p><h3 id="启动模拟器-Pixel-XL-API-28"><a href="#启动模拟器-Pixel-XL-API-28" class="headerlink" title="启动模拟器 Pixel_XL_API_28"></a>启动模拟器 Pixel_XL_API_28</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要以这样的方式启动安卓模拟器才可转到包</span></span><br><span class="line">emulator -avd Pixel_XL_API_28 -writable-system</span><br></pre></td></tr></table></figure><h2 id="获取Root权限"><a href="#获取Root权限" class="headerlink" title="获取Root权限"></a>获取Root权限</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb remount</span><br></pre></td></tr></table></figure><p>命令执行完之后，模拟器会重新启动。如果启动成功，那么手机的<code>root</code>权限已开启</p><h2 id="配置抓包工具证书"><a href="#配置抓包工具证书" class="headerlink" title="配置抓包工具证书"></a>配置抓包工具证书</h2><p><img src="https://s.poetries.work/uploads/2023/09/8068bd69e487f012.png" alt></p><h3 id="根据证书计算hash值"><a href="#根据证书计算hash值" class="headerlink" title="根据证书计算hash值"></a>根据证书计算hash值</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -subject_hash_old -<span class="keyword">in</span> charles-ssl-proxying-certificate.pem</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2023/09/051c22061247f384.png" alt></p><h3 id="安装证书到系统目录"><a href="#安装证书到系统目录" class="headerlink" title="安装证书到系统目录"></a>安装证书到系统目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb push charles-ssl-proxying-certificate.pem /system/etc/security/cacerts/xxx.0</span><br></pre></td></tr></table></figure><ul><li>这里的<code>xxx.0</code>是上面的<code>hash值</code> 例如<code>dfaf1.0</code></li><li>安装完成后，进入<code>adb shell</code>，执行<code>reboot</code>重启模拟器，<strong>切记</strong>：<code>一定要重启模拟器证书才会生效</code></li></ul><p><img src="https://s.poetries.work/uploads/2023/09/38cdb96a1af15879.png" alt></p><p>看到<code>charles</code>证书安装到系统目录才算成功</p><h3 id="配置模拟器代理即可"><a href="#配置模拟器代理即可" class="headerlink" title="配置模拟器代理即可"></a>配置模拟器代理即可</h3><p><img src="https://s.poetries.work/uploads/2023/09/4ccabc1ea3295b2d.png" alt></p><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p><img src="https://s.poetries.work/uploads/2023/09/ba150e9d39dcef21.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建安卓模拟器，选择Google-APIs的包&quot;&gt;&lt;a href=&quot;#创建安卓模拟器，选择Google-APIs的包&quot; class=&quot;headerlink&quot; title=&quot;创建安卓模拟器，选择Google APIs的包&quot;&gt;&lt;/a&gt;创建安卓模拟器，选择Google 
      
    
    </summary>
    
      <category term="Tools" scheme="http://blog.poetries.top/categories/Tools/"/>
    
    
      <category term="调试" scheme="http://blog.poetries.top/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Charles" scheme="http://blog.poetries.top/tags/Charles/"/>
    
  </entry>
  
  <entry>
    <title>前端异常监控平台之Sentry落地</title>
    <link href="http://blog.poetries.top/2022/07/27/sentry-summary/"/>
    <id>http://blog.poetries.top/2022/07/27/sentry-summary/</id>
    <published>2022-07-27T12:40:43.000Z</published>
    <updated>2025-03-30T13:54:29.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sentry介绍"><a href="#Sentry介绍" class="headerlink" title="Sentry介绍"></a>Sentry介绍</h2><blockquote><p><code>Sentry</code> 是一套开源的实时的异常收集、追踪、监控系统。这套解决方案由对应各种语言的 SDK 和一套庞大的数据后台服务组成，通过 Sentry SDK 的配置，还可以上报错误关联的版本信息、发布环境。同时 Sentry SDK 会自动捕捉异常发生前的相关操作，便于后续异常追踪。异常数据上报到数据服务之后，会通过过滤、关键信息提取、归纳展示在数据后台的 Web 界面中</p></blockquote><blockquote><ul><li>Github: <a href="https://github.com/getsentry/sentry" target="_blank" rel="noopener">https://github.com/getsentry/sentry</a></li><li>文档 <a href="https://docs.sentry.io/" target="_blank" rel="noopener">https://docs.sentry.io/</a></li></ul></blockquote><p><strong>支持如下语言</strong></p><p><img src="https://s.poetries.work/uploads/2022/07/bb6538297dd29493.png" alt></p><p><strong>sentry功能架构</strong></p><p><img src="https://s.poetries.work/uploads/2022/07/ea60de5188aaa2a1.png" alt></p><p><strong>sentry核心架构</strong></p><p><img src="https://s.poetries.work/uploads/2022/07/31d57c95765101aa.png" alt></p><h2 id="环境搭建配置"><a href="#环境搭建配置" class="headerlink" title="环境搭建配置"></a>环境搭建配置</h2><h3 id="官方Sentry服务"><a href="#官方Sentry服务" class="headerlink" title="官方Sentry服务"></a>官方Sentry服务</h3><blockquote><p>sentry是开源的，如果我们愿意付费的话，sentry给我们提供了方便。省去了自己搭建和维护 Python 服务的麻烦事</p></blockquote><p>登录官网 <a href="https://sentry.io" target="_blank" rel="noopener">https://sentry.io</a> 注册账号后接入sdk即可使用</p><p><img src="https://s.poetries.work/uploads/2022/07/5db080cc6f487560.png" alt></p><h3 id="Sentry私有化部署"><a href="#Sentry私有化部署" class="headerlink" title="Sentry私有化部署"></a>Sentry私有化部署</h3><blockquote><p>Sentry 的管理后台是基于 <code>Python Django</code> 开发的。这个管理后台由背后的 Postgres 数据库（管理后台默认的数据库）、<code>ClickHouse</code>（存数据特征的数据库）、relay、kafka、redis 等一些基础服务或由 Sentry 官方维护的总共 23 个服务支撑运行。可见的是，如果独立的部署和维护这 23 个服务将是异常复杂和困难的。幸运的是，官方提供了基于 docker 镜像的一键部署实现 <a href="https://github.com/getsentry/self-hosted" target="_blank" rel="noopener">getsentry/onpremise</a></p></blockquote><p>sentry 本身是基于 Django 开发的，而且也依赖到其他的如 Postgresql、 Redis 等组件，所以一般有两种途径进行安装：通过 Docker 或用 Python 搭建</p><p><strong>前置环境</strong></p><blockquote><p>需要安装对应版本，否则安装会报错</p></blockquote><ul><li><code>Docker 19.03.6+</code></li><li><code>Docker-Compose 1.28.0+</code></li><li><code>4 CPU Cores</code></li><li><code>8 GB RAM</code></li><li><code>20 GB Free Disk Space</code></li></ul><h4 id="安装docker环境"><a href="#安装docker环境" class="headerlink" title="安装docker环境"></a>安装docker环境</h4><p>安装工具包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install yum-utils device-mapper-persistent-data lvm2 -y</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/e0f4f8f2621b11c0.png" alt></p><p>设置阿里镜像源</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/0b017f9a76914c6e.png" alt></p><p>安装docker</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br></pre></td></tr></table></figure><p>启动docker</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设为开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p><strong>docker 镜像加速（重要）</strong></p><blockquote><p>在后续部署的过程中，需要拉取大量镜像，官方源拉取较慢，可以修改 docker 镜像源</p></blockquote><p>登录阿里云官网，打开 <a href="https://cr.console.aliyun.com" target="_blank" rel="noopener">阿里云容器镜像服务</a>。点击左侧菜单最下面的 <code>镜像加速器</code> ，选择 <code>Centos</code></p><p><img src="https://s.poetries.work/uploads/2022/07/48ed424be7911056.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://l6of9ya6.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重启docker即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p><strong>安装docker-compose</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用国内源安装</span></span><br><span class="line">sudo curl -L <span class="string">"https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p><strong>设置docker-compose执行权限</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p><strong>创建软链</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p><strong>测试是否安装成功：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line"></span><br><span class="line">docker-compose version 1.22.0, build f46880fe</span><br></pre></td></tr></table></figure><h4 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/getsentry/onpremise</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>onpremise</code> 的根路径下有一个 <code>install.sh</code> 文件，只需要执行此脚本即可完成快速部署，脚本运行的过程中，大致会经历以下步骤：</p></blockquote><ul><li>环境检查</li><li>生成服务配置</li><li><code>docker volume</code> 数据卷创建（可理解为 <code>docker</code> 运行的应用的数据存储路径的创建）</li><li>拉取和升级基础镜像</li><li>构建镜像</li><li>服务初始化</li><li>设置管理员账号（如果跳过此步，可手动创建）</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> onpremise</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接运行 ./install.sh 将 Sentry 及其依赖都通过 docker 安装</span></span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure><p>后续一步一步安装下来</p><p><img src="https://s.poetries.work/uploads/2022/07/ec9447e63222462a.png" alt></p><p>设置管理员账号（如果跳过此步，可手动创建）</p><p><img src="https://s.poetries.work/uploads/2022/07/c960c51703ae0a14.png" alt></p><h4 id="启动项目执行"><a href="#启动项目执行" class="headerlink" title="启动项目执行"></a>启动项目执行</h4><p>在执行结束后，会提示创建完毕，运行 <code>docker-compose up -d</code> 启动服务</p><p><img src="https://s.poetries.work/uploads/2022/07/751ff76231406eec.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/07/5fe231a45329b6bf.png" alt></p><p>查看服务运行状态<code>docker-compose ps</code></p><p><img src="https://s.poetries.work/uploads/2022/07/d00aa7e4b2070d77.png" alt></p><h4 id="访问项目"><a href="#访问项目" class="headerlink" title="访问项目"></a>访问项目</h4><blockquote><p>所有服务都启动成功后,就可以访问<code>sentry</code>后台了,后台默认运行在服务器的<code>9000</code>端口,这里的<code>账户密码就是安装时让你设置</code>的那个</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/07/e714d0cdfa38438d.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/07/26405ca96fbdf205.png" alt></p><h3 id="设置语言和时区"><a href="#设置语言和时区" class="headerlink" title="设置语言和时区"></a>设置语言和时区</h3><p>点击头像<code>User settings - Account Details</code>的相应菜单设置，刷新后生效</p><p><img src="https://s.poetries.work/uploads/2022/07/d86d96288fe1ea13.png" alt></p><h2 id="Vue2-Sentry"><a href="#Vue2-Sentry" class="headerlink" title="Vue2 + Sentry"></a>Vue2 + Sentry</h2><h3 id="创建一个vue项目"><a href="#创建一个vue项目" class="headerlink" title="创建一个vue项目"></a>创建一个vue项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i @vue/cli -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化vue2项目</span></span><br><span class="line">vue create vue2-sentry</span><br></pre></td></tr></table></figure><h3 id="接入sentry"><a href="#接入sentry" class="headerlink" title="接入sentry"></a>接入sentry</h3><p><img src="https://s.poetries.work/uploads/2022/07/c4137ad12fdccfbd.png" alt></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Using npm</span></span><br><span class="line">npm install --save @sentry/vue @sentry/tracing</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Sentry <span class="keyword">from</span> <span class="string">"@sentry/vue"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Integrations &#125; <span class="keyword">from</span> <span class="string">"@sentry/tracing"</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  Vue,</span><br><span class="line">  dsn: <span class="string">"http://xdsdfafda21212@119.75.24.41:9000/2"</span>,</span><br><span class="line">  integrations: [</span><br><span class="line">    <span class="keyword">new</span> Integrations.BrowserTracing(&#123;</span><br><span class="line">      routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span><br><span class="line">      tracingOrigins: [<span class="string">"localhost"</span>, <span class="string">"my-site-url.com"</span>, /^\<span class="comment">//],</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 不同的环境上报到不同的 environment 分类</span></span><br><span class="line">  <span class="comment">// environment: process.env.ENVIRONMENT,</span></span><br><span class="line">  <span class="comment">// Set tracesSampleRate to 1.0 to capture 100%</span></span><br><span class="line">  <span class="comment">// of transactions for performance monitoring.</span></span><br><span class="line">  <span class="comment">// We recommend adjusting this value in production</span></span><br><span class="line">  <span class="comment">//  高访问量应用可以控制上报百分比</span></span><br><span class="line">  tracesSampleRate: <span class="number">1.0</span>,</span><br><span class="line">  release: process.env.SENTRY_VERSION || <span class="string">'0.0.1'</span>, <span class="comment">// 版本号，每次都npm run build上传都修改版本号</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>);</span><br></pre></td></tr></table></figure><p>我们手动抛出异常，在控制台可见捕获了错误</p><p><img src="https://s.poetries.work/uploads/2022/07/893f765fac6d2520.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/07/695199f400f7e40d.png" alt></p><h3 id="上传sourceMap到sentry"><a href="#上传sourceMap到sentry" class="headerlink" title="上传sourceMap到sentry"></a>上传sourceMap到sentry</h3><p>为了方便查看具体的报错内容，我们需要上传<code>sourceMap</code>到<code>sentry</code>平台。一般有两种方式 <code>sentry-cli</code>和 <code>sentry-webpack-plugin</code>方式，这里为了方便采用<code>webpack</code>方式</p><ul><li><code>source-map</code> 是一个文件，可以让已编译过的代码可以映射出原始源;</li><li><code>source-map</code> 就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。</li></ul><p><strong>webpack方式上传</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i @sentry/webpack-plugin -D</span><br></pre></td></tr></table></figure><p>修改<code>vue.config.js</code>配置文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SentryCliPlugin = <span class="built_in">require</span>(<span class="string">'@sentry/webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 打包生成sourcemap，打包完上传到sentry之后在删除，不要把sourcemao传到生产环境</span></span><br><span class="line">  productionSourceMap: process.env.NODE_ENV !== <span class="string">'development'</span>,</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'development'</span>) &#123;</span><br><span class="line">      config.plugins.push(</span><br><span class="line">        <span class="keyword">new</span> SentryCliPlugin(&#123;</span><br><span class="line">          include: <span class="string">'./dist/js'</span>, <span class="comment">// 只上传js</span></span><br><span class="line">          ignore: [<span class="string">'node_modules'</span>, <span class="string">'webpack.config.js'</span>],</span><br><span class="line">          ignoreFile: <span class="string">'.sentrycliignore'</span>,</span><br><span class="line">          release: process.env.SENTRY_VERSION || <span class="string">'0.0.1'</span>, <span class="comment">// 版本号，每次都npm run build上传都修改版本号 对应main.js中设置的Sentry.init版本号</span></span><br><span class="line">          cleanArtifacts: <span class="literal">true</span>, <span class="comment">// Remove all the artifacts in the release before the upload.</span></span><br><span class="line">          <span class="comment">// URL prefix to add to the beginning of all filenames. Defaults to ~/ but you might want to set this to the full URL. This is also useful if your files are stored in a sub folder. eg: url-prefix '~/static/js'</span></span><br><span class="line">          urlPrefix: <span class="string">'~/js'</span>, <span class="comment">// 线上对应的url资源的相对路径 注意修改这里，否则上传sourcemap还原错误信息有问题</span></span><br><span class="line">          <span class="comment">// urlPrefix： 关于这个，是要看你线上项目的资源地址，比如</span></span><br><span class="line">          <span class="comment">// 怎么看资源地址呢， 例如谷歌浏览器， F12控制台， 或者去Application里面找到对应资源打开</span></span><br><span class="line">        &#125;),</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取<code>TOKEN</code></p><p><img src="https://s.poetries.work/uploads/2022/07/d2cf43bc99c8125d.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/07/f427cd23cd15f067.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/07/1db9fed291b04c9c.png" alt></p><p>获取<code>org</code></p><p><img src="https://s.poetries.work/uploads/2022/07/8962b2ec56f2cc19.png" alt></p><p>在项目根目录创建<code>.sentryclirc</code></p><ul><li><code>url</code>：sentry部署的地址，默认是<code>https://sentry.io/</code></li><li><code>org</code>：控制台查看组织名称</li><li><code>project</code>：项目名称</li><li><code>token</code>：生成token需要勾选<code>project:write</code>项目写入权限</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .sentryclirc</span></span><br><span class="line"></span><br><span class="line">[auth]</span><br><span class="line">token=填入控制台创建的TOKEN</span><br><span class="line"></span><br><span class="line">[defaults]</span><br><span class="line">url=https://sentry.io/</span><br><span class="line">org=sentry</span><br><span class="line">project=vue</span><br></pre></td></tr></table></figure><p>执行项目打包命令，即可把js下的<code>sourcemap</code>相关文件上传到<code>sentry</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>上传后的<code>sourcemap</code>在这里可以看到</p><p><img src="https://s.poetries.work/uploads/2022/07/fc614a806ae0c774.png" alt></p><p>正确上传过 <code>source-map</code> 的项目，可以看到很清晰的报错位置</p><blockquote><p>进入本地打包的dist，<code>http-server -p 6002</code> 启动一个模拟正式环境部署的服务访问看看效果</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/07/c28db99ceb1e7001.png" alt></p><p>还可以通过 <code>面包屑</code> 功能查看，报错前发生了什么操作</p><p><img src="https://s.poetries.work/uploads/2022/07/1d6f7cba82780187.png" alt></p><p><strong>记得别把sourcemap文件传到生产环境，又大又不安全</strong> 删除<code>sourcemap</code>, 基于vue2演示的三种方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"vue-cli-service build &amp;&amp; rimraf ./dist/js/*.map"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2 单独生成map</span></span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line">configureWebpack(config) &#123;</span><br><span class="line">     config.output.sourceMapFilename(<span class="string">'sourceMap/[name].[chunkhash].map.js'</span>)</span><br><span class="line">     config.plugin(<span class="string">'sentry'</span>).use(SentryCliPlugin, [&#123;</span><br><span class="line">        include: <span class="string">'./dist/sourceMap'</span>, <span class="comment">// 只上传js</span></span><br><span class="line">        ignore: [<span class="string">'node_modules'</span>],</span><br><span class="line">        configFile: <span class="string">'sentry.properties'</span>,</span><br><span class="line">        release: process.env.SENTRY_VERSION || <span class="string">'0.0.1'</span>, <span class="comment">// 版本号，每次都npm run build上传都修改版本号</span></span><br><span class="line">        cleanArtifacts: <span class="literal">true</span>, <span class="comment">// 先清理再上传</span></span><br><span class="line">    &#125;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3 webpack插件清理</span></span><br><span class="line">$ npm i webpack-<span class="keyword">delete</span>-sourcemaps-plugin -D</span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; DeleteSourceMapsPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack-delete-sourcemaps-plugin'</span>)</span><br><span class="line"></span><br><span class="line">configureWebpack(config) &#123;</span><br><span class="line">    config.plugin.push(</span><br><span class="line">        <span class="keyword">new</span> DeleteSourceMapsPlugin(), <span class="comment">// 清理sourcemap</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看-Performance"><a href="#查看-Performance" class="headerlink" title="查看 Performance"></a>查看 Performance</h3><p><img src="https://s.poetries.work/uploads/2022/07/d02c70b8bed7be49.png" alt></p><blockquote><p><code>Sentry.init()</code> 中，<code>new Integrations.BrowserTracing()</code> 的功能是将浏览器页面加载和导航检测作为事物，并捕获请求，指标和错误。</p></blockquote><ul><li><code>TPM</code>: 每分钟事务数</li><li><code>FCP</code>：首次内容绘制（浏览器第第一次开始渲染 dom 的时间点）</li><li><code>LCP</code>：最大内容渲染，代表 <code>viewpoint</code> 中最大页面元素的加载时间</li><li><code>FID</code>：用户首次输入延迟，可以衡量用户首次与网站交互的时间</li><li><code>CLS</code>：累计布局偏移，一个元素初始时和消失前的数据</li><li><code>TTFB</code>：首字节时间，测量用户浏览器接收页面的第一个字节的时间（可以判断缓慢来自网络请求还是页面加载问题）</li><li><code>USER</code>：<code>uv</code> 数字</li><li><code>USER MISERY</code>: 对响应时间难以忍受的用户指标，由 <code>sentry</code> 计算出来，阈值可以动态修改</li></ul><h2 id="Vue3-Vite-Sentry"><a href="#Vue3-Vite-Sentry" class="headerlink" title="Vue3 + Vite + Sentry"></a>Vue3 + Vite + Sentry</h2><h3 id="创建vue3项目"><a href="#创建vue3项目" class="headerlink" title="创建vue3项目"></a>创建vue3项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn create vite</span><br></pre></td></tr></table></figure><h3 id="安装sentry依赖"><a href="#安装sentry依赖" class="headerlink" title="安装sentry依赖"></a>安装sentry依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i @sentry/vue @sentry/tracing</span><br></pre></td></tr></table></figure><h3 id="初始化sentry"><a href="#初始化sentry" class="headerlink" title="初始化sentry"></a>初始化sentry</h3><blockquote><p><code>src/main.js</code>中修改</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRouter &#125; <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Sentry <span class="keyword">from</span> <span class="string">"@sentry/vue"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Integrations &#125; <span class="keyword">from</span> <span class="string">"@sentry/tracing"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  app,</span><br><span class="line">  dsn: <span class="string">"http://xdfada1212@12.715.204.41:9000/2"</span>,</span><br><span class="line">  integrations: [</span><br><span class="line">    <span class="keyword">new</span> Integrations.BrowserTracing(&#123;</span><br><span class="line">      routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span><br><span class="line">      tracingOrigins: [<span class="string">"localhost"</span>, <span class="string">"my-site-url.com"</span>, /^\<span class="comment">//],</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 不同的环境上报到不同的 environment 分类</span></span><br><span class="line"><span class="comment">//   environment: process.env.ENVIRONMENT,</span></span><br><span class="line">  <span class="comment">// Set tracesSampleRate to 1.0 to capture 100%</span></span><br><span class="line">  <span class="comment">// of transactions for performance monitoring.</span></span><br><span class="line">  <span class="comment">// We recommend adjusting this value in production</span></span><br><span class="line">    <span class="comment">//  高访问量应用可以控制上报百分比</span></span><br><span class="line">  tracesSampleRate: <span class="number">1.0</span>,</span><br><span class="line">  release: process.env.SENTRY_VERSION || <span class="string">'0.0.1'</span>, <span class="comment">// 版本号，每次都npm run build上传都修改版本号</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router);</span><br><span class="line">app.mount(<span class="string">"#app"</span>);</span><br></pre></td></tr></table></figure><h3 id="sourcemap上传"><a href="#sourcemap上传" class="headerlink" title="sourcemap上传"></a>sourcemap上传</h3><blockquote><p>修改<code>vite.config.js</code>配置</p></blockquote><p>安装<code>npm i vite-plugin-sentry -D</code>插件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vite'</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">'@vitejs/plugin-vue'</span></span><br><span class="line"><span class="keyword">import</span> viteSentry <span class="keyword">from</span> <span class="string">'vite-plugin-sentry'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sentryConfig = &#123;</span><br><span class="line">  configFile: <span class="string">'./.sentryclirc'</span>,</span><br><span class="line">  release: process.env.SENTRY_VERSION || <span class="string">'0.0.1'</span>, <span class="comment">// 版本号，每次都npm run build上传都修改版本号</span></span><br><span class="line">  deploy: &#123;</span><br><span class="line">   env: <span class="string">'production'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  skipEnvironmentCheck: <span class="literal">true</span>, <span class="comment">// 可以跳过环境检查</span></span><br><span class="line">  sourceMaps: &#123;</span><br><span class="line">   include: [<span class="string">'./dist/assets'</span>],</span><br><span class="line">   ignore: [<span class="string">'node_modules'</span>],</span><br><span class="line">   urlPrefix: <span class="string">'~/assets'</span>, <span class="comment">// 注意这里设置正确，否则sourcemap上传不正确</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    vue(),</span><br><span class="line">    process.env.NODE_ENV === <span class="string">'production'</span> ? viteSentry(sentryConfig) : <span class="literal">null</span>,</span><br><span class="line">  ],</span><br><span class="line">  build: &#123;</span><br><span class="line">    sourcemap: process.env.NODE_ENV === <span class="string">'production'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>此时当执行<code>vite build</code>时，<code>viteSentry</code>这个插件会将构建的<code>sourcemap</code>文件上传到s<code>entry</code>对应的项目<code>release</code>之下。当次版本新捕获到错误时就可以还原出错误行，以及详细的错误信息。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/07/605e5eb69a429340.png" alt></p><h2 id="React-Sentry"><a href="#React-Sentry" class="headerlink" title="React + Sentry"></a>React + Sentry</h2><blockquote><p>使用umi项目接入演示</p></blockquote><h3 id="创建一个umi项目"><a href="#创建一个umi项目" class="headerlink" title="创建一个umi项目"></a>创建一个umi项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir umi-sentry &amp;&amp; <span class="built_in">cd</span>  umi-sentry</span><br><span class="line"></span><br><span class="line">yarn create umi</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/07/b7e76f88d489b17f.png" alt></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Using npm</span></span><br><span class="line">npm install --save @sentry/react @sentry/tracing</span><br></pre></td></tr></table></figure><h3 id="接入sentry-1"><a href="#接入sentry-1" class="headerlink" title="接入sentry"></a>接入sentry</h3><p>初始化sentry</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pages/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Sentry <span class="keyword">from</span> <span class="string">"@sentry/react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserTracing &#125; <span class="keyword">from</span> <span class="string">"@sentry/tracing"</span>;</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  dsn: <span class="string">"https://xdfa@o1334810.ingest.sentry.io/121"</span>,</span><br><span class="line">  integrations: [<span class="keyword">new</span> BrowserTracing()],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set tracesSampleRate to 1.0 to capture 100%</span></span><br><span class="line">  <span class="comment">// of transactions for performance monitoring.</span></span><br><span class="line">  <span class="comment">// We recommend adjusting this value in production</span></span><br><span class="line">  release: <span class="string">'0.0.1'</span>,</span><br><span class="line">  tracesSampleRate: <span class="number">1.0</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手动抛出异常查看是否能正确上报到sentry</p><p><img src="https://s.poetries.work/uploads/2022/07/1742ca6bb482613a.png" alt></p><h3 id="sourcemap上传-1"><a href="#sourcemap上传-1" class="headerlink" title="sourcemap上传"></a>sourcemap上传</h3><h4 id="根目录创建配置文件-sentryclirc"><a href="#根目录创建配置文件-sentryclirc" class="headerlink" title="根目录创建配置文件 .sentryclirc"></a>根目录创建配置文件 .sentryclirc</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[auth]</span><br><span class="line">token=TOKEN控制台获取，TOKEN需要勾选project:write写入权限</span><br><span class="line"></span><br><span class="line">[defaults]</span><br><span class="line">url=https:<span class="comment">//sentry.io/ // 默认地址</span></span><br><span class="line">org=组织名称，控制台获取</span><br><span class="line">project=react <span class="comment">// 项目名称</span></span><br></pre></td></tr></table></figure><h4 id="sourcemap配置上传"><a href="#sourcemap配置上传" class="headerlink" title="sourcemap配置上传"></a>sourcemap配置上传</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i @sentry/webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .umirc.ts 修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SentryPlugin = <span class="built_in">require</span>(<span class="string">'@sentry/webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  devtool: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'source-map'</span> : <span class="string">'eval'</span>, <span class="comment">// 开启sourcemao</span></span><br><span class="line">  chainWebpack(config, &#123; webpack &#125;)&#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>)&#123;<span class="comment">//当为prod时候才进行sourcemap的上传，如果不判断，在项目运行的打包也会上传</span></span><br><span class="line">      config.plugin(<span class="string">"sentry"</span>).use(SentryPlugin, [&#123;</span><br><span class="line">        ignore: [<span class="string">'node_modules'</span>],</span><br><span class="line">        include: <span class="string">'./dist'</span>, <span class="comment">//上传dist文件的js</span></span><br><span class="line">        configFile: <span class="string">'./sentryclirc'</span>, <span class="comment">//配置文件地址，这个一定要有，踩坑在这里，忘了写导致一直无法实现上传sourcemap</span></span><br><span class="line">        release:<span class="string">'1.0.1'</span>, <span class="comment">//版本号，自己定义的变量，整个版本号在项目里面一定要对应</span></span><br><span class="line">        deleteAfterCompile: <span class="literal">true</span>,</span><br><span class="line">        urlPrefix: <span class="string">'~/'</span> <span class="comment">// js的代码路径前缀</span></span><br><span class="line">       &#125;])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行打包上传sourcemap</span></span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入dist文件，启动http-server 本地服务模拟线上效果</span></span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/07/3dce162037de39ac.png" alt></p><p>修改代码抛出异常，查看控制台sourcemap解析的效果</p><p><img src="https://s.poetries.work/uploads/2022/07/3cd50955a8f30718.png" alt></p><p><strong>注意：npm run build之后，不要把sourcemap上传到生产环境，记得删除</strong></p><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><h3 id="识别用户"><a href="#识别用户" class="headerlink" title="识别用户"></a>识别用户</h3><blockquote><p>在上传的 issues 里面，我们可以借助 setUser 方法，设置读取存在本地的用户信息。（此信息需要持久化存储，否则刷新会消失）</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/main.js</span></span><br><span class="line">Sentry.setUser(&#123;</span><br><span class="line">  id: <span class="string">'dfar12e31'</span>, <span class="comment">// userId cookie.get('userId')</span></span><br><span class="line">  email: <span class="string">'test@qq.com'</span>, <span class="comment">// cookie.get('email')</span></span><br><span class="line">  username: <span class="string">'poetry'</span>, <span class="comment">// cookie.get('username')</span></span><br><span class="line">&#125;)</span><br><span class="line">Vue.prototype.$Sentry = Sentry</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/07/5406d9288512bbf5.png" alt></p><h3 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h3><ul><li>定义错误边界，当组件报错的时候，可以上报相关信息</li><li>使用 <code>Sentry.ErrorBoundary</code>。加了错误边界，可以把错误定位到组件上面。</li></ul><h3 id="rrweb-重播"><a href="#rrweb-重播" class="headerlink" title="rrweb 重播"></a>rrweb 重播</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i @sentry/rrweb rrweb -S</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SentryRRWeb <span class="keyword">from</span> <span class="string">'@sentry/rrweb'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/main.js</span></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">    Vue,</span><br><span class="line">    dsn: <span class="string">"xxx"</span>,</span><br><span class="line">    integrations: [</span><br><span class="line">      <span class="keyword">new</span> Integrations.BrowserTracing(&#123;</span><br><span class="line">        routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span><br><span class="line">        tracingOrigins: [<span class="string">"localhost"</span>, <span class="string">"my-site-url.com"</span>, /^<span class="comment">//],</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> SentryRRWeb(&#123;</span><br><span class="line">        checkoutEveryNms: <span class="number">10</span> * <span class="number">1000</span>, <span class="comment">// 每10秒重新制作快照</span></span><br><span class="line">        checkoutEveryNth: <span class="number">200</span>, <span class="comment">// 每 200 个 event 重新制作快照</span></span><br><span class="line">        maskAllInputs: <span class="literal">false</span>, <span class="comment">// 将所有输入内容记录为 *</span></span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 不同的环境上报到不同的 environment 分类</span></span><br><span class="line">    environment: process.env.ENVIRONMENT,</span><br><span class="line">    <span class="comment">//  高访问量应用可以控制上报百分比</span></span><br><span class="line">    tracesSampleRate: <span class="number">1.0</span>,</span><br><span class="line">    release: process.env.SENTRY_VERSION || <span class="string">'0.0.1'</span>, <span class="comment">// 版本号，每次都npm run build上传都修改版本号</span></span><br><span class="line">    logErrors: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在报错后，可以录屏播放错误发生的情况</p><p><img src="https://s.poetries.work/uploads/2022/07/d7231e857e234509.png" alt></p><h3 id="手动设置报警"><a href="#手动设置报警" class="headerlink" title="手动设置报警"></a>手动设置报警</h3><ul><li>设置报警规则，当我们某些情况，如 <code>issues</code>，<code>performance</code> 超过我们设置的阈值，会触发 <code>alert</code>。</li><li>我们可以通过提醒等功能来帮助我们即时发现问题。</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/4bd87c7949fd6a74.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Sentry介绍&quot;&gt;&lt;a href=&quot;#Sentry介绍&quot; class=&quot;headerlink&quot; title=&quot;Sentry介绍&quot;&gt;&lt;/a&gt;Sentry介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Sentry&lt;/code&gt; 是一套开源的实时的异常收集
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="前端监控" scheme="http://blog.poetries.top/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
      <category term="Sentry" scheme="http://blog.poetries.top/tags/Sentry/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL+Koa2实现服务端API结合Apollo+Vue</title>
    <link href="http://blog.poetries.top/2022/07/01/graphql-koa2-apollo-vue/"/>
    <id>http://blog.poetries.top/2022/07/01/graphql-koa2-apollo-vue/</id>
    <published>2022-07-01T12:40:43.000Z</published>
    <updated>2025-03-30T13:54:29.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、GraphQL介绍"><a href="#一、GraphQL介绍" class="headerlink" title="一、GraphQL介绍"></a>一、GraphQL介绍</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><blockquote><p>GraphQL 是一种新的 API 的查询语言，它提供了一种更高效、强大和灵活 API 查询。它 是由 Facebook 开发和开源，目前由来自世界各地的大公司和个人维护。GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且 没有任何冗余。它弥补了 RESTful API（字段冗余，扩展性差、无法聚合 api、无法定义数据 类型、网络请求次数多）等不足</p></blockquote><p><strong>注意</strong>：GraphQL 是 api 的查询语言，而不是数据库。从这个意义上说，它是数据库无关的， 而且可以在使用 API 的任何环境中有效使用，我们可以理解为 GraphQL 是基于 API 之上的一 层封装，目的是为了更好，更灵活的适用于业务的需求变化</p><p><strong>GraphQL 可以用在常见各种服务器端语言以及客户端语言中</strong></p><ul><li>服务器端语言：C# / .NET、Clojure、Elixir、Erlang、Go、Groovy、Java、JavaScript、PHP、Python、 Scala、Ruby</li><li><p>客户端语言：js、React + React Native、Angular、Vue.js、Apollo Link、Native iOS、Native Android、 Scala.js</p></li><li><p>中文文档：<a href="http://graphql.cn" target="_blank" rel="noopener">http://graphql.cn</a></p></li><li>Github: <a href="https://github.com/facebook/graphql" target="_blank" rel="noopener">https://github.com/facebook/graphql</a></li></ul><p><strong>GraphQL 出现的历史背景</strong></p><p>当提起API设计的时候，大家通常会想到SOAP（一种简单的基于 XML 的协议），RESTful 等设计方式，从 2000 年 RESTful 的理论被提出的时候，在业界引起了很大反响，因为这种 设计理念更易于用户的使用，所以便很快的被大家所接受。</p><p>我们知道 REST 是一种从服务 器公开数据的流行方式。<strong>当 REST 的概念被提及出来时</strong>，客户端应用程序对数据的需求相 对简单，<strong>而开发的速度并没有达到今天的水平</strong>。</p><p>因此 REST 对于许多应用程序来说是非常 适合的。然而在业务越发复杂，客户对系统的扩展性有了更高的要求时，API 环境发生了巨 大的变，<strong>RESTful 显得心有余而力不足</strong>。比如：字段冗余，扩展性差、无法聚合 api、无法 定义数据类型、网络请求次数多</p><p>GraphQL 的出现整好弥补了 RESTful APi 的不足</p><p><strong>使用 GraphQL 的公司</strong></p><p>目前已经有很多的公司在使用 GraphQL（<a href="https://graphql.org/users/）" target="_blank" rel="noopener">https://graphql.org/users/）</a></p><p><img src="https://s.poetries.work/uploads/2022/06/1f26bea368abe7ae.png" alt></p><h2 id="1-2-为什么推荐-GraphQL-而不是-RESTful-API"><a href="#1-2-为什么推荐-GraphQL-而不是-RESTful-API" class="headerlink" title="1.2 为什么推荐 GraphQL 而不是 RESTful API"></a>1.2 为什么推荐 GraphQL 而不是 RESTful API</h2><p>在过去的十多年中，REST 已经成为设计 web api 的标准(虽然只是一个模糊的标准)。 </p><p>它提供了一些很棒的想法，比如无状态服务器和结构化的资源访问。</p><p>然而 REST api 表 现得过于僵化，无法跟上访问它们的客户的快速变化的需求</p><h3 id="RESTful-API-不足"><a href="#RESTful-API-不足" class="headerlink" title="RESTful API 不足"></a>RESTful API 不足</h3><ul><li><strong>扩展性（多个终端需要返回不同的字段）</strong>，单个 RESTful 接口返回数据越来越 臃肿。前端对于真正用到的字段是没有直观映像的，仅仅通过 url 地址，无法预测也无 法回忆返回的字段数目和字段是否有效，接口返回 50 个字段，但却只用 5 个字段，造 成字段冗余，扩展性差，单个 RESTful 接口返回数据越来越臃肿</li><li><strong>API 聚合问题</strong>，某个前端展现，实际需要调用多个独立的 RESTful API 才能获 取到足够的数据，<strong>导致网络请求次数多</strong></li><li><strong>前后端字段频繁改动</strong>，导致类型不一致，错误的数据类型可能会导致网站出错 尤其是在业务多变的场景中，很难在保证工程质量的同时快速满足业务需求</li></ul><h3 id="GraphQL-的优点"><a href="#GraphQL-的优点" class="headerlink" title="GraphQL 的优点"></a>GraphQL 的优点</h3><ul><li>吸收了 RESTful API 的特性</li><li><strong>所见即所得</strong> 各种不同的前端框架和平台可以指定自己需要的字段。查询的返回结果就是输 入的查询结构的精确映射</li></ul><p><strong>客户端可以自定义 Api 聚合</strong></p><p>如果设计的数据结构是从属的，直接就能在查询语句中指定;即使数据结构是独 立的，也可以在查询语句中指定上下文，只需要一次网络请求，就能获得资源和子 资源的数据。</p><p><strong>代码即是文档</strong></p><p>GraphQL 会把 schema 定义和相关的注释生成可视化的文档，从而使得代码的变更，直接就反映到最新的文档上，避免 RESTful 中手工维护可能会造成代码、 文档不一致的问题</p><p><strong>参数类型强校验</strong></p><ul><li>RESTful 方案本身没有对参数的类型做规定，往往都需要自行实现参数的校验机制， 以确保安全。</li><li>但 GraphQL 提供了强类型的 schema 机制，从而天然确保了参数类型的合法性</li></ul><h1 id="二、GraphQl类型系统"><a href="#二、GraphQl类型系统" class="headerlink" title="二、GraphQl类型系统"></a>二、GraphQl类型系统</h1><h2 id="2-1-GraphQl类型"><a href="#2-1-GraphQl类型" class="headerlink" title="2.1 GraphQl类型"></a>2.1 GraphQl类型</h2><blockquote><p>可以将GraphQL的类型系统分为<code>标量类型</code>（ScalarTypes，标量类型）和其他<code>高级数据类型</code>，标量类型即可以表示最细粒度数据结构的数据类型，可以和JavaScript的原始类型对应</p></blockquote><p><strong>GraphQL规范目前规定支持的标量类型有</strong></p><ul><li><strong>Int</strong>：有符号<code>32</code>位整数 – <code>GraphQLInt</code></li><li><strong>Float</strong>：有符号双精度浮点值 – <code>GraphQLFloat</code></li><li><strong>String</strong>：<code>UTF‐8</code>字符序列 – <code>GraphQLString</code></li><li><strong>Boolean</strong>：<code>true</code>或者<code>false</code> – <code>GraphQLBoolean</code></li><li><strong>ID(GraphQLID)</strong>：ID标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID类型使用和String一样的方式序列化；然而将其定义为ID意味着并不需要可读型。</li></ul><p><strong>GraphQL其他高级数据类型包括</strong></p><ul><li><strong>Object：对象(newGraphQLObjectType)</strong></li></ul><blockquote><p>用于描述层级或者树形数据结构。对于树形数据结构来说，叶子字段的类型都是标量数据类型。几乎所有GraphQL类型都是对象类型。Object类型有一个name字段，以及一个很重要的fields字段。fields字段可以描述出一个完整的数据结构。例如一个表示地址数据结构的GraphQL对象为</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AddressType=newGraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'Address'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        street:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        number:&#123;</span><br><span class="line">            type:GraphQLInt</span><br><span class="line">        &#125;,</span><br><span class="line">        formatted:&#123;</span><br><span class="line">            type:GraphQLString,</span><br><span class="line">            resolve(obj)&#123;</span><br><span class="line">                <span class="keyword">return</span> obj.number+<span class="string">''</span>+obj.street</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>Interface</code>：接口用于描述多个类型的通用字</li><li><code>Union</code>：联合类型用于描述某个字段能够支持的所有返回类型以及具体请求真正的返回类型</li><li><code>Enum</code>：枚举用于表示可枚举数据结构的类型</li><li><code>InputObject</code>：输入对象</li><li><code>List</code>：列表</li></ul><blockquote><p>列表是其他类型的封装，通常用于对象字段的描述。例如下面PersonType类型数据的parents和children字段</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PersonType=newGraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'Person'</span>,</span><br><span class="line">    fields:<span class="function"><span class="params">()</span>=&gt;</span>(&#123;</span><br><span class="line">        parents:&#123;<span class="attr">type</span>:newGraphQLList(Person)&#125;,</span><br><span class="line">        children:&#123;<span class="attr">type</span>:newGraphQLList(Person)&#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>Non-Null</code>：不能为<code>Null</code></li></ul><blockquote><p><code>Non-Null</code>强制类型的值不能为<code>null</code>，并且在请求出错时一定会报错。可以用于必须保证值不能为<code>null</code>的字段。例如数据库的行的id字段不能为<code>null</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RowType=newGraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'Row'</span>,</span><br><span class="line">    fields:<span class="function"><span class="params">()</span>=&gt;</span>(&#123;</span><br><span class="line">        id:&#123;</span><br><span class="line">            type:newGraphQLNonNull(GraphQLString)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-2-GraphQl查询语言"><a href="#2-2-GraphQl查询语言" class="headerlink" title="2.2 GraphQl查询语言"></a>2.2 GraphQl查询语言</h2><p><strong>GraphQL规范支持两种操作</strong></p><ul><li><code>query</code>：仅获取数据（<code>fetch</code>）的只读请求</li><li><code>mutation</code>：获取数据后还有写操作的请求</li></ul><blockquote><p>新版本的GraphQL还支持<code>subscription</code>，这是为了处理订阅更新这种比较复杂的实时数据更新场景而设计的操作</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/07/505bd2a4b2604bcf.png" alt></p><h1 id="三、Express中集成GraphQl-实现-Server-API"><a href="#三、Express中集成GraphQl-实现-Server-API" class="headerlink" title="三、Express中集成GraphQl 实现 Server API"></a>三、Express中集成GraphQl 实现 Server API</h1><h2 id="3-1-安装mongodb造数据"><a href="#3-1-安装mongodb造数据" class="headerlink" title="3.1 安装mongodb造数据"></a>3.1 安装mongodb造数据</h2><p>使用<code>mongodb</code>做数据库演示，mac安装<code>mongodb</code>，<code>brew install mongodb-community</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入mongo shell</span></span><br><span class="line">mongo </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库</span></span><br><span class="line">use graphql (graphql数据库不存在会自动创建)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建nav、articlecate集合插入数据</span></span><br><span class="line">db.nav.insert(&#123;name: <span class="string">"标题1"</span>, url: <span class="string">"/"</span>, sort: 1, add_time: <span class="string">"2022-06-30"</span>&#125;)</span><br><span class="line">db.nav.insert(&#123;name: <span class="string">"标题2"</span>, url: <span class="string">"/"</span>, sort: 1, add_time: <span class="string">"2022-06-30"</span>&#125;)</span><br><span class="line">db.nav.insert(&#123;name: <span class="string">"标题3"</span>, url: <span class="string">"/"</span>, sort: 1, add_time: <span class="string">"2022-06-30"</span>&#125;)</span><br><span class="line"></span><br><span class="line">db.articlecate.insert(&#123;name: <span class="string">"分类1"</span>, description: <span class="string">"描述"</span>, keywords: <span class="string">"关键词"</span>, status: 1&#125;)</span><br><span class="line">db.articlecate.insert(&#123;name: <span class="string">"分类2"</span>, description: <span class="string">"描述"</span>, keywords: <span class="string">"关键词"</span>, status: 1&#125;)</span><br><span class="line">db.articlecate.insert(&#123;name: <span class="string">"分类3"</span>, description: <span class="string">"描述"</span>, keywords: <span class="string">"关键词"</span>, status: 1&#125;)</span><br></pre></td></tr></table></figure><p><strong>或者导入数据库数据</strong></p><blockquote><p>下载数据库文件解压并导入mongodb即可 <a href="https://blog.poetries.top/db/koa.zip">https://blog.poetries.top/db/koa.zip</a></p></blockquote><p><strong>导入mongodb数据库</strong> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongorestore -h localhost:27017 -d koa-demo(数据库名称，不存在会自动创建) ./dump(本地数据文件路径)</span><br></pre></td></tr></table></figure><h2 id="3-2-express集成GraphQl"><a href="#3-2-express集成GraphQl" class="headerlink" title="3.2 express集成GraphQl"></a>3.2 express集成GraphQl</h2><p><a href="https://github.com/graphql/express-graphql" target="_blank" rel="noopener">https://github.com/graphql/express-graphql</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install express-graphql graphql--save</span><br></pre></td></tr></table></figure><p>引入express-graphql配置中间件</p><h3 id="app完善配置"><a href="#app完善配置" class="headerlink" title="app完善配置"></a>app完善配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> DB=<span class="built_in">require</span>(<span class="string">'./model/db.js'</span>); </span><br><span class="line"><span class="keyword">const</span> graphqlHTTP = <span class="built_in">require</span>(<span class="string">'express-graphql'</span>);</span><br><span class="line"><span class="keyword">const</span> GraphQLDefaultSchema = <span class="built_in">require</span>(<span class="string">'./schema/default.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app=express(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置中间件</span></span><br><span class="line">app.use(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">    schema: GraphQLDefaultSchema,</span><br><span class="line">    graphiql: <span class="literal">true</span> <span class="comment">// 线上环境关闭，开发环境开启</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置路由</span></span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'hello express'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,()=&gt;<span class="built_in">console</span>.log(<span class="string">"http://localhost:3000"</span>));</span><br></pre></td></tr></table></figure><h3 id="定义GraphQLSchema模型"><a href="#定义GraphQLSchema模型" class="headerlink" title="定义GraphQLSchema模型"></a>定义GraphQLSchema模型</h3><ul><li>新建<code>schema/default.js</code></li><li>定义<code>Schema</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DB=<span class="built_in">require</span>(<span class="string">'../model/db.js'</span>); <span class="comment">/*引入DB库*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    GraphQLObjectType,</span><br><span class="line">    GraphQLString,</span><br><span class="line">    GraphQLInt,</span><br><span class="line">    GraphQLSchema,</span><br><span class="line">    GraphQLList</span><br><span class="line">&#125; =<span class="built_in">require</span>(<span class="string">'graphql'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、获取导航列表     定义导航的schema类型</span></span><br><span class="line"><span class="keyword">var</span> NavSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'nav'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        _id:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        title:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        url:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        sort:&#123;</span><br><span class="line">            type:GraphQLInt</span><br><span class="line">        &#125;,</span><br><span class="line">        status:&#123;</span><br><span class="line">            type:GraphQLInt</span><br><span class="line">        &#125;,</span><br><span class="line">        add_time:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ArticleCateSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'articlecate'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        _id:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        title:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        description:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        keywords:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125; , </span><br><span class="line">        status:&#123;</span><br><span class="line">            type:GraphQLInt</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、定义一个跟       根里面定义调用导航Schema类型的方法</span></span><br><span class="line"><span class="keyword">var</span> RootSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'root'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        oneNavList:&#123;  <span class="comment">//方法名称：定义调用导航Schema类型的方法</span></span><br><span class="line">            type:NavSchema,  <span class="comment">//方法的类型, 方法返回的参数必须和NavSchema里面定义的类型一致</span></span><br><span class="line">            args:&#123;<span class="attr">id</span>:&#123;<span class="attr">type</span>:GraphQLString&#125;&#125;, <span class="comment">//参数</span></span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;  <span class="comment">//执行的操作</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// args.id 获取调用方法传入的值</span></span><br><span class="line">                <span class="keyword">var</span> id=args.id;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> navList=<span class="keyword">await</span> DB.find(<span class="string">'nav'</span>,&#123;<span class="string">"_id"</span>:DB.getObjectId(id)&#125;);</span><br><span class="line">                <span class="keyword">return</span> navList[<span class="number">0</span>];               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        navList:&#123;</span><br><span class="line">            type:GraphQLList(NavSchema),  </span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;               </span><br><span class="line">                <span class="keyword">var</span> navList=<span class="keyword">await</span> DB.find(<span class="string">'nav'</span>,&#123;&#125;);</span><br><span class="line">                <span class="keyword">return</span> navList;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        articleCateList:&#123;</span><br><span class="line">            type:GraphQLList(ArticleCateSchema),</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;               </span><br><span class="line">                <span class="keyword">var</span> articlecateList=<span class="keyword">await</span> DB.find(<span class="string">'articlecate'</span>,&#123;&#125;);</span><br><span class="line">                <span class="keyword">return</span> articlecateList; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        oneArticleCateList:&#123;</span><br><span class="line">            type:ArticleCateSchema, </span><br><span class="line">            args:&#123;<span class="attr">id</span>:&#123;<span class="attr">type</span>:GraphQLString&#125;&#125;,</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;             </span><br><span class="line">                <span class="keyword">var</span> id=args.id;</span><br><span class="line">                <span class="keyword">var</span> articlecateList=<span class="keyword">await</span> DB.find(<span class="string">'articlecate'</span>,&#123;<span class="string">"_id"</span>:DB.getObjectId(id)&#125;);</span><br><span class="line">                <span class="keyword">return</span> articlecateList[<span class="number">0</span>];   <span class="comment">//要返回一个json对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、把根挂载到 GraphQLSchema</span></span><br><span class="line"><span class="built_in">module</span>.exports=<span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query:RootSchema</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="编写数据库操作方法"><a href="#编写数据库操作方法" class="headerlink" title="编写数据库操作方法"></a>编写数据库操作方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * http://mongodb.github.io/node-mongodb-native</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * http://mongodb.github.io/node-mongodb-native/3.0/api/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DB库</span></span><br><span class="line"><span class="keyword">var</span> MongoDB=<span class="built_in">require</span>(<span class="string">'mongodb'</span>);</span><br><span class="line"><span class="keyword">var</span> MongoClient =MongoDB.MongoClient;</span><br><span class="line"><span class="keyword">const</span> ObjectID = MongoDB.ObjectID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Config= &#123;</span><br><span class="line">    dbUrl: <span class="string">'mongodb://localhost:27017/'</span>,</span><br><span class="line">    dbName: <span class="string">'graphql'</span> <span class="comment">// 数据库名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Db</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> getInstance()&#123;   <span class="comment">/*1、单例  多次实例化实例不共享的问题*/</span></span><br><span class="line">        <span class="keyword">if</span>(!Db.instance)&#123;</span><br><span class="line">            Db.instance=<span class="keyword">new</span> Db();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  Db.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbClient=<span class="string">''</span>; <span class="comment">/*属性 放db对象*/</span></span><br><span class="line">        <span class="keyword">this</span>.connect();   <span class="comment">/*实例化的时候就连接数据库*/</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    connect()&#123;  <span class="comment">/*连接数据库*/</span></span><br><span class="line">      <span class="keyword">let</span> _that=<span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(!_that.dbClient)&#123;         <span class="comment">/*1、解决数据库多次连接的问题*/</span></span><br><span class="line">              MongoClient.connect(Config.dbUrl,&#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;,(err,client)=&gt;&#123;</span><br><span class="line">                  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    _that.dbClient=client.db(Config.dbName);</span><br><span class="line">                    resolve(_that.dbClient)</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(_that.dbClient);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     DB.find('user',&#123;&#125;)  返回所有数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     DB.find('user',&#123;&#125;,&#123;"title":1&#125;)    返回所有数据  只返回一列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     DB.find('user',&#123;&#125;,&#123;"title":1&#125;,&#123;   返回第二页的数据</span></span><br><span class="line"><span class="comment">        page:2,</span></span><br><span class="line"><span class="comment">        pageSize:20,</span></span><br><span class="line"><span class="comment">        sort:&#123;"add_time":-1&#125;</span></span><br><span class="line"><span class="comment">     &#125;)</span></span><br><span class="line"><span class="comment">     js中实参和形参可以不一样      arguments 对象接收实参传过来的数据</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    find(collectionName,json1,json2,json3)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> attr=&#123;&#125;;</span><br><span class="line">            <span class="keyword">var</span> slipNum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> pageSize=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> attr=json2;</span><br><span class="line">            <span class="keyword">var</span> slipNum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> pageSize=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> attr=json2;</span><br><span class="line">            <span class="keyword">var</span> page=<span class="built_in">parseInt</span>(json3.page) ||<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">var</span> pageSize=<span class="built_in">parseInt</span>(json3.pageSize)||<span class="number">20</span>;</span><br><span class="line">            <span class="keyword">var</span> slipNum=(page<span class="number">-1</span>)*pageSize;</span><br><span class="line">            <span class="keyword">if</span>(json3.sort)&#123;</span><br><span class="line">                <span class="keyword">var</span> sortJson=json3.sort;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> sortJson=&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'传入参数错误'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.connect().then(<span class="function">(<span class="params">db</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//var result=db.collection(collectionName).find(json);</span></span><br><span class="line">                <span class="keyword">var</span> result =db.collection(collectionName).find(json1,&#123;<span class="attr">fields</span>:attr&#125;).skip(slipNum).limit(pageSize).sort(sortJson);</span><br><span class="line">                result.toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolve(docs);</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    update(collectionName,json1,json2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.connect().then(<span class="function">(<span class="params">db</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//db.user.update(&#123;&#125;,&#123;$set:&#123;&#125;&#125;)</span></span><br><span class="line">                db.collection(collectionName).updateOne(json1,&#123;</span><br><span class="line">                    $<span class="keyword">set</span>:json2</span><br><span class="line">                &#125;,(err,result)=&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    insert(collectionName,json)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.connect().then(<span class="function">(<span class="params">db</span>)=&gt;</span>&#123;</span><br><span class="line">                db.collection(collectionName).insertOne(json,<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    remove(collectionName,json)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.connect().then(<span class="function">(<span class="params">db</span>)=&gt;</span>&#123;</span><br><span class="line">                db.collection(collectionName).removeOne(json,<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    getObjectId(id)&#123;  <span class="comment">/*mongodb里面查询 _id 把字符串转换成对象*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjectID(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计数量的方法</span></span><br><span class="line">    count(collectionName,json)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.connect().then(<span class="function">(<span class="params">db</span>)=&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> result = db.collection(collectionName).count(json);</span><br><span class="line">                result.then(<span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">                        resolve(count);</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports=Db.getInstance();</span><br></pre></td></tr></table></figure><p><strong>打开本地调试</strong></p><p><a href="http://localhost:3000/graphql" target="_blank" rel="noopener">http://localhost:3000/graphql</a></p><p><img src="https://s.poetries.work/uploads/2022/06/f906b572a508f1bc.png" alt></p><h1 id="四、Koa中集成GraphQl实现-Server-API"><a href="#四、Koa中集成GraphQl实现-Server-API" class="headerlink" title="四、Koa中集成GraphQl实现 Server API"></a>四、Koa中集成GraphQl实现 Server API</h1><blockquote><p>下载数据库文件解压并导入mongodb即可 <a href="https://blog.poetries.top/db/koa.zip">https://blog.poetries.top/db/koa.zip</a></p></blockquote><ul><li><strong>导入mongodb数据库</strong> <code>mongorestore -h localhost:27017 -d koa-demo(数据库名称，不存在会自动创建) ./dump(本地数据文件路径)</code></li><li>导出mongodb数据库 <code>mongodump -h localhost:27017 -d test(数据库名称) -o ./dump</code></li></ul><blockquote><p>文档地址 <a href="https://github.com/chentsulin/koa-graphql" target="_blank" rel="noopener">https://github.com/chentsulin/koa-graphql</a></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install graphql koa-graphql koa-mount --save</span><br></pre></td></tr></table></figure><blockquote><p>实现导航列表API、文章分类API、文章列表API、文章详情API 、文章列表分页查询API、以及文章列表关联文章分类实现聚合API</p></blockquote><h2 id="4-1-app完善配置"><a href="#4-1-app完善配置" class="headerlink" title="4.1 app完善配置"></a>4.1 app完善配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Koa=<span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mount = <span class="built_in">require</span>(<span class="string">'koa-mount'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> graphqlHTTP = <span class="built_in">require</span>(<span class="string">'koa-graphql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> GraphQLDefaultSchema=<span class="built_in">require</span>(<span class="string">'./schema/default.js'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DB=<span class="built_in">require</span>(<span class="string">'./model/db.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置中间件</span></span><br><span class="line">app.use(mount(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">    schema: GraphQLDefaultSchema,</span><br><span class="line">    graphiql: <span class="literal">true</span></span><br><span class="line">&#125;)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>,<span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    ctx.body=<span class="string">"首页"</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/getNavList'</span>,<span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> navList=<span class="keyword">await</span> DB.find(<span class="string">'nav'</span>,&#123;&#125;);     </span><br><span class="line">     ctx.body=navList;</span><br><span class="line">&#125;)  </span><br><span class="line"></span><br><span class="line">app.use(router.routes());   <span class="comment">/*启动路由*/</span></span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line">app.listen(<span class="number">4000</span>, ()=&gt;<span class="built_in">console</span>.log(<span class="string">'http://localhost:4000'</span>));</span><br></pre></td></tr></table></figure><h2 id="4-2-定义schema模型"><a href="#4-2-定义schema模型" class="headerlink" title="4.2 定义schema模型"></a>4.2 定义schema模型</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// schema/default.js</span></span><br><span class="line"><span class="keyword">const</span> DB=<span class="built_in">require</span>(<span class="string">'../model/db.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//文章分类api接口     //文章列表api接口 （分页）     //文章详情api接口（api聚合 获取分类信息）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    GraphQLObjectType,</span><br><span class="line">    GraphQLString,</span><br><span class="line">    GraphQLInt,</span><br><span class="line">    GraphQLFloat,</span><br><span class="line">    GraphQLList,</span><br><span class="line">    GraphQLSchema,</span><br><span class="line">    GraphQLID</span><br><span class="line">&#125;=<span class="built_in">require</span>(<span class="string">'graphql'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、定义导航的schema</span></span><br><span class="line"><span class="keyword">var</span> NavSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'nav'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        _id:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        title:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;,<span class="attr">url</span>:&#123;</span><br><span class="line"></span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        sort:&#123;</span><br><span class="line">            type:GraphQLInt</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        status:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        add_time:&#123;</span><br><span class="line">            type:GraphQLString</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义文章分类的schema</span></span><br><span class="line"><span class="keyword">var</span> ArticleCateSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'articlecate'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        _id:&#123;<span class="attr">type</span>:GraphQLString&#125;,</span><br><span class="line">        title:&#123;<span class="attr">type</span>:GraphQLString&#125;,</span><br><span class="line">        description:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        keywords:&#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        pid:&#123;<span class="attr">type</span>:GraphQLInt&#125;,</span><br><span class="line">        add_time:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        status:&#123; <span class="attr">type</span>: GraphQLInt &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义文章的schema</span></span><br><span class="line"><span class="keyword">var</span> ArticleSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'article'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        _id:&#123;<span class="attr">type</span>:GraphQLID&#125;,</span><br><span class="line">        pid:&#123;<span class="attr">type</span>:GraphQLID&#125;,    </span><br><span class="line">        title:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        author:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        status:&#123;<span class="attr">type</span>:GraphQLInt&#125;,</span><br><span class="line">        is_best:&#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        is_hot:&#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        is_new:&#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        keywords:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        description:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        content:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        sort:&#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        <span class="comment">// 聚合查询文章分类信息</span></span><br><span class="line">        cateInfo:&#123;</span><br><span class="line">            type:ArticleCateSchema,</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;</span><br><span class="line">                <span class="comment">// parent.pid 当前新闻的分类id</span></span><br><span class="line">                <span class="built_in">console</span>.log(parent);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> cateResult=<span class="keyword">await</span> DB.find(<span class="string">'articlecate'</span>,&#123;<span class="string">"_id"</span>:DB.getObjectId(parent.pid)&#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> cateResult[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//订单商品的Schema  （order_item）</span></span><br><span class="line"><span class="keyword">var</span> OrderItem=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'orderitem'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        uid:&#123; <span class="attr">type</span>: GraphQLID &#125;,</span><br><span class="line">        order_id:  &#123; <span class="attr">type</span>: GraphQLID &#125;,</span><br><span class="line">        product_title: &#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        product_id: &#123; <span class="attr">type</span>: GraphQLID &#125;,    </span><br><span class="line">        product_img: &#123; <span class="attr">type</span>: GraphQLString &#125;,    </span><br><span class="line">        product_price: &#123; <span class="attr">type</span>: GraphQLFloat &#125;,  </span><br><span class="line">        product_num: &#123; <span class="attr">type</span>: GraphQLInt &#125;,        </span><br><span class="line">        add_time: &#123;</span><br><span class="line">          type: GraphQLString        </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//订单的Schema</span></span><br><span class="line"><span class="keyword">var</span> OrderSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'order'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        _id:&#123;<span class="attr">type</span>:GraphQLID&#125;,</span><br><span class="line">        uid: &#123; <span class="attr">type</span>:GraphQLID&#125;,</span><br><span class="line">        all_price: &#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        order_id: &#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        name: &#123; <span class="attr">type</span>: GraphQLString &#125;,  </span><br><span class="line">        phone: &#123; <span class="attr">type</span>: GraphQLString &#125;,    </span><br><span class="line">        address:  &#123; <span class="attr">type</span>: GraphQLString &#125;,    </span><br><span class="line">        zipcode:  &#123; <span class="attr">type</span>: GraphQLString &#125;,    </span><br><span class="line">        pay_status:&#123; <span class="attr">type</span>: GraphQLInt&#125;,   <span class="comment">// 支付状态： 0 表示未支付     1 已经支付</span></span><br><span class="line">        pay_type:&#123;<span class="attr">type</span>: GraphQLString&#125;,      <span class="comment">// 支付类型： alipay    wechat  </span></span><br><span class="line">        order_status: &#123;               <span class="comment">// 订单状态： 0 已下单  1 已付款  2 已配货  3、发货   4、交易成功   5、退货     6、取消      </span></span><br><span class="line">          type: GraphQLInt      </span><br><span class="line">        &#125;,</span><br><span class="line">        add_time: &#123;</span><br><span class="line">          type: GraphQLString          </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 聚合查询订单关联的商品列表信息</span></span><br><span class="line">        orderItems:&#123;</span><br><span class="line">            type:GraphQLList(OrderItem),</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;</span><br><span class="line">                <span class="comment">//获取当前订单对应的商品 parent._id就是objectId</span></span><br><span class="line">                <span class="keyword">var</span> orderItemList=<span class="keyword">await</span> DB.find(<span class="string">'order_item'</span>,&#123;<span class="string">"order_id"</span>:parent._id&#125;);</span><br><span class="line">                <span class="keyword">return</span> orderItemList;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、定义一个根 配置调用Schema的方法</span></span><br><span class="line"><span class="keyword">var</span> RootSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'root'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        navList:&#123;</span><br><span class="line">            type:GraphQLList(NavSchema),</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;</span><br><span class="line">                <span class="keyword">var</span> navList=<span class="keyword">await</span> DB.find(<span class="string">'nav'</span>,&#123;&#125;);     </span><br><span class="line">                <span class="keyword">return</span> navList;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;,</span><br><span class="line">        oneNavList:&#123;</span><br><span class="line">            type:NavSchema,</span><br><span class="line">            args:&#123;</span><br><span class="line">                _id:&#123;</span><br><span class="line">                    type:GraphQLString</span><br><span class="line">                &#125;,</span><br><span class="line">                status:&#123;</span><br><span class="line">                    type:GraphQLString</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> oneNavList=<span class="keyword">await</span> DB.find(<span class="string">'nav'</span>,&#123;<span class="string">"_id"</span>:DB.getObjectId(args._id),<span class="string">"status"</span>:args.status&#125;);     </span><br><span class="line">                <span class="keyword">return</span> oneNavList[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        articleCateList:&#123;</span><br><span class="line">            type:GraphQLList(ArticleCateSchema),</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> articlecateList=<span class="keyword">await</span> DB.find(<span class="string">'articlecate'</span>,&#123;&#125;);     </span><br><span class="line">                <span class="keyword">return</span> articlecateList;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        articleList:&#123;</span><br><span class="line">            type:GraphQLList(ArticleSchema),</span><br><span class="line">            args:&#123;</span><br><span class="line">                page:&#123;</span><br><span class="line">                    type:GraphQLInt</span><br><span class="line">                &#125;,</span><br><span class="line">                pageSize:&#123;</span><br><span class="line">                    type:GraphQLInt</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 分页查询文章列表</span></span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;</span><br><span class="line">                <span class="keyword">var</span> page=args.page||<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">var</span> pageSize=args.pageSize||<span class="number">5</span>;</span><br><span class="line">                <span class="built_in">console</span>.log(page,pageSize);</span><br><span class="line">                <span class="keyword">var</span> articleList=<span class="keyword">await</span> DB.find(<span class="string">'article'</span>,&#123;&#125;,&#123;&#125;,&#123;</span><br><span class="line">                    page,</span><br><span class="line">                    pageSize:pageSize,</span><br><span class="line">                    sort:&#123;<span class="string">"add_time"</span>:<span class="number">-1</span>&#125;</span><br><span class="line">                 &#125;);     </span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> articleList;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 订单列表</span></span><br><span class="line">        orderList:&#123;</span><br><span class="line">            type:GraphQLList(OrderSchema),</span><br><span class="line">            args:&#123;</span><br><span class="line">                page:&#123;</span><br><span class="line">                    type:GraphQLInt</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;</span><br><span class="line">                <span class="keyword">var</span> page=args.page || <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">var</span> orderList=<span class="keyword">await</span> DB.find(<span class="string">'order'</span>,&#123;&#125;,&#123;&#125;,&#123;</span><br><span class="line">                    page,</span><br><span class="line">                    pageSize:<span class="number">3</span>                    </span><br><span class="line">                 &#125;);     </span><br><span class="line">                <span class="keyword">return</span> orderList;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 单个订单信息</span></span><br><span class="line">        oneOrderList:&#123;</span><br><span class="line">            type:OrderSchema,</span><br><span class="line">            args:&#123;</span><br><span class="line">                _id:&#123;</span><br><span class="line">                    type:GraphQLID</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;               </span><br><span class="line">                <span class="keyword">var</span> orderList=<span class="keyword">await</span> DB.find(<span class="string">'order'</span>,&#123;<span class="string">"_id"</span>:DB.getObjectId(args._id)&#125;);     </span><br><span class="line">                <span class="keyword">return</span> orderList[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、把查询的根 挂载到GraphQLSchema</span></span><br><span class="line"><span class="built_in">module</span>.exports=<span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query:RootSchema</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-3-编写数据库操作方法"><a href="#4-3-编写数据库操作方法" class="headerlink" title="4.3 编写数据库操作方法"></a>4.3 编写数据库操作方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// model/db.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * http://mongodb.github.io/node-mongodb-native</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * http://mongodb.github.io/node-mongodb-native/3.0/api/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DB库</span></span><br><span class="line"><span class="keyword">var</span> MongoDB=<span class="built_in">require</span>(<span class="string">'mongodb'</span>);</span><br><span class="line"><span class="keyword">var</span> MongoClient =MongoDB.MongoClient;</span><br><span class="line"><span class="keyword">const</span> ObjectID = MongoDB.ObjectID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Config= &#123;</span><br><span class="line">    url: <span class="string">'mongodb://localhost:27017'</span>,</span><br><span class="line">    dbName: <span class="string">'koa-demo'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Db</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> getInstance()&#123;   <span class="comment">/*1、单例  多次实例化实例不共享的问题*/</span></span><br><span class="line">        <span class="keyword">if</span>(!Db.instance)&#123;</span><br><span class="line">            Db.instance=<span class="keyword">new</span> Db();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  Db.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbClient=<span class="string">''</span>; <span class="comment">/*属性 放db对象*/</span></span><br><span class="line">        <span class="keyword">this</span>.connect();   <span class="comment">/*实例化的时候就连接数据库*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    connect()&#123;  <span class="comment">/*连接数据库*/</span></span><br><span class="line">      <span class="keyword">let</span> _that=<span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(!_that.dbClient)&#123;         <span class="comment">/*1、解决数据库多次连接的问题*/</span></span><br><span class="line">              MongoClient.connect(Config.dbUrl,&#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;,(err,client)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                      reject(err)</span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                      _that.dbClient=client.db(Config.dbName);</span><br><span class="line">                      resolve(_that.dbClient)</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(_that.dbClient);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     DB.find('user',&#123;&#125;)  返回所有数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     DB.find('user',&#123;&#125;,&#123;"title":1&#125;)    返回所有数据  只返回一列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     DB.find('user',&#123;&#125;,&#123;"title":1&#125;,&#123;   返回第二页的数据</span></span><br><span class="line"><span class="comment">        page:2,</span></span><br><span class="line"><span class="comment">        pageSize:20,</span></span><br><span class="line"><span class="comment">        sort:&#123;"add_time":-1&#125;</span></span><br><span class="line"><span class="comment">     &#125;)</span></span><br><span class="line"><span class="comment">     js中实参和形参可以不一样      arguments 对象接收实参传过来的数据</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    find(collectionName,json1,json2,json3)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> attr=&#123;&#125;;</span><br><span class="line">            <span class="keyword">var</span> slipNum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> pageSize=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> attr=json2;</span><br><span class="line">            <span class="keyword">var</span> slipNum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> pageSize=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> attr=json2;</span><br><span class="line">            <span class="keyword">var</span> page=<span class="built_in">parseInt</span>(json3.page) ||<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">var</span> pageSize=<span class="built_in">parseInt</span>(json3.pageSize)||<span class="number">20</span>;</span><br><span class="line">            <span class="keyword">var</span> slipNum=(page<span class="number">-1</span>)*pageSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(json3.sort)&#123;</span><br><span class="line">                <span class="keyword">var</span> sortJson=json3.sort;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> sortJson=&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'传入参数错误'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.connect().then(<span class="function">(<span class="params">db</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//var result=db.collection(collectionName).find(json);</span></span><br><span class="line">                <span class="keyword">var</span> result =db.collection(collectionName).find(json1,&#123;<span class="attr">fields</span>:attr&#125;).skip(slipNum).limit(pageSize).sort(sortJson);</span><br><span class="line">                result.toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolve(docs);</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    update(collectionName,json1,json2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.connect().then(<span class="function">(<span class="params">db</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//db.user.update(&#123;&#125;,&#123;$set:&#123;&#125;&#125;)</span></span><br><span class="line">                    db.collection(collectionName).updateOne(json1,&#123;</span><br><span class="line">                        $<span class="keyword">set</span>:json2</span><br><span class="line">                    &#125;,(err,result)=&gt;&#123;</span><br><span class="line">                        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                            reject(err);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            resolve(result);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    insert(collectionName,json)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.connect().then(<span class="function">(<span class="params">db</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">                db.collection(collectionName).insertOne(json,<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove(collectionName,json)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.connect().then(<span class="function">(<span class="params">db</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">                db.collection(collectionName).removeOne(json,<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    getObjectId(id)&#123;    <span class="comment">/*mongodb里面查询 _id 把字符串转换成对象*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjectID(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计数量的方法</span></span><br><span class="line">    count(collectionName,json)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.connect().then(<span class="function">(<span class="params">db</span>)=&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> result = db.collection(collectionName).count(json);</span><br><span class="line">                result.then(<span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                        resolve(count);</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports=Db.getInstance();</span><br></pre></td></tr></table></figure><p><strong>启动服务</strong></p><p><img src="https://s.poetries.work/uploads/2022/07/1550d35a92e40d2e.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/07/7c07e1cc36336aa9.png" alt></p><h2 id="4-4-聚合查询"><a href="#4-4-聚合查询" class="headerlink" title="4.4 聚合查询"></a>4.4 聚合查询</h2><p><strong>聚合查询文章分类信息，分类信息的方式要放在article的schema里面，这样才能聚合查询到</strong></p><p><img src="https://s.poetries.work/uploads/2022/07/3312490f4089a734.png" alt></p><p>聚合查询结果</p><p><img src="https://s.poetries.work/uploads/2022/07/ef305f6e77e96b5f.png" alt></p><p><strong>查询订单，聚合查询订单关联的商品信息返回，实现类似以下效果</strong></p><p><img src="https://s.poetries.work/uploads/2022/07/d4573ffa0133b43f.png" alt></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// schema/default.js </span></span><br><span class="line"><span class="comment">//订单商品的Schema  （order_item）</span></span><br><span class="line"><span class="keyword">var</span> OrderItem=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'orderitem'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        uid:&#123; <span class="attr">type</span>: GraphQLID &#125;,</span><br><span class="line">        order_id:  &#123; <span class="attr">type</span>: GraphQLID &#125;,</span><br><span class="line">        product_title: &#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        product_id: &#123; <span class="attr">type</span>: GraphQLID &#125;,    </span><br><span class="line">        product_img: &#123; <span class="attr">type</span>: GraphQLString &#125;,    </span><br><span class="line">        product_price: &#123; <span class="attr">type</span>: GraphQLFloat &#125;,  </span><br><span class="line">        product_num: &#123; <span class="attr">type</span>: GraphQLInt &#125;,        </span><br><span class="line">        add_time: &#123;</span><br><span class="line">          type: GraphQLString        </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//订单的Schema</span></span><br><span class="line"><span class="keyword">var</span> OrderSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'order'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        _id:&#123;<span class="attr">type</span>:GraphQLID&#125;,</span><br><span class="line">        uid: &#123; <span class="attr">type</span>:GraphQLID&#125;,</span><br><span class="line">        all_price: &#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        order_id: &#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        name: &#123; <span class="attr">type</span>: GraphQLString &#125;,  </span><br><span class="line">        phone: &#123; <span class="attr">type</span>: GraphQLString &#125;,    </span><br><span class="line">        address:  &#123; <span class="attr">type</span>: GraphQLString &#125;,    </span><br><span class="line">        zipcode:  &#123; <span class="attr">type</span>: GraphQLString &#125;,    </span><br><span class="line">        pay_status:&#123; <span class="attr">type</span>: GraphQLInt&#125;,   <span class="comment">// 支付状态： 0 表示未支付     1 已经支付</span></span><br><span class="line">        pay_type:&#123;<span class="attr">type</span>: GraphQLString&#125;,      <span class="comment">// 支付类型： alipay    wechat  </span></span><br><span class="line">        order_status: &#123;               <span class="comment">// 订单状态： 0 已下单  1 已付款  2 已配货  3、发货   4、交易成功   5、退货     6、取消      </span></span><br><span class="line">          type: GraphQLInt      </span><br><span class="line">        &#125;,</span><br><span class="line">        add_time: &#123;</span><br><span class="line">          type: GraphQLString          </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 聚合查询订单关联的商品列表信息</span></span><br><span class="line">        orderItems:&#123;</span><br><span class="line">            type:GraphQLList(OrderItem),</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;</span><br><span class="line">                <span class="comment">//获取当前订单对应的商品 parent._id就是objectId</span></span><br><span class="line">                <span class="keyword">var</span> orderItemList=<span class="keyword">await</span> DB.find(<span class="string">'order_item'</span>,&#123;<span class="string">"order_id"</span>:parent._id&#125;);</span><br><span class="line">                <span class="keyword">return</span> orderItemList;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个根 配置调用Schema的方法</span></span><br><span class="line"><span class="keyword">var</span> RootSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'root'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        orderList:&#123;</span><br><span class="line">            type:GraphQLList(OrderSchema),</span><br><span class="line">            args:&#123;</span><br><span class="line">                page:&#123;</span><br><span class="line">                    type:GraphQLInt</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;</span><br><span class="line">                <span class="keyword">var</span> page=args.page || <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">var</span> orderList=<span class="keyword">await</span> DB.find(<span class="string">'order'</span>,&#123;&#125;,&#123;&#125;,&#123;</span><br><span class="line">                    page,</span><br><span class="line">                    pageSize:<span class="number">3</span>                    </span><br><span class="line">                 &#125;);     </span><br><span class="line">                <span class="keyword">return</span> orderList;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        oneOrderList:&#123;</span><br><span class="line">            type:OrderSchema,</span><br><span class="line">            args:&#123;</span><br><span class="line">                _id:&#123;</span><br><span class="line">                    type:GraphQLID</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;               </span><br><span class="line">                <span class="keyword">var</span> orderList=<span class="keyword">await</span> DB.find(<span class="string">'order'</span>,&#123;<span class="string">"_id"</span>:DB.getObjectId(args._id)&#125;);     </span><br><span class="line">                <span class="keyword">return</span> orderList[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/07/7d04081f284a53c4.png" alt></p><p>查询订单详情</p><p><img src="https://s.poetries.work/uploads/2022/07/eb55ac8b7201d6e9.png" alt></p><p>需要哪些字段，就返回哪些字段，编辑器会自定提示</p><p><img src="https://s.poetries.work/uploads/2022/07/f43be591155843e5.png" alt></p><h2 id="4-5-分页查询"><a href="#4-5-分页查询" class="headerlink" title="4.5 分页查询"></a>4.5 分页查询</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义文章分类的schema</span></span><br><span class="line"><span class="keyword">var</span> ArticleCateSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'articlecate'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        _id:&#123;<span class="attr">type</span>:GraphQLString&#125;,</span><br><span class="line">        title:&#123;<span class="attr">type</span>:GraphQLString&#125;,</span><br><span class="line">        description:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        keywords:&#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        pid:&#123;<span class="attr">type</span>:GraphQLInt&#125;,</span><br><span class="line">        add_time:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        status:&#123; <span class="attr">type</span>: GraphQLInt &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义文章的schema</span></span><br><span class="line"><span class="keyword">var</span> ArticleSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'article'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        _id:&#123;<span class="attr">type</span>:GraphQLID&#125;,</span><br><span class="line">        pid:&#123;<span class="attr">type</span>:GraphQLID&#125;,    </span><br><span class="line">        title:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        author:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        status:&#123;<span class="attr">type</span>:GraphQLInt&#125;,</span><br><span class="line">        is_best:&#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        is_hot:&#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        is_new:&#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        keywords:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        description:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        content:&#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">        sort:&#123; <span class="attr">type</span>: GraphQLInt &#125;,</span><br><span class="line">        <span class="comment">// 聚合查询文章分类信息</span></span><br><span class="line">        cateInfo:&#123;</span><br><span class="line">            type:ArticleCateSchema,</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;</span><br><span class="line">                <span class="comment">// parent.pid 当前新闻的分类id</span></span><br><span class="line">                <span class="built_in">console</span>.log(parent);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> cateResult=<span class="keyword">await</span> DB.find(<span class="string">'articlecate'</span>,&#123;<span class="string">"_id"</span>:DB.getObjectId(parent.pid)&#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> cateResult[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、定义一个根 配置调用Schema的方法</span></span><br><span class="line"><span class="keyword">var</span> RootSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">'root'</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        articleCateList:&#123;</span><br><span class="line">            type:GraphQLList(ArticleCateSchema),</span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> articlecateList=<span class="keyword">await</span> DB.find(<span class="string">'articlecate'</span>,&#123;&#125;);     </span><br><span class="line">                <span class="keyword">return</span> articlecateList;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        articleList:&#123;</span><br><span class="line">            type:GraphQLList(ArticleSchema),</span><br><span class="line">            args:&#123;</span><br><span class="line">                page:&#123;</span><br><span class="line">                    type:GraphQLInt</span><br><span class="line">                &#125;,</span><br><span class="line">                pageSize:&#123;</span><br><span class="line">                    type:GraphQLInt</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 分页查询文章列表</span></span><br><span class="line">            <span class="keyword">async</span> resolve(parent,args)&#123;</span><br><span class="line">                <span class="keyword">var</span> page=args.page||<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">var</span> pageSize=args.pageSize||<span class="number">5</span>;</span><br><span class="line">                <span class="built_in">console</span>.log(page,pageSize);</span><br><span class="line">                <span class="keyword">var</span> articleList=<span class="keyword">await</span> DB.find(<span class="string">'article'</span>,&#123;&#125;,&#123;&#125;,&#123;</span><br><span class="line">                    page,</span><br><span class="line">                    pageSize:pageSize,</span><br><span class="line">                    sort:&#123;<span class="string">"add_time"</span>:<span class="number">-1</span>&#125;</span><br><span class="line">                 &#125;);     </span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> articleList;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-6-实现数据增加、修改、删除"><a href="#4-6-实现数据增加、修改、删除" class="headerlink" title="4.6 实现数据增加、修改、删除"></a>4.6 实现数据增加、修改、删除</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scehma/default.js </span></span><br><span class="line"><span class="comment">//增加 修改 删除</span></span><br><span class="line"><span class="comment">// 定义根MutationRoot实现增删改</span></span><br><span class="line"><span class="keyword">var</span> MutationSchema=<span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name:<span class="string">"mutation"</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        addNav:&#123;</span><br><span class="line">            type:NavSchema,</span><br><span class="line">            args:&#123;</span><br><span class="line">                title: &#123;<span class="attr">type</span>: <span class="keyword">new</span> GraphQLNonNull(GraphQLString)&#125;,     <span class="comment">//表示title 和 url是必传字段</span></span><br><span class="line">                url: &#123;<span class="attr">type</span>: GraphQLNonNull(GraphQLString)&#125;,</span><br><span class="line">                sort: &#123;<span class="attr">type</span>: GraphQLInt&#125;,</span><br><span class="line">                status: &#123;<span class="attr">type</span>: GraphQLString&#125;,</span><br><span class="line">                add_time: &#123;<span class="attr">type</span>: GraphQLString&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> resolve(parent, args) &#123;</span><br><span class="line">                <span class="keyword">var</span> result = <span class="keyword">await</span> DB.insert(<span class="string">'nav'</span>, &#123;<span class="attr">title</span>:args.title,</span><br><span class="line">                    url:args.url,</span><br><span class="line">                    sort:args.sort,</span><br><span class="line">                    status:args.status,</span><br><span class="line">                    add_time:<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">console</span>.log(result.ops[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result.ops[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        editNav:&#123;</span><br><span class="line">            type:NavSchema,</span><br><span class="line">            args:&#123;</span><br><span class="line">                _id:&#123;<span class="attr">type</span>: <span class="keyword">new</span> GraphQLNonNull(GraphQLString)&#125;,</span><br><span class="line">                title: &#123;<span class="attr">type</span>: <span class="keyword">new</span> GraphQLNonNull(GraphQLString)&#125;,     <span class="comment">//表示title 和 url是必传字段</span></span><br><span class="line">                url: &#123;<span class="attr">type</span>: GraphQLNonNull(GraphQLString)&#125;,</span><br><span class="line">                sort: &#123;<span class="attr">type</span>: GraphQLInt&#125;,</span><br><span class="line">                status: &#123;<span class="attr">type</span>: GraphQLString&#125;,</span><br><span class="line">                add_time: &#123;<span class="attr">type</span>: GraphQLString&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> resolve(parent, args) &#123;</span><br><span class="line">                <span class="keyword">var</span> result = <span class="keyword">await</span> DB.update(<span class="string">'nav'</span>, &#123;<span class="string">"_id"</span>:DB.getObjectId(args._id)&#125;,&#123;<span class="attr">title</span>:args.title,</span><br><span class="line">                    url:args.url,</span><br><span class="line">                    sort:args.sort,</span><br><span class="line">                    status:args.status,</span><br><span class="line">                    add_time:<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// console.log(result);</span></span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    _id:args._id,</span><br><span class="line">                    title:args.title,</span><br><span class="line">                    url:args.url,</span><br><span class="line">                    sort:args.sort,</span><br><span class="line">                    status:args.status,</span><br><span class="line">                    add_time:<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;    </span><br><span class="line">        ,</span><br><span class="line">        deleteNav:&#123;</span><br><span class="line">            type:NavSchema,</span><br><span class="line">            args:&#123;</span><br><span class="line">                _id:&#123;<span class="attr">type</span>: <span class="keyword">new</span> GraphQLNonNull(GraphQLString)&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">async</span> resolve(parent, args) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> oneNavList = <span class="keyword">await</span> DB.find(<span class="string">'nav'</span>, &#123; <span class="string">"_id"</span>: DB.getObjectId(args._id)&#125;);</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">var</span> deleteResult = <span class="keyword">await</span> DB.remove(<span class="string">'nav'</span>, &#123;<span class="string">"_id"</span>:DB.getObjectId(args._id)&#125;);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">console</span>.log(deleteResult.result.n);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(deleteResult.result.n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> oneNavList[<span class="number">0</span>];  </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载到GraphQLSchema</span></span><br><span class="line"><span class="built_in">module</span>.exports=<span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    <span class="comment">// query:RootSchema,</span></span><br><span class="line">    mutation:MutationSchema</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>新增</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/52aab4cf8421000b.png" alt></p><p>可以看到必填字段不填会提示</p><p><img src="https://s.poetries.work/uploads/2022/07/9d5c6adb31018789.png" alt></p><p>再次查询列表</p><p><img src="https://s.poetries.work/uploads/2022/07/a91926ec7799fd92.png" alt></p><ul><li>修改</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/afd87b6526705d2b.png" alt></p><ul><li>删除</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/db769eb8c3a823aa.png" alt></p><h1 id="五、Vue中使用GraphQl"><a href="#五、Vue中使用GraphQl" class="headerlink" title="五、Vue中使用GraphQl"></a>五、Vue中使用GraphQl</h1><h2 id="5-1-使用graphQl简单查询"><a href="#5-1-使用graphQl简单查询" class="headerlink" title="5.1 使用graphQl简单查询"></a>5.1 使用graphQl简单查询</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>找到Vue中集成GraphQl的文档</li></ol><ul><li><a href="https://github.com/vuejs/apollo" target="_blank" rel="noopener">https://github.com/vuejs/apollo</a></li><li><a href="https://vue-apollo.netlify.app/" target="_blank" rel="noopener">https://vue-apollo.netlify.app/</a></li></ul><ol start="2"><li>安装相应的模块</li></ol><blockquote><p>ApolloBoost是一种零配置开始使用ApolloClient的方式。它包含一些实用的默认值，例如我们推荐的InMemoryCache和HttpLink，它非常适合用于快速启动开发。将它与vue-apollo和graphql一起安装：</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue-apollo graphql apollo-boost --save</span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>src/main.js</code>中引入<code>apollo-boost</code>模块并实例化<code>ApolloClient</code></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ApolloClient <span class="keyword">from</span><span class="string">'apollo-boost'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apolloClient = newApolloClient(&#123;</span><br><span class="line">    <span class="comment">//你需要在这里使用绝对路径</span></span><br><span class="line">    uri:<span class="string">'http://118.123.14.36:3002/graphql'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以打开 <a href="http://118.123.14.36:3002/graphql" target="_blank" rel="noopener">http://118.123.14.36:3002/graphql</a> 在控制台查看查询结果</p><p><img src="https://s.poetries.work/uploads/2022/07/580837041d7098cc.png" alt></p><ol start="4"><li>在<code>src/main.js</code>配置<code>vue-apollo</code>插件</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueApollofrom<span class="string">'vue-apollo'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueApollo);</span><br></pre></td></tr></table></figure><ol start="5"><li>创建<code>Apollo provider</code></li></ol><blockquote><p>Provider保存了可以在接下来被所有子组件使用的Apollo客户端实例</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> apolloProvider = newVueApollo(&#123;</span><br><span class="line">    defaultClient:apolloClient</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用<code>apollo Provider</code>选项将它添加到你的应用程序</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    apolloProvider,</span><br><span class="line">    render:<span class="function"><span class="params">h</span>=&gt;</span>h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><blockquote><p>组件加载的时候就会去服务器请求数据，请求的数据会放在<code>navList</code>这个属性上面，在模板中可以直接使用当前属性</p></blockquote><blockquote><p><a href="https://vue-apollo.netlify.app/zh-cn/guide/apollo/queries.html#%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2" target="_blank" rel="noopener">简单查询文档</a></p></blockquote><p><a href="https://vue-apollo.netlify.app/zh-cn/guide/apollo/queries.html#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%9F%A5%E8%AF%A2" target="_blank" rel="noopener">带参数查询参考 </a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gql <span class="keyword">from</span><span class="string">'graphql-tag'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123; </span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">msg</span>: <span class="string">'我是一个 home 组件'</span> &#125; </span><br><span class="line">    &#125;,</span><br><span class="line">    apollo: &#123;</span><br><span class="line">        <span class="comment">// 简单的查询，将更新 'hello' 这个 vue 属性 </span></span><br><span class="line">        navList: gql<span class="string">`query &#123; </span></span><br><span class="line"><span class="string">            navList &#123; </span></span><br><span class="line"><span class="string">                title</span></span><br><span class="line"><span class="string">            &#125; </span></span><br><span class="line"><span class="string">        &#125;`</span> </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种写法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gql <span class="keyword">from</span> <span class="string">'graphql-tag'</span>; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123; </span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">            msg:<span class="string">'我是一个 home 组件'</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Apollo 具体选项</span></span><br><span class="line">    apollo: &#123;</span><br><span class="line">        <span class="comment">// // 带参数的查询</span></span><br><span class="line">        <span class="comment">// ping: &#123;</span></span><br><span class="line">        <span class="comment">//     // gql 查询</span></span><br><span class="line">        <span class="comment">//     query: gql`query PingMessage($message: String!) &#123;</span></span><br><span class="line">        <span class="comment">//     ping(message: $message)</span></span><br><span class="line">        <span class="comment">//     &#125;`,</span></span><br><span class="line">        <span class="comment">//     // 静态参数</span></span><br><span class="line">        <span class="comment">//     variables: &#123;</span></span><br><span class="line">        <span class="comment">//     message: 'Meow',</span></span><br><span class="line">        <span class="comment">//     &#125;,</span></span><br><span class="line">        <span class="comment">// &#125;,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    apollo: &#123; </span><br><span class="line">        <span class="comment">// 注意方法名称 和 查询的名称对应 </span></span><br><span class="line">        navList()&#123; </span><br><span class="line">            <span class="keyword">return</span> &#123; </span><br><span class="line">                query:gql<span class="string">`query &#123; </span></span><br><span class="line"><span class="string">                    navList &#123; </span></span><br><span class="line"><span class="string">                        title</span></span><br><span class="line"><span class="string">                     &#125; </span></span><br><span class="line"><span class="string">                &#125;`</span> </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整例子</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) of navList"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">          &#123;&#123;item.title&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of articleList"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">          &#123;&#123;item.title&#125;&#125;---&#123;&#123;item.status&#125;&#125;--&#123;&#123;item._id&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> gql <span class="keyword">from</span> <span class="string">'graphql-tag'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">'app'</span>,</span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        msg:<span class="string">'我是一个首页页面'</span></span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    apollo: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 简单的查询，将更新 'hello' 这个 vue 属性</span></span></span><br><span class="line">      navList: gql`&#123;</span><br><span class="line">         navList&#123;</span><br><span class="line">            title</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;`,</span><br><span class="line">      articleList:gql`&#123;</span><br><span class="line">         articleList&#123;</span><br><span class="line">            title,</span><br><span class="line">            status,</span><br><span class="line">            _id</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;`</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><blockquote><p><a href="https://vue-apollo.netlify.app/zh-cn/api/smart-query.html" target="_blank" rel="noopener">高级查询文档</a></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,key) of articleList"</span> <span class="attr">v-bind:key</span>=<span class="string">"key"</span>&gt;</span></span><br><span class="line">        &#123;&#123;item.title&#125;&#125;---&#123;&#123;item.status&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span>      </span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getData()"</span>&gt;</span></span><br><span class="line">    点击按钮触发事件请求graphQl接口</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;&#123;navList&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>逻辑</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gql <span class="keyword">from</span> <span class="string">'graphql-tag'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> navListGql=gql<span class="string">`&#123;</span></span><br><span class="line"><span class="string">        navList&#123;</span></span><br><span class="line"><span class="string">            title           </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">   &#125;`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'app'</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">      <span class="keyword">return</span>&#123;</span><br><span class="line">        msg:<span class="string">'我是一个新闻页面'</span>,</span><br><span class="line">        navList:[]</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    apollo:&#123;</span><br><span class="line">      <span class="comment">// articleList:gql`&#123;</span></span><br><span class="line">      <span class="comment">//        articleList&#123;</span></span><br><span class="line">      <span class="comment">//         title,</span></span><br><span class="line">      <span class="comment">//         status</span></span><br><span class="line">      <span class="comment">//       &#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// &#125;`</span></span><br><span class="line">        <span class="comment">// 把请求的数据赋值给articleList</span></span><br><span class="line">        articleList:&#123;</span><br><span class="line">          query:gql<span class="string">`query articleList($page:Int!,$pageSize:Int!)&#123;</span></span><br><span class="line"><span class="string">                articleList(page:$page,pageSize:$pageSize)&#123;</span></span><br><span class="line"><span class="string">                  title,</span></span><br><span class="line"><span class="string">                  status</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">          &#125;`</span>,</span><br><span class="line">          variables:&#123;</span><br><span class="line">            page:<span class="number">2</span>,</span><br><span class="line">            pageSize:<span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      getData()&#123;</span><br><span class="line">        <span class="keyword">this</span>.$apollo.addSmartQuery(<span class="string">'navList'</span>,&#123;          </span><br><span class="line">            query:navListGql,</span><br><span class="line">            result(response)&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(response);</span><br><span class="line">            &#125;,error(err)&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-GraphQl-传参查询"><a href="#Vue-GraphQl-传参查询" class="headerlink" title="Vue GraphQl 传参查询"></a>Vue GraphQl 传参查询</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getData()"</span>&gt;</span>获取文章数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,key) of articleList"</span> <span class="attr">v-bind:key</span>=<span class="string">"key"</span>&gt;</span></span><br><span class="line">          &#123;&#123;item.title&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> gql <span class="keyword">from</span> <span class="string">'graphql-tag'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> articleListGql=gql<span class="string">`query articleList($page:Int!,$pageSize:Int!)&#123;</span></span></span><br><span class="line">       articleList(page:$page,pageSize:$pageSize)&#123;</span><br><span class="line">        title       </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;`;</span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">'app'</span>,</span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">        msg:<span class="string">'article页面'</span>,</span></span><br><span class="line">        articleList:[]</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      getData()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$apollo.addSmartQuery(<span class="string">'articleList'</span>,&#123;</span></span><br><span class="line">          query:articleListGql,</span><br><span class="line">          variables:&#123;</span><br><span class="line">            page:2,</span><br><span class="line">            pageSize:8</span><br><span class="line">          &#125;,</span><br><span class="line">          result(response)&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(response)</span></span><br><span class="line">          &#125;,error(err)&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(err)</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-2-使用graphQl增加修改删除"><a href="#5-2-使用graphQl增加修改删除" class="headerlink" title="5.2 使用graphQl增加修改删除"></a>5.2 使用graphQl增加修改删除</h2><blockquote><p><a href="https://vue-apollo.netlify.app/zh-cn/guide/apollo/mutations.html#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A4%BA%E4%BE%8B" target="_blank" rel="noopener">详情文档参考</a></p></blockquote><p>服务器端接口</p><p><img src="https://s.poetries.work/uploads/2022/07/5a2e957da5d677af.png" alt></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>导航的增加修改删除<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navForm"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        导航名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"navJson.title"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        导航链接： <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"navJson.url"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"doAdd()"</span>&gt;</span>提交数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"doEdit()"</span>&gt;</span>修改数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"doDele()"</span>&gt;</span>删除数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> gql <span class="keyword">from</span> <span class="string">'graphql-tag'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> navMutationAddGql=gql<span class="string">`mutation($title:String!,$url:String!)&#123;</span></span></span><br><span class="line">    addNav(title:$title,url:$url)&#123;</span><br><span class="line">      title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;`;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> navMutationEditGql=gql<span class="string">`mutation($id:String!,$title:String!,$url:String!)&#123;</span></span></span><br><span class="line">    editNav(_id:$id,title:$title,url:$url)&#123;</span><br><span class="line">      title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;`;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> navMutationDelGql=gql<span class="string">`mutation($id:String!)&#123;</span></span></span><br><span class="line">    deleteNav(_id:$id)&#123;</span><br><span class="line">      title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;`;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">'app'</span>,</span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span>&#123;</span></span><br><span class="line">        navJson:&#123;</span><br><span class="line"><span class="javascript">          title:<span class="string">""</span>,</span></span><br><span class="line"><span class="javascript">          url:<span class="string">""</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 提交表单</span></span></span><br><span class="line">      doAdd()&#123;</span><br><span class="line"><span class="javascript">          <span class="comment">// eslint-disable-next-line no-console</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.navJson.title);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$apollo.mutate(&#123;</span></span><br><span class="line">            mutation:navMutationAddGql,</span><br><span class="line">            variables: &#123;</span><br><span class="line"><span class="javascript">            title: <span class="keyword">this</span>.navJson.title,</span></span><br><span class="line"><span class="javascript">            url:<span class="keyword">this</span>.navJson.url,</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">        &#125;).then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">        &#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(err);</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="comment">// 修改数据</span></span></span><br><span class="line">      doEdit()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$apollo.mutate(&#123;</span></span><br><span class="line">          mutation:navMutationEditGql,</span><br><span class="line">          variables: &#123;</span><br><span class="line"><span class="javascript">            id:<span class="string">"62beaf16323cb708d06580ce"</span>,</span></span><br><span class="line"><span class="javascript">            title: <span class="keyword">this</span>.navJson.title,</span></span><br><span class="line"><span class="javascript">            url:<span class="keyword">this</span>.navJson.url,</span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="javascript">        &#125;).then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">        &#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(err);</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      doDele()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$apollo.mutate(&#123;</span></span><br><span class="line">          mutation:navMutationDelGql,</span><br><span class="line">          variables: &#123;</span><br><span class="line"><span class="javascript">            id:<span class="string">"62beaf50323cb708d06580d0"</span>,</span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="javascript">        &#125;).then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">        &#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(err);</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/07/a68e014f0e3fee3c.png" alt></p><p>可以看到新增成功效果</p><p><img src="https://s.poetries.work/uploads/2022/07/990bcf87b1a4293f.png" alt></p><h2 id="5-3-上拉分页加载更多"><a href="#5-3-上拉分页加载更多" class="headerlink" title="5.3 上拉分页加载更多"></a>5.3 上拉分页加载更多</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i vue-infinite-scroll -S</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js配置 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置上拉分页加载更多</span></span><br><span class="line"><span class="keyword">var</span> infiniteScroll =  <span class="built_in">require</span>(<span class="string">'vue-infinite-scroll'</span>);</span><br><span class="line">Vue.use(infiniteScroll);</span><br></pre></td></tr></table></figure><h3 id="方法1：数据拼接"><a href="#方法1：数据拼接" class="headerlink" title="方法1：数据拼接"></a>方法1：数据拼接</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-infinite-scroll</span>=<span class="string">"loadMore"</span> <span class="attr">infinite-scroll-disabled</span>=<span class="string">"busy"</span> <span class="attr">infinite-scroll-distance</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,key) of articleListData"</span> <span class="attr">v-bind:key</span>=<span class="string">"key"</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> gql <span class="keyword">from</span> <span class="string">"graphql-tag"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> articleListGql = gql<span class="string">`</span></span></span><br><span class="line">  query articleList($page: Int!, $pageSize: Int!) &#123;</span><br><span class="line">    articleList(page: $page, pageSize: $pageSize) &#123;</span><br><span class="line">      title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">"app"</span>,</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      msg: <span class="string">"上拉分页加载更多"</span>,</span></span><br><span class="line">      articleList: [],</span><br><span class="line"><span class="javascript">      articleListData: [] <span class="comment">/*实际要循环的数据*/</span>,</span></span><br><span class="line"></span><br><span class="line">      page: 1,</span><br><span class="line"><span class="javascript">      busy: <span class="literal">false</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    loadMore() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$apollo.addSmartQuery(<span class="string">"articleList"</span>, &#123;</span></span><br><span class="line">        query: articleListGql,</span><br><span class="line"></span><br><span class="line">        variables: &#123;</span><br><span class="line"><span class="javascript">          page: <span class="keyword">this</span>.page,</span></span><br><span class="line">          pageSize: 8</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        result(response) &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(response);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.articleListData = <span class="keyword">this</span>.articleListData.concat(</span></span><br><span class="line">            response.data.articleList</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.page++;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (response.data.articleList &lt; <span class="number">8</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.busy = <span class="literal">true</span>; <span class="comment">//没有数据禁用上拉分页加载更多</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error(err) &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(err);</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">  li &#123;</span><br><span class="line">    line-height: 4;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方法2：使用-fetchMore-实现分页（推荐）"><a href="#方法2：使用-fetchMore-实现分页（推荐）" class="headerlink" title="方法2：使用 fetchMore 实现分页（推荐）"></a>方法2：使用 fetchMore 实现分页（推荐）</h3><blockquote><p><a href="https://vue-apollo.netlify.app/zh-cn/guide/apollo/pagination.html" target="_blank" rel="noopener">https://vue-apollo.netlify.app/zh-cn/guide/apollo/pagination.html</a></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-infinite-scroll</span>=<span class="string">"loadMore"</span> <span class="attr">infinite-scroll-disabled</span>=<span class="string">"busy"</span> <span class="attr">infinite-scroll-distance</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,key) of articleList"</span> <span class="attr">v-bind:key</span>=<span class="string">"key"</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> gql <span class="keyword">from</span> <span class="string">"graphql-tag"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> articleListGql = gql<span class="string">`</span></span></span><br><span class="line">  query articleList($page: Int!, $pageSize: Int!) &#123;</span><br><span class="line">    articleList(page: $page, pageSize: $pageSize) &#123;</span><br><span class="line">      title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">"app"</span>,</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      msg: <span class="string">"上拉分页加载更多"</span>,</span></span><br><span class="line">      articleList: [],</span><br><span class="line">      page: 1,</span><br><span class="line"><span class="javascript">      busy: <span class="literal">false</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  apollo: &#123;</span><br><span class="line">    articleList() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// GraphQL 查询</span></span></span><br><span class="line">        query: articleListGql,</span><br><span class="line"><span class="javascript">        <span class="comment">// 初始变量</span></span></span><br><span class="line">        variables: &#123;</span><br><span class="line"><span class="javascript">          page: <span class="keyword">this</span>.page,</span></span><br><span class="line">          pageSize: 5</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    loadMore() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.page++;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$apollo.queries.articleList.fetchMore(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 新的变量</span></span></span><br><span class="line">        variables: &#123;</span><br><span class="line"><span class="javascript">          page: <span class="keyword">this</span>.page,</span></span><br><span class="line">          pageSize: 5</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">// 用新数据转换之前的结果</span></span></span><br><span class="line"><span class="javascript">        updateQuery: <span class="function">(<span class="params">previousResult, &#123; fetchMoreResult &#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// eslint-disable-next-line no-console</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(fetchMoreResult);</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line">            articleList: [</span><br><span class="line">              ...previousResult.articleList,</span><br><span class="line">              ...fetchMoreResult.articleList</span><br><span class="line">            ]</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">li &#123;</span><br><span class="line">  line-height: 4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分页效果 </p><p><img src="https://s.poetries.work/uploads/2022/07/a1ddb2379d5c7287.png" alt></p><blockquote><p>项目例子完整代码下载地址 <a href="https://blog.poetries.top/assets/graphql-code.zip">https://blog.poetries.top/assets/graphql-code.zip</a></p></blockquote><h1 id="六、文档"><a href="#六、文档" class="headerlink" title="六、文档"></a>六、文档</h1><ul><li>中文文档：<a href="http://graphql.cn" target="_blank" rel="noopener">http://graphql.cn</a></li><li>Github: <a href="https://github.com/facebook/graphql" target="_blank" rel="noopener">https://github.com/facebook/graphql</a></li><li>vue-apollo文档：<a href="https://vue-apollo.netlify.app/zh-cn/guide/apollo.html" target="_blank" rel="noopener">https://vue-apollo.netlify.app/zh-cn/guide/apollo.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、GraphQL介绍&quot;&gt;&lt;a href=&quot;#一、GraphQL介绍&quot; class=&quot;headerlink&quot; title=&quot;一、GraphQL介绍&quot;&gt;&lt;/a&gt;一、GraphQL介绍&lt;/h1&gt;&lt;h2 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; cla
      
    
    </summary>
    
      <category term="Back-end" scheme="http://blog.poetries.top/categories/Back-end/"/>
    
    
      <category term="Node" scheme="http://blog.poetries.top/tags/Node/"/>
    
      <category term="GraphQL" scheme="http://blog.poetries.top/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux与Docker系统运维总结</title>
    <link href="http://blog.poetries.top/2022/06/30/linux-summary/"/>
    <id>http://blog.poetries.top/2022/06/30/linux-summary/</id>
    <published>2022-06-30T07:32:41.000Z</published>
    <updated>2025-03-30T13:54:29.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux简单介绍"><a href="#Linux简单介绍" class="headerlink" title="Linux简单介绍"></a>Linux简单介绍</h2><ul><li>Linux 是一套开源操作系统，它有稳定、消耗资源小、功能很强、安全性高等特点，让它在 服务器领域有庞大的用户群体</li><li>目前市面上较知名的发行版有：RedHat、Ubuntu、CentOS、Debian、Fedora、SuSE、OpenSUSE、 Arch Linux、SolusOS 等</li><li>常见的服务器操作系统主要有 <code>CentOS</code> 、<code>Ubuntu</code>、<code>Debian</code>,<code>CentOS</code> 现在市场占有率第一</li></ul><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><ul><li><code>init 0</code>  关机 </li><li><code>init 6</code>   重启   </li><li><code>ls</code>  、 <code>ls -l</code>  、  <code>ll</code> 列出出当前目录下的文件 </li><li><code>cd</code>  切换目录</li><li><code>pwd</code> 查看当前路径</li><li><code>ctrl+c</code>     中断当前程序</li><li><code>ctrl+l  / (clear)</code>   清屏</li><li><code>ifconfig/ipconfig</code>    查看网卡信息</li><li><code>ping 127.0.0.1</code>   看网络是否通畅</li><li>Linux 创建用户修改密码<ul><li>添加用户 <code>useradd zhangsan</code></li><li>设置密码 <code>passwd zhangsan</code></li><li>删除用户 <code>userdel -rf zhangsan</code>  <code>-r</code>：递归的删除目录下面文件以及子目录下文件。</li></ul></li><li>文件管理<ul><li>创建文件 <code>touch file</code></li><li>删除文件 <code>rm -rf file</code><ul><li><code>-r</code>：递归的删除目录下面文件以及子目录下文件。<ul><li><code>-f</code>：强制删除，忽略不存在的文件，从不给出提示    </li></ul></li></ul></li><li>修改文件名 <code>mv file1 file11</code></li><li>查看文件内容 <code>cat file1</code></li><li>复制文件 <code>cp file2 file22</code></li><li>移动文件 <code>mv file1 file11</code></li><li>编辑文件 <code>vi file1</code></li><li>批量创建文件 <code>touch file{1..10}</code>     <code>rm -rf file{1..10}</code></li><li>查看文件前3行 <code>cat file1 | head -3</code></li><li>查看文件后3行    <code>cat file1 | tail -3</code></li><li>liunx服务器上面查找文件<ul><li><code>find</code> 查找文件<ul><li><code>find / -name httpd.conf</code> 查找当前目录下的文件名为 <code>httpd.conf</code> 的文件</li><li><code>find</code> 目录 <code>-name</code>  文件名</li></ul></li></ul></li><li>查找文件里面内容找到<code>httpd.conf</code> 里面有<code>listen</code><ul><li><code>cat httpd.conf | grep listen</code></li><li><code>cat httpd.conf | grep -ignore listen   /  cat httpd.conf | grep -i listen</code>  忽略大小写</li></ul></li><li>查找文件里面内容  vi搜索 <ul><li><code>vi  httpd.conf</code></li><li>输入 <code>/Listen</code> 搜索<code>Listen</code> <code>N</code>下一个</li></ul></li></ul></li><li>Linux 目录管理<ul><li>创建目录 <code>mkdir dir1 dir2 dir3</code></li><li>删除目录 <code>rm -rf dir1 dir2</code><ul><li><code>-r</code>：递归的删除目录下面文件以及子目录下文件。<ul><li><code>-f</code>：强制删除，忽略不存在的文件，从不给出提示</li><li><code>rm -rf  dir*</code> 以<code>dir</code>开头的所有文件删除</li></ul></li></ul></li><li>重命名目录或移动目录    <code>mv dir1 dir11</code></li><li>查看目录 <code>ls  / ll</code></li><li>递归创建目录 <code>mkdir -p a/b/c/d/e/f/g</code> 创建多层级目录</li><li>递归查看目录 <code>tree a</code>  tree命令不存在的话需要安装 <code>yum install tree -y</code></li><li>复制目录 <code>cp  -rf  wwwroot/ mywwwroot/</code></li></ul></li><li>Linux 打包压缩别名管理<ul><li>zip压缩包<ul><li>安装zip减压软件 <code>yum install -y unzip zip</code></li><li>zip压缩包 <code>zip -r public.zip public</code> <code>-r</code> 递归 表示将指定的目录下的所有子目录以及文件一起处理</li><li>解压 <code>unzip public.zip</code> <code>unzip public.zip -d dir</code></li><li>查看 <code>unzip -l public.zip</code></li></ul></li><li>gz压缩包:  (源代码压缩)<ul><li>Linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲tar命令的基本用法</li><li>制作gz包 <code>tar czvf public.tar.gz public</code></li><li>解压gz包 <code>tar xzvf public.tar.gz</code></li><li>查看gz包 <code>tar tf public.tar.gz</code></li></ul></li><li>tar包<ul><li><code>tar cvf wwwroot.tar wwwroot</code> 仅打包，不压缩！</li><li>解压tar包 <code>tar xvf wwwroot.tar</code> </li></ul></li><li>xz压缩包<ul><li>对于xz这个压缩相信很多人陌生，但xz是绝大数linux默认就带的一个压缩工具，xz格式比7z还要小。</li><li>制作<pre><code>- `tar  cvf xxx.tar xxx`  这样创建xxx.tar文件先，- `xz  xxx.tar`      将 xxx.tar压缩成为 xxx.tar.xz       删除原来的tar包- `xz  -k xxx.tar`     将 xxx.tar压缩成为 xxx.tar.xz      保留原来的tar包</code></pre></li><li>解压<pre><code>- `xz   -d  ***.tar.xz`   先解压xz   删除原来的xz包- `xz  -dk  ***.tar.xz`   先解压xz  保留原来的xz包- `tar  -xvf  ***.tar` 再解压tar</code></pre><ul><li>查看 <code>xz  -l  ***.tar.xz</code>   先解压xz</li></ul></li></ul></li><li>别名管理<ul><li>添加别名<pre><code>- `alias chttp=&apos;cat /etc/httpd/conf/httpd.conf&apos;`  - `chttp`</code></pre></li><li>删除别名 <code>unalias chttp</code></li><li>查看别名 <code>alias</code></li></ul></li></ul></li><li>用户管理、用户权限管理<ul><li>用户管理<ul><li>添加用户 <code>useradd lisi</code></li><li>设置密码 <code>passwd lisi</code></li><li>删除用户<ul><li><code>userdel -r lisi</code></li><li><code>-r</code>：递归的删除目录下面文件以及子目录下文件。<pre><code>- 备注：删除用户的时候用户组被删除</code></pre></li></ul></li><li>查看用户 <code>id user</code></li><li>把用户加入组 <ul><li><code>gpasswd -a testuser root</code></li><li>把用户<code>testuser</code>加入到<code>root</code>组，加入组后<code>testuser</code>获取到<code>user</code>组及<code>root</code>组所有权限</li></ul></li><li>把用户移出租 <code>gpasswd -d testuser root</code></li></ul></li><li>用户权限管理<ul><li>drwxr-xr-x.   2 root root 6 4月  11 2022 mnt<ul><li><code>rwx</code>   当前用户对mnt有读写执行权限      <code>u</code></li><li><code>r-x</code>   当前用户的组对mnt文件有读和执行  <code>g</code></li><li><code>r-x</code>   其他用户对mnt也具有读和执行      <code>o</code></li></ul></li><li>权限:<br><code>r</code> 读<br><code>w</code> 写<br><code>x</code> 执行</li><li>用户:<ul><li>所有者   <code>user u</code></li><li>所属组   <code>group  g</code></li><li>其他用户 <code>other  o</code></li><li>所有用户 <code>all     a</code>  <code>u+g+o=a</code>(表示所有人) </li></ul></li><li>目录的rwx<ul><li><code>r</code>  查看目录里面的文件(4)</li><li><code>w</code> 在目录里创建或删除文件(2)</li><li><code>x</code>  切换进目录(1)</li></ul></li><li>文件的rwx<ul><li><code>r</code> 查看文件内容</li><li><code>w</code> 在文件里写内容</li><li><code>x</code> 执行该文件(文件不是普通文件，是程序或脚本)</li></ul></li><li>chmod权限分配<ul><li><code>+</code>增加权限         -删除权限</li><li><code>chmod u+x my.sh</code>   给当前用户分配执行<code>my.sh</code>的权限</li><li><code>chmod o+r,o+w file.txt</code>    给其他用户分配对<code>file.txt</code>的读写权限</li><li><code>chmod o+r,o+w,o+x mnt/</code>     给所有其他用户分配对mnt目录的进入、读取、写入权限</li><li><code>chmod -R o+r,o+w,o+x mnt/</code>       修改目录下的所有文件的权限为可读、可修改、可执行</li><li><code>chmod 755 file</code></li><li><code>chmod -R 777 wwwroot/</code>  修改目录下的所有文件的权限为可读、可修改、可执行</li></ul></li></ul></li></ul></li><li>rpm软件安装卸载<ul><li>rpm命令安装卸载查找rpm包<ul><li>挂载光盘<ul><li><code>mount dev/cdrom /media</code>  挂载</li><li><code>df</code>  查看光盘是否挂载<pre><code>- 卸载`umount /media`</code></pre></li></ul></li><li>rpm安装<pre><code>- `rpm -ivh` `rpm`软件包</code></pre><ul><li><code>rpm</code>卸载软件<ul><li><code>rpm -e net-tools</code> <code>net-tools</code>表示要卸载的软件包</li></ul></li><li>查看<code>rpm</code>软件包的安装位置 / 软件包是否安装 <code>rpm -ql net-tools</code></li></ul></li></ul></li><li>Yum安装rpm 卸载rpm 查看rpm包<ul><li>yum安装rpm包<pre><code>- `yum install -y net-tools`              包括 `netstat` `ifconfig`等命令- `yum install -y unzip zip`               `zip`压缩减压- `yum install -y mlocate`                 `updatedb`- `yum install -y wget`                    下载文件包- `yum -y install psmisc`                   `pstree | grep httpd`   查看进程    `pstree -p`   显示进程以及子进程</code></pre><ul><li><code>yum</code>卸载<code>rpm</code>包<ul><li><code>yum -y remove wget</code></li></ul></li><li><code>yum</code>搜索<code>npm</code>包<ul><li><code>yum search</code> 名称</li></ul></li><li><code>yum</code>查看<code>rpm</code>包<ul><li><code>yum list</code></li><li><code>yum list | grep httpd</code></li><li><code>yum list updates</code>  列出所有可更新的软件包</li><li><code>yum list installed</code>   列出所有已安装的软件包</li></ul></li><li>yum显示rpm包信息<ul><li><code>yum info package1</code></li><li><code>yum info httpd</code>   </li><li><code>yum info zip</code></li><li><code>yum info unzip</code></li></ul></li></ul></li><li>yum 安装Apache <pre><code>- `yum -y install httpd`  `service httpd start`   安装启动`apache`- 启动`apache`- 关闭防火墙  `systemctl stop firewalld`</code></pre><ul><li><code>yum</code>的主配置文件 <code>etc/yum.conf</code></li><li><code>yum</code>的仓库配置文件 <code>/etc/yum.repo.d/*.repo</code></li></ul></li><li>Yum 安装Nginx：<ul><li>安装nginx源<ul><li><code>sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></li></ul></li><li>查看Nginx源是否配置成功　<ul><li>通过<code>yum search nginx</code>看看是否已经添加源成功。如果成功则执行下列命令安装Nginx。</li><li>或者 <code>npm info nginx</code>也可以看看<code>nginx</code>源是否添加成功</li></ul></li><li>安装Nginx <code>sudo yum install -y nginx</code></li><li>启动Nginx并设置开机自动运行 <ul><li><code>sudo systemctl start nginx.service</code></li><li><code>sudo systemctl enable nginx.service</code></li></ul></li></ul></li></ul></li></ul></li><li>源代码包的安装<ul><li>先安装源代码编译的软件<code>gcc</code>，<code>make</code>，<code>openssl</code> 如下：</li><li><code>yum install -y gcc make gcc-c++ openssl-devel</code></li><li>检查系统中是否已经安装 gcc：<code>rpm -qa | grep gcc  /  rpm -ql  gcc</code> </li><li>编译安装源代码包<pre><code>- 生成编译配置文件(`Makefile`)- 开始编译(`make`)- 开始安装(`make install`)</code></pre><ul><li>安装<code>httpd-2.2.9.tar.gz</code>源代码:<ul><li>减压并cd到对应目录</li><li><code>./configure --prefix=/usr/local/nodejs</code>              安装路径设置为<code>/usr/local/apache</code></li><li><code>make   /  make -j4</code></li><li><code>make install</code></li></ul></li></ul></li><li>删除源代码包<pre><code>- 结束当前源代码进程- 删除源代码  - 如：结束进程      - `pstree|grep httpd`        - `pkill httpd`    - 删除源代码      - `cd  /usr/local/`      - 直接删除源代码 `rm -rf apache/`</code></pre><ul><li>linux下源代码安装nodejs:<ul><li>下载nodejs源码包</li><li>减压到<code>usr/local/nodejs</code> 目录</li><li><code>./configure</code></li><li><code>make   /  make -j4</code></li><li><code>make install</code></li></ul></li></ul></li></ul></li><li>Linux 内存、cpu、进程、端口、硬盘管理 <ul><li>top命令 查看内存 cpu 进程 以及服务器负载<ul><li>top命令的第一行：<pre><code>- `top` - 15:31:47 up  9:30,  3 users,  load average: 0.00, 0.02, 0.05- 依次对应：系统当前时间 up 系统到目前为止i运行的时间， 当前登陆系统的用户数量， load average后面的三个数字分别表示距离现在一分钟，五分钟，十五分钟的负载情况。</code></pre><ul><li>top命令的第二行：<ul><li>Tasks: 133 total,   1 running, 132 sleeping,   0 stopped,   0 zombie</li><li>依次对应：tasks表示任务（进程），133 total则表示现在有133 个进程，其中处于运行中的有1个，132 个在休眠（挂起），stopped状态即停止的进程数为0，zombie状态即僵尸的进程数为0个。</li></ul></li><li>top命令的第三行，cpu状态：<ul><li>%Cpu(s):  0.2 us,  0.4 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.1 si,  0.0 st</li><li>只看空闲就可以了：cpu空闲率为99.3%</li></ul></li><li>top命令的第四行，内存状态：<ul><li>KiB Mem :  2897496 total,  1995628 free,   191852 used,   710016 buff/cache</li><li>总内存:2.76g  空闲：1995628/1024/1024=1.9g   已经使用0.18g   缓存区内存0.67g  </li><li>缓冲区是从主内存中特地预留出的内存，用来存放特定的一些信息，例如从磁盘中取得的文件表，程序正在读取的内容等等</li></ul></li></ul></li><li>看当前登录的账户who、查看最新操作电脑的用户last<ul><li><code>who</code>命令: 显示当前正在系统中的所有用户名字，使用终端设备号，注册时间。 </li><li><code>whoami</code> : 显示出当前终端上使用的用户。 </li><li><code>last</code>: <code>last</code>作用是显示近期用户或终端的登录情况</li></ul></li><li>查看进程关闭进程</li><li>查看进程<pre><code>  - `pstree`        查看进程树  - `pstree -ap`     显示所有信息  - `pstree | grep httpd`  - `pstree -ap | grep httpd`  - `ps -au`  - `ps -au |grep httpd`  - `ps -aux`- `ps` 中`aux`的含义:    - 显示现行终端机下的所有程序，包括其他用户的程序（`a`）    - 以用户为主的格式来显示程序状况。 （`x`）    - 显示所有程序，不以终端机来区分（`u`）</code></pre><ul><li>关闭进程<ul><li><code>pkill httpd</code>   <code>pkill</code>进程的名字</li><li><code>kill 2245</code>    <code>kill</code>进程号</li><li><code>kill -9 1234</code>   <code>kill -9</code>进程号  强制杀死</li><li><code>kill：执行</code>kill`命令，系统会发送一个SIGTERM信号给对应的程序。当程序接收到该signal信号后，将会发生以下事情：<br>程序立刻停止</li><li>当程序释放相应资源后再停止</li><li>程序可能仍然继续运行</li><li>大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后再停止。但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应，我在使用wkhtmltopdf转pdf的项目中遇到这现象），也就是说，SIGTERM多半是会被阻塞的。</li><li><code>kill -9</code>:  <code>kill -9</code>命令，系统给对应程序发送的信号是SIGKILL，即<code>exit</code>。<code>exit</code>信号不会被系统阻塞，所以<code>kill -9</code>能顺利杀掉进程。<ul><li>查看端口 <code>netstat -tunpl |grep httpd</code></li></ul></li></ul></li></ul></li></ul></li><li>查看硬盘信息：<pre><code>- `df`命令作用是列出文件系统的整体磁盘空间使用情况。可以用来查看磁盘已被使用多少空间和还剩余多少空间。- `df -h`  以人们易读的方式显示，总共多少g用了多少g- `df /home`   查看该文件夹所在磁盘的使用情况</code></pre></li></ul></li><li>Linux <code>systemctl</code>管理服务<ul><li><code>yum</code>安装<code>httpd</code><ul><li><code>yum install -y httpd</code></li><li><code>systemctl start httpd</code></li></ul></li><li><code>systemctl</code>管理服务<ul><li>启动服务：<code>systemctl start httpd</code></li><li>关闭服务：<code>systemctl stop httpd</code></li><li>重启服务：<code>systemctl restart httpd</code></li><li>查看一个服务的状态：<code>systemctl status httpd</code></li><li>查看一个服务是否在运行：<code>systemctl is-active httpd</code></li><li>查看当前已经运行的服务：<code>systemctl list-units -t service</code></li><li>列出所有服务：  <code>systemctl list-units -at service</code> 注意顺序 </li><li>设置开机自启动：    <code>systemctl enable httpd</code></li><li>停止开机自启动：    <code>systemctl disable httpd</code></li><li>列出所有自启动服务：<ul><li><code>systemctl list-unit-files|grep enabled`</code></li><li><code>systemctl list-unit-files|grep disabled`</code></li><li><code>systemctl list-unit-files|grep disabled | grep httpd`</code></li></ul></li><li>使指定服务从新加载配置：<code>systemctl reload httpd</code>    </li></ul></li></ul></li><li>Firewalld防火墙和SELinux防火墙的设置<ul><li><code>firewalld</code>的基本使用:<ul><li>启动： <code>systemctl start firewalld</code></li><li>关闭： <code>systemctl stop firewalld</code></li><li>查看状态： <code>systemctl status firewalld</code></li><li>开机禁用 ： <code>systemctl disable firewalld</code></li><li>开机启用 ： <code>systemctl enable firewalld</code></li></ul></li><li><code>firewall-cmd</code>的基本使用:<ul><li>那怎么开启一个端口呢: <code>firewall-cmd --zone=public --add-port=80/tcp --permanent</code> （<code>–permanent</code>永久生效，没有此参数重启后失效）</li><li>重新载入: <code>firewall-cmd --reload</code>  修改<code>firewall-cmd</code>配置后必须重启</li><li>查看: <code>firewall-cmd --zone= public --query-port=80/tcp</code></li><li>删除: <code>firewall-cmd --zone= public --remove-port=80/tcp --permanent</code></li><li>查看所有打开的端口：<code>firewall-cmd --zone=public --list-ports</code><ul><li>SELinux防火墙的设置</li></ul></li><li>修改<code>/etc/selinux/config</code> 文件</li><li>将<code>SELINUX=enforcing</code>改为<code>SELINUX=disabled</code></li></ul></li></ul></li></ul><h2 id="配置服务器的免密码快捷登录"><a href="#配置服务器的免密码快捷登录" class="headerlink" title="配置服务器的免密码快捷登录"></a>配置服务器的免密码快捷登录</h2><h3 id="登录服务器-ssh"><a href="#登录服务器-ssh" class="headerlink" title="登录服务器: ssh"></a>登录服务器: ssh</h3><blockquote><p>ssh，<code>secure shell protocol</code>，以更加安全的方式连接远程服务器</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root: 用户名</span></span><br><span class="line"><span class="comment"># 192.168.13.21</span></span><br><span class="line">$ ssh root@192.168.13.21</span><br></pre></td></tr></table></figure><h3 id="配置别名快速登录：ssh-config"><a href="#配置别名快速登录：ssh-config" class="headerlink" title="配置别名快速登录：ssh-config"></a>配置别名快速登录：ssh-config</h3><blockquote><p>在本地电脑上配置 <code>ssh-config</code>，对自己管理的服务器起别名，可以更方便地登录多台云服务器</p></blockquote><p><strong>ssh-config 的配置文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/ssh/ssh_config</span><br><span class="line"></span><br><span class="line">~/.ssh/config</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改~/.ssh/config配置</span></span><br><span class="line">Host tencent <span class="comment"># 服务器别名</span></span><br><span class="line">  HostName 413.12.151.18</span><br><span class="line">  User root</span><br><span class="line"></span><br><span class="line">Host server <span class="comment"># 服务器别名</span></span><br><span class="line">  HostName 192.168.105.130</span><br><span class="line">  User root</span><br></pre></td></tr></table></figure><blockquote><p>配置成功之后直接 <code>ssh</code>  就可以直接登录</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录服务器1</span></span><br><span class="line">ssh tencent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录服务器2</span></span><br><span class="line">ssh server</span><br></pre></td></tr></table></figure><h3 id="免密登录：public-key-与-ssh-copy-id"><a href="#免密登录：public-key-与-ssh-copy-id" class="headerlink" title="免密登录：public-key 与 ssh-copy-id"></a>免密登录：public-key 与 ssh-copy-id</h3><p><strong>把自己的公钥放在远程服务器的 authorized_keys 中</strong></p><blockquote><p>把本地文件 <code>~/.ssh/id_rsa.pub</code> 中内容复制粘贴到远程服务器 <code>~/.ssh/authorized_keys</code></p></blockquote><p>简单来说，就是 Ctrl-C 与 Ctrl-V 操作，不过还有一个更加有效率的工具: <code>ssh-copy-id</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在本地环境进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示你输入密码，成功之后可以直接 ssh 登录，无需密码</span></span><br><span class="line">$ ssh-copy-id tencent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登陆成功，无需密码</span></span><br><span class="line">$ ssh tencent</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录成功服务器，可以看到authorized_keys中的公钥信息</span></span><br><span class="line"></span><br><span class="line">Last login: Tue Jun 28 09:31:25 2022</span><br><span class="line">[root@VM-8-14-centos ~]<span class="comment"># cat ~/.ssh/authorized_keys</span></span><br><span class="line"></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCf4fy+KhLFADybnII3OOOI0MAghkuYgEqPLAbhQfrL+zjj1qSoX1dnaZ9PULykGU+QN4nyRrduZOgvDaUCMR+vPDJH3Nii45HUuKWBpdyA/L1sQ7pLKsBsOca7HK4U0P7lrux2IfnOmbYCz4xPsbc/RDArkYbc2uIszmwvdtgGL49fJn6VUC0TaQvRX5dQWznyC3HgarBze2NoilXfKsBr5V2Moc83QkUZdU8fFiiiolpDHf2narGwz+r1bhZrazfI72nOUTjXd5GXd+VOnZdxnk8njBeAAW87RwZ3b2Cg5FsEckzKWP5ddvVxoPEv8cmk= xx@qq.com</span><br><span class="line">[root@VM-8-14-centos ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="保持连接，防止断掉"><a href="#保持连接，防止断掉" class="headerlink" title="保持连接，防止断掉"></a>保持连接，防止断掉</h3><p>我们可以通过 <code>man ssh-config</code>，找到每一项的详细释义。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑 ~/.ssh/config</span></span><br><span class="line"></span><br><span class="line">Host *</span><br><span class="line">  ServerAliveInterval 30</span><br><span class="line">  TCPKeepAlive yes</span><br><span class="line">  ServerAliveCountMax 6</span><br><span class="line">  Compression yes</span><br></pre></td></tr></table></figure><h2 id="Linux环境变量"><a href="#Linux环境变量" class="headerlink" title="Linux环境变量"></a>Linux环境变量</h2><p>通过 <code>printenv</code> 可获得系统的所有环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ printenv</span><br><span class="line"></span><br><span class="line">TERM_SESSION_ID=w0t0p0:5D9702D2-F505-4D4D-B65B-745A4055x4D13</span><br><span class="line">SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.mIeXmJ4KFo/Listeners</span><br><span class="line">LC_TERMINAL_VERSION=3.4.15</span><br><span class="line">COLORFGBG=7;0</span><br><span class="line">ITERM_PROFILE=Default</span><br><span class="line">XPC_FLAGS=0x0</span><br><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">PWD=/Users/poetry</span><br><span class="line">SHELL=/bin/zsh</span><br><span class="line">TERM_PROGRAM_VERSION=3.4.15</span><br></pre></td></tr></table></figure><blockquote><p>我们也可以通过 <code>printenv</code>，来获得某个环境变量的值</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ printenv NVM_BIN</span><br><span class="line"></span><br><span class="line">/Users/poetry/.nvm/versions/node/v16.15.0/bin</span><br></pre></td></tr></table></figure><blockquote><p>通过 <code>$var</code> 或者 <code>${var}</code> 可以取得环境变量，并通过 <code>echo`</code> 进行打印</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$path</span></span><br><span class="line"></span><br><span class="line">/Users/poetry/.nvm/versions/node/v16.15.0/bin /opt/anaconda3/bin /usr/<span class="built_in">local</span>/bin /usr/<span class="built_in">local</span>/sbin /usr/<span class="built_in">local</span>/bin /usr/bin /bin /usr/sbin /sbin</span><br></pre></td></tr></table></figure><ul><li><code>$HOME</code> 当前用户目录，也就是 <code>~</code> 目录</li><li><code>$USER</code> 当前用户名</li><li><code>$PATH</code> 环境变量，指向环境变量的路径</li><li><code>$SHELL</code> 当前用户的 shell，比如 <code>bash</code>、<code>zsh</code>、<code>fish</code> 等</li><li><code>export</code> 可以用来设置环境变量，比如 </li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span> </span><br><span class="line">$ <span class="built_in">export</span> NODE_ENV=production</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$NODE_ENV</span></span><br><span class="line">production</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要使得配置的环境变量永久有效，需要写入 ~/.bashrc 或者 ~/.zshrc</span></span><br></pre></td></tr></table></figure><blockquote><p>在执行命令之前置入环境变量，可以用以指定仅在该命令中有效的环境变量。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该环境变量仅在当前命令中有效</span></span><br><span class="line">$ NODE_ENV=production printenv NODE_ENV</span><br><span class="line">production</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有输出</span></span><br><span class="line">$ printenv NODE_ENV</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在前端中大量使用，如</span></span><br><span class="line">$ NODE_ENV=production npm run build</span><br></pre></td></tr></table></figure><h2 id="使用-rsync进行文件拷贝"><a href="#使用-rsync进行文件拷贝" class="headerlink" title="使用 rsync进行文件拷贝"></a>使用 rsync进行文件拷贝</h2><blockquote><p>快速高效，支持断点续传、按需复制的文件拷贝工具，并支持远程服务器拷贝，建议在本地也使用 <code>rsync</code> 替换 <code>cp</code> 进行文件拷贝</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将本地的test目录拷贝到服务器的/home目录</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># -l：--links，拷贝符号链接</span></span><br><span class="line"><span class="comment"># -a：--archive，归档模式</span></span><br><span class="line"><span class="comment"># -h：--human-readable，可读化格式进行输出</span></span><br><span class="line"><span class="comment"># -z：--compress，压缩传输</span></span><br><span class="line"><span class="comment"># -v：--verbose，详细输出</span></span><br><span class="line">$ rsync -lahzv ~/Download/<span class="built_in">test</span> root@192.168.12.12:/home</span><br></pre></td></tr></table></figure><blockquote><p>拷贝目录，则需要看原目录是否以 <code>/</code> 结尾</p></blockquote><ul><li>不以 <code>/</code> 结尾，代表将该目录连同目录名一起进行拷贝</li><li>以 <code>/</code> 结尾，代表将该目录下所有内容进行拷贝</li></ul><h2 id="服务安装"><a href="#服务安装" class="headerlink" title="服务安装"></a>服务安装</h2><h3 id="mongodb4-x的安装配置"><a href="#mongodb4-x的安装配置" class="headerlink" title="mongodb4.x的安装配置"></a>mongodb4.x的安装配置</h3><blockquote><p>官方文档：<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</a></p></blockquote><h4 id="Mongodb的安装"><a href="#Mongodb的安装" class="headerlink" title="Mongodb的安装"></a>Mongodb的安装</h4><p><strong>配置yum源</strong></p><ol><li>在路径<code>/etc/yum.repos.d/</code>下创建文件<code>mongodb-org-4.0.repo</code></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">touch mongodb-org-4.0.repo</span><br></pre></td></tr></table></figure><ol start="2"><li>在文件<code>mongodb-org-4.0.repo</code>中写入如下内容(下面内容可以直接复制，也可以复制官方文档)</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mongodb-org-4.0]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/<span class="variable">$releasever</span>/mongodb-org/4.0/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc</span><br></pre></td></tr></table></figure><ol start="3"><li>安装mongodb  </li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y mongodb-org</span><br></pre></td></tr></table></figure><ol start="4"><li>开启mongodb服务</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start mongod </span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入mongod终端</span></span><br><span class="line">$ mongo</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/366a505fdb77ca61.png" alt></p><ol start="5"><li>设置开机启动mongodb    </li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable mongod</span><br></pre></td></tr></table></figure><h4 id="远程连接mongodb"><a href="#远程连接mongodb" class="headerlink" title="远程连接mongodb"></a>远程连接mongodb</h4><ul><li>修改mongo.conf文件<ul><li>命令：<code>sudo  vi /etc/mongod.conf</code></li><li>将原来bindIp: <code>127.0.0.1</code> 修改为<code>0.0.0.0</code><br><img src="https://s.poetries.work/uploads/2022/06/2e64b45acc69230d.png" alt></li></ul></li><li>重启动mongo服务：<code>service mongod restart</code></li><li>永久开放<code>27017</code>端口：<ul><li><code>firewall-cmd --zone=public --add-port=27017/tcp --permanent;</code> （<code>--permanent</code>永久生效，没有此参数重启后失效）</li><li><code>firewall-cmd --reload</code> </li></ul></li></ul><h4 id="Mongodb4-x卸载"><a href="#Mongodb4-x卸载" class="headerlink" title="Mongodb4.x卸载"></a>Mongodb4.x卸载</h4><ul><li>停止服务 <code>service mongod stop</code></li><li>删除安装的包<ul><li><code>rpm -qa | grep mongodb-org</code>   列出所有的包</li><li><code>yum remove -y $(rpm -qa | grep mongodb-org)</code></li><li>也可以尝试下面命令卸载 <code>yum remove -y  mongodb-org*</code></li></ul></li><li>删除数据及日志<ul><li><code>rm -r /var/log/mongodb</code></li><li><code>rm -r /var/lib/mongo</code></li></ul></li></ul><h3 id="mysql安装配置"><a href="#mysql安装配置" class="headerlink" title="mysql安装配置"></a>mysql安装配置</h3><p>找到<code>mysql</code>的<code>yum</code>源<code>rpm</code>包 <a href="https://dev.mysql.com/downloads/repo/yum" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum</a></p><blockquote><p>mysql安装源地址：<a href="http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm" target="_blank" rel="noopener">http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</a></p></blockquote><p>查看机器上面是否安装过mysql</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mysql*</span><br><span class="line">yum list installed | grep mysql*</span><br></pre></td></tr></table></figure><p><strong>mysql的安装：</strong></p><ul><li>安装配置yum源 <code>rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</code></li><li>安装 <code>yum -y install mysql-server</code></li><li>启动 <code>mysql</code> <code>systemctl start mysqld</code></li><li>mysql开机启动    <code>systemctl enable mysqld</code>        </li><li>修改 mysql 密码    <ul><li>查看mysql默认安装以后的密码</li><li>mysql 安装完成之后，在<code>/var/log/mysqld.log</code> 文件中给 <code>root</code> 生成了一个默认密码。通过下面的方式找到 root 默认密码，然后登录 mysql 进行修改</li></ul></li><li><code>mysql -u root -p</code>    输入密码</li><li><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;MyNewPass4!&#39;</code>;</li><li><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></li><li>默认情况mysql对密码要求非常严格<ul><li>修改密码策略 在<code>/etc/my.cnf</code> 文件添加 <code>validate_password_policy</code> 配置，指定密码策略</li><li>选择 <code>0（LOW），1（MEDIUM），2（STRONG）</code>其中一种，选择 <code>2</code> 需要提供密码字典文件<ul><li><code>validate_password_policy=0</code><ul><li>如果不需要密码策略，添加 my.cnf 文件中添加如下配置禁用即可：<code>validate_password = off</code></li><li>重新启动 mysql 服务使配置生效：<code>systemctl restart mysqld</code></li></ul></li></ul></li></ul></li><li><p>远程管理mysql  添加 <code>mysql</code> 远程登录用户</p><ul><li><p>把<code>host</code>改为<code>%</code></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user <span class="built_in">set</span> host = <span class="string">'%'</span> <span class="built_in">where</span> user = <span class="string">'root'</span>;</span><br><span class="line">mysql&gt; select host, user from user;</span><br><span class="line">mysql&gt; select host, user from user;</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| host      | user          |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| localhost | mysql.session |</span><br><span class="line">| localhost | mysql.sys     |</span><br><span class="line">| localhost | root          |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; update user <span class="built_in">set</span> host = <span class="string">'%'</span> <span class="built_in">where</span> user = <span class="string">'root'</span>;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select host, user from user;</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| host      | user          |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| %         | root          |</span><br><span class="line">| localhost | mysql.session |</span><br><span class="line">| localhost | mysql.sys     |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">   退出mysql</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure><ul><li>配置防火墙</li><li><code>firewall-cmd --zone=public --add-port=3306/tcp --permanent</code></li><li><code>firewall-cmd --reload</code><ul><li>最后注意：重启<code>mysql</code></li></ul></li></ul></li></ul></li></ul><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><ol><li>检查是否有 <code>redis</code> yum 源</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum search redis </span><br><span class="line">yum info redis</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 epel 仓库</li></ol><blockquote><p>EPEL (Extra Packages for Enterprise Linux)是基于 Fedora 的一个项目，为“红帽系”的操作系 统提供额外的软件包，适用于 RHEL、CentOS 和 Scientific Linux.</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br></pre></td></tr></table></figure><ol start="3"><li>安装 redis 数据库</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum info redis </span><br><span class="line">yum install redis -y</span><br></pre></td></tr></table></figure><ol start="4"><li>安装完毕后，使用下面的命令启动 redis 服务</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start redis</span><br><span class="line">systemctl restart redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><p>linux 上面进入 Redis 客户端</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><h3 id="nginx-nodejs-一台服务器站架多个网站"><a href="#nginx-nodejs-一台服务器站架多个网站" class="headerlink" title="nginx+nodejs 一台服务器站架多个网站"></a>nginx+nodejs 一台服务器站架多个网站</h3><p><img src="https://s.poetries.work/uploads/2022/06/f3bd51d6f4acf247.png" alt></p><h4 id="搭建-Nodejs-生产环境"><a href="#搭建-Nodejs-生产环境" class="headerlink" title="搭建 Nodejs 生产环境"></a>搭建 Nodejs 生产环境</h4><ul><li>下载 nodejs 二进制代码包，然后减压到 <code>/usr/local/nodejs</code></li><li><strong>配置环境变量</strong><ul><li><code>vi /etc/profile</code></li><li>最后面添加： <ul><li><code>export NODE_HOME=/usr/local/nodejs/bin</code></li><li><code>export PATH=$NODE_HOME:$PATH</code></li></ul></li><li><code>:wq</code> 保存，然后运行 <code>source /etc/profile</code></li></ul></li></ul><h4 id="nodejs-进程管理器-pm2-的使用"><a href="#nodejs-进程管理器-pm2-的使用" class="headerlink" title="nodejs 进程管理器 pm2 的使用"></a>nodejs 进程管理器 pm2 的使用</h4><blockquote><p>PM2 是一款非常优秀的 Node 进程管理工具，它有着丰富的特性：能够充分利用多核 CPU 且能够负载均衡、能够帮助应用在崩溃后、指定时间(cluster model)和超出最大内存限制 等情况下实现自动重启。 PM2 是开源的基于 Nodejs 的进程管理器，包括守护进程，监控，日志的一整套完整的功能。</p></blockquote><p><strong>PM2 的主要特性:</strong></p><ul><li>内建负载均衡（使用 Node cluster 集群模块） </li><li>后台运行 </li><li>0 秒停机重载，我理解大概意思是维护升级的时候不需要停机. </li><li>具有 Ubuntu 和 CentOS 的启动脚本 </li><li>停止不稳定的进程（避免无限循环） </li><li>控制台检测</li></ul><p><strong>PM2 的常见命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure><blockquote><p>运行 <code>pm2</code> 的程序并指定 <code>name</code></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start app.js --name appName </span><br><span class="line">pm2 start app.js -i 3 --name appName 3 <span class="comment"># 启动 3 个进程 （自带负载均衡）</span></span><br></pre></td></tr></table></figure><ul><li>显示所有进程状态 <code>pm2 list</code></li><li>显示所有进程状态 <code>pm2 logs</code></li><li>显示一个进程的日志 <code>pm2 logs appName</code></li><li>关闭重启所有进程<ul><li><code>pm2 stop all</code> # 停止所有进程</li><li><code>pm2 restart all</code> # 重启所有进程</li><li><code>pm2 reload all</code> # 0 秒停机重载进程 (用于 NETWORKED 进程)</li></ul></li><li>关闭重启指定进程<ul><li><code>pm2 stop 0</code> # 停止指定的进程 </li><li><code>pm2 restart 0</code> # 重启指定的进程</li><li><code>pm2 stop appName</code></li><li><code>pm2 restart appName</code></li></ul></li><li>杀死进程<ul><li><code>pm2 delete 0</code> # 杀死指定的进程</li><li><code>pm2 delete all</code> # 杀死全部进程</li><li><code>pm2 delete appName</code> # 杀死指定名字的进程</li></ul></li><li>显示相应进程/应用的总体信息<ul><li><code>pm2 show appName</code></li></ul></li></ul><h4 id="Nginx-的安装"><a href="#Nginx-的安装" class="headerlink" title="Nginx 的安装"></a>Nginx 的安装</h4><ol><li>安装 nginx 源</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure><ol start="2"><li>查看 Nginx 源是否配置成功</li></ol><ul><li>通过 <code>yum search nginx</code> 看看是否已经添加源成功。如果成功则执行下列命令安装 Nginx。 </li><li>或者 <code>npm info nginx</code> 也可以看看 nginx 源是否添加成功</li></ul><ol start="3"><li>安装 Nginx</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure><ol start="4"><li>启动 Nginx 并设置开机自动运行</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start nginx </span><br><span class="line">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure><h4 id="Nginx-反向代理配置"><a href="#Nginx-反向代理配置" class="headerlink" title="Nginx 反向代理配置"></a>Nginx 反向代理配置</h4><ol><li>关闭 Selinux</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 SELINUX=enforcing 为 SELINUX=disabled </span></span><br><span class="line">vi etc/selinux/config </span><br><span class="line"><span class="comment"># 必须重启 </span></span><br><span class="line">linux init 6</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 <code>firewalld</code> 开启 <code>80</code> 端口</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><ol start="3"><li>配置反向代理</li></ol><p>找到 <code>/etc/nginx/conf.d</code> 然后在里面新建对应网站的配置文件</p><p><img src="https://s.poetries.work/uploads/2022/06/34c70c7723b1c5b3.png" alt></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">  listen 80; </span><br><span class="line">  server_name www.bbb.com; </span><br><span class="line">  location / &#123; </span><br><span class="line">    <span class="comment">#设置主机头和客户端真实地址，以便服务器获取客户端真实 IP </span></span><br><span class="line">    proxy_set_header Host <span class="variable">$host</span>; </span><br><span class="line">    proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>; </span><br><span class="line">    proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>; </span><br><span class="line">    <span class="comment">#禁用缓存 </span></span><br><span class="line">    proxy_buffering off; </span><br><span class="line">    <span class="comment">#反向代理的地址 </span></span><br><span class="line">    proxy_pass http://127.0.0.1:3001; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重启 nginx</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><ul><li><code>nginx -t</code> 看配置是否正确 </li><li><code>systemctl stop nginx</code>  停止nginx</li><li><code>systemctl start nginx</code> 启动nginx</li></ul><p><strong>域名测试</strong></p><p>找到 <code>C:\Windows\System32\drivers\etc\hosts</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.1.128 </span><br><span class="line">192.168.1.128 www.bbb.com</span><br></pre></td></tr></table></figure><blockquote><p>浏览器输入 <code>www.aaa.com</code> nginx 转发到了 <code>127.0.0.1:3001</code></p></blockquote><h4 id="相关防火墙配置"><a href="#相关防火墙配置" class="headerlink" title="相关防火墙配置"></a>相关防火墙配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment">#  刷新</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有打开的端口： </span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">firewall-cmd --zone= public --remove-port=3306/tcp --permanent</span><br></pre></td></tr></table></figure><h4 id="nginx-nodejs多台服务器负载均衡"><a href="#nginx-nodejs多台服务器负载均衡" class="headerlink" title="nginx+nodejs多台服务器负载均衡"></a>nginx+nodejs多台服务器负载均衡</h4><p><img src="https://s.poetries.work/uploads/2022/06/2025927792fe986a.png" alt></p><p><strong>负载均衡的种类</strong></p><ul><li>一种是通过硬件来进行解决，常见的硬件有 NetScaler、F5、Radware 和 Array 等商用的 负载均衡器，但是它们是比较昂贵的</li><li>一种是通过软件来进行解决的，常见的软件有 LVS、Nginx、apache 等,它们是基于 Linux 系统并且开源的负载均衡策略.</li></ul><blockquote><p>Nginx 的特点是占有内存少，并发能力强，事实上 nginx 的并发能力确实在同类型的网页服 务器中表现最好，中国大陆使用 nginx 网站用户有：新浪、网易、 腾讯等</p></blockquote><p><strong>nginx 的 upstream 目前支持 3 种方式的分配</strong></p><ul><li>轮询（默认）<ul><li>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉， 能自动剔除。</li></ul></li><li><code>weight 权重</code> ——you can you up<ul><li>指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况</li></ul></li><li><code>ip_hash</code> ip 哈希算法<ul><li>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器， 可以解决 session 的问题。</li></ul></li><li>配置负载均衡<ul><li>找到 <code>/etc/nginx/conf.d</code> 然后在里面新建对应网站的配置文件</li></ul></li></ul><p><img src="https://s.poetries.work/uploads/2022/06/2977a3d908a6b1b3.png" alt></p><blockquote><p>重启 nginx：<code>systemctl restart nginx</code></p></blockquote><p><strong>www_aaa_com.conf</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream bakeaaa &#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 127.0.0.1:3001; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.aaa.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      <span class="comment"># 获取客户端的 IP 地址</span></span><br><span class="line">      proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">      proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="comment"># 禁用缓存</span></span><br><span class="line">      proxy_buffering off;</span><br><span class="line">            </span><br><span class="line">      proxy_pass http://bakeaaa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>www_bbb.com.conf</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">upstream bakebbb &#123;</span><br><span class="line"></span><br><span class="line">ip_hash;</span><br><span class="line">server 127.0.0.1:3002 ; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.bbb.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      <span class="comment">#获取客户端真实IP</span></span><br><span class="line">      proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">      proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="comment">#关闭缓存</span></span><br><span class="line">      proxy_buffering off;</span><br><span class="line">            </span><br><span class="line">      proxy_pass http://bakebbb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>www_ccc_com.conf</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream bakeccc &#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 192.168.1.129:3001; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.ccc.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      <span class="comment"># 获取客户端真实IP</span></span><br><span class="line">      proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">      proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="comment"># 关闭缓存</span></span><br><span class="line">      proxy_buffering off;</span><br><span class="line">            </span><br><span class="line">      proxy_pass http://bakeccc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>负载均衡操作演示</strong></p><blockquote><p>我们使用docker跑三个nodejs应用程序作为演示</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/7bdc4513afb0e8c5.png" alt></p><ul><li><strong>使用koa搭建三个服务3001,3002,3003</strong></li></ul><ol><li>3001服务</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World 3001'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3001</span>, ()=&gt;<span class="built_in">console</span>.log(<span class="string">'http://localhost:3001'</span>));</span><br></pre></td></tr></table></figure><ol start="2"><li>3002服务</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World 3002'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3002</span>, ()=&gt;<span class="built_in">console</span>.log(<span class="string">'http://localhost:3002'</span>));</span><br></pre></td></tr></table></figure><ol start="3"><li>3003服务</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World 3003'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3003</span>, ()=&gt;<span class="built_in">console</span>.log(<span class="string">'http://localhost:3003'</span>));</span><br></pre></td></tr></table></figure><blockquote><p>在本地启动以上三个服务</p></blockquote><ul><li><strong>docker运行Nginx</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx/Dockerfile</span></span><br><span class="line">FROM daocloud.io/library/nginx:1.13.0-alpine</span><br><span class="line"><span class="comment"># 拷贝配置文件到Nginx目录覆盖默认配置</span></span><br><span class="line"><span class="comment"># COPY conf/nginx.conf /etc/nginx/conf/nginx.conf</span></span><br><span class="line">COPY ./conf.d /etc/nginx/conf.d</span><br></pre></td></tr></table></figure><blockquote><p>本机<code>conf.d/default.conf</code>文件</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream bakeaaa &#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 192.168.1.34:3001 weight=1;  <span class="comment"># 192.168.1.34本机ip</span></span><br><span class="line">server 192.168.1.34:3002 weight=1;</span><br><span class="line">server 192.168.1.34:3003 weight=3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    <span class="comment"># server_name  www.aaa.com;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      <span class="comment"># 获取客户端真实IP</span></span><br><span class="line">      proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">      proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="comment"># 关闭缓存</span></span><br><span class="line">      proxy_buffering off;</span><br><span class="line">            </span><br><span class="line">      proxy_pass http://bakeaaa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构建nginx镜像 <code>docker build -t nginx-demo .</code></li><li>运行nginx镜像 <code>ddocker run --name nginx -d -p 8666:80(本机端口:容器端口) -v /Users/poetry/Download/docker/nginx/conf.d:/etc/nginx/conf.d(本机配置文件目录:容器配置文件目录) e00b36d6975b(nginx镜像ID)</code></li><li>运行 <code>docker ps</code> 查看启动的服务</li><li>修改配置<code>nginx/conf.d</code>需要重启容器才生效 <code>docker restart nginx(容器名称)</code></li></ul><blockquote><p>修改<code>upstream bakeaaa</code>中的权重等，可以看到不断刷新页面，可以看到不同的服务器负载均衡的效果</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/99bc3d74f889990a.png" alt></p><h3 id="云服务器部署node项目"><a href="#云服务器部署node项目" class="headerlink" title="云服务器部署node项目"></a>云服务器部署node项目</h3><ol><li>安装 nginx</li></ol><p>安装nginx源 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure><p>查看 Nginx 源是否配置成功</p><ul><li>通过 <code>yum search nginx</code> 看看是否已经添加源成功。如果成功则执行下列命令安装 Nginx。 </li><li>或者 <code>npm info nginx</code> 也可以看看 nginx 源是否添加成功</li></ul><p>安装nginx源</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure><p>启动 <code>Nginx</code> 并设置开机自动运行 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start nginx sudo systemctl enable nginx</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 nodejs</li></ol><p>下载 nodejs 二进制代码包，然后减压到 <code>/usr/local/nodejs</code> </p><p>配置环境变量 </p><p><code>vi /etc/profile</code></p><p>最后面添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export NODE_HOME=/usr/local/nodejs/bin </span><br><span class="line">export PATH=$NODE_HOME:$PATH</span><br></pre></td></tr></table></figure><p><code>:wq</code> 保存，然后运行 <code>source /etc/profile</code></p><ol start="3"><li>配置 nginx</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  koa.test.com;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#charset koi8-r;</span></span><br><span class="line">  <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    <span class="comment"># 获取客户端真实IP</span></span><br><span class="line">    proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">    proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="comment"># 关闭缓存</span></span><br><span class="line">    proxy_buffering off;</span><br><span class="line">          </span><br><span class="line">    proxy_pass http://127.0.0.1:3001;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  error_page   500 502 503 504  /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nginx配置https"><a href="#nginx配置https" class="headerlink" title="nginx配置https"></a>nginx配置https</h3><p><strong>为什么要使用 https</strong></p><blockquote><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。 </p></blockquote><p>HTTPS 是在 HTTP 的基础上添加了安全层，从原来的明文传输变成密文传输，当然加密与解 密是需要一些时间代价与开销的，不完全统计有 10 倍的差异。在当下的网络环境下可以忽 略不计，已经成为一种必然趋势。 </p><p>目前微信小程序请求 Api 必须用 https、Ios 请求 api 接口必须用 https</p><p><strong>配置 https</strong></p><p>证书类型 </p><ul><li>域名型 https 证书（DVSSL）：信任等级一般，只需验证网站的真实性便可颁发证书保护网站</li><li>企业型 https 证书（OVSSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高</li><li>增强型 https 证书（EVSSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高， 同时可以激活绿色网址栏</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 443; <span class="comment"># 监听443端口</span></span><br><span class="line">  server_name a.test.com;</span><br><span class="line">  ssl on; <span class="comment"># 开启ssl</span></span><br><span class="line">  ssl_certificate /root/nginxssl/1_a.expressjiaocheng.com_bundle.crt; <span class="comment"># ssl证书</span></span><br><span class="line">  ssl_certificate_key /root/nginxssl/2_a.expressjiaocheng.com.key; <span class="comment"># ssl私钥</span></span><br><span class="line">  ssl_session_timeout 5m; <span class="comment"># ssl会话超时时间</span></span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; <span class="comment"># ssl协议</span></span><br><span class="line">  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; <span class="comment"># ssl加密算法</span></span><br><span class="line">  ssl_prefer_server_ciphers on; <span class="comment"># ssl优先选择服务器端加密算法</span></span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    <span class="comment"># 获取客户端真实IP</span></span><br><span class="line">    proxy_set_header Host <span class="variable">$host</span>; <span class="comment"># 设置Host头信息</span></span><br><span class="line">    proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>; <span class="comment"># 设置客户端IP</span></span><br><span class="line">    proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>; <span class="comment"># 设置反向代理IP</span></span><br><span class="line">    <span class="comment"># 关闭缓存</span></span><br><span class="line">    proxy_buffering off;</span><br><span class="line">          </span><br><span class="line">    proxy_pass http://127.0.0.1:3001;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  error_page   500 502 503 504  /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">    root   /usr/share/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="docker系统管理"><a href="#docker系统管理" class="headerlink" title="docker系统管理"></a>docker系统管理</h2><h3 id="docker简介与安装"><a href="#docker简介与安装" class="headerlink" title="docker简介与安装"></a>docker简介与安装</h3><blockquote><p>Docker 是一个跨平台的开源的应用容器引擎，诞生于 2013 年初，基于 Go 语言 并遵从 Apache2.0 协议开源</p></blockquote><p>刚开始学 Docker 你可以把它理解成我们以前学过的虚拟机，但是 Docke 和传统虚拟化方式 的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系 统上再运行所需应用进程；Docker 相比传统的虚拟化技术要更轻量级，Docker 容器内的应 用程序是直接运行在宿主内核中的，容器内没有自己的内核，也没有进行硬件虚拟</p><p><img src="https://s.poetries.work/uploads/2022/06/d475d80c46a6b836.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/5f8aa431399633c4.png" alt></p><blockquote><p>因此 Docker 容器要比传统虚拟机占用资源更小、系统支持量更大、启动速度更快、更容易 维护和扩展。 目前 Docker 是全栈开发者必备的技能之一。 官网：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></p></blockquote><h4 id="为什么要使用-Docker"><a href="#为什么要使用-Docker" class="headerlink" title="为什么要使用 Docker"></a>为什么要使用 Docker</h4><ul><li>开发人员利用 Docker 快速部署 调试我们的应用</li><li>开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作，其他机器不能正 常工作”的问题。Docker 可以提供一致的运行环境，开发过程中一个常见的问题是环境一致 性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被 发现。</li><li>运维人员利用 Docker 可以在隔离容器中并行运行和管理应用</li><li>Serverless 也是基于 docker 容器技术</li></ul><h4 id="mac-docker安装"><a href="#mac-docker安装" class="headerlink" title="mac docker安装"></a>mac docker安装</h4><p><strong>本地docker环境搭建</strong></p><p>mac下安装docker: <code>brew install docker</code>，或者下载安装 <a href="https://docs.docker.com/docker-for-mac/install" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/install</a></p><blockquote><p><a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> 拉取镜像速度比较慢，我们推荐使用国内的镜像源访问速度较快 <a href="https://hub.daocloud.io" target="_blank" rel="noopener">https://hub.daocloud.io</a></p></blockquote><p>设置国内镜像源</p><p><img src="https://s.poetries.work/uploads/2022/06/82cdc649caaa9a4d.png" alt></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://register.docker-cn.com/"</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入该网站 <code>https://hub.daocloud.io</code> 获取镜像的下载地址</p><p><strong>docker命令基础</strong></p><ul><li><code>docker images</code> 查看镜像</li><li><code>docker ps</code> 查看启动的容器 (<code>-a</code> 查看全部)</li><li><code>docker rmi 镜像ID</code> 删除镜像</li><li><code>docker rm 容器ID</code> 删除容器</li><li><code>docker exec -it 1a8eca716169(容器ID:docker ps获取) sh</code> 进入容器内部</li><li><code>docker inspect bf70019da487(容器ID)</code> 查看容器内的信息 </li></ul><blockquote><p>删除none的镜像，要先删除镜像中的容器。要删除镜像中的容器，必须先停止容器。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker rmi $(docker images | grep <span class="string">"none"</span> | awk <span class="string">'&#123;print $3&#125;'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker stop $(docker ps -a | grep <span class="string">"Exited"</span> | awk <span class="string">'&#123;print $1 &#125;'</span>) //停止容器</span><br><span class="line"></span><br><span class="line">$ docker rm $(docker ps -a | grep <span class="string">"Exited"</span> | awk <span class="string">'&#123;print $1 &#125;'</span>) //删除容器</span><br><span class="line"></span><br><span class="line">$ docker rmi $(docker images | grep <span class="string">"none"</span> | awk <span class="string">'&#123;print $3&#125;'</span>) //删除镜像</span><br></pre></td></tr></table></figure><p><code>docker info</code> 命令可以查看 Docker 容器的配置信息，包括镜像源、网络、磁盘、内存、系统等。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker info</span><br><span class="line">Client:</span><br><span class="line"> Context:    default</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Plugins:</span><br><span class="line">  buildx: Docker Buildx (Docker Inc., v0.8.2)</span><br><span class="line">  compose: Docker Compose (Docker Inc., v2.4.1)</span><br><span class="line">  sbom: View the packaged-based Software Bill Of Materials (SBOM) for an image (Anchore Inc., 0.6.0)</span><br><span class="line">  scan: Docker Scan (Docker Inc., v0.17.0)</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 3</span><br><span class="line">  Running: 1</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 2</span><br><span class="line"> Images: 5</span><br><span class="line"> Server Version: 20.10.14</span><br><span class="line"> Storage Driver: overlay2</span><br><span class="line">  Backing Filesystem: extfs</span><br><span class="line">  Supports d_type: true</span><br><span class="line">  Native Overlay Diff: true</span><br><span class="line">  userxattr: false</span><br><span class="line"> Logging Driver: json-file</span><br><span class="line"> Cgroup Driver: cgroupfs</span><br><span class="line"> Cgroup Version: 2</span><br><span class="line"> Plugins:</span><br><span class="line">  Volume: local</span><br><span class="line">  Network: bridge host ipvlan macvlan null overlay</span><br><span class="line">  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line"> Swarm: inactive</span><br><span class="line"> Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc</span><br><span class="line"> Default Runtime: runc</span><br><span class="line"> Init Binary: docker-init</span><br><span class="line"> containerd version: 3df54a852345ae127d1fa3092b95168e4a88e2f8</span><br><span class="line"> runc version: v1.0.3-0-gf46b6ba</span><br><span class="line"> init version: de40ad0</span><br><span class="line"> Security Options:</span><br><span class="line">  seccomp</span><br><span class="line">   Profile: default</span><br><span class="line">  cgroupns</span><br><span class="line"> Kernel Version: 5.10.104-linuxkit</span><br><span class="line"> Operating System: Docker Desktop</span><br><span class="line"> OSType: linux</span><br><span class="line"> Architecture: x86_64</span><br><span class="line"> CPUs: 2</span><br><span class="line"> Total Memory: 3.843GiB</span><br><span class="line"> Name: docker-desktop</span><br><span class="line"> ID: PLR7:VYHP:QZEW:EDCY:4EDN:K77K:M7H5:CHIG:VRZE:OD34:TACY:4MI5</span><br><span class="line"> Docker Root Dir: /var/lib/docker</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> HTTP Proxy: http.docker.internal:3128</span><br><span class="line"> HTTPS Proxy: http.docker.internal:3128</span><br><span class="line"> No Proxy: hubproxy.docker.internal</span><br><span class="line"> Registry: https://index.docker.io/v1/</span><br><span class="line"> Labels:</span><br><span class="line"> Experimental: false</span><br><span class="line"> Insecure Registries:</span><br><span class="line">  hubproxy.docker.internal:5000</span><br><span class="line">  127.0.0.0/8</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://register.docker-cn.com/</span><br><span class="line"> Live Restore Enabled: false</span><br></pre></td></tr></table></figure><h4 id="Linux-中安装-docker"><a href="#Linux-中安装-docker" class="headerlink" title="Linux 中安装 docker"></a>Linux 中安装 docker</h4><p><strong>安装工具包</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install yum-utils device-mapper-persistent-data lvm2 -y</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/e0f4f8f2621b11c0.png" alt></p><p><strong>设置阿里镜像源</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/0b017f9a76914c6e.png" alt></p><p><strong>安装docker</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br></pre></td></tr></table></figure><p><strong>启动docker</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设为开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p><strong>设置docker镜像源</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://register.docker-cn.com/"</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续拉取镜像直接从 <a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> 网站拉取速度更快</p><p><strong>重启docker</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h4 id="安装指定版本的-docker"><a href="#安装指定版本的-docker" class="headerlink" title="安装指定版本的 docker"></a>安装指定版本的 docker</h4><ul><li>要安装特定版本的 Docker Engine，请在 repo 中列出可用版本，然后选择并安装： 一种。</li><li>列出并排序您的存储库中可用的版本。此示例按版本号对结果进行排序，从高到低， 并被截断：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/717f82025ea75291.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.i o</span><br></pre></td></tr></table></figure><h4 id="卸载-docker"><a href="#卸载-docker" class="headerlink" title="卸载 docker"></a>卸载 docker</h4><ul><li>卸载 Docker Engine、CLI 和 Containerd 包：<code>$ sudo yum remove docker-ce docker-ce-cli containerd.io</code></li><li>主机上的映像、容器、卷或自定义配置文件不会自动删除。删除所有镜像、容器和卷<ul><li><code>$ sudo rm -rf /var/lib/docker</code></li><li><code>$ sudo rm -rf /var/lib/containerd</code></li><li>您必须手动删除任何已编辑的配置文件</li></ul></li></ul><h4 id="阿里云-Docker-镜像加速器"><a href="#阿里云-Docker-镜像加速器" class="headerlink" title="阿里云 Docker 镜像加速器"></a>阿里云 Docker 镜像加速器</h4><p>访问 <a href="https://www.aliyun.com/" target="_blank" rel="noopener">https://www.aliyun.com/</a> 搜索 “容器镜像服务”</p><p><img src="https://s.poetries.work/uploads/2022/06/dacef356b4101fd5.png" alt></p><p>您可以通过修改daemon配置文件<code>/etc/docker/daemon.json</code>来使用加速器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://l6of9ya6.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="docker镜像容器仓库"><a href="#docker镜像容器仓库" class="headerlink" title="docker镜像容器仓库"></a>docker镜像容器仓库</h3><p><img src="https://s.poetries.work/uploads/2022/06/311938585465b33b.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/4c1ecee2ce96588b.png" alt></p><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><blockquote><p>Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运 行在 Linux 内核的程序以及相应的数据</p></blockquote><ul><li>镜像是分层（Layer）的：即一个镜像可以多个中间层组成，多个镜像可以共享同一中 间层，我们也可以通过在镜像添加多一层来生成一个新的镜像。</li><li>镜像是只读的（read-only）：镜像在构建完成之后，便不可以再修改，而上面我们所说 的添加一层构建新的镜像，这中间实际是通过创建一个临时的容器，在容器上增加或 删除文件，从而形成新的镜像，因为容器是可以动态改变的</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/a524edcdba080105.png" alt></p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><blockquote><p>类似 linux 系统环境，运行和隔离应用。容器从镜像启动的时候，docker 会在镜像的最上一 层创建一个可写层，镜像本身是只读的，保持不变。容器与镜像的关系，就如同面向编程中 对象与类之间的关系。</p></blockquote><ul><li>因为容器是通过镜像来创建的，所以必须先有镜像才能创建容器，而生成的容器是一个独立 于宿主机的隔离进程，并且有属于容器自己的网络和命名空间</li><li>镜像由多个中间层（layer）组成，生成的镜像是只读的，但容器却是可读 可写的，这是因为容器是在镜像上面添一层读写层（writer/read layer）来实现的，如下图所 示：</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/2681b9ce8eeab9d5.png" alt></p><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><blockquote><p>仓库（Repository）是集中存储镜像的地方，这里有个概念要区分一下，那就是仓库与仓库 服务器(Registry)是两回事，像我们上面说的 Docker Hub，就是 Docker 官方提供的一个仓库 服务器，不过其实有时候我们不太需要太过区分这两个概念。</p></blockquote><p><strong>公共仓库</strong></p><ul><li>公共仓库一般是指 Docker Hub，除了 获取镜像外，我们也可以将自己构建的镜像存放到 Docker Hub，这样，别人也可以使用我们 构建的镜像。</li><li>不过要将镜像上传到 Docker Hub，必须先在 Docker 的官方网站上注册一个账号</li></ul><p><strong>私有仓库</strong></p><p>有时候自己部门内部有一些镜像要共享时，如果直接导出镜像拿给别人又比较麻烦，使用像 Docker Hub 这样的公共仓库又不是很方便，这时候我们可以自己搭建属于自己的私有仓库服 务，用于存储和分布我们的镜像。</p><h4 id="Docker-镜像以及仓库"><a href="#Docker-镜像以及仓库" class="headerlink" title="Docker 镜像以及仓库"></a>Docker 镜像以及仓库</h4><blockquote><p>Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运 行在 Linux 内核的程序以及相应的数据</p></blockquote><p>镜像结构: <code>registryname/repositoryname/imagename:tagname</code> 例如：<code>docker.io/library/centos:8.3.2011</code></p><ul><li><code>docker search</code> 搜索镜像 <code>docker search centos</code></li><li><code>docker pull</code> 下载镜像 <code>docker pull centos</code><ul><li>下载指定的 tag <code>docker pull centos:8.3.2011</code></li></ul></li><li><code>docker images</code> 查看本地镜像</li><li><code>docker tag</code> 给镜像打标签<ul><li>给镜像打标签可以创建自己的镜像</li><li>镜像结构: <code>registryname/repositoryname/imagename:tagname</code></li><li>例如：<code>docker.io/library/centos:8.3.2011</code></li></ul></li><li><code>docker rmi 镜像ID -f(强制删除)</code> 删除镜像<ul><li>这样删除只会删除对应的标签<code>docker images | grep centos</code></li></ul></li><li>把本地镜像推送到<code>dockerHub</code>仓库<ul><li>需要在 dockerHub 上面注册一个账户：<code>https://hub.docker.com/</code></li><li>使用<code>docker login</code>本地登录<code>dockerHub</code></li><li><code>docker login</code></li><li>查看保存的账户信息 <code>cat .docker/config.json</code></li></ul></li><li><code>docker push</code> 镜像名称 把本地镜像推送到远程</li></ul><h4 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h4><blockquote><p>类似 linux 系统环境，运行和隔离应用。容器从镜像启动的时候，docker 会在镜像的最上一 层创建一个可写层，镜像本身是只读的，保持不变。容器与镜像的关系，就如同面向编程中 对象与类之间的关系。</p></blockquote><p>因为容器是通过镜像来创建的，所以必须先有镜像才能创建容器，而生成的容器是一个独立 于宿主机的隔离进程，并且有属于容器自己的网络和命名空间</p><ul><li>查看所的容器<ul><li><code>docker ps</code></li><li><code>docker ps -a</code> 查看所有容器</li></ul></li><li><code>docker run</code> 参数<ul><li><code>docker run</code> ：创建一个新的容器并运行一个命令</li><li><code>docker run</code> 是日常用的最频繁用的命令之一，同样也是较为复杂的命令之一 命令格式：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code><ul><li>参数<ul><li><strong>OPTIONS :选项</strong><ul><li><code>-i</code>:表示启动一个可交互的容器，并持续打开标准输入</li><li><code>-t</code>: 表示使用终端关联到容器的标准输入输出上</li><li><code>-d</code>:表示容器放置后台运行</li><li><code>--rm</code>:退出后即删除容器</li><li><code>--name</code> :表示定义容器唯一名称</li><li><code>-p</code> 映射端口</li><li><code>-v</code> 指定路径挂载数据卷</li><li><code>-e</code> 运行容器传递环境变量</li></ul></li><li><code>IMAGE</code> :表示要运行的镜像</li><li><code>COMMAND</code> :表示启动容器时要运行的命令</li></ul></li></ul></li><li><code>-it</code> 启动一个交互式容器<ul><li><code>docker run</code> 启动一个交互式容器在容器内执行<code>/bin/bash</code> 命令</li><li><code>docker run -it nginx(镜像ID或名称) /bin/bash</code></li></ul></li></ul></li><li>删除容器 <code>docker rm 容器ID -f</code></li><li>停止容器 <code>docker stop 容器ID</code></li><li>启动容器 <code>docker start 容器ID</code></li><li>重启容器 <code>docker restart 容器ID</code></li><li>进入容器内部<ul><li>进入容器内部 <code>docker exec -it 容器ID /bin/bash</code></li><li><code>docker exec</code>：进入容器开启一个新的终端（常用） 执行 <code>exit</code> 退出的时候不会停止容器</li><li><code>docker attach</code>：进入容器正在执行的终端 <code>exit</code> 退出会停止容器 </li></ul></li><li>查看容器日志 <code>docker logs 容器ID</code><ul><li>语法<code>docker logs [OPTIONS] CONTAINER</code></li><li><code>-f</code> : 跟踪日志输出</li><li><code>--since</code> :显示某个开始时间的所有日志 </li><li><code>-t</code> : 显示时间戳 </li><li><code>--tail</code> :仅列出最新 <code>N</code> 条容器日志</li></ul></li><li><code>docker commit</code> 容器转换为镜像<ul><li>镜像是没有写入权限的，但是我们可以修改容器把容器制作为镜像 </li><li>启动一个容器 给容器写入内容</li><li><code>docker exec -it 容器ID /bin/bash</code> 进入容器内部，写入内容 <code>echo test &gt; 1.txt</code></li><li><code>docker commit 容器ID 自定义镜像名称</code> 将容器转换为镜像</li></ul></li></ul><h3 id="docker应用"><a href="#docker应用" class="headerlink" title="docker应用"></a>docker应用</h3><h4 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h4><p>进入<code>https://hub.daocloud.io</code> 搜索node，切换到版本获取下载地址</p><ul><li><code>docker pull daocloud.io/library/node:12.18</code></li><li><code>docker tag 28faf336034d node</code> 重命名镜像</li></ul><p>重命名镜像后IMAGE ID都是一样的</p><p><img src="https://s.poetries.work/uploads/2022/06/59d83f0139c878de.png" alt></p><p>也可以导出镜像到本地备份 <code>docker save -o node.image(导出镜像要起的名称) 28faf336034d(要导出的镜像的ID)</code></p><p><img src="https://s.poetries.work/uploads/2022/06/7b993abfdc8f07b6.png" alt></p><p>我们先删除之前的镜像 <code>docker rmi 28faf336034d -f</code> 强制删除</p><p><img src="https://s.poetries.work/uploads/2022/06/df79f11b704aae4d.png" alt></p><p>再次导入本地镜像</p><p><code>docker load -i node.image(导入的镜像名称)</code></p><p><img src="https://s.poetries.work/uploads/2022/06/566d2f2270c40840.png" alt></p><p>然后再次重命名镜像即可</p><p><code>docker tag 28faf336034d node:v1.0(版本v1.0)</code></p><p><img src="https://s.poetries.work/uploads/2022/06/129f0a59b6d7c5d4.png" alt></p><h4 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h4><p><img src="https://s.poetries.work/uploads/2022/06/49bb3cc9f49c2dd1.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull daocloud.io/library/nginx:1.13.0-alpine</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/1f9aea9f1c9a18fc.png" alt></p><p><strong>启动Nginx镜像</strong></p><p>服务器上启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name nginx(起一个容器名称) -d(后台运行) -p 80:80(本机:容器) -v(映射Nginx容器的运行目录本机) /root/nginx/log:/var/log/nginx(本机目录:容器目录) -v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf(本机目录:容器内nginx配置所在目录) -v /root/nginx/conf.d:/etc/nginx/conf.d -v /root/nginx/html:/usr/share/nginx/html f00ab1b3ac6d(nginx镜像ID)</span><br></pre></td></tr></table></figure><p>本地电脑启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name nginx -d -p 8666:80 -v /Users/poetry/Downloads/docker/nginx/log:/var/log/nginx -v /Users/poetry/Downloads/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /Users/poetry/Downloads/docker/nginx/conf.d:/etc/nginx/conf.d -v /Users/poetry/Downloads/docker/nginx/html:/usr/share/nginx/html f00ab1b3ac6d</span><br></pre></td></tr></table></figure><blockquote><p>把docker容器中的Nginx服务配置映射本地方便管理</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/691129b326f9fb23.png" alt></p><p>访问docker暴露的8666端口即可</p><p><img src="https://s.poetries.work/uploads/2022/06/6d9b07b85c22e0b5.png" alt></p><p>当我们修改了html中的文件，无需重启容器即可看到效果</p><p><img src="https://s.poetries.work/uploads/2022/06/d0ded5a28d96ce59.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/cb0109ef19b551e4.png" alt></p><h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h4><p>进入<code>https://hub.daocloud.io</code> 搜索mysql，切换到版本获取下载地址</p><p><img src="https://s.poetries.work/uploads/2022/06/a6a34ed8d66f7cdc.png" alt></p><ul><li><code>docker pull daocloud.io/library/mysql:8.0.20</code></li></ul><p><img src="https://s.poetries.work/uploads/2022/06/f7e34f9ea2331ffb.png" alt></p><p><strong>启动MySQL镜像</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d(后台运行) -p 3307:3306(本机端口:MySQL运行端口) --name mysql(容器名称) -e MYSQL_ROOT_PASSWORD=123456(设置mysql密码) be0dbf01a0f3(mysql镜像ID)</span><br></pre></td></tr></table></figure><p><strong>查看当前正在运行的镜像</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a(正在运行和停止的镜像-a都可见)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/5ba00266271ef558.png" alt></p><p><strong>删除容器</strong></p><p>删除之前需要stop：<code>docker stop bac2692e2b9a(容器ID)</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm bac2692e2b9a(容器ID：docker ps获取)</span><br></pre></td></tr></table></figure><p><strong>进入容器内部</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it bac2692e2b9a(容器ID) sh(指定进入方式)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/16c4541cf84b6e48.png" alt></p><p>我们使用Navicat新建一个连接测试一下</p><p><img src="https://s.poetries.work/uploads/2022/06/65357b17bf38f12e.png" alt></p><p>说明我们使用docker安装MySQL的方式是没问题的</p><p><strong>查看MySQL容器日志</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs -f(查看最后几条)  bac2692e2b9a(容器ID)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/639c44fb75dfe354.png" alt></p><p><strong>重启容器</strong></p><p>如果修改了容器配置，我们需要重新启动容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart bac2692e2b9a(容器ID)</span><br></pre></td></tr></table></figure><p><strong>设置MySQL权限</strong></p><blockquote><p>mysql8.0后，需要设置，否则node连接不上</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it bac2692e2b9a sh</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 远程连接权限</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新加密规则</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'password'</span> PASSWORD EXPIRE NEVER;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新用户密码</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/2ce28bda82ab01d4.png" alt></p><p><strong>挂载配置文件目录</strong></p><blockquote><p>默认数据库的数据是放在容器里面的，这样的话当容器删除会导致数据丢失。我们想的是删 除容器的时候不删除容器里面的 mysql 数据，这个时候启动容器的时候就可以把 mysql 数据 挂载到外部。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d(后台运行) -p 3307:3306(本机端口:MySQL运行端口) -v v /mysql/conf.d:/etc/mysql/conf.d -v /mysql/data:/var/lib/mysql  --name mysql(容器名称) -e MYSQL_ROOT_PASSWORD=123456(设置mysql密码) be0dbf01a0f3(mysql镜像ID)</span><br></pre></td></tr></table></figure><blockquote><p>docker inspect bac2692e2b9a(容器ID) </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect bac2692e2b9a | grep mysql</span><br></pre></td></tr></table></figure><h4 id="安装redis-1"><a href="#安装redis-1" class="headerlink" title="安装redis"></a>安装redis</h4><p><img src="https://s.poetries.work/uploads/2022/06/b38b5f228f3bcafe.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull daocloud.io/library/redis:6.0.3-alpine3.11</span><br></pre></td></tr></table></figure><p><strong>启动Redis镜像</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6380:6379 --name redis 29c713657d31(镜像ID) --requirepass 123456(redis登录密码)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/57a4ce88939753b0.png" alt></p><p>或进入redis镜像后在输入密码</p><p><img src="https://s.poetries.work/uploads/2022/06/b6183fc0a23c353d.png" alt></p><p><strong>交互式进入redis容器</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 9751cbc96861(容器ID) sh</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/ab4cf5d68cdd846b.png" alt></p><h4 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/c40b78b7f3a083f7.png" alt></p><p>启动容器 映射端口 挂载目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name mongoTest -p 27018:27017 -v ~/Downloads/docker/mongo:/data/db -d mongo(镜像ID或名称)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/ee188453d7a2fa5d.png" alt></p><p>可以看到通过 <code>-v</code>挂载到本地的数据</p><p><img src="https://s.poetries.work/uploads/2022/06/c7bda56df3a23c53.png" alt></p><p>进入容器内部 <code>docker exec -it mongoTest(镜像ID或名称) sh</code></p><p><img src="https://s.poetries.work/uploads/2022/06/34f02c9235be1c72.png" alt></p><p>输入mongo，可以看到mongo已经安装成功了，我们从容器外连接容器的mongo</p><p><img src="https://s.poetries.work/uploads/2022/06/5e31f8c9d31961df.png" alt></p><p><strong>连接需要密码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name authMongo -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=123456 -p 27019:27017 -v ~/Downloads/docker/authMongo:/data/db mongo(镜像名称或者ID) --auth</span><br></pre></td></tr></table></figure><p>进入容器内部</p><p><img src="https://s.poetries.work/uploads/2022/06/7be573b2aa974fb0.png" alt></p><p>远程连接</p><p><img src="https://s.poetries.work/uploads/2022/06/dcd42440f0686a39.png" alt></p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h4 id="Dockerfile-构建一个-nginx-镜像"><a href="#Dockerfile-构建一个-nginx-镜像" class="headerlink" title="Dockerfile 构建一个 nginx 镜像"></a>Dockerfile 构建一个 nginx 镜像</h4><blockquote><p>Dockerfile 构建一个 nginx 镜像,构建好的镜像内会有一个 <code>/usr/share/nginx/html/index.html</code> 文件</p></blockquote><p>新建一个名为 Dockerfile 文件，并在文件内添加以下内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM nginx </span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'你好 docker'</span> &gt; /usr/share/nginx/html/index.html </span><br><span class="line">WORKDIR /usr/share/nginx/html</span><br></pre></td></tr></table></figure><ul><li>构建镜像 <code>docker build -t nginx:v1 .</code></li><li>进入容器 <code>docker run -it -d -p 8900:80 容器ID</code></li><li>[root@localhost ~]# <code>curl 127.0.0.1</code> 你好 docker</li></ul><h4 id="Dockerfile-详解"><a href="#Dockerfile-详解" class="headerlink" title="Dockerfile 详解"></a>Dockerfile 详解</h4><ul><li><code>Dockerfile</code> 文件的文件名建议使用 <code>Dockerfile</code> ，如果是其他文件构建的时候需要指定文件 名</li><li>Dockerfile 构建镜像的执行顺序是从上往下</li><li>每一个指令都会创建一个新的镜像层，并提交</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM <span class="comment"># 基础境像,一切从这里开始构建 </span></span><br><span class="line">MAINTAINER <span class="comment"># 镜像是谁写的,姓名+邮箱 </span></span><br><span class="line">LABEL <span class="comment"># LABEL 指令用来给镜像添加一些元数据 </span></span><br><span class="line">RUN <span class="comment"># 编译镜像时运行的脚本 </span></span><br><span class="line">COPY <span class="comment"># 编译镜像时复制文件到镜像中 不会解压 </span></span><br><span class="line">ADD <span class="comment"># 编译镜像时复制文件到镜像中 tar.gz 文件会自动解压 </span></span><br><span class="line">WORKDIR <span class="comment"># 镜像的工作目录 </span></span><br><span class="line">CMD <span class="comment"># 设置容器启动的命令 </span></span><br><span class="line">ENTRYPOINT <span class="comment"># 设置容器启动的命令 </span></span><br><span class="line">EXPOSE <span class="comment"># 设置镜像暴露的端口 </span></span><br><span class="line">VOLUME <span class="comment"># 设置容器挂载的卷 </span></span><br><span class="line">ENV <span class="comment"># 设置容器的环境变量</span></span><br></pre></td></tr></table></figure><ul><li><code>FROM</code> 指定哪种镜像作为新镜像的基础镜像，如：<code>FROM ubuntu:14.04</code></li><li><code>MAINTAINER</code> 指明该镜像的作者和其电子邮件，如：<code>MAINTAINER &quot;xxxxxxx@qq.com&quot;</code></li><li><code>LABEL</code> 给镜像添加信息。使用 <code>docker inspect</code> 可查看镜像的相关信息，如：<ul><li><code>LABEL maintainer=&quot;xx@qq.com&quot;</code></li><li><code>LABEL version=&quot;1.0&quot;</code></li><li><code>LABEL description=&quot;This is description&quot;</code></li></ul></li><li><code>RUN</code> 在新镜像内部执行的命令<ul><li>比如安装一些软件、配置一些基础环境，可使用<code>\</code>来换行，如： <code>RUN apt-get update &amp;&amp; apt-get install -y vim</code></li><li>也可以使用 <code>exec</code> 格式 <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>的命令，如<ul><li><code>RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot;]</code></li><li><code>RUN [&quot;yum&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot;]</code></li></ul></li></ul></li><li><code>COPY</code><ul><li>将主机的文件复制到镜像内，如果目的位置不存在，Docker 会自动创建所有需要的目录结 构，但是它只是单纯的复制，并不会去做文件提取和解压工作。如：</li><li><code>COPY ./src/ /usr/share/nginx/html/</code></li></ul></li><li><code>ADD</code><ul><li>将主机的文件复制到镜像内，如果目的位置不存在，Docker 会自动创建所有需要的目录结 构，并且会解压文件。如：</li><li><code>ADD ./src.tar.gz /usr/share/nginx/html/</code></li></ul></li><li><code>WORKDIR</code><ul><li>在构建镜像时，指定镜像的工作目录，之后的命令都是基于此工作目录，如果不存在，则会 创建目录</li><li><code>WORKDIR /usr/share/nginx/html</code></li></ul></li><li><code>CMD</code><ul><li>在构建镜像时，指定容器启动的命令，如果不存在，则会使用镜像的默认启动命令</li><li><code>CMD [&quot;/bin/bash&quot;]</code></li></ul></li><li><code>ENTRYPOINT</code><ul><li>在构建镜像时，指定容器启动的命令，如果不存在，则会使用镜像的默认启动命令</li><li><code>ENTRYPOINT [&quot;/bin/bash&quot;]</code></li><li><code>CMD</code> 和 <code>ENTRYPOINT</code> 同样作为容器启动时执行的命令，区别有以下几点<ul><li><code>CMD</code> 的命令会被 <code>docker run</code> 的命令覆盖而 <code>ENTRYPOINT</code> 不会</li><li>如使用 <code>CMD [&quot;/bin/bash&quot;]</code>或 <code>ENTRYPOINT [&quot;/bin/bash&quot;]</code>后，再使用 <code>docker run -it image</code> 启动容 器，它会自动进入容器内部的交互终端，如同使用 <code>docker run -it image /bin/bash</code></li><li>但是如果启动镜像的命令为 <code>docker run -it image /bin/ps</code>，使用 <code>CMD</code> 后面的命令就会被覆盖 转而执行 <code>bin/ps</code> 命令，而 <code>ENTRYPOINT</code> 的则不会，而是会把 <code>docker run</code> 后面的命令当做 <code>ENTRYPOINT</code> 执行命令的参数</li></ul></li></ul></li><li><code>EXPOSE 暴露端口</code><ul><li>在构建镜像时，指定暴露的端口，如果不存在，则会使用镜像的默认端口</li><li><code>EXPOSE 8080</code></li><li>仅仅是声明了一个暴露的端口</li><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射端口</li><li>在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</li></ul></li><li><code>VOLUME</code><ul><li>在构建镜像时，指定挂载的卷，如果不存在，则会使用镜像的默认卷</li><li><code>VOLUME /usr/share/nginx/html</code></li><li>帮助镜像使用者理解这个镜像服务的守护卷，以方便配置映射卷</li><li>在运行时使用随机卷映射时，也就是 <code>docker run -v</code> 时，会自动随机映射 <code>VOLUME</code> 的卷。</li><li>我们通过 <code>docker inspect</code> 查看通过该 <code>dockerfile</code> 创建的镜像生成的容器</li></ul></li><li><code>ENV</code><ul><li>在构建镜像时，指定环境变量，如果不存在，则会使用镜像的默认环境变量</li><li><code>ENV PATH=/usr/bin</code></li><li>帮助镜像使用者理解这个镜像服务的守护环境变量，以方便配置映射环境变量</li><li>在运行时使用随机环境变量映射时，也就是 <code>docker run -e</code> 时，会自动随机映射 <code>ENV</code> 的环境变量。</li></ul></li></ul><h4 id="Dockerfile-构建-Centos-并安装-net-tools-yum-软件"><a href="#Dockerfile-构建-Centos-并安装-net-tools-yum-软件" class="headerlink" title="Dockerfile 构建 Centos 并安装 net-tools yum 软件"></a>Dockerfile 构建 Centos 并安装 net-tools yum 软件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dockerfile_centos</span></span><br><span class="line">FROM centos </span><br><span class="line">MAINTAINER xx.com </span><br><span class="line">ENV MyLocal /usr/<span class="built_in">local</span> </span><br><span class="line">WORKDIR <span class="variable">$MyLocal</span> </span><br><span class="line">EXPOSE 80 </span><br><span class="line">VOLUME [<span class="string">"volume1"</span>,<span class="string">"volume2"</span>] </span><br><span class="line">RUN yum install -y net-tools </span><br><span class="line">RUN yum install -y vim </span><br><span class="line">ADD test.tar.gz /root </span><br><span class="line">COPY test.tar.gz /usr/<span class="built_in">local</span> </span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>编译 编译的时候注意最后面的<code>.</code></p><p><code>docker build -f Dockerfile_centos -t centos:v1.0 .</code></p><p>查看执行的历史 <code>docker history 镜像名称或者id</code></p><h4 id="Dockerfile-自动部署-Nodejs-程序"><a href="#Dockerfile-自动部署-Nodejs-程序" class="headerlink" title="Dockerfile 自动部署 Nodejs 程序"></a>Dockerfile 自动部署 Nodejs 程序</h4><p>项目目录中新建 <code>Dockerfile</code> <code>COPY . /root/wwwroot/</code>表示把项目目录中的代码复制到容器里面的<code>/root/wwwroot</code> 目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM node </span><br><span class="line"></span><br><span class="line">COPY . /root/wwwroot/ </span><br><span class="line"></span><br><span class="line">WORKDIR /root/wwwroot/ </span><br><span class="line"></span><br><span class="line">EXPOSE 3000 </span><br><span class="line"></span><br><span class="line">RUN npm install cnpm -g --registry=https://registry.nlark.com </span><br><span class="line"></span><br><span class="line">RUN cnpm install </span><br><span class="line"></span><br><span class="line">CMD node app.js</span><br></pre></td></tr></table></figure><p>构建 <code>docker build -t nodeimg:v1.0.1 .</code></p><p>运行镜像并且进入容器 <code>docker run -tid --name nodeDemo -p 3000:3000 nodeimg:v1.0.1</code></p><h3 id="配置docker网络"><a href="#配置docker网络" class="headerlink" title="配置docker网络"></a>配置docker网络</h3><p>多个容器之间如何通信，是否可以直接连接</p><p><img src="https://s.poetries.work/uploads/2022/06/26463dace73153a0.png" alt></p><p>首先看看网卡信息</p><p><img src="https://s.poetries.work/uploads/2022/06/d994954b9bc09429.png" alt></p><blockquote><p>：默认情况同一台主机上面的容器是可以互相通信的，默认情况同一台主机上面的容器 和主机之间是可以互相通信的</p></blockquote><p><strong>通信原理</strong></p><blockquote><p>我们每启动一个Docker容器，Docker就会给Docker容器分配一个ip，我们只要安装了Docker， 就会有一个网卡 <code>Docker0</code>，<code>Docker0</code> 使用的是桥接模式，使用的技术是 evth-pair 技术</p></blockquote><h4 id="Docker-Network-详解"><a href="#Docker-Network-详解" class="headerlink" title="Docker Network 详解"></a>Docker Network 详解</h4><ul><li>关于 docker network 命令 <code>docker network --help</code></li><li><code>docker network ls</code> 查看网络 </li><li><code>docker network inspect 网络ID(docker network ls获取)</code> 查看网络详情</li></ul><h4 id="Docker-网络的四种模式"><a href="#Docker-网络的四种模式" class="headerlink" title="Docker 网络的四种模式"></a>Docker 网络的四种模式</h4><table><thead><tr><th>Docker 网络模式</th><th>配置</th><th>说明</th></tr></thead><tbody><tr><td><code>host</code> 模式</td><td><code>--net=host</code></td><td>容器和宿主机共享 <code>Network namespace</code></td></tr><tr><td><code>container</code> 模式</td><td><code>--net=container:NAMEorID</code></td><td>容器和另外一个容器共享 <code>Network namespace</code>。 <code>kubernetes</code> 中的 <code>pod</code> 就是多个容器共享一个 <code>Network namespace</code>。</td></tr><tr><td><code>none</code> 模式</td><td><code>--net=none</code></td><td>容器有独立的 <code>Network namespace</code>，但并没有对其 进行任何网络设置，如分配 <code>veth pair</code>和网桥连 接，配置 <code>IP</code> 等。</td></tr><tr><td><code>bridge</code> 模式</td><td><code>--net=bridge</code></td><td>（默认为该模式）</td></tr></tbody></table><p><strong>host 模式</strong></p><blockquote><p>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡， 配置自己的 IP 等，而是使用宿主机的 IP 和端口。但是，容器的其他方面，如文件系统、进 程列表等还是和宿主机隔离的</p></blockquote><p>使用 host 模式的容器可以直接使用宿主机的 IP 地址与外界通信，容器内部的服务端口也可 以使用宿主机的端口，不需要进行 NAT，host 最大的优势就是网络性能比较好，但是 docker host 上已经使用的端口就不能再用了，网络的隔离性不好</p><p><img src="https://s.poetries.work/uploads/2022/06/c6301becc0c6096b.png" alt></p><p><strong>container 模式</strong></p><blockquote><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和 宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器 共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还 是隔离的。两个容器的进程可以通过 lo 网卡设备通信</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/eb659e57bfedb72b.png" alt></p><p><strong>none 模式</strong></p><blockquote><p>使用 none 模式，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker 容器进 行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己 为 Docker 容器添加网卡、配置 IP 等。</p></blockquote><p>这种网络模式下容器只有 lo 回环网络，没有其他网卡。none 模式可以在容器创建时通过 <code>--network=none</code> 来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安 全性</p><p><img src="https://s.poetries.work/uploads/2022/06/9edcca445e5df197.png" alt></p><p><strong>bridge 模式</strong></p><blockquote><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有 容器就通过交换机连在了一个二层网络中</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/69625851feead1f2.png" alt></p><p><strong>docker network create 创建网络以及启动容器指定网络</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create --help</span><br></pre></td></tr></table></figure><h4 id="容器直接网络连接演示"><a href="#容器直接网络连接演示" class="headerlink" title="容器直接网络连接演示"></a>容器直接网络连接演示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><p><strong>创建一个 mysqlNet网络</strong></p><ul><li><code>--driver bridge</code> 配置网络类型 <code>bridge</code> 桥接</li><li><code>--subnet 192.168.1.0/24</code> 配置子网 建议每个网络的范围尽量小</li><li><code>--gateway 192.168.1.1</code> 配置网关</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create --driver bridge --subnet 192.168.1.0/24 --gateway 192.168.1.1 mysql Net</span><br></pre></td></tr></table></figure><p><strong>启动容器指定网络</strong></p><p>我们启动容器的时候可以加上 <code>--net</code> 参数可以指定启动容器的时候使用的网络，如果不加表 示默认使用 <code>docker0</code> 网络</p><blockquote><p><code>--net bridge</code> 表示使用 <code>docker0</code> 网络</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -tid --name centos01 centos /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker run -tid --name centos01 --net bridge centos /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p><code>--net mysqlNet</code> 表示使用我们自定义网络 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -tid --name centos04 --net mysqlNet centos /bin/bash</span><br><span class="line">docker run -tid --name centos05 --net mysqlNet centos /bin/bash</span><br></pre></td></tr></table></figure><p>使用主机名称可以 ping 通</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入centos05</span><br><span class="line">docker exec -it centos05 /bin/bash</span><br><span class="line"></span><br><span class="line">$ ping centos04</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it centos05 /bin/bash</span><br><span class="line">[root@5d8bd8036698 /]<span class="comment"># ping centos04</span></span><br><span class="line"></span><br><span class="line">PING centos04 (192.168.1.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos04.mysqlNet (192.168.1.2): icmp_seq=1 ttl=64 time=1.58 ms</span><br><span class="line">64 bytes from centos04.mysqlNet (192.168.1.2): icmp_seq=2 ttl=64 time=0.177 ms</span><br><span class="line">64 bytes from centos04.mysqlNet (192.168.1.2): icmp_seq=3 ttl=64 time=0.123 ms</span><br></pre></td></tr></table></figure><blockquote><p>不同网络的容器默认没法通信</p></blockquote><p>我们在<code>centos05</code>容器内<code>ping centos01</code>容器，结果是不成功的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入centos05</span></span><br><span class="line">docker <span class="built_in">exec</span> -it centos05 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># ping centos01容器网络 (172.17.0.2是centos01网络ip `ip addr`获取)</span></span><br><span class="line">ping 172.17.0.2</span><br></pre></td></tr></table></figure><blockquote><p>这样我们就把 centos04 和 centos05 加入了我们自定义的 mysqlNet 网络，这样的话 centos04 和 centos05 是互通的，但是 mysqlNet 网络和 docker0 网络默认是不互通的</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/a45d6c71c3c73341.png" alt></p><p><strong>docker network connect 实现不同网络之间的连通</strong></p><blockquote><p>如上图，我们想的是 centos01 可以 访问 mysqlNet 里面的 centos04 和 centos05，这个时候 我们就需要使用 docker network connect 实现网络连通</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network connect mysqlNet centos01</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地网络</span></span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure><blockquote><p>查看网络详情</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker network inspect mysqlNet</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"mysqlNet"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"854913f194cab31417f3f589a7970bf0d14a88d74d67bbfbfd15acd79ce774f1"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2022-06-30T03:13:47.053474447Z"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"192.168.1.0/24"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"192.168.1.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"ConfigFrom"</span>: &#123;</span><br><span class="line">            <span class="string">"Network"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ConfigOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"56c1371a31196943da831b3e938d4c0c750e0654d8f103e0745baa125dd6ec81"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"centos01"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"22c7b14acbd9c4ded534e80bd248486a19ccba56a80445788457df1fd8e2e018"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:01:04"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.1.4/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"5d8bd803669872ed21488f6b61077933d50e8009d105c1798da30fd0fcb0ad65"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"centos05"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"bc016cfdfdaa01288d33aa33ad08ff687e32b720c654396bda4d068852c1330c"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:01:03"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.1.3/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"c34b6f27e3a7a8c4956cb3ca965fe63fbabab99c22a3846c8b5aaaa7643de905"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"centos04"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"daf09599773b09cbfd7b92fd14a426dc030c2ce5250277b0726366e2b2c79806"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:c0:a8:01:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"192.168.1.2/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到是ping成功的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> centos01 ping centos05</span><br><span class="line"></span><br><span class="line">PING centos05 (192.168.1.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=1 ttl=64 time=2.28 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=2 ttl=64 time=0.093 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=3 ttl=64 time=0.112 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=4 ttl=64 time=0.105 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=5 ttl=64 time=0.154 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=6 ttl=64 time=0.077 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=7 ttl=64 time=0.158 ms</span><br><span class="line">64 bytes from centos05.mysqlNet (192.168.1.3): icmp_seq=8 ttl=64 time=0.099 ms</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux简单介绍&quot;&gt;&lt;a href=&quot;#Linux简单介绍&quot; class=&quot;headerlink&quot; title=&quot;Linux简单介绍&quot;&gt;&lt;/a&gt;Linux简单介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Linux 是一套开源操作系统，它有稳定、消耗资源小、功能很强、安全性高
      
    
    </summary>
    
      <category term="Back-end" scheme="http://blog.poetries.top/categories/Back-end/"/>
    
    
      <category term="Linux" scheme="http://blog.poetries.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>云开发cloudbase实践总结</title>
    <link href="http://blog.poetries.top/2022/06/25/cloudbase-summary/"/>
    <id>http://blog.poetries.top/2022/06/25/cloudbase-summary/</id>
    <published>2022-06-25T06:40:12.000Z</published>
    <updated>2025-03-30T13:54:29.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、关于云开发介绍"><a href="#一、关于云开发介绍" class="headerlink" title="一、关于云开发介绍"></a>一、关于云开发介绍</h2><p><strong>云开发与serverless的区别</strong></p><ul><li><code>Serverless Framework</code> 是无服务器应用框架，提供将云函数<code>SCF</code>、<code>API</code> 网关、对象存储 <code>COS</code>、云数据库 <code>DB</code> 等资源组合的业务框架，开发者可以直接基于框架编写业务逻辑，而无需关注底层资源的配置和管理。</li><li>云开发（<code>Tencent CloudBase，TCB</code>）是腾讯云提供的云原生一体化开发环境和工具平台，为开发者提供高可用、自动弹性扩缩的后端云服务，包含计算、存储、托管等 <code>serverless</code> 化能力，可用于云端一体化开发多种端应用（小程序、公众号、<code>Web</code> 应用、<code>Flutter</code> 客户端等），帮助开发者统一构建和管理后端服务和云资源，避免了应用开发过程中繁琐的服务器搭建及运维，开发者可以专注于业务逻辑的实现，开发门槛更低，效率更高。</li><li><strong>二者最大的区别是</strong>：给开发者使用的平台支持不一样，云开发支持web端、QQ、微信小程序级静态网站托管等这些平台服务。</li></ul><h2 id="二、使用云开发创建一个nestjs项目"><a href="#二、使用云开发创建一个nestjs项目" class="headerlink" title="二、使用云开发创建一个nestjs项目"></a>二、使用云开发创建一个nestjs项目</h2><p>在产品中选择云开发产品</p><p><img src="https://s.poetries.work/uploads/2022/06/97bfb6a300ede8cb.png" alt></p><blockquote><p>创建一个项目, 这里要选择好区域，下次创建了项目，区域不一样，可能项目就看不到</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/4a9fa09df00ae121.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/f91fc2a56fd7d19f.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/111082e4a79965b8.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/3cae71f70a9723d2.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/4cccec9f4013b9aa.png" alt></p><h2 id="三、使用脚手架的方式创建"><a href="#三、使用脚手架的方式创建" class="headerlink" title="三、使用脚手架的方式创建"></a>三、使用脚手架的方式创建</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><p>全局安装脚手架包<a href="https://docs.cloudbase.net/cli-v1/quick-start" target="_blank" rel="noopener">官方地址</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g @cloudbase/cli</span><br></pre></td></tr></table></figure><blockquote><p>为了简化输入，cloudbase 命令可以简写成 tcb</p></blockquote><p>测试安装是否成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb -v</span><br></pre></td></tr></table></figure><p>查看命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb -h</span><br></pre></td></tr></table></figure><h3 id="3-2-登录"><a href="#3-2-登录" class="headerlink" title="3.2 登录"></a>3.2 登录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># CloudBase CLI 会自动打开云开发控制台获取授权，您需要点击同意授权按钮允许 CloudBase CLI 获取授权。如您没有登录，您需要登录后才能进行此操作。</span><br><span class="line"></span><br><span class="line">tcb login</span><br></pre></td></tr></table></figure><p>也可以使用下面的方式通过 API 秘钥直接登录，避免交互式输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb login --apiKeyId xxx --apiKey xxx</span><br></pre></td></tr></table></figure><h3 id="3-3-创建项目"><a href="#3-3-创建项目" class="headerlink" title="3.3 创建项目"></a>3.3 创建项目</h3><p>本地创建项目</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcb new [options] [appName] [templateUri]</span><br><span class="line"><span class="comment"># 比如</span></span><br><span class="line">tcb new nest-cloundbase nest-starter</span><br></pre></td></tr></table></figure><blockquote><p>云开发项目是和云开发环境资源关联的实体，云开发项目聚合了云函数、数据库、文件存储等服务，您可以在云开发项目中编写函数，存储文件，并通过 CloudBase 快速的操作您的云函数、文件存储、数据库等资源。</p></blockquote><p><strong>云开发项目文件结构：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .gitignore</span><br><span class="line">├── functions // 云函数目录</span><br><span class="line">│   └── node-app</span><br><span class="line">│       └── index.js</span><br><span class="line">└── cloudbaserc.json // 项目配置文件</span><br></pre></td></tr></table></figure><p>选择自己已经创建的环境,如果没有就 创建新环境,这时候会打开浏览器</p><p><img src="https://s.poetries.work/uploads/2022/06/6b018bec4591c9aa.png" alt></p><p>本地打开项目并且安装依赖包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>部署到线上</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用 tcb framework deploy</span></span><br><span class="line">npm run deploy</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/c9016bdd4a84dac4.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/00b5a9d585e5f5ee.png" alt></p><p>部署完成后可以使用 <code>tcb fn list</code> 命令查看已经部署完成的函数列表</p><p><img src="https://s.poetries.work/uploads/2022/06/d83d3bfc9b7d025b.png" alt></p><h3 id="3-4-环境"><a href="#3-4-环境" class="headerlink" title="3.4 环境"></a>3.4 环境</h3><p><strong>查看所有环境</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb env list</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/417413944366f8e2.png" alt></p><p><strong>安全域名</strong></p><blockquote><p>当您需要在网页应用中使用云开发的身份验证服务时，您需要将您的网站的域名（发起请求的页面的域名）加入安全域名名单中。安全域名是云开发服务认可的用户请求来源域名，所有来自非安全域名名单中的请求都不会被响应。</p></blockquote><p>使用下面的命令查看所有配置的安全域名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb env domain list</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/efa5ad40c4f22218.png" alt></p><p>新增安全域名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加一个域名</span><br><span class="line">tcb env domain create www.xxx.com</span><br><span class="line"></span><br><span class="line"># 添加多个域名</span><br><span class="line">tcb env domain create www.domain1.com/www.domain2.com/www.domain3.com</span><br></pre></td></tr></table></figure><p>删除安全域名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb env domain delete</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/0f6c3726e168a64b.png" alt></p><p><strong>登录方式</strong></p><blockquote><p>当您需要使用云开发的身份验证服务时，您需要配置您想使用的登录方式。目前云开发支持自定义登录、微信公众平台、微信开放平台登录等多种登录方式。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 您可以使用下面的命令列出环境配置的登录方式列表，查看环境配置的登录方式，以及相关的状态。</span><br><span class="line"></span><br><span class="line">tcb env login list</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/0afa72546600b36a.png" alt></p><p>您可以使用下面的命令新建登录方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb env login create</span><br></pre></td></tr></table></figure><blockquote><p>您需要选择配置的平台，登录方式状态，以及对应的 AppId 和 AppSecret，登录方式请选择启用。在添加方式时不会校验 AppId 和 AppSecret 的有效性，只有在请求时，AppId 和 AppSecret 才会被校验，所以请确保您添加的 AppId 和 AppSecret 是有效的。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/14072565a7df9cfc.png" alt></p><p>修改登录方式</p><blockquote><p>您也可以使用 <code>tcb env login update</code> 修改已经配置的登录方式，如切换启用状态，修改 AppId 和 AppSecret。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/4c5a0f883f8093dd.png" alt></p><h4 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h4><blockquote><p>在 <code>cloudbaserc.json</code> 中声明 <code>&quot;version&quot;: &quot;2.0&quot;</code> 即可启用新的特性，新版配置文件只支持 JSON 格式</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态变量特性允许在 `cloudbaserc.json` 配置文件中使用动态变量，从环境变量或其他数据源获取动态的数据。使用 `&#123;&#123;&#125;&#125;` 包围的值定义为动态变量，可以引用数据源中的值。如下所示</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"envId"</span>,</span><br><span class="line">  <span class="string">"functionRoot"</span>: <span class="string">"./functions"</span>,</span><br><span class="line">  <span class="string">"functions"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"&#123;&#123;variable&#125;&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>CloudBase 支持使用 <code>.env</code> 类型文件作为主要数据源，使用不同的后缀区分不同的阶段、场景，如 <code>.env.development</code> 可以表示开发阶段的配置，<code>.env.production</code> 可以表示生产环境的配置</p><blockquote><p>当指定 <code>--mode [mode]</code> 时，会再加载 <code>.env.[mode]</code> 文件，并按照如下的顺序合并覆盖同名变量：<code>.env.[mode] &gt; .env.local &gt; .env</code> 即 <code>.env.[mode]</code> 中的同名变量会覆盖 <code>.env.local</code> 和 <code>.env</code> 文件中的同名变量</p></blockquote><blockquote><p>当使用 <code>tcb framework deploy --mode test</code> 命令时，会自动加载 <code>.env</code>，<code>.env.local</code> 以及 <code>.env.test</code> 等三个文件中的环境变量合并使用。</p></blockquote><p>我们建议你将秘钥等私密配置放在 <code>.env.local</code> 文件中，并将 <code>.env.local</code> 加入 <code>.gitignore</code> 配置中</p><p>如 <code>.env.local</code> 文件中存在以下变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DB_HOST = localhost</span><br><span class="line">DB_USER = root</span><br><span class="line">DB_PASSWORD = s1mpl3</span><br></pre></td></tr></table></figure><p>则可以在配置文件中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"xxx"</span>,</span><br><span class="line">  <span class="string">"functionRoot"</span>: <span class="string">"./functions"</span>,</span><br><span class="line">  <span class="string">"functions"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"test"</span>,</span><br><span class="line">      <span class="string">"envVariables"</span>: &#123;</span><br><span class="line">        <span class="string">"PASSWORD"</span>: <span class="string">"&#123;&#123;env.DB_PASSWORD&#125;&#125;"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-云函数操作"><a href="#3-5-云函数操作" class="headerlink" title="3.5 云函数操作"></a>3.5 云函数操作</h3><h4 id="函数配置cloudbaserc-json"><a href="#函数配置cloudbaserc-json" class="headerlink" title="函数配置cloudbaserc.json"></a>函数配置cloudbaserc.json</h4><p>参考配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://docs.cloudbase.net/cli/functions/configs</span></span><br><span class="line"><span class="comment">// https://docs.cloudbase.net/cli-v1/functions/configs</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// version 表示当前配置文件的版本，目前支持的版本号有："2.0"。当 version 字段不存在时，默认当前配置文件为 "1.0" 版本。</span></span><br><span class="line">  <span class="string">"version"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="comment">// 关联环境 ID</span></span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"dev-xxxx"</span>,</span><br><span class="line">  <span class="string">"functionRoot"</span>: <span class="string">"./functions"</span>, <span class="comment">// 云函数函数代码存放的文件夹路径，相对于根目录的路径。</span></span><br><span class="line">  <span class="comment">// region 指定了当前环境的地域信息，上海地域的环境可以不填，其他地域的环境则必须填写。</span></span><br><span class="line">  <span class="string">"region"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="comment">// 函数配置项组成的数组</span></span><br><span class="line">  <span class="string">"functions"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// functions 文件夹下函数文件夹的名称，即函数名</span></span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"app"</span>,</span><br><span class="line">      <span class="comment">// 超时时间，单位：秒 S</span></span><br><span class="line">      <span class="string">"timeout"</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="comment">// 环境变量</span></span><br><span class="line">      <span class="string">"envVariables"</span>: &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"value"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 私有网络配置，如果不使用私有网络，可不配置</span></span><br><span class="line">      <span class="string">"vpc"</span>: &#123;</span><br><span class="line">        <span class="comment">// vpc id</span></span><br><span class="line">        <span class="string">"vpcId"</span>: <span class="string">"vpc-xxx"</span>,</span><br><span class="line">        <span class="comment">// 子网 id</span></span><br><span class="line">        <span class="string">"subnetId"</span>: <span class="string">"subnet-xxx"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 运行时，目前可选运行包含：Nodejs8.9, Nodejs10.15, Php7, Java8</span></span><br><span class="line">      <span class="comment">// 此参数可以省略，默认为 Nodejs10.15</span></span><br><span class="line">      <span class="string">"runtime"</span>: <span class="string">"Nodejs10.15"</span>,</span><br><span class="line">      <span class="comment">// 是否云端安装依赖，仅支持 Node.js 项目</span></span><br><span class="line">      <span class="string">"installDependency"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 函数触发器，说明见文档: https://cloud.tencent.com/document/product/876/32314</span></span><br><span class="line">      <span class="string">"triggers"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// name: 触发器的名字</span></span><br><span class="line">          <span class="string">"name"</span>: <span class="string">"myTrigger"</span>,</span><br><span class="line">          <span class="comment">// type: 触发器类型，目前仅支持 timer （即定时触发器）</span></span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"timer"</span>,</span><br><span class="line">          <span class="comment">// config: 触发器配置，在定时触发器下，config 格式为 cron 表达式</span></span><br><span class="line">          <span class="string">"config"</span>: <span class="string">"0 0 2 1 * * *"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="comment">// 函数处理入口，Node.js 和 PHP 项目可以省略，默认值为 index.main</span></span><br><span class="line">      <span class="comment">// 因 Java 的 handler 配置较为特殊，所以当运行时为 Java 时，handler 不能省略</span></span><br><span class="line">      <span class="comment">// 如：package.Class::mainHandler</span></span><br><span class="line">      <span class="string">"handler"</span>: <span class="string">"index.main"</span>,</span><br><span class="line">      <span class="comment">// functions:invoke 本地触发云函数时的调用参数</span></span><br><span class="line">      <span class="string">"params"</span>: &#123;&#125;,</span><br><span class="line">      <span class="comment">// 部署/更新云函数时忽略的文件</span></span><br><span class="line">      <span class="string">"ignore"</span>: [</span><br><span class="line">        <span class="comment">// 忽略 markdown 文件</span></span><br><span class="line">        <span class="string">"*.md"</span>,</span><br><span class="line">        <span class="comment">// 忽略 node_modules 文件夹</span></span><br><span class="line">        <span class="string">"node_modules"</span>,</span><br><span class="line">        <span class="string">"node_modules/**/*"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面为目前所有支持的配置项</p><table><thead><tr><th>配置项</th><th>是否必填</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>是</td><td>String</td><td>云函数名称，即为函数部署后的名称</td></tr><tr><td>params</td><td>否</td><td>Object/JSONObject</td><td>CIL 调用云函数时的函数入参</td></tr><tr><td>triggers</td><td>否</td><td><a href="https://docs.cloudbase.net/cli-v1/functions/configs#cloudfunctiontrigger" target="_blank" rel="noopener"><code>Array</code></a></td><td>触发器配置</td></tr><tr><td>handler</td><td>否</td><td>String</td><td>函数处理方法名称，名称格式支持“文件名称.函数名称”形式</td></tr><tr><td>ignore</td><td>否</td><td><code>String/Array&lt;String&gt;</code></td><td>部署/更新云函数代码时的忽略文件，支持 glob 匹配规则</td></tr><tr><td>timeout</td><td>否</td><td>Number</td><td>函数超时时间（1 - 60S）</td></tr><tr><td>envVariables</td><td>否</td><td>Object</td><td>包含环境变量的键值对对象</td></tr><tr><td>vpc</td><td>否</td><td><a href="https://docs.cloudbase.net/cli-v1/functions/configs#vpc" target="_blank" rel="noopener">VPC</a></td><td>私有网络配置</td></tr><tr><td>runtime</td><td>否</td><td>String</td><td>运行时环境配置，可选值： <code>Nodejs8.9, Nodejs10.15 Php7, Java8</code></td></tr><tr><td>memorySize</td><td>否</td><td>Number</td><td>函数内存，默认值为 256，可选 128、256、512、1024、2048</td></tr><tr><td>installDependency</td><td>否</td><td>Boolean</td><td>是否云端安装依赖，目前仅支持 Node.js</td></tr><tr><td>codeSecret</td><td>否</td><td>String</td><td>代码加密秘钥，格式为 36 位大小写字母、数字</td></tr></tbody></table><ul><li><strong>注：<code>runtime</code> 默认为 <code>Nodejs10.15</code>，使用 Node.js 运行时可不填，使用 Php 和 Java 则必填。</strong></li><li><strong>启用代码加密后，将无法在小程序 IDE、腾讯云控制台中查看云函数的代码和信息</strong></li></ul><p><strong>CloudFunctionTrigger</strong></p><table><thead><tr><th>名称</th><th>是否必填</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>是</td><td>String</td><td>触发器名称</td></tr><tr><td>type</td><td>是</td><td>String</td><td>触发器类型，可选值：timer</td></tr><tr><td>config</td><td>是</td><td>String</td><td>触发器配置，在定时触发器下，config 格式为 cron 表达式</td></tr></tbody></table><p><strong>VPC</strong></p><table><thead><tr><th>名称</th><th>是否必填</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>vpcId</td><td>是</td><td>String</td><td>VPC Id</td></tr><tr><td>subnetId</td><td>是</td><td>String</td><td>VPC 子网 Id</td></tr></tbody></table><p><strong>更新函数运行时配置</strong></p><blockquote><p>创建函数式，Cloudbase CLI 会为函数提供一些默认的配置，所以您不需要添加配置信息也可以直接部署函数。您也可以通过下面的命令修改函数的运行时配置</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 更新 app 函数的配置</span><br><span class="line">tcb fn config update app</span><br><span class="line"></span><br><span class="line"># 更新配置文件中所有函数的配置信息</span><br><span class="line">tcb fn config update</span><br></pre></td></tr></table></figure><p>目前支持修改的函数配置包含超时时间 <code>timeout</code>、环境变量 <code>envVariables</code>、运行时 <code>runtime</code>，vpc网络以及 <code>installDependency</code> 等选项。</p><p>CloudBase CLI 会从配置文件中读取函数的配置信息并更新，CloudBase CLI 会更新配置文件中存在的函数的所有配置，暂不支持指定更新单个配置选项。</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><blockquote><p><code>fn deploy</code> 命令部署函数的文件大小总计不能超过 <code>50 M</code>，否则可能会部署失败。</p></blockquote><p>在一个包含 <code>cloudbaserc.json</code> 配置文件的项目下，您可以直接使用下面的命令部署云函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb fn deploy &lt;functionName&gt;</span><br></pre></td></tr></table></figure><p>使用 <code>fn deploy</code> 时，<code>functionName</code> 选项是可以省略的，当 <code>functionName</code> 省略时，Cloudbase CLI 会部署配置文件中的全部函数：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署配置文件中的全部函数</span></span><br><span class="line">tcb fn deploy</span><br></pre></td></tr></table></figure><p>全部参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: tcb fn deploy [options] [name]</span><br><span class="line"></span><br><span class="line">部署云函数</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -e, --envId &lt;envId&gt;         环境 Id</span><br><span class="line">  --code-secret &lt;codeSecret&gt;  传入此参数将保护代码，格式为 36 位大小写字母和数字</span><br><span class="line">  --force                     如果存在同名函数，上传后覆盖同名函数</span><br><span class="line">  --path &lt;path&gt;               自动创建HTTP 访问服务访问路径</span><br><span class="line">  --all                       部署配置文件中的包含的全部云函数</span><br><span class="line">  --dir &lt;dir&gt;                 指定云函数的文件夹路径</span><br><span class="line">  -h, --help                  查看命令帮助信息</span><br></pre></td></tr></table></figure><p><strong>默认选项</strong></p><p>Cloudbase CLI 为 Node.js 云函数提供了默认选项，您在部署 Node.js 云函数时可以不用指定云函数的配置，使用默认配置即可部署云函数。</p><p>云函数默认配置：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 超时时间 5S</span><br><span class="line">  "timeout": 5,</span><br><span class="line">  // 运行时</span><br><span class="line">  "runtime": "Nodejs10.15",</span><br><span class="line">  // 自动安装依赖</span><br><span class="line">  "installDependency": true,</span><br><span class="line">  // 处理入口</span><br><span class="line">  "handler": "index.main",</span><br><span class="line">  // 忽略 node_modules 目录</span><br><span class="line">  "ignore": ["node_modules", "node_modules/**/*", ".git"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>deploy 命令做了啥</strong></p><p><code>fn deploy</code> 会读取 <code>cloudbaserc.json</code> 文件中指定函数的配置，并完成以下几项工作</p><ul><li>将函数打包成压缩文件，并上传函数代码。</li><li>部署函数配置，包括超时时间、网络配置等。</li><li>部署函数触发器。</li></ul><h4 id="管理云函数"><a href="#管理云函数" class="headerlink" title="管理云函数"></a>管理云函数</h4><ul><li>您可以使用下面的命令列出所有云函数，查看函数的基本信息：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb fn list</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/7f14d68f7629334e.png" alt></p><ul><li>指定返回条数和偏移量</li></ul><blockquote><p>默认情况下，<code>fn list</code> 命令只会列出前 <code>20</code> 个函数，如果您的函数较多，需要列出其他的函数，您可以通过下面的选项指定命令返回的数据长度以及数据的偏移量：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-l, --limit &lt;limit&gt;    返回数据长度，默认值为 20</span><br><span class="line">-o, --offset &lt;offset&gt;  数据偏移量，默认值为 0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 返回前 10 个函数的信息</span><br><span class="line">tcb fn list -l 10</span><br><span class="line"># 返回第 3 - 22 个函数的信息（包含 3 和 22）</span><br><span class="line">tcb fn list -l 20 -o 2</span><br></pre></td></tr></table></figure><ul><li>下载云函数代码</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb fn code download &lt;functionName&gt; [destPath]</span><br></pre></td></tr></table></figure><p>默认情况下，函数代码会下载到 <code>functionRoot</code> 下，以函数名称作为存储文件夹，您可以指定函数存放的文件夹地址，函数的所有代码文件会直接下载到指定的文件夹中。</p><p><img src="https://s.poetries.work/uploads/2022/06/d3b9aed0b63bb50b.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/c4dc431bcd542129.png" alt></p><ul><li>查看函数详情</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看 vue-echo 函数的详情</span><br><span class="line">tcb fn detail vue-echo</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/2437d329c6b5e767.png" alt></p><ul><li>删除函数</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除 app 函数</span><br><span class="line">tcb fn delete app</span><br><span class="line"></span><br><span class="line"># 删除配置文件中的所有的函数</span><br><span class="line">tcb fn delete</span><br></pre></td></tr></table></figure><ul><li>复制函数</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 复制 app 函数为 app2 函数</span><br><span class="line">tcb fn copy app app2</span><br></pre></td></tr></table></figure><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>触发器是按照一定规则触发函数的模块的抽象，CloudBase 云函数目前仅支持定时触发器。</p><blockquote><p>如果云函数需要定时/定期执行，即定时触发，您可以使用云函数定时触发器。已配置定时触发器的云函数，会在相应时间点被自动触发，函数的返回结果不会返回给调用方。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"xxx"</span>,</span><br><span class="line">  <span class="string">"functions"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// triggers 字段是触发器数组，目前仅支持一个触发器，即数组只能填写一个，不可添加多个</span></span><br><span class="line">      <span class="string">"triggers"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// name: 触发器的名字，规则见下方说明</span></span><br><span class="line">          <span class="string">"name"</span>: <span class="string">"myTrigger"</span>,</span><br><span class="line">          <span class="comment">// type: 触发器类型，目前仅支持 timer （即定时触发器）</span></span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"timer"</span>,</span><br><span class="line">          <span class="comment">// config: 触发器配置，在定时触发器下，config 格式为 cron 表达式，规则见下方说明</span></span><br><span class="line">          <span class="string">"config"</span>: <span class="string">"0 0 2 1 * * *"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建函数触发器</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建 app 函数配置的触发器</span><br><span class="line">tcb fn trigger create app</span><br></pre></td></tr></table></figure><blockquote><p>Cloudbase CLI 会自动读取 <code>cloudbaserc.json</code> 文件中指定函数配置的定时触发器，并创建云函数触发器。如果配置文件中没有包含触发器配置，则会创建失败。</p></blockquote><p>一个函数可以包含多个触发器，一个触发器包含了以下 3 个主要信息：<code>name</code>, <code>type</code>, <code>config</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// name: 触发器的名字，规则见下方说明</span></span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"myTrigger"</span>,</span><br><span class="line">  <span class="comment">// type: 触发器类型，目前仅支持 timer （即定时触发器）</span></span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"timer"</span>,</span><br><span class="line">  <span class="comment">// config: 触发器配置，在定时触发器下，config 格式为 cron 表达式</span></span><br><span class="line">  <span class="string">"config"</span>: <span class="string">"0 0 2 1 * * *"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有指定函数名时，Cloudbase CLI 会创建 <code>cloudbaserc.json</code> 文件包含的所有函数的所有触发器</p><p><strong>删除函数触发器</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除 app 函数的名为 trigger 的触发器</span><br><span class="line">tcb fn trigger delete app trigger</span><br></pre></td></tr></table></figure><blockquote><p>当没有指定函数名时，Cloudbase CLI 会删除 <code>cloudbaserc.json</code> 文件包含的所有函数的所有触发器。当只指定了函数名时，Cloudbase CLI 会删除指定函数的所有触发器，当同时指定了函数名称和触发器名称时，Cloudbase CLI 只会删除指定的触发器。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除 cloudbaserc.json 文件中所有函数的所有触发器</span></span><br><span class="line">tcb fn trigger delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除函数 app 的所有触发器</span></span><br><span class="line">tcb fn trigger delete app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除函数 app 的触发器 trigger</span></span><br><span class="line">tcb fn trigger delete app trigger</span><br></pre></td></tr></table></figure><p><strong>触发器规则</strong></p><ul><li>定时触发器名称（name） ：最大支持 <code>60</code> 个字符，支持 <code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, <code>-</code> 和 <code>_</code>。必须以字母开头，且一个函数下不支持同名的多个定时触发器。</li><li>定时触发器触发周期（config）：指定的函数触发时间。填写自定义标准的 Cron 表达式来决定何时触发函数。有关 Cron 表达式的更多信息，请参考以下内容。</li></ul><p>Cron 表达式有七个必需字段，按空格分隔。其中，每个字段都有相应的取值范围：</p><table><thead><tr><th>排序</th><th>字段</th><th>值</th><th>通配符</th></tr></thead><tbody><tr><td>第一位</td><td>秒</td><td>0 - 59 的整数</td><td><code>, - * /</code></td></tr><tr><td>第二位</td><td>分钟</td><td>0 - 59 的整数</td><td><code>, - * /</code></td></tr><tr><td>第三位</td><td>小时</td><td>0 - 23 的整数</td><td><code>, - * /</code></td></tr><tr><td>第四位</td><td>日</td><td>1 - 31 的整数（需要考虑月的天数）</td><td><code>, - * /</code></td></tr><tr><td>第五位</td><td>月</td><td>1 - 12 的整数或 JAN、FEB、MAR、APR、MAY、JUN、JUL、AUG、SEP、OCT、NOV 和 DEC</td><td><code>, - * /</code></td></tr><tr><td>第六位</td><td>星期</td><td>0 - 6 的整数或 MON、TUE、WED、THU、FRI、SAT 和 SUN，其中 0 指周日，1 指星期一，以此类推</td><td><code>, - * /</code></td></tr><tr><td>第七位</td><td>年</td><td>1970 - 2099 的整数</td><td><code>, - * /</code></td></tr></tbody></table><p><strong>通配符</strong></p><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td><code>，</code>（逗号）</td><td>代表取用逗号隔开的字符的并集。例如：在“小时”字段中 1，2，3 表示 1 点、2 点和 3 点</td></tr><tr><td><code>-</code>（短横线）</td><td>包含指定范围的所有值。例如：在“日”字段中，1 - 15 包含指定月份的 1 号到 15 号</td></tr><tr><td><code>*</code>（星号）</td><td>表示所有值。在“小时”字段中，<code>*</code> 表示每个小时</td></tr><tr><td><code>/</code>（正斜杠）</td><td>指定增量。在“分钟”字段中，输入 1/10 以指定从第一分钟开始的每隔十分钟重复。例如，第 11 分钟、第 21 分钟和第 31 分钟，以此类推</td></tr></tbody></table><blockquote><p>!在 Cron 表达式中的“日”和“星期”字段同时指定值时，两者为“或”关系，即两者的条件均生效。</p></blockquote><p><strong>下面列举一些 <code>Cron</code> 表达式和相关含义：</strong></p><ul><li><code>*/5 * * * * * *</code> 表示每 5 秒触发一次</li><li><code>0 0 2 1 * * *</code> 表示在每月的 1 日的凌晨 2 点触发</li><li><code>0 15 10 * * MON-FRI *</code> 表示在周一到周五每天上午 10:15 触发</li><li><code>0 0 10,14,16 * * * *</code> 表示在每天上午 10 点，下午 2 点，下午 4 点触发</li><li><code>0 */30 9-17 * * * *</code> 表示在每天上午 9 点到下午 5 点内每半小时触发</li><li><code>0 0 12 * * WED *</code> 表示在每个星期三中午 12 点触发</li></ul><h4 id="代码更新"><a href="#代码更新" class="headerlink" title="代码更新"></a>代码更新</h4><p>当您的函数代码发生改变时，您可以使用下面的命令更新您的云函数的代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新 app 函数的代码</span></span><br><span class="line">tcb fn code update app</span><br></pre></td></tr></table></figure><blockquote><p><code>fn code update</code> 命令和 <code>fn deploy</code> 命令的主要区别是：<code>fn code update</code> 命令只会更新函数的代码以及执行入口，不会修改函数的其他配置，而 <code>fn deploy</code> 命令则会修改函数的代码、配置以及触发器等。</p></blockquote><h4 id="函数版本"><a href="#函数版本" class="headerlink" title="函数版本"></a>函数版本</h4><p>您可以通过下面的命令查看函数版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb fn list-function-versions &lt;name&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/88eb3713574d7f1b.png" alt></p><h4 id="函数日志"><a href="#函数日志" class="headerlink" title="函数日志"></a>函数日志</h4><p>您可以通过下面的命令打印云函数的运行日志，使用此命令时必须指定函数的名称：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看 vue-echo 函数的调用日志</span><br><span class="line">tcb fn log vue-echo</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/8f3777524f8f6e77.png" alt></p><p>默认情况下，Cloudbase CLI 会打印最近的 20 条日志，您可以通过在命令后附加下面的可用选项指定返回日志的筛选条件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-i, --reqId &lt;reqId&gt;  函数请求 Id</span><br><span class="line">-o, --offset &lt;offset&gt;                        数据的偏移量，Offset + Limit不能大于10000</span><br><span class="line">-l, --limit &lt;limit&gt;                          返回数据的长度，Offset + Limit不能大于10000</span><br><span class="line">--order &lt;order&gt;                              以升序还是降序的方式对日志进行排序，可选值 desc 和 asc</span><br><span class="line">--orderBy &lt;orderBy&gt;                          根据某个字段排序日志,支持以下字段：function_name,duration, mem_usage, start_time</span><br><span class="line">--startTime &lt;startTime&gt;                      查询的具体日期，例如：2019-05-16 20:00:00，只能与endtime 相差一天之内</span><br><span class="line">--endTime &lt;endTime&gt;                          查询的具体日期，例如：2019-05-16 20:59:59，只能与startTime 相差一天之内</span><br><span class="line">-e, --error                                  只返回错误类型的日志</span><br><span class="line">-s, --success                                只返回正确类型的日志</span><br></pre></td></tr></table></figure><p>如：<code>tcb fn log app -l 2</code> 打印 <code>app</code> 函数的最新 2 条日志信息</p><h4 id="部署示例"><a href="#部署示例" class="headerlink" title="部署示例"></a>部署示例</h4><ul><li>编写<code>cloudbaserc.json文件</code></li></ul><p><img src="https://s.poetries.work/uploads/2022/06/705a1f9853edda3a.png" alt></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"envId"</span>: <span class="string">"poetry-prod-xx"</span>,</span><br><span class="line">  <span class="attr">"functionRoot"</span>: <span class="string">"./cloudfunctions"</span>,</span><br><span class="line">  <span class="attr">"functions"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"vue-echo"</span>,</span><br><span class="line">      <span class="attr">"timeout"</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">"runtime"</span>: <span class="string">"Nodejs10.15"</span>,</span><br><span class="line">      <span class="attr">"installDependency"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>部署，执行以下命令，部署指定函数名称</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb fn deploy vue-echo</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/840a923b27e4ee59.png" alt></p><ul><li>查看已部署的函数</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb fn list</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/7f14d68f7629334e.png" alt></p><h3 id="3-6-静态网站托管"><a href="#3-6-静态网站托管" class="headerlink" title="3.6 静态网站托管"></a>3.6 静态网站托管</h3><blockquote><p>云开发为开发者提供静态网页托管的能力，静态资源（HTML、CSS、JavaScript、字体等）的分发由对象存储 COS 和拥有多个边缘网点的 CDN 提供支持。您可在腾讯云控制台进行静态网站的部署，提供给您的用户访问。目前云开发静态网页托管能力仅在腾讯云云开发控制台支持，小程序 IDE 侧控制台暂不支持。</p></blockquote><p>仅有付费方式为按量付费的环境可开通静态网页托管能力，预付费方式环境不可开通。</p><p>使用 CLI 操作静态网站服务前请先到<a href="https://console.cloud.tencent.com/tcb" target="_blank" rel="noopener">云开发控制台开通静态网站服务</a>。</p><p><strong>全量部署</strong></p><blockquote><p>云开发 CLI 提供了直接部署网站文件的命令，在您需要部署的文件夹目录下，直接运行 <code>tcb hosting deploy</code> 命令即可将当前目前下所有的文件部署静态网站中。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dist 构建目录</span></span><br><span class="line"><span class="built_in">cd</span> dist</span><br><span class="line"><span class="comment"># 部署全部文件</span></span><br><span class="line">tcb hosting deploy -e envId</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/cd6fa613aa0ba32c.png" alt></p><p><strong>您可以使用下面的命令展示静态网站的状态，访问域名等信息</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/08f8a4eed05f40c3.png" alt></p><p><strong>删除文件</strong></p><p>您可以使用下面的命令删除静态网站的存储空间中的文件或文件夹</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cloudPath 为文件或文件夹的相对根目录的路径，为 目录/文件名 的形式，如 index.js、static/css/index.js 等</span><br><span class="line"></span><br><span class="line">tcb hosting delete cloudPath -e envId</span><br></pre></td></tr></table></figure><p><strong>删除全部文件</strong></p><p>云端路径为空时，表示删除全部文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb hosting delete -e envId</span><br></pre></td></tr></table></figure><p><strong>查看文件列表</strong></p><p>您可以使用下面的命令部署展示静态网站存储空间中文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb hosting list -e envId</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/68112e40d3a20d26.png" alt></p><h2 id="四、云开发登录鉴权"><a href="#四、云开发登录鉴权" class="headerlink" title="四、云开发登录鉴权"></a>四、云开发登录鉴权</h2><blockquote><p>CloudBase 提供跨平台的登录鉴权功能，您可以基于此为自己的应用构建用户体系，包括但不限于：</p></blockquote><ul><li>为用户分配全局唯一的身份标识 uid；</li><li>储存和管理用户个人信息；</li><li>关联多种登录方式；</li><li>管理用户对数据、资源的访问权限；</li><li>用户行为的收集和分析。</li></ul><blockquote><p>同时，CloudBase 登录鉴权还是保护您的服务资源的重要手段，CloudBase 对用户端发来的每一个请求，都会进行身份和权限的检查，避免您的资源被恶意攻击者消耗或者盗用。</p></blockquote><h3 id="4-1-登录鉴权"><a href="#4-1-登录鉴权" class="headerlink" title="4.1 登录鉴权"></a>4.1 登录鉴权</h3><p><img src="https://s.poetries.work/uploads/2022/06/015d7200d6f0ed7b.png" alt></p><blockquote><p>每个登录 CloudBase 的用户，都有一个对应的 CloudBase 账号，用户通过此账号访问调用 CloudBase 的数据与资源。</p></blockquote><ul><li>每个账号都有全局唯一的 UID，即账号 ID，作为用户的唯一身份标识</li><li>每个账号可以添加、修改用户信息</li><li>每个账号除了最初的登录方式之外，还可以关联其它登录方式</li></ul><p><strong>登录状态的持久化</strong></p><p>您可以指定登录状态如何持久保留。默认为 <code>local</code>，相关选项包括</p><p><img src="https://s.poetries.work/uploads/2022/06/aafc37032a793f1c.png" alt></p><p>例如，对于网页应用，最佳选择是 <code>local</code>，即在用户关闭浏览器之后仍保留该用户的会话。这样，用户不需要每次访问该网页时重复登录，避免给用户带来诸多不便体验。</p><p><strong>访问令牌与刷新令牌</strong></p><p>用户登录 CloudBase 之后，会获得访问令牌（<code>Access Token</code>） 作为访问 <code>CloudBase</code> 的凭证，访问令牌默认具有两小时有效期。</p><p>登录时还会获得刷新令牌（Refresh Token），默认有效期 30 天，用于访问令牌过期后，获取新的访问令牌。</p><p>CloudBase 用户端 SDK 会自动维护令牌的刷新和有效期，开发者无需特别关注此流程。</p><blockquote><p>匿名登录 的刷新令牌（<code>Refresh Token</code>）会在到期后自动续期，以实现长期的匿名登录状态。</p></blockquote><h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4><p><strong>获取当前登录的用户</strong></p><ul><li>订阅登录状态变化的回调函数</li></ul><blockquote><p>获取当前用户，推荐在 <code>Auth</code> 对象上设置一个回调函数，每当用户登录状态转变时，会触发这个回调函数，并且获得当前的 <code>LoginState</code>：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cloudbase <span class="keyword">from</span> <span class="string">"@cloudbase/js-sdk"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">  env: <span class="string">"your-env-id"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> auth = app.auth();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个观察者</span></span><br><span class="line">auth.onLoginStateChanged(<span class="function">(<span class="params">loginState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (loginState) &#123;</span><br><span class="line">    <span class="comment">// 此时用户已经登录</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有登录</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>直接获取当前用户</li></ul><blockquote><p>您还可以使用 <code>Auth.currentUser</code> 属性来获取当前登录的用户。如果用户未登录，则 <code>currentUser</code> 为 null</p></blockquote><p>您还可以使用 <code>Auth.currentUser</code> 属性来获取当前登录的用户。如果用户未登录，则 <code>currentUser</code> 为 <code>null</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = auth.currentUser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user) &#123;</span><br><span class="line">  <span class="comment">// 此时用户已经登录</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 没有登录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取用户个人资料</strong></p><blockquote><p>您可以通过 <code>User</code> 对象的各个属性来获取用户的个人资料信息：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = auth.currentUser;</span><br><span class="line"><span class="keyword">let</span> uid, nickName, gender, avatarUrl, location;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user) &#123;</span><br><span class="line">  <span class="comment">// 云开发唯一用户 id</span></span><br><span class="line">  uid = user.uid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 昵称</span></span><br><span class="line">  nickName = user.nickName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 性别</span></span><br><span class="line">  gender = user.gender;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 头像URL</span></span><br><span class="line">  avatarUrl = user.avatarUrl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用户地理位置</span></span><br><span class="line">  location = user.location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>更新用户个人资料</strong></p><p>您可以使用 <code>User.update</code> 方法来更新用户的个人资料信息。例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = auth.currentUser;</span><br><span class="line"></span><br><span class="line">user</span><br><span class="line">  .update(&#123;</span><br><span class="line">    nickName: <span class="string">"Tony Stark"</span>,</span><br><span class="line">    gender: <span class="string">"MALE"</span>,</span><br><span class="line">    avatarUrl: <span class="string">"https://..."</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 更新用户资料成功</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>刷新用户资料信息</strong></p><p>对于一个多端应用，用户可能在其中某个端上更新过自己的个人资料信息，此时其它端上可能需要刷新信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = auth.currentUser;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新用户信息</span></span><br><span class="line">user.refresh().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 刷新后，获取到的用户信息即为最新的信息</span></span><br><span class="line">  <span class="keyword">const</span> &#123; nickName, gender, avatarUrl &#125; = user;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="账户关联"><a href="#账户关联" class="headerlink" title="账户关联"></a>账户关联</h4><p><strong>关联微信登录</strong></p><ul><li>用户以任意一种登录方式（除微信登录）登录云开发</li><li>获取 Provider：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = app.auth();</span><br><span class="line"><span class="keyword">const</span> provider = auth.weixinAuthProvider(&#123;</span><br><span class="line">  appid: <span class="string">"...."</span>,</span><br><span class="line">  scope: <span class="string">"snsapi_base"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>重定向到提供方的页面进行登录：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">auth.currentUser.linkWithRedirect(provider);</span><br></pre></td></tr></table></figure><p>用户在微信的页面登录之后，会被重定向回您的页面。然后，可以在页面加载时通过调用 <code>Provider.getLinkRedirectResult()</code> 来获取关联结果：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> provider = auth.weixinAuthProvider();</span><br><span class="line"></span><br><span class="line">provider.getLinkRedirectResult().then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 关联成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>关联自定义登录</strong></p><ul><li>用户以任意一种登录方式（除自定义登录）登录云开发；</li><li>使用 <code>User.linkWithTicket</code>，获取自定义登录 <code>Ticket</code> 后，关联自定义用户：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = app.auth();</span><br><span class="line"><span class="keyword">const</span> ticket = <span class="string">"......"</span>; <span class="comment">// 自定义登录 Ticket</span></span><br><span class="line">auth.currentUser.linkWithTicket(ticket).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 关联成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>关联邮箱密码登录</strong></p><ul><li>用户以任意一种登录方式登录云开发</li><li>更新用户的密码：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = app.auth();</span><br><span class="line">auth.currentUser.updatePassword(password).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置密码成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>更新用户的邮箱，用户点击验证邮件之后，便关联成功：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">auth.currentUser.updateEmail(email).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 发送验证邮件成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>关联用户名密码登录</strong></p><ul><li>用户以任意一种登录方式（除匿名登录）登录云开发：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以邮箱登录为例</span></span><br><span class="line"><span class="keyword">await</span> app.auth().signInWithEmailAndPassword(email, password);</span><br></pre></td></tr></table></figure><ul><li>绑定登录的用户名：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> app.auth().currentUser.updateUsername(username); <span class="comment">// 绑定用户名</span></span><br></pre></td></tr></table></figure><ul><li>绑定成功后，便可以使用用户名密码登录：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loginState = <span class="keyword">await</span> app.auth().signInWithUsernameAndPassword(username, password); <span class="comment">// 用户名密码登录</span></span><br></pre></td></tr></table></figure><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p><strong>避免重复登录</strong></p><blockquote><p>执行登录流程之前，我们非常建议您先判断用户端是否已经登录 CloudBase，如已经登录，那么不需要执行登录流程，以避免无意义的重复登录。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = app.auth();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用初始化时</span></span><br><span class="line"><span class="keyword">if</span> (auth.hasLoginState()) &#123;</span><br><span class="line">  <span class="comment">// 此时已经登录</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 此时未登录，执行您的登录流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>登录状态的持久保留</strong></p><blockquote><p>对于网页应用，最佳选择是 <code>local</code>，即在用户关闭浏览器之后仍保留该用户的会话。这样，用户不需要每次访问该网页时重复登录，避免给用户带来诸多不便体验</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = app.auth(&#123;</span><br><span class="line">  persistence: <span class="string">"local"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-2-登录方式"><a href="#4-2-登录方式" class="headerlink" title="4.2 登录方式"></a>4.2 登录方式</h3><h4 id="匿名登录"><a href="#匿名登录" class="headerlink" title="匿名登录"></a>匿名登录</h4><blockquote><p>登录 腾讯云 CloudBase 控制台，在 <a href="https://console.cloud.tencent.com/tcb/env/login" target="_blank" rel="noopener">登录授权页面中</a>，将匿名登录一栏打开或关闭。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/e95ddf99a0e2939c.png" alt></p><p><strong>添加安全域名（可选）</strong></p><p>Web 应用需要将域名添加到 CloudBase 控制台的<a href="https://console.cloud.tencent.com/tcb/env/safety" target="_blank" rel="noopener">Web 安全域名</a>列表中，否则将被识别为非法来源：</p><p><img src="https://s.poetries.work/uploads/2022/06/3404d8f9e5a8d4cf.png" alt></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cloudbase <span class="keyword">from</span> <span class="string">'@cloudbase/js-sdk'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">  env: <span class="string">'xxxx-yyy'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> auth = app.auth();</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">await</span> auth.anonymousAuthProvider().signIn();</span><br><span class="line">  <span class="comment">// 匿名登录成功检测登录状态isAnonymous字段为true</span></span><br><span class="line">  <span class="keyword">const</span> loginState = <span class="keyword">await</span> auth.getLoginState();</span><br><span class="line">  <span class="built_in">console</span>.log(loginState.isAnonymousAuth); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">login();</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/b34c3d3acc92627a.png" alt></p><p>可以看到token缓存到了本地</p><p><img src="https://s.poetries.work/uploads/2022/06/501a1e7be7791960.png" alt></p><blockquote><p>每个 <code>CloudBase</code> 环境的匿名用户数量不超过 <code>1000</code> 万个</p></blockquote><p>匿名用户在安全规则中的<code>auth.loginType</code>值为<code>ANONYMOUS</code>，配合安全规则可以限制匿名用户的 云数据库 和 云存储 的访问权限。比如下述代码展示的安全规则为：</p><ul><li>云数据库匿名用户不可读写；</li><li>云存储所有用户可读，匿名用户不可写。</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/f49d51410d41a7e2.png" alt></p><p><strong>转化为正式用户</strong></p><ul><li>如果用户在匿名状态下产生了一些私有数据（例如游戏中获取了个人成就和装备），想将此匿名账号转化为正式账号长久持有。</li><li>针对这种需求，您可以 将匿名账号与任意一种登录方式关联，关联后，便可以永久使用该种登录方式登录 CloudBase，达成”匿名账号转正“的效果。详情请参考：账户关联。</li></ul><p><strong>问题</strong></p><ul><li>匿名登录与未登录有什么区别？</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/d8b255edaee3b012.png" alt></p><ul><li>匿名登录的用户达到上限后怎么办？</li></ul><blockquote><p>CloudBase 限制每个环境的匿名用户数量不超过 1000 万个，如果达到上限可以在 CloudBase 控制台 的“用户管理”页面查看匿名用户的活跃情况，针对长期不登录的匿名用户可以考虑将其删除以释放空间。</p></blockquote><ul><li>匿名用户是否会过期？</li></ul><blockquote><p>CloudBase 对匿名用户的有效期限策略是：每个设备同时只存在一个匿名用户，并且此用户永不过期。当然，如果用户手动清除了设备或浏览器的本地数据，那么匿名用户的数据便会被同步清除，再次调用 CloudBase 匿名登录 API 会产生一个新的匿名用户。</p></blockquote><h4 id="未登录"><a href="#未登录" class="headerlink" title="未登录"></a>未登录</h4><blockquote><p>CloudBase 允许客户端在未登录的情况下调用 CloudBase 的资源，开发者可以配合安全规则限制未登录对资源的访问权限。</p></blockquote><p>登录 云开发 CloudBase 控制台，在 <a href="https://console.cloud.tencent.com/tcb/env/login" target="_blank" rel="noopener">登录授权</a> 中，将未登录一栏打开或关闭。</p><p><img src="https://s.poetries.work/uploads/2022/06/46c9989ef1cea582.png" alt></p><p><strong>添加安全域名（可选）</strong></p><p>Web 应用需要将域名添加到 CloudBase 控制台的<a href="https://console.cloud.tencent.com/tcb/env/safety" target="_blank" rel="noopener">Web 安全域名</a>列表中，否则将被识别为非法来源：</p><p><img src="https://s.poetries.work/uploads/2022/06/3404d8f9e5a8d4cf.png" alt></p><p><strong>使用流程</strong></p><ol><li>设置自定义安全规则，放通未登录访问</li></ol><p>您需要使用自定义安全规则，来放通未登录模式下的资源访问。</p><blockquote><p>基于安全性的考虑，基础的四种权限设置下，均不允许未登录进行访问。</p></blockquote><p>如，您可以这样设置云数据库的权限：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;read&quot;: &quot;doc._openid==auth.openid || auth == null&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原始私有读 <code>doc._openid==auth.openid</code> 的基础上，允许了所有未登录用户进行读资源。详细可查看 <a href="https://docs.cloudbase.net/rule/rule-example" target="_blank" rel="noopener">编写安全规则</a>。</p><p><img src="https://s.poetries.work/uploads/2022/06/4bf8025e0f47dce5.png" alt></p><ol start="2"><li>初始化 SDK 发起调用</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cloudbase <span class="keyword">from</span> <span class="string">'@cloudbase/js-sdk'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">  env: <span class="string">'xxxx-yyy'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SDK 初始化完成后可以正常发起云开发资源的调用。</p><p><img src="https://s.poetries.work/uploads/2022/06/c81cf50a598dd81f.png" alt></p><h4 id="邮箱登录"><a href="#邮箱登录" class="headerlink" title="邮箱登录"></a>邮箱登录</h4><blockquote><p>使用邮箱登录，您可以让您的用户使用自己的邮箱和密码注册、登录 CloudBase，并且还可以更新登录使用的邮箱和密码。</p></blockquote><p><strong>开通邮箱登录</strong></p><ol><li>开启邮箱登录</li></ol><p>进入 云开发 CloudBase 控制台，在 登录授权 设置页面中，开启邮箱登录:</p><p><img src="https://s.poetries.work/uploads/2022/06/bdff32d173347663.png" alt></p><ol start="2"><li>配置发件邮箱</li></ol><blockquote><p>填入您邮箱的 SMTP 账号信息</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/d5760279a4e8d4b9.png" alt></p><ol start="3"><li>设置应用名称及自动跳转链接</li></ol><p>打开右侧「应用配置」页面，设置您的应用名称和自动跳转链接。</p><ul><li>您设置的应用名称将会出现在验证邮件的内容中；</li><li>CloudBase 发送的邮件中会包含一个 URL，用户打开邮件中的 URL 后，会自动跳转到您设置的自动跳转链接。</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/75fe3a786ac2f19b.png" alt></p><p><strong>登录流程</strong></p><ol><li>初始化 SDK</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cloudbase <span class="keyword">from</span> <span class="string">"@cloudbase/js-sdk"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">  env: <span class="string">"your-env-id"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用邮箱注册账号</li></ol><p>首先需要用户填入自己的邮箱和密码，然后调用 SDK 的注册接口：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app</span><br><span class="line">  .auth()</span><br><span class="line">  .signUpWithEmailAndPassword(email, password)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 发送验证邮件成功</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>调用注册接口之后，<code>CloudBase</code> 会使用您预先设置的邮箱，发送一封验证邮件到用户的邮箱。邮件中包含一个激活链接，用户在点击激活链接后，账号才会正式注册成功。</p><blockquote><p>密码强度要求:密码长度不小于 8 位，不大于 32 位，需要包含字母和数字。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/8dfd1a122cf97ef9.png" alt></p><p>可以看到注册成功的账户</p><p><img src="https://s.poetries.work/uploads/2022/06/88c3a1a2a39dab05.png" alt></p><ol start="3"><li>使用邮箱+密码登录 CloudBase</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app</span><br><span class="line">  .auth()</span><br><span class="line">  .signInWithEmailAndPassword(email, password)</span><br><span class="line">  .then(<span class="function">(<span class="params">loginState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 登录成功</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/3dbf8e6a924809df.png" alt></p><h4 id="微信授权登录"><a href="#微信授权登录" class="headerlink" title="微信授权登录"></a>微信授权登录</h4><p>经微信授权的网页应用可以直接使用微信登录 CloudBase，包括两种授权类型：</p><ul><li>微信公众平台（公众号网页）；</li><li>微信开放平台（普通网站应用及移动应用等）</li></ul><p><strong>开通流程</strong></p><ol><li>开通平台账号</li></ol><p>首先需要一个微信公众平台 / 开放平台的注册账号，如果没有，请前往 <a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">微信公众平台</a> 或 <a href="https://open.weixin.qq.com/" target="_blank" rel="noopener">微信开放平台申请</a></p><p>然后在微信公众平台/开放平台的管理后台中，查看开发者 ID（AppId）和开发者密码（AppSecret）。</p><p>以微信公众平台为例，在“开发 - 基本配置”中有以下内容：</p><p><img src="https://s.poetries.work/uploads/2022/06/d9590e7139fec14a.png" alt></p><blockquote><p>开发者密码（AppSecret）是非常私密的信息，每次点击上图中的「重置」按钮都会获取一个新的 AppSecret。</p></blockquote><ol start="2"><li>开启微信登录</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/c6f20fd79e5cf432.png" alt></p><p>点击启用按钮后在弹窗的对应位置填入 AppId 和 AppSecret。</p><ol start="3"><li>添加安全域名（可选）</li></ol><p>Web 应用需要将域名添加到 CloudBase 控制台的<a href="https://console.cloud.tencent.com/tcb/env/safety" target="_blank" rel="noopener">Web 安全域名</a>列表中，否则将被识别为非法来源：</p><p><img src="https://s.poetries.work/uploads/2022/06/3404d8f9e5a8d4cf.png" alt></p><p><strong>微信登录流程</strong></p><p>在使用微信登录 CloudBase 前，请先在控制台中 <a href="https://docs.cloudbase.net/authentication/method/wechat-login#%E5%BC%80%E9%80%9A%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener">启用微信登录</a>。</p><ol><li>初始化 SDK</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cloudbase <span class="keyword">from</span> <span class="string">"@cloudbase/js-sdk"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">  env: <span class="string">"your-env-id"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 SDK 处理登录流程</li></ol><p>创建 Provider：首先我们创建一个 Provider 实例，并且填入参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = app.auth();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> provider = auth.weixinAuthProvider(&#123;</span><br><span class="line">  appid: <span class="string">"..."</span>,</span><br><span class="line">  scope: <span class="string">"xxxx"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/befa9164c6b90b3f.png" alt></p><ul><li>如果用户使用 <code>snsapi_userinfo</code> 或 <code>snsapi_login</code> 登录，并且是首次登录，那么 CloudBase 将会自动拉取、同步微信的用户基本信息。</li><li>如果用户不是首次登录，将不会有此行为。</li></ul><p>使用 Provider 进行登录</p><blockquote><p>首先调用 <code>Provider.signInWithRedirect()</code>，用户将会跳转到微信 OAuth 授权页面：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">provider.signInWithRedirect();</span><br></pre></td></tr></table></figure><p>在授权页面内，需要用户对登录行为进行授权，成功后，会返回至当前页面。</p><p>然后调用 <code>Provider.getRedirectResult()</code>，获取登录结果：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">provider.getRedirectResult().then(<span class="function">(<span class="params">loginState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (loginState) &#123;</span><br><span class="line">    <span class="comment">// 登录成功！</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="自定义登录"><a href="#自定义登录" class="headerlink" title="自定义登录"></a>自定义登录</h4><blockquote><p>开发者可以使用自定义登录，在自己的服务器或者云函数内，为用户签发带有自定义身份 ID 的自定义登录凭证 Ticket，随后用户端 SDK 便可以使用 Ticket 登录 CloudBase。</p></blockquote><p>自定义登录一般用于下面几种场景：</p><ul><li>开发者希望将自有的账号体系与云开发 CloudBase 账号进行一对一关联；</li><li>开发者希望自行接管鉴权流程。</li></ul><p>自定义登录需要以下几个步骤：</p><ul><li>获取 CloudBase 自定义登录私钥；</li><li>使用 CloudBase 服务端 SDK，通过私钥签发出 Ticket，并返回至用户端；</li><li>用户端 SDK 使用 Ticket 登录 CloudBase。</li></ul><ol><li>获取自定义登录私钥</li></ol><blockquote><p>登录 CloudBase 控制台，在 <a href="https://console.cloud.tencent.com/tcb/env/login" target="_blank" rel="noopener">环境 -&gt; 登录授权</a>下的自定义登录栏中，点击「私钥下载」或者「私钥复制」：</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/0d8163e0ab3193ec.png" alt></p><blockquote><p>私钥是一份携带有 JSON 数据的文件，请将下载或复制的私钥文件保存到您的服务器或者云函数中，假设路径为<code>/path/to/your/tcb_custom_login.json</code>。</p></blockquote><ul><li>私钥文件是证明管理员身份的重要凭证，请务必妥善保存，避免泄漏；</li><li>每次生成私钥文件都会使之前生成的私钥文件在 2 小时后失效。</li></ul><ol start="2"><li>签发 Ticket</li></ol><p>调用 CloudBase 服务端 SDK，在初始化时传入自定义登录私钥，随后便可以签发出 Ticket，并返回至用户端</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cloudbase = <span class="built_in">require</span>(<span class="string">"@cloudbase/node-sdk"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 初始化 SDK</span></span><br><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">  env: <span class="string">"your-env-id"</span>,</span><br><span class="line">  <span class="comment">// 传入自定义登录私钥</span></span><br><span class="line">  credentials: <span class="built_in">require</span>(<span class="string">"/path/to/your/tcb_custom_login.json"</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 开发者自定义的用户唯一身份标识</span></span><br><span class="line"><span class="keyword">const</span> customUserId = <span class="string">"your-customUserId"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建ticket</span></span><br><span class="line"><span class="keyword">const</span> ticket = app.auth().createTicket(customUserId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 将ticket返回至客户端</span></span><br><span class="line"><span class="keyword">return</span> ticket;</span><br></pre></td></tr></table></figure><blockquote><p>开发者也可以编写一个云函数用于生成 Ticket，并为其设置 HTTP 访问服务，随后用户端便可以通过 HTTP 请求的形式获取 Ticket，详细的方案请参阅 <a href="https://docs.cloudbase.net/service/access-cloud-function" target="_blank" rel="noopener">使用 HTTP 访问云函数</a>。</p></blockquote><p>customUserId 必须满足以下需求：</p><ul><li>4-32 位字符；</li><li>字符只能是大小写英文字母、数字、以及 <code>_-#@(){}[]:.,&lt;&gt;+#~</code> 中的字符。</li></ul><ol start="3"><li>使用 Ticket 登录 CloudBase</li></ol><blockquote><p>用户端应用获取到 Ticket 之后，便可以调用客户端 SDK 提供的 <code>auth.signInWithTicket()</code> 登录 CloudBase：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cloudbase <span class="keyword">from</span> <span class="string">'@cloudbase/js-sdk'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">  env: <span class="string">'your-env-id'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> auth = app.auth();</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> loginState = <span class="keyword">await</span> auth.getLoginState();</span><br><span class="line">  <span class="comment">// 1. 建议登录前检查当前是否已经登录</span></span><br><span class="line">  <span class="keyword">if</span>(!loginState)&#123;</span><br><span class="line">    <span class="comment">// 2. 请求开发者自有服务接口获取ticket</span></span><br><span class="line">    <span class="keyword">const</span> ticket = <span class="keyword">await</span> fetch(<span class="string">'...'</span>)；</span><br><span class="line">    <span class="comment">// 3. 登录 CloudBase</span></span><br><span class="line">    <span class="keyword">await</span> auth.customAuthProvider().signIn(ticket);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">login();</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/bf6484c27c260614.png" alt></p><p><strong>自定义登录一定需要自己假设用于创建 Ticket 的服务器吗？</strong></p><ul><li>自定义登录必须有一个创建 Ticket 的服务，但是开发者并非一定要自己搭建服务器。</li><li>开发者还可以编写一个云函数来创建 Ticket，然后客户端使用 HTTP 请求调用这个云函数获取 Ticket，详细请参阅 <a href="https://docs.cloudbase.net/service/access-cloud-function" target="_blank" rel="noopener">使用 HTTP 访问云函数</a></li></ul><h4 id="用户名密码登录"><a href="#用户名密码登录" class="headerlink" title="用户名密码登录"></a>用户名密码登录</h4><ul><li>使用用户名密码登录，您可以让您的用户绑定用户名，并使用用户名密码登录 CloudBase。您可以更改用户名和密码，还可以查询用户名是否绑定过。</li><li>如果用户名未被绑定过，需要先使用其他登录方式完成登录后，才可以绑定用户名。绑定成功后，可以使用用户名和密码完成登录。</li></ul><p>进入 云开发 CloudBase 控制台，在 登录授权 设置页面中，开启用户名密码登录:</p><p><img src="https://s.poetries.work/uploads/2022/06/6d0258075bf46615.png" alt></p><p><strong>绑定用户名流程</strong></p><ol><li>初始化 SDK</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cloudbase <span class="keyword">from</span> <span class="string">"@cloudbase/js-sdk"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">  env: <span class="string">"your-env-id"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用其他方式进行登录</li></ol><p>绑定用户名之前，用户需要先使用其他方式进行登录，例如邮箱登录、微信公众号登录等，但不包括匿名登录</p><p>下面以邮箱登录为例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = app.auth();</span><br><span class="line"><span class="keyword">await</span> auth.signInWithEmailAndPassword(email, password); <span class="comment">// 邮箱登录</span></span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/acd1fb389d6c9a6d.png" alt></p><ol start="3"><li>绑定用户名</li></ol><p>绑定用户名时，可以检查在当前云开发环境下，此用户名是否存在。然后再调用绑定用户名的接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = app.auth();</span><br><span class="line"><span class="keyword">if</span> (!(<span class="keyword">await</span> auth.isUsernameRegistered(username))) &#123;</span><br><span class="line">  <span class="comment">// 检查用户名是否绑定过</span></span><br><span class="line">  <span class="keyword">await</span> auth.currentUser.updateUsername(username); <span class="comment">// 绑定用户名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用用户名+密码登录 CloudBase</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auth = app.auth();</span><br><span class="line"><span class="keyword">const</span> loginState = <span class="keyword">await</span> auth.signInWithUsernameAndPassword(username, password); <span class="comment">// 用户名密码登录</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：用户名登录和邮箱登录的密码是相同的</p></blockquote><h4 id="短信验证码登录"><a href="#短信验证码登录" class="headerlink" title="短信验证码登录"></a>短信验证码登录</h4><blockquote><p>使用短信验证码登录，您可以让用户使用自己的手机号，结合短信验证码或密码注册、登录 CloudBase，并且还可以更新或者解绑登录使用的手机号。</p></blockquote><p><strong>开通短信验证码登录</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/e4eac02d22f679e0.png" alt></p><p><strong>登录流程</strong></p><ol><li>初始化 SDK</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cloudbase <span class="keyword">from</span> <span class="string">"@cloudbase/js-sdk"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">  env: <span class="string">"your-env-id"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用手机号注册账号</li></ol><blockquote><p>首先需要用户填入自己的手机号，然后调用 SDK 的发送短信验证码接口：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app</span><br><span class="line">  .auth()</span><br><span class="line">  .sendPhoneCode(phoneNumber)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 发送短信验证码</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>调用发送短信接口后，手机将会收到云开发的短信验证码。用户填入短信验证码，以及自定义密码后，调用注册账号接口</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app</span><br><span class="line">  .auth()</span><br><span class="line">  .signUpWithPhoneCode(phoneNumber, phoneCode, password)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 手机短信注册账号</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>使用手机号 + 密码 or 手机号 + 短信验证码登录 CloudBase</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app</span><br><span class="line">  .auth()</span><br><span class="line">  .signInWithPhoneCodeOrPassword(&#123;</span><br><span class="line">    phoneNumber,</span><br><span class="line">    phoneCode, <span class="comment">// 非必填，验证码和密码至少二选一</span></span><br><span class="line">    password <span class="comment">// 非必填，验证码和密码至少二选一</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">loginState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 登录成功</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="五、CloudBase-Framework一体化部署（推荐方式）"><a href="#五、CloudBase-Framework一体化部署（推荐方式）" class="headerlink" title="五、CloudBase Framework一体化部署（推荐方式）"></a>五、CloudBase Framework一体化部署（推荐方式）</h2><blockquote><p>文档地址 <a href="https://docs.cloudbase.net/framework/index" target="_blank" rel="noopener">https://docs.cloudbase.net/framework/index</a></p></blockquote><blockquote><p>CloudBase Framework 是云开发官方出品的云原生一体化部署工具，可以帮助开发者将静态网站、后端服务和小程序等应用，一键部署到云开发 Serverless 架构的云平台上，自动伸缩且无需关心运维，聚焦应用本身，无需关心底层配置和资源。</p></blockquote><h3 id="5-1-云开发应用介绍"><a href="#5-1-云开发应用介绍" class="headerlink" title="5.1 云开发应用介绍"></a>5.1 云开发应用介绍</h3><blockquote><p>云开发应用可以理解为运行在云开发环境的应用，例如一个包含前后端、数据库等能力等服务，可以通过一键部署，直接部署在云开发环境中，使用云开发底层的各项 Serverless 资源，享受弹性免运维的优势。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/40bd0c9ceadc339e.png" alt></p><p>一个云开发应用可以拆解为三个部分，包括代码、声明式配置和环境变量信息。</p><p><img src="https://s.poetries.work/uploads/2022/06/7215d3f021c80ef9.png" alt></p><p><strong>如何开发一个云开发应用</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/3731b6c2de7002eb.png" alt></p><h3 id="5-2-cloudbase-framework配置文件"><a href="#5-2-cloudbase-framework配置文件" class="headerlink" title="5.2 cloudbase framework配置文件"></a>5.2 cloudbase framework配置文件</h3><blockquote><p>在使用 CloudBase Framework 之前，您需要需要创建一个 <code>cloudbaserc.json</code> 配置文件，<code>cloudbaserc.json</code> 文件是 CloudBase CLI 、CloudBase VSCode 插件和 CloudBase 应用的配置文件，配置文件会关系到云开发如何构建和部署您的应用。</p></blockquote><p>默认情况下，使用 <code>cloudbase init</code> 初始化项目时，会生成 <code>cloudbaserc.json</code> 文件作为配置文件，您也可以使用 <code>--config-file</code> 指定其他文件作为配置文件，文件必须满足格式要求。</p><p><strong>CloudBase Framework 配置文件包含以下几类配置信息：</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/3e69b0ecfb4b5b1c.png" alt></p><ol><li>plugins：描述您的应用依赖哪些 CloudBase Framework 插件，以便根据配置来构建和部署您的应用，应用可以使用多个插件，具体插件配置方式参考下文。</li></ol><blockquote><p>目前支持的插件名称请参阅 <a href="https://github.com/Tencent/cloudbase-framework#目前支持的插件列表" target="_blank" rel="noopener">https://github.com/Tencent/cloudbase-framework#目前支持的插件列表</a></p></blockquote><p>示例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"client"</span>: &#123;</span><br><span class="line">        <span class="comment">// 使用的插件 npm 包名，例如 @cloudbase/framework-plugin-website支持指定插件版本，例如@cloudbase/framework-plugin-website@1.3.5</span></span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-website"</span>,</span><br><span class="line">        <span class="comment">// 插件入参配置，不同的插件，支持的入参不同，请查阅对应插件的 README 或者文档</span></span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"buildCommand"</span>: <span class="string">"npm run build"</span>,</span><br><span class="line">          <span class="string">"outputPath"</span>: <span class="string">"dist"</span>,</span><br><span class="line">          <span class="string">"cloudPath"</span>: <span class="string">"/vue"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"server"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-function"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"functionRootPath"</span>: <span class="string">"cloudfunctions"</span>,</span><br><span class="line">          <span class="string">"functions"</span>: [&#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"vue-echo"</span></span><br><span class="line">          &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>生命周期</li></ol><blockquote><p>配置在构建部署生命周期前后，需要执行的自定义动作</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"hooks"</span>: &#123;</span><br><span class="line">       <span class="comment">// 前置钩子，在执行 Framework 完整的构建部署动作之前执行的钩子，可以执行一些命令行命令</span></span><br><span class="line">      <span class="string">"preDeploy"</span>: &#123;</span><br><span class="line">        <span class="comment">// 前置钩子的类型，目前仅支持 execCommand，表示执行命令行命令</span></span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"execCommand"</span>,</span><br><span class="line">        <span class="string">"commands"</span>: [<span class="comment">// 要执行的 command 命令列表</span></span><br><span class="line">          <span class="string">"sudo npm install -g lerna"</span>,</span><br><span class="line">          <span class="string">"lerna bootstrap"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//后置钩子，在执行 Framework 部署之后，在云端调用的钩子，可以调用一些云函数</span></span><br><span class="line">      <span class="string">"postDeploy"</span>: &#123;</span><br><span class="line">        <span class="comment">// 后置钩子钩子的类型，目前仅支持 callFunction 代表在云端执行云函数</span></span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"callFunction"</span>,</span><br><span class="line">        <span class="string">"functions"</span>:[ <span class="comment">// 要调用的云函数列表，支持数组，例如</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"functionName"</span>: <span class="string">"echo"</span>, <span class="comment">// 调用的云函数的函数名</span></span><br><span class="line">            <span class="string">"params"</span>: &#123; <span class="comment">// 调用云函数的参数信息</span></span><br><span class="line">              <span class="string">"foo"</span>: <span class="string">"bar"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>应用依赖</li></ol><blockquote><p>在云端一键部署场景下，您需要完善应用依赖配置来声明应用依赖的扩展资源和环境变量参数</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="comment">// 描述项目通过控制台一键安装部署时依赖的其他资源信息、环境变量等业务参数。</span></span><br><span class="line">    <span class="string">"requirement"</span>: &#123;</span><br><span class="line">        <span class="comment">// 应用部署过程中用到的外部云上资源，包括 cfs、cynosdb、redis 等</span></span><br><span class="line">      <span class="string">"addons"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"CynosDB"</span>,<span class="comment">// 资源类型，目前支持 CFS 和 CynosDB</span></span><br><span class="line">          <span class="string">"name"</span>: <span class="string">"wordpress"</span>,<span class="comment">// 资源名称，只支持 a-z 0-9 和 -</span></span><br><span class="line">          <span class="string">"envMap"</span>: &#123;<span class="comment">// 环境变量映射文件，会将云资源产生的 IP 、PORT 通过右侧定义的名称来映射为对应的环境变量名称，并注入环境变</span></span><br><span class="line">            <span class="string">"IP"</span>: <span class="string">"WORDPRESS-IP"</span>,</span><br><span class="line">            <span class="string">"PORT"</span>: <span class="string">"WORDPRESS-PORT"</span>,</span><br><span class="line">            <span class="string">"USERNAME"</span>: <span class="string">"WORDPRESS-USERNAME"</span>,</span><br><span class="line">            <span class="string">"PASSWORD"</span>: <span class="string">"WORDPRESS-PASSWORD"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="comment">// 应用在构建时和运行时的环境变量配置声明，默认注入计算环境中(云函数、云应用)，也会在云端构建时作为构建部署的环境变量，可以在 cloudbaserc.json 中通过 &#123;&#123;env.ENV_NAME&#125;&#125;引用</span></span><br><span class="line">      <span class="string">"environment"</span>: &#123;</span><br><span class="line">        <span class="string">"SECRET_TOKEN"</span>: &#123;</span><br><span class="line">            <span class="comment">// 环境变量描述，会在输入时进行提示</span></span><br><span class="line">          <span class="string">"description"</span>: <span class="string">"A secret key for verifying the integrity of signed cookies."</span>,</span><br><span class="line">          <span class="string">"required"</span>: <span class="literal">true</span>, <span class="comment">//是否必填</span></span><br><span class="line">          <span class="string">"default"</span>: <span class="string">"default_value"</span>,</span><br><span class="line">          <span class="string">"validation"</span>: &#123;<span class="comment">// 校验规则配置</span></span><br><span class="line">            <span class="string">"rule"</span>: &#123;<span class="comment">//校验规则信息</span></span><br><span class="line">              <span class="string">"type"</span>: <span class="string">"RegExp"</span>,<span class="comment">//校验规则类型，目前支持"RegExp" 代表正则类型</span></span><br><span class="line">              <span class="string">"pattern"</span>: <span class="string">"[3-9]"</span>,<span class="comment">//正则的 Pattern</span></span><br><span class="line">              <span class="string">"flag"</span>: <span class="string">"g"</span><span class="comment">//正则的 Flag</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"errorMessage"</span>: <span class="string">"数值范围3-9"</span><span class="comment">//校验失败时的错误信息</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>模板变量</li></ol><p>配置文件支持动态变量的特性。在 <code>cloudbaserc.json</code> 中声明 <code>&quot;version&quot;: &quot;2.0&quot;</code> 即可启用。</p><blockquote><p>动态变量特性允许<code>cloudbaserc.json</code> 配置文件中使用动态变量，从环境变量中获取动态的数据。使用<code>{}</code>包围的值定义为动态变量，可以引用数据源中的值。例如`{env.ENV_ID}:</p></blockquote><ul><li>第一步：在项目根目录下创建 <code>cloudbaserc.json</code> 和 <code>.env</code> 文件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├─cloudbaserc.json</span><br><span class="line">├─.env</span><br></pre></td></tr></table></figure><ul><li>第二步：在 .env 文件内添加变量</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV_ID=pro-123</span><br><span class="line">DB_NAME=pro_user</span><br></pre></td></tr></table></figure><ul><li>第三步：在 <code>cloudbaserc.json</code> 文件内通过 <code>env</code> 注入模板变量</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"&#123;&#123;env.ENV_ID&#125;&#125;"</span>,</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"node-capp"</span>,</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"node"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-node"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"name"</span>: <span class="string">"node-capp"</span>,</span><br><span class="line">          <span class="string">"path"</span>: <span class="string">"/node-capp"</span>,</span><br><span class="line">          <span class="string">"platform"</span>: <span class="string">"container"</span>,</span><br><span class="line">          <span class="string">"containerOptions"</span>: &#123;</span><br><span class="line">            <span class="string">"envVariables"</span>: &#123;</span><br><span class="line">              <span class="string">"env"</span>: <span class="string">"&#123;&#123;env.ENV_ID&#125;&#125;"</span>,</span><br><span class="line">              <span class="string">"db"</span>: <span class="string">"&#123;&#123;env.DB_NAME&#125;&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第四步：一键部署应用</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb framework deploy</span><br></pre></td></tr></table></figure><ol start="5"><li>模式切换</li></ol><p>假设你已经完成了以上模板变量的配置</p><ul><li>第一步：在项目根目录额外添加 <code>.env.dev</code> 文件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├─cloudbaserc.json</span><br><span class="line">├─.env</span><br><span class="line">├─.env.dev</span><br></pre></td></tr></table></figure><ul><li>第二步：在 <code>.env.dev</code> 文件添加变量</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV_ID=dev-123</span><br><span class="line">DB_NAME=dev_user</span><br></pre></td></tr></table></figure><ul><li>第三步：部署应用时使用 –mode 指定模式</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloudbase framework deploy --mode dev</span><br></pre></td></tr></table></figure><p><strong>完整示例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://docs.cloudbase.net/framework/config</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"&#123;&#123;env.ENV_ID&#125;&#125;"</span>,</span><br><span class="line">  <span class="string">"$schema"</span>: <span class="string">"https://framework-1258016615.tcloudbaseapp.com/schema/latest.json"</span>,</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"admin"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-website"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"outputPath"</span>: <span class="string">"./packages/admin/dist"</span>,</span><br><span class="line">          <span class="string">"installCommand"</span>: <span class="string">"echo \"Skip Install\""</span>,</span><br><span class="line">          <span class="string">"buildCommand"</span>: <span class="string">"npm run build"</span>,</span><br><span class="line">          <span class="string">"cloudPath"</span>: <span class="string">"&#123;&#123;env.deployPath&#125;&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"init"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-function"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"functionRootPath"</span>: <span class="string">"./packages"</span>,</span><br><span class="line">          <span class="string">"functions"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"name"</span>: <span class="string">"cms-init"</span>,</span><br><span class="line">              <span class="string">"timeout"</span>: <span class="number">60</span>,</span><br><span class="line">              <span class="string">"envVariables"</span>: &#123;</span><br><span class="line">                <span class="string">"CMS_ADMIN_USER_NAME"</span>: <span class="string">"&#123;&#123;env.administratorName&#125;&#125;"</span>,</span><br><span class="line">                <span class="string">"CMS_ADMIN_PASS_WORD"</span>: <span class="string">"&#123;&#123;env.administratorPassword&#125;&#125;"</span>,</span><br><span class="line">                <span class="string">"CMS_OPERATOR_USER_NAME"</span>: <span class="string">"&#123;&#123;env.operatorName&#125;&#125;"</span>,</span><br><span class="line">                <span class="string">"CMS_OPERATOR_PASS_WORD"</span>: <span class="string">"&#123;&#123;env.operatorPassword&#125;&#125;"</span>,</span><br><span class="line">                <span class="string">"CMS_DEPLOY_PATH"</span>: <span class="string">"&#123;&#123;env.deployPath&#125;&#125;"</span>,</span><br><span class="line">                <span class="string">"ACCESS_DOMAIN"</span>: <span class="string">"&#123;&#123;env.accessDomain&#125;&#125;"</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="string">"installDependency"</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="string">"handler"</span>: <span class="string">"index.main"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"service"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-node"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"name"</span>: <span class="string">"tcb-ext-cms-service"</span>,</span><br><span class="line">          <span class="string">"entry"</span>: <span class="string">"app.js"</span>,</span><br><span class="line">          <span class="string">"projectPath"</span>: <span class="string">"./packages/service"</span>,</span><br><span class="line">          <span class="string">"path"</span>: <span class="string">"/tcb-ext-cms-service"</span>,</span><br><span class="line">          <span class="string">"functionOptions"</span>: &#123;</span><br><span class="line">            <span class="string">"timeout"</span>: <span class="number">15</span>,</span><br><span class="line">            <span class="string">"envVariables"</span>: &#123;</span><br><span class="line">              <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"db"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-database"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"collections"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"tcb-ext-cms-projects"</span>,</span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"CMS 系统项目数据（请不要手动修改）"</span>,</span><br><span class="line">              <span class="string">"aclTag"</span>: <span class="string">"ADMINONLY"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"tcb-ext-cms-schemas"</span>,</span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"CMS 系统内容模型数据（请不需要手动修改）"</span>,</span><br><span class="line">              <span class="string">"aclTag"</span>: <span class="string">"ADMINONLY"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"tcb-ext-cms-users"</span>,</span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"CMS 系统系统用户数据，存储 CMS 的用户信息，包括管理员账号信息，角色信息等（请不要手动修改）"</span>,</span><br><span class="line">              <span class="string">"aclTag"</span>: <span class="string">"ADMINONLY"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"tcb-ext-cms-webhooks"</span>,</span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"CMS 系统系统 webhook 集合，存储 CMS 系统的回调接口配置，CMS 系统数据的变更可以通过回调来进行同步 （请不要手动修改）"</span>,</span><br><span class="line">              <span class="string">"aclTag"</span>: <span class="string">"ADMINONLY"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"tcb-ext-cms-settings"</span>,</span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"CMS 系统系统配置集合，存储 CMS 系统的设置（请不要手动修改）"</span>,</span><br><span class="line">              <span class="string">"aclTag"</span>: <span class="string">"ADMINONLY"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"tcb-ext-cms-user-roles"</span>,</span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"CMS 系统系统用户角色配置集合，存储 CMS 系统的自定义用户角色信息（请不要手动修改）"</span>,</span><br><span class="line">              <span class="string">"aclTag"</span>: <span class="string">"ADMINONLY"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"requirement"</span>: &#123;</span><br><span class="line">      <span class="string">"addons"</span>: [],</span><br><span class="line">      <span class="string">"environment"</span>: &#123;</span><br><span class="line">        <span class="string">"administratorName"</span>: &#123;</span><br><span class="line">          <span class="string">"description"</span>: <span class="string">"管理员账户名，账号名长度需要大于 4 位，支持字母和数字"</span>,</span><br><span class="line">          <span class="string">"required"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="string">"default"</span>: <span class="string">"admin"</span>,</span><br><span class="line">          <span class="string">"validation"</span>: &#123;</span><br><span class="line">            <span class="string">"rule"</span>: &#123;</span><br><span class="line">              <span class="string">"type"</span>: <span class="string">"RegExp"</span>,</span><br><span class="line">              <span class="string">"pattern"</span>: <span class="string">"[^[a-zA-Z0-9]+[a-zA-Z0-9_-]?[a-zA-Z0-9]+$]"</span>,</span><br><span class="line">              <span class="string">"flag"</span>: <span class="string">"g"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"errorMessage"</span>: <span class="string">"字母和数字的组合，不能为纯数字，长度范围是 1 ~ 32"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其他项目配置文件示例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://docs.cloudbase.net/framework/config</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"&#123;&#123;env.ENV_ID&#125;&#125;"</span>,</span><br><span class="line">  <span class="string">"$schema"</span>: <span class="string">"https://framework-1258016615.tcloudbaseapp.com/schema/latest.json"</span>,</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"admin"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-website"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"outputPath"</span>: <span class="string">"./packages/admin/dist"</span>,</span><br><span class="line">          <span class="string">"installCommand"</span>: <span class="string">"echo \"Skip Install\""</span>,</span><br><span class="line">          <span class="string">"buildCommand"</span>: <span class="string">"npm run build"</span>,</span><br><span class="line">          <span class="string">"cloudPath"</span>: <span class="string">"&#123;&#123;env.deployPath&#125;&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"init"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-function"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"functionRootPath"</span>: <span class="string">"./packages"</span>,</span><br><span class="line">          <span class="string">"functions"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"name"</span>: <span class="string">"cms-init"</span>,</span><br><span class="line">              <span class="string">"timeout"</span>: <span class="number">60</span>,</span><br><span class="line">              <span class="string">"envVariables"</span>: &#123;</span><br><span class="line">                <span class="string">"CMS_ADMIN_USER_NAME"</span>: <span class="string">"&#123;&#123;env.administratorName&#125;&#125;"</span>,</span><br><span class="line">                <span class="string">"CMS_ADMIN_PASS_WORD"</span>: <span class="string">"&#123;&#123;env.administratorPassword&#125;&#125;"</span>,</span><br><span class="line">                <span class="string">"CMS_OPERATOR_USER_NAME"</span>: <span class="string">"&#123;&#123;env.operatorName&#125;&#125;"</span>,</span><br><span class="line">                <span class="string">"CMS_OPERATOR_PASS_WORD"</span>: <span class="string">"&#123;&#123;env.operatorPassword&#125;&#125;"</span>,</span><br><span class="line">                <span class="string">"CMS_DEPLOY_PATH"</span>: <span class="string">"&#123;&#123;env.deployPath&#125;&#125;"</span>,</span><br><span class="line">                <span class="string">"ACCESS_DOMAIN"</span>: <span class="string">"&#123;&#123;env.accessDomain&#125;&#125;"</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="string">"installDependency"</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="string">"handler"</span>: <span class="string">"index.main"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"service"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-node"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"name"</span>: <span class="string">"tcb-ext-cms-service"</span>,</span><br><span class="line">          <span class="string">"entry"</span>: <span class="string">"app.js"</span>,</span><br><span class="line">          <span class="string">"projectPath"</span>: <span class="string">"./packages/service"</span>,</span><br><span class="line">          <span class="string">"path"</span>: <span class="string">"/tcb-ext-cms-service"</span>,</span><br><span class="line">          <span class="string">"functionOptions"</span>: &#123;</span><br><span class="line">            <span class="string">"timeout"</span>: <span class="number">15</span>,</span><br><span class="line">            <span class="string">"envVariables"</span>: &#123;</span><br><span class="line">              <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"db"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-database"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"collections"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"tcb-ext-cms-projects"</span>,</span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"CMS 系统项目数据（请不要手动修改）"</span>,</span><br><span class="line">              <span class="string">"aclTag"</span>: <span class="string">"ADMINONLY"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"tcb-ext-cms-schemas"</span>,</span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"CMS 系统内容模型数据（请不需要手动修改）"</span>,</span><br><span class="line">              <span class="string">"aclTag"</span>: <span class="string">"ADMINONLY"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"tcb-ext-cms-users"</span>,</span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"CMS 系统系统用户数据，存储 CMS 的用户信息，包括管理员账号信息，角色信息等（请不要手动修改）"</span>,</span><br><span class="line">              <span class="string">"aclTag"</span>: <span class="string">"ADMINONLY"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"tcb-ext-cms-webhooks"</span>,</span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"CMS 系统系统 webhook 集合，存储 CMS 系统的回调接口配置，CMS 系统数据的变更可以通过回调来进行同步 （请不要手动修改）"</span>,</span><br><span class="line">              <span class="string">"aclTag"</span>: <span class="string">"ADMINONLY"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"tcb-ext-cms-settings"</span>,</span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"CMS 系统系统配置集合，存储 CMS 系统的设置（请不要手动修改）"</span>,</span><br><span class="line">              <span class="string">"aclTag"</span>: <span class="string">"ADMINONLY"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"tcb-ext-cms-user-roles"</span>,</span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"CMS 系统系统用户角色配置集合，存储 CMS 系统的自定义用户角色信息（请不要手动修改）"</span>,</span><br><span class="line">              <span class="string">"aclTag"</span>: <span class="string">"ADMINONLY"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"requirement"</span>: &#123;</span><br><span class="line">      <span class="string">"addons"</span>: [],</span><br><span class="line">      <span class="string">"environment"</span>: &#123;</span><br><span class="line">        <span class="string">"administratorName"</span>: &#123;</span><br><span class="line">          <span class="string">"description"</span>: <span class="string">"管理员账户名，账号名长度需要大于 4 位，支持字母和数字"</span>,</span><br><span class="line">          <span class="string">"required"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="string">"default"</span>: <span class="string">"admin"</span>,</span><br><span class="line">          <span class="string">"validation"</span>: &#123;</span><br><span class="line">            <span class="string">"rule"</span>: &#123;</span><br><span class="line">              <span class="string">"type"</span>: <span class="string">"RegExp"</span>,</span><br><span class="line">              <span class="string">"pattern"</span>: <span class="string">"[^[a-zA-Z0-9]+[a-zA-Z0-9_-]?[a-zA-Z0-9]+$]"</span>,</span><br><span class="line">              <span class="string">"flag"</span>: <span class="string">"g"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"errorMessage"</span>: <span class="string">"字母和数字的组合，不能为纯数字，长度范围是 1 ~ 32"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-插件"><a href="#5-3-插件" class="headerlink" title="5.3 插件"></a>5.3 插件</h3><p>插件可以处理应用中的一些独立单元的构建、部署、开发、调试等流程。例如 website 插件可以处理静态网站等单元，node 插件可以处理 koa 、express 等 node 应用。</p><p>插件的配置写在 cloudbaserc.json 文件中，具体请参考配置说明中的 插件配置可以手动填写，也可以自动生成。</p><p><strong>自动检测生成插件配置</strong></p><p>可以在项目目录下直接运行 <code>cloudbase</code> 命令进行自动检测生成插件配置文件并部署</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloudbase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔ 是否使用云开发部署当前项目 &lt;Projects/test/test-vue&gt; ？ (Y/n) · true</span><br><span class="line">✔ 选择关联环境 · webpage - [webpage:按量计费]</span><br><span class="line">   ______ __                   __ ____</span><br><span class="line">  / ____// /____   __  __ ____/ // __ ) ____ _ _____ ___</span><br><span class="line"> / /    / // __ \ / / / // __  // __  |/ __ `// ___// _ \</span><br><span class="line">/ /___ / // /_/ // /_/ // /_/ // /_/ // /_/ /(__  )/  __/</span><br><span class="line">\_________\____/ \__,_/ \__,_//_____/ \__,_//____/ \___/       __</span><br><span class="line">   / ____/_____ ____ _ ____ ___   ___  _      __ ____   _____ / /__</span><br><span class="line">  / /_   / ___// __ `// __ `__ \ / _ \| | /| / // __ \ / ___// //_/</span><br><span class="line"> / __/  / /   / /_/ // / / / / //  __/| |/ |/ // /_/ // /   / ,&lt;</span><br><span class="line">/_/    /_/    \__,_//_/ /_/ /_/ \___/ |__/|__/ \____//_/   /_/|_|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> CloudBase Framework  info     Version v1.2.10</span><br><span class="line"> CloudBase Framework  info     Github: https://github.com/Tencent/cloudbase-framework</span><br><span class="line"></span><br><span class="line"> CloudBase Framework  info     EnvId webpage</span><br><span class="line">? 检测到当前项目包含 Vue.js 项目</span><br><span class="line"></span><br><span class="line">  🔨 构建脚本 `npm run build`</span><br><span class="line">  📦 本地静态文件目录 `dist`</span><br><span class="line"></span><br><span class="line">  是否需要修改默认配置 No</span><br><span class="line">? 请输入应用唯一标识(支持大小写字母数字及连字符, 同一账号下不能相同) test-vue</span><br><span class="line">? 是否需要保存当前项目配置，保存配置之后下次不会再次询问 Yes</span><br><span class="line"> CloudBase Framework  info     📦 install plugins</span><br></pre></td></tr></table></figure><p><strong>手动填写插件配置</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;framework&quot;: &#123;</span><br><span class="line">    &quot;plugins&quot;: &#123;</span><br><span class="line">      &quot;client&quot;: &#123;</span><br><span class="line">        &quot;use&quot;: &quot;@cloudbase/framework-plugin-website&quot;,</span><br><span class="line">        &quot;inputs&quot;: &#123;</span><br><span class="line">          &quot;buildCommand&quot;: &quot;npm run build&quot;,</span><br><span class="line">          &quot;outputPath&quot;: &quot;dist&quot;,</span><br><span class="line">          &quot;cloudPath&quot;: &quot;/vue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;server&quot;: &#123;</span><br><span class="line">        &quot;use&quot;: &quot;@cloudbase/framework-plugin-function&quot;,</span><br><span class="line">        &quot;inputs&quot;: &#123;</span><br><span class="line">          &quot;functionRootPath&quot;: &quot;cloudfunctions&quot;,</span><br><span class="line">          &quot;functions&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;name&quot;: &quot;vue-echo&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>官方插件列表</strong></p><ul><li><a href="https://github.com/Tencent/cloudbase-framework/tree/master/packages/framework-plugin-website" target="_blank" rel="noopener">@cloudbase/framework-plugin-website 一键部署网站应用</a></li><li><a href="https://github.com/Tencent/cloudbase-framework/tree/master/packages/framework-plugin-node" target="_blank" rel="noopener">@cloudbase/framework-plugin-node 一键部署 Node 应用（支持底层部署为函数或者 云托管）</a></li><li><a href="https://github.com/Tencent/cloudbase-framework/tree/master/packages/framework-plugin-nuxt" target="_blank" rel="noopener">@cloudbase/framework-plugin-nuxt 一键部署 Nuxt SSR 应用</a></li><li><a href="https://github.com/Tencent/cloudbase-framework/tree/master/packages/framework-plugin-function" target="_blank" rel="noopener">@cloudbase/framework-plugin-function 一键部署函数资源</a></li><li><a href="https://github.com/Tencent/cloudbase-framework/tree/master/packages/framework-plugin-container" target="_blank" rel="noopener">@cloudbase/framework-plugin-container 一键部署云托管容器服务</a></li><li><a href="https://github.com/Tencent/cloudbase-framework/tree/master/packages/framework-plugin-database" target="_blank" rel="noopener">@cloudbase/framework-plugin-database 一键声明式部署云开发 NoSQL 云数据库</a></li><li><a href="https://github.com/Tencent/cloudbase-framework/tree/master/packages/framework-plugin-deno" target="_blank" rel="noopener">@cloudbase/framework-plugin-deno 一键部署 Deno 应用</a></li><li><a href="https://github.com/Tencent/cloudbase-framework/tree/master/packages/framework-plugin-next" target="_blank" rel="noopener">@cloudbase/framework-plugin-next 一键部署 Next SSR 应用</a></li><li><a href="https://github.com/Tencent/cloudbase-framework/tree/master/packages/framework-plugin-mp" target="_blank" rel="noopener">@cloudbase/framework-plugin-mp 一键部署微信小程序应用</a></li><li><a href="https://github.com/Tencent/cloudbase-framework/tree/master/packages/framework-plugin-auth" target="_blank" rel="noopener">    @cloudbase/framework-plugin-auth 一键设置登录配置</a></li></ul><blockquote><p>常用插件介绍</p></blockquote><h4 id="静态网站插件"><a href="#静态网站插件" class="headerlink" title="静态网站插件"></a>静态网站插件</h4><blockquote><p>云开发 CloudBase Framework 框架「Function」插件： 通过云开发 CloudBase Framework 框架将静态网站一键部署云开发环境，提供生产环境可用的 CDN 加速、自动弹性伸缩的高性能网站服务。可以搭配其他插件如 Node 插件、函数插件实现云端一体开发。</p></blockquote><ul><li>节约成本: 资源伸缩，弹性扩缩容，灵活计费，极大节约资源成本</li><li>极简配置：自动检测框架，无须配置，同时支持没有使用框架的纯静态项目</li><li>框架支持: 无缝支持原生和前端框架构建的项目<ul><li>Vue</li><li>React</li><li>Next SPA</li><li>Nuxt SPA</li><li>VuePress</li></ul></li></ul><blockquote><p>如果想全新开始一个项目，可以直接执行 init 来从模板开始一个网站项目</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 部署</span><br><span class="line">cloudbase framework deploy</span><br></pre></td></tr></table></figure><blockquote><p>cloudbase init 之后会创建云开发的配置文件 cloudbaserc.json，可在配置文件的 plugins 里修改和写入插件配置</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"&#123;&#123;envId&#125;&#125;"</span>,</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"client"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-website"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"installCommand"</span>: <span class="string">"npm install --prefer-offline --no-audit --progress=false"</span>,</span><br><span class="line">          <span class="string">"buildCommand"</span>: <span class="string">"npm run build"</span>, <span class="comment">// 构建命令，如npm run build，没有可不传</span></span><br><span class="line">          <span class="string">"outputPath"</span>: <span class="string">"dist"</span>, <span class="comment">// 网站静态文件的路径。</span></span><br><span class="line">          <span class="string">"cloudPath"</span>: <span class="string">"/path"</span>, <span class="comment">// 静态资源部署到云开发环境的路径，默认为根目录。</span></span><br><span class="line">          <span class="string">"ignore"</span>: [<span class="string">".git"</span>, <span class="string">".github"</span>, <span class="string">"node_modules"</span>, <span class="string">"cloudbaserc.js"</span>] <span class="comment">// 静态资源部署时忽略的文件路径，支持通配符</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="云函数插件"><a href="#云函数插件" class="headerlink" title="云函数插件"></a>云函数插件</h4><p><strong>功能特性</strong></p><ul><li>节约成本: 资源伸缩，弹性扩缩容，灵活计费，极大节约资源成本</li><li>极简配置：自动检测框架，无须配置</li><li>语言支持:<ul><li>Node.JS</li><li>PHP</li><li>Java</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"&#123;&#123;envId&#125;&#125;"</span>,</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"function"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-function"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">            <span class="comment">// 函数根目录</span></span><br><span class="line">          <span class="string">"functionRootPath"</span>: <span class="string">"./cloudfunctions"</span>,</span><br><span class="line">          <span class="string">"publishIncludeList"</span>: <span class="string">"&#123;&#123;env.publishIncludeList&#125;&#125;"</span>,</span><br><span class="line">          <span class="comment">// 云函数默认配置, 配置格式和单个函数配置格式相同</span></span><br><span class="line">          <span class="string">"functionDefaultConfig"</span>: &#123;</span><br><span class="line">            <span class="string">"timeout"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">"envVariables"</span>: &#123;</span><br><span class="line">              <span class="string">"FOO"</span>: <span class="string">"bar"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"runtime"</span>: <span class="string">"Nodejs10.15"</span>,</span><br><span class="line">            <span class="string">"memorySize"</span>: <span class="number">128</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 函数配置数组，每个函数的配置格式要求如下：</span></span><br><span class="line">          <span class="string">"functions"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 云函数名称，即为函数部署后的名称</span></span><br><span class="line">              <span class="string">"name"</span>: <span class="string">"helloworld"</span>,</span><br><span class="line">              <span class="string">"envVariables"</span>: &#123;<span class="comment">// 包含环境变量的键值对对象</span></span><br><span class="line">                <span class="string">"ABC"</span>: <span class="string">"xyz"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="comment">// 服务路径配置</span></span><br><span class="line">          <span class="string">"servicePaths"</span>: &#123;</span><br><span class="line">            <span class="string">"helloworld"</span>: <span class="string">"/helloworld"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="登录鉴权插件"><a href="#登录鉴权插件" class="headerlink" title="登录鉴权插件"></a>登录鉴权插件</h4><blockquote><p>云开发 CloudBase Framework 框架「登录配置」插件： 通过云开发 CloudBase Framework 框架一键设置环境下的登录配置。</p></blockquote><ul><li>支持未登录、匿名登录登录设置</li><li>后续会支持开放平台、公众号、账号密码等其他登录方式配置</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://docs.cloudbase.net/framework/plugins/framework-plugin-auth</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"YOU_ENV_ID"</span>,</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"auth"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-auth"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"configs"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"platform"</span>: <span class="string">"NONLOGIN"</span>,</span><br><span class="line">              <span class="string">"status"</span>: <span class="string">"ENABLE"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="云数据库插件"><a href="#云数据库插件" class="headerlink" title="云数据库插件"></a>云数据库插件</h4><blockquote><p>云开发 CloudBase Framework 框架「Database」插件： 通过云开发 CloudBase Framework 框架一键配置云开发数据库集合、索引，使用高性能的 Serverless 化的 NoSQL 数据库服务。可以搭配其他插件如 Website 插件、Node 插件实现云端一体开发。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://docs.cloudbase.net/framework/plugins/framework-plugin-database</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"&#123;&#123;envId&#125;&#125;"</span>,</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"client"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-database"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"collections"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"collectionName"</span>: <span class="string">"test-collection"</span>, <span class="comment">//集合名称</span></span><br><span class="line">              <span class="string">"description"</span>: <span class="string">"test"</span>, <span class="comment">// 描述信息</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="微信小程序插件"><a href="#微信小程序插件" class="headerlink" title="微信小程序插件"></a>微信小程序插件</h4><blockquote><p>云开发 CloudBase Framework 框架「小程序」插件： 通过云开发 CloudBase Framework 框架一键部署微信小程序应用。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://docs.cloudbase.net/framework/plugins/framework-plugin-mp</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"&#123;&#123;envId&#125;&#125;"</span>,</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"client"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-mp"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"appid"</span>: <span class="string">""</span>,<span class="comment">//必填，小程序应用的 appid</span></span><br><span class="line">          <span class="comment">//选填，小程序应用的部署私钥内容，需要经过 base64 编码 可以使用 小程序部署密钥转换小工具 来转换为 Base64</span></span><br><span class="line">          <span class="comment">// https://framework-1258016615.tcloudbaseapp.com/mp-key-tool/</span></span><br><span class="line">          <span class="string">"privateKeyPath"</span>: <span class="string">""</span>,</span><br><span class="line">          <span class="string">"localPath"</span>: <span class="string">"./"</span>,</span><br><span class="line">          <span class="string">"ignores"</span>: [<span class="string">"node_modules/**/*"</span>],</span><br><span class="line">          <span class="string">"deployMode"</span>: <span class="string">"preview"</span>,</span><br><span class="line">          <span class="string">"previewOptions"</span>: &#123;</span><br><span class="line">            <span class="string">"desc"</span>: <span class="string">"CloudBase Framework 一键预览"</span>,</span><br><span class="line">            <span class="string">"setting"</span>: &#123;</span><br><span class="line">              <span class="string">"es6"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"qrcodeOutputPath"</span>: <span class="string">"./qrcode.jpg"</span>,</span><br><span class="line">            <span class="string">"pagePath"</span>: <span class="string">"pages/index/index"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>默认模板的 appid 和 privateKeyPath 为空，需要开发者填入</p></blockquote><h4 id="Node-插件"><a href="#Node-插件" class="headerlink" title="Node 插件"></a>Node 插件</h4><blockquote><p>云开发 CloudBase Framework 框架「Node.js App」插件： 通过云开发 CloudBase Framework 框架将 Node 应用一键部署云开发环境，提供自动弹性伸缩的高性能 Node 应用服务，支持底层部署为函数或者 云托管，可以搭配其他插件如 Website 插件、函数插件实现云端一体开发。</p></blockquote><p><strong>功能特性</strong></p><ul><li>无须关心底层架构: 只需要开发业务服务，不用适配函数或者容器</li><li>节约成本: 资源伸缩，弹性扩缩容，灵活计费，极大节约资源成本</li><li>框架支持: 无缝支持原生和前端框架构建的项目<ul><li>原生 Node.js</li><li>Express</li><li>Koa</li></ul></li></ul><p>如果目前已有 Node 应用项目</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloudbase</span><br></pre></td></tr></table></figure><p>如果想全新开始一个项目，可以直接执行 init 来从模板开始一个项目</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloudbase init</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://docs.cloudbase.net/framework/plugins/framework-plugin-node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"&#123;&#123;envId&#125;&#125;"</span>,</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"server"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-node"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">        <span class="comment">// 默认app.js</span></span><br><span class="line">        <span class="comment">// Node 服务入口文件，相对于projectPath,需要导出 app 或者 server 的实例，同时也支持导出异步获取 app 的 tcbGetApp 方法，方法的返回值为 app 或者 server 的实例。</span></span><br><span class="line">          <span class="string">"entry"</span>: <span class="string">"app.js"</span>,</span><br><span class="line">          <span class="string">"path"</span>: <span class="string">"/nodeapp"</span>, <span class="comment">// 必填，访问子路径，如 /node-app</span></span><br><span class="line">          <span class="string">"name"</span>: <span class="string">"nodeapp"</span>, <span class="comment">// 必填，服务名，如node-app</span></span><br><span class="line">          <span class="string">"projectPath"</span>: <span class="string">""</span>, <span class="comment">// 选填，指定 Node 服务所在目录，相对于当前项目根目录</span></span><br><span class="line">          <span class="string">"buildCommand"</span>: <span class="string">""</span>, <span class="comment">// 选填，指定构建命令，比如npm run build</span></span><br><span class="line">          <span class="string">"platform"</span>: <span class="string">""</span>, <span class="comment">// 选填，底层使用平台，支持 container（ 云托管） 和 function （云函数）, 默认是 function</span></span><br><span class="line">          <span class="string">"containerOptions"</span>: &#123;<span class="comment">// 选填，当 platform 选择 container 时，可以支持自定义更多高级设置，例如 CPU 内存等</span></span><br><span class="line">            <span class="string">"cpu"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="string">"mem"</span>: <span class="number">2</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">"functionOptions"</span>: &#123;</span><br><span class="line">                <span class="string">"timeout"</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="string">"envVariables"</span>: &#123;</span><br><span class="line">                    <span class="string">"TEST_ENV"</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"vpc"</span>: &#123;</span><br><span class="line">                    <span class="string">"vpcId"</span>: <span class="string">"xxx"</span>,</span><br><span class="line">                    <span class="string">"subnetId"</span>: <span class="string">"xxx"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>entry</code></li></ul><p>默认 <code>app.js</code></p><blockquote><p>Node 服务入口文件，相对于projectPath,需要导出 app 或者 server 的实例，同时也支持导出异步获取 app 的 tcbGetApp 方法，方法的返回值为 app 或者 server 的实例。</p></blockquote><p>如 koa 服务的 <code>app.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; router &#125; = <span class="built_in">require</span>(<span class="string">'./routes/'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure><p>nest 服务的 <code>app.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; NestFactory &#125; = <span class="built_in">require</span>(<span class="string">'@nestjs/core'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ExpressAdapter &#125; = <span class="built_in">require</span>(<span class="string">'@nestjs/platform-express'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; AppModule &#125; = <span class="built_in">require</span>(<span class="string">'./dist/app.module'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> expressApp = express();</span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> ExpressAdapter(expressApp);</span><br><span class="line"></span><br><span class="line">exports.tcbGetApp = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule, adapter);</span><br><span class="line">  <span class="keyword">await</span> app.init();</span><br><span class="line">  <span class="keyword">return</span> expressApp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="云托管容器插件"><a href="#云托管容器插件" class="headerlink" title="云托管容器插件"></a>云托管容器插件</h4><p><strong>功能特性</strong></p><ul><li>节约成本: 资源伸缩，弹性扩缩容，灵活计费，极大节约资源成本</li><li>极简配置：自动检测框架，无须配置</li><li>语言支持和框架支持广泛<ul><li>Node.JS</li><li>PHP</li><li>Java</li><li>Go</li><li>Dart</li><li>Deno</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://docs.cloudbase.net/framework/plugins/framework-plugin-container</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"&#123;&#123;envId&#125;&#125;"</span>,</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"client"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-container"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"serviceName"</span>: <span class="string">"node-api"</span>, <span class="comment">// 必填，服务名，字符串格式，如 node-api</span></span><br><span class="line">          <span class="string">"servicePath"</span>: <span class="string">"/node-api"</span>,<span class="comment">// 必填，服务路径配置, 字符串格式, 如 /node-api</span></span><br><span class="line">          <span class="string">"localPath"</span>: <span class="string">"./"</span> <span class="comment">// 选填，本地代码文件夹相对于项目根目录的路径，默认值 ./</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-一键部署按钮制作"><a href="#5-4-一键部署按钮制作" class="headerlink" title="5.4 一键部署按钮制作"></a>5.4 一键部署按钮制作</h3><blockquote><p>参考 <a href="https://docs.cloudbase.net/framework/deploy-button" target="_blank" rel="noopener">https://docs.cloudbase.net/framework/deploy-button</a></p></blockquote><h3 id="5-5-云开发部署应用演示"><a href="#5-5-云开发部署应用演示" class="headerlink" title="5.5 云开发部署应用演示"></a>5.5 云开发部署应用演示</h3><blockquote><p>云开发部署模板参考：<a href="https://github.com/TencentCloudBase/cloudbase-templates" target="_blank" rel="noopener">https://github.com/TencentCloudBase/cloudbase-templates</a></p></blockquote><h4 id="云开发部署Egg"><a href="#云开发部署Egg" class="headerlink" title="云开发部署Egg"></a>云开发部署Egg</h4><blockquote><p>node插件文档 <a href="https://docs.cloudbase.net/framework/plugins/framework-plugin-node" target="_blank" rel="noopener">https://docs.cloudbase.net/framework/plugins/framework-plugin-node</a></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 初始化egg项目</span><br><span class="line">tcb new egg-demo</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/627d5a83ca20f2ae.png" alt></p><p><strong>编写cloudbaserc.json</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"test-xx"</span>,</span><br><span class="line">  <span class="string">"$schema"</span>: <span class="string">"https://framework-1258016615.tcloudbaseapp.com/schema/latest.json"</span>,</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"egg-starter"</span>,</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"node"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-node"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"entry"</span>: <span class="string">"app.js"</span>,</span><br><span class="line">          <span class="string">"name"</span>: <span class="string">"egg-starter"</span>,</span><br><span class="line">          <span class="string">"path"</span>: <span class="string">"/egg-starter"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"functionRoot"</span>: <span class="string">"./functions"</span>,</span><br><span class="line">  <span class="string">"functions"</span>: [],</span><br><span class="line">  <span class="string">"region"</span>: <span class="string">"ap-guangzhou"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加启动入口文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Application &#125; = <span class="built_in">require</span>(<span class="string">'egg'</span>);</span><br><span class="line"></span><br><span class="line">exports.tcbGetApp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Application(&#123;</span><br><span class="line">    env: <span class="string">'prod'</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>部署</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb framework deploy</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/2f3e27804bd7105b.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/c2500d4d92e0da5e.png" alt></p><h4 id="云开发部署Koa"><a href="#云开发部署Koa" class="headerlink" title="云开发部署Koa"></a>云开发部署Koa</h4><blockquote><p>node插件文档 <a href="https://docs.cloudbase.net/framework/plugins/framework-plugin-node" target="_blank" rel="noopener">https://docs.cloudbase.net/framework/plugins/framework-plugin-node</a></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 初始化koa项目</span><br><span class="line">tcb new koa-demo</span><br></pre></td></tr></table></figure><p><strong>编写cloudbaserc.json</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"test-xxx"</span>,</span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"koa-starter"</span>,</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"node"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-node"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"name"</span>: <span class="string">"koa-starter"</span>,</span><br><span class="line">          <span class="string">"path"</span>: <span class="string">"/koa-starter"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"functionRoot"</span>: <span class="string">"./functions"</span>,</span><br><span class="line">  <span class="string">"functions"</span>: [],</span><br><span class="line">  <span class="string">"region"</span>: <span class="string">"ap-guangzhou"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改<code>app.js</code>，导出 <code>module.exports = app</code></p></blockquote><p>部署</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb framework deploy</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/e287aea2c9821cc4.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/966fc0e7f631cba5.png" alt></p><h4 id="云开发部署React"><a href="#云开发部署React" class="headerlink" title="云开发部署React"></a>云开发部署React</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 初始化react项目</span><br><span class="line">tcb new react-demo</span><br></pre></td></tr></table></figure><p><strong>编写cloudbaserc.json</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="string">"envId"</span>: <span class="string">"test-xx"</span>,</span><br><span class="line">  <span class="string">"$schema"</span>: <span class="string">"https://framework-1258016615.tcloudbaseapp.com/schema/latest.json"</span>,</span><br><span class="line">  <span class="string">"functionRoot"</span>: <span class="string">"cloudfunctions"</span>, <span class="comment">// 云函数目录</span></span><br><span class="line">  <span class="string">"framework"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"react-starter"</span>,</span><br><span class="line">    <span class="string">"plugins"</span>: &#123;</span><br><span class="line">      <span class="string">"client"</span>: &#123;</span><br><span class="line">        <span class="comment">// 插件文档 https://docs.cloudbase.net/framework/plugins/framework-plugin-website</span></span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-website"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"buildCommand"</span>: <span class="string">"npm run build"</span>,</span><br><span class="line">          <span class="string">"outputPath"</span>: <span class="string">"build"</span>,</span><br><span class="line">          <span class="string">"cloudPath"</span>: <span class="string">"/react-starter"</span>, <span class="comment">// 当前静态托管的 /react-starter 目录下</span></span><br><span class="line">          <span class="string">"envVariables"</span>: &#123;</span><br><span class="line">            <span class="string">"REACT_APP_ENV_ID"</span>: <span class="string">"&#123;&#123;env.ENV_ID&#125;&#125;"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"server"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-function"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"functionRootPath"</span>: <span class="string">"cloudfunctions"</span>,</span><br><span class="line">          <span class="string">"functions"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"name"</span>: <span class="string">"helloworld"</span>,</span><br><span class="line">              <span class="string">"timeout"</span>: <span class="number">5</span>,</span><br><span class="line">              <span class="string">"envVariables"</span>: &#123;&#125;,</span><br><span class="line">              <span class="string">"runtime"</span>: <span class="string">"Nodejs10.15"</span>,</span><br><span class="line">              <span class="string">"memory"</span>: <span class="number">256</span>,</span><br><span class="line">              <span class="string">"aclRule"</span>: &#123;</span><br><span class="line">                <span class="string">"invoke"</span>: <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"auth"</span>: &#123;</span><br><span class="line">        <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-auth"</span>,</span><br><span class="line">        <span class="string">"inputs"</span>: &#123;</span><br><span class="line">          <span class="string">"configs"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">"platform"</span>: <span class="string">"NONLOGIN"</span>,</span><br><span class="line">              <span class="string">"status"</span>: <span class="string">"ENABLE"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"functions"</span>: [],</span><br><span class="line">  <span class="string">"region"</span>: <span class="string">"ap-guangzhou"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb framework deploy</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/50d7e5c2d8654dff.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/ad02ca3fac62bdec.png" alt></p><h4 id="云开发部署Vue"><a href="#云开发部署Vue" class="headerlink" title="云开发部署Vue"></a>云开发部署Vue</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 初始化vue项目</span><br><span class="line">tcb new vue-demo</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/4af41bcbd091b686.png" alt></p><p><strong>编写cloudbaserc.json</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"envId"</span>: <span class="string">"test-xx"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">    <span class="string">"$schema"</span>: <span class="string">"https://framework-1258016615.tcloudbaseapp.com/schema/latest.json"</span>,</span><br><span class="line">    <span class="string">"functionRoot"</span>: <span class="string">"./functions"</span>,</span><br><span class="line">    <span class="string">"functions"</span>: [],</span><br><span class="line">    <span class="string">"region"</span>: <span class="string">"ap-guangzhou"</span>, <span class="comment">// 默认是ap-shanghai</span></span><br><span class="line">    <span class="string">"framework"</span>: &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"vue-hello-world"</span>,</span><br><span class="line">        <span class="string">"plugins"</span>: &#123;</span><br><span class="line">            <span class="string">"vue"</span>: &#123;</span><br><span class="line">                <span class="comment">// 插件文档 https://docs.cloudbase.net/framework/plugins/framework-plugin-website</span></span><br><span class="line">                <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-website"</span>,</span><br><span class="line">                <span class="string">"inputs"</span>: &#123;</span><br><span class="line">                    <span class="string">"buildCommand"</span>: <span class="string">"npm run build"</span>,</span><br><span class="line">                    <span class="string">"outputPath"</span>: <span class="string">"dist"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb framework deploy</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/c34f69c797a05e2b.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/569a41e7e44d4911.png" alt></p><h4 id="部署hexo"><a href="#部署hexo" class="headerlink" title="部署hexo"></a>部署hexo</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 初始化hexo项目</span><br><span class="line">tcb new hexo-demo</span><br></pre></td></tr></table></figure><p><strong>编写cloudbaserc.json</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"envId"</span>: <span class="string">"poetry-xx"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">    <span class="string">"$schema"</span>: <span class="string">"https://framework-1258016615.tcloudbaseapp.com/schema/latest.json"</span>,</span><br><span class="line">    <span class="string">"functionRoot"</span>: <span class="string">"./functions"</span>,</span><br><span class="line">    <span class="string">"functions"</span>: [],</span><br><span class="line">    <span class="string">"region"</span>: <span class="string">"ap-guangzhou"</span>, <span class="comment">// 默认是ap-shanghai</span></span><br><span class="line">    <span class="string">"framework"</span>: &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"hexo-hello-world"</span>,</span><br><span class="line">        <span class="string">"plugins"</span>: &#123;</span><br><span class="line">            <span class="string">"hexo"</span>: &#123;</span><br><span class="line">                <span class="comment">// 插件文档 https://docs.cloudbase.net/framework/plugins/framework-plugin-website</span></span><br><span class="line">                <span class="string">"use"</span>: <span class="string">"@cloudbase/framework-plugin-website"</span>,</span><br><span class="line">                <span class="string">"inputs"</span>: &#123;</span><br><span class="line">                    <span class="string">"buildCommand"</span>: <span class="string">"npx hexo generate"</span>,</span><br><span class="line">                    <span class="string">"outputPath"</span>: <span class="string">"./public"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb framework deploy</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/fb0f146a969d6506.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/f09f236c850cdbc6.png" alt></p><h2 id="六、使用云开发部署web应用"><a href="#六、使用云开发部署web应用" class="headerlink" title="六、使用云开发部署web应用"></a>六、使用云开发部署web应用</h2><h3 id="6-1-部署hexo"><a href="#6-1-部署hexo" class="headerlink" title="6.1 部署hexo"></a>6.1 部署hexo</h3><p><strong>使用 hexo 命令行初始化一个项目</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx hexo init hexo-hello-world</span><br></pre></td></tr></table></figure><p><strong>部署项目</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcb env list 查看环境列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">cloudbase framework deploy -e &lt;your-env-id&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/8a0f9b7b169f862a.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/2e99b96c91ea6bf4.png" alt></p><h3 id="6-2-部署Vue"><a href="#6-2-部署Vue" class="headerlink" title="6.2 部署Vue"></a>6.2 部署Vue</h3><p><strong>初始化项目</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx vue create vue-hello-world</span><br></pre></td></tr></table></figure><p><strong>发布项目</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tcb env list 查看环境列表</span><br><span class="line"></span><br><span class="line"># 部署</span><br><span class="line">tcb framework deploy -e &lt;your-env-id&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/bc8ba28de42ff604.png" alt></p><h2 id="七、在云开发中使用NoSQL数据库"><a href="#七、在云开发中使用NoSQL数据库" class="headerlink" title="七、在云开发中使用NoSQL数据库"></a>七、在云开发中使用NoSQL数据库</h2><blockquote><p>在面板上创建一个<code>NoSQL</code>的数据库，<a href="https://docs.cloudbase.net/database/introduce" target="_blank" rel="noopener">参考地址</a></p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/fd5954cd15c3e0e9.png" alt></p><blockquote><p>在项目中安装连接数据库的<code>SDK</code><a href="https://docs.cloudbase.net/api-reference/server/node-sdk/introduction" target="_blank" rel="noopener">参考文档</a></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @cloudbase/node-sdk</span><br></pre></td></tr></table></figure><blockquote><p>初始化数据库连接<a href="https://docs.cloudbase.net/api-reference/server/node-sdk/initialization" target="_blank" rel="noopener">参考地址</a></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cloudbase <span class="keyword">from</span> <span class="string">'@cloudbase/node-sdk'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意以下几个参数是必填的,文档上说的是非必填</span></span><br><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">    secretId: <span class="string">'xx'</span>,</span><br><span class="line">    secretKey: <span class="string">'yy'</span>,</span><br><span class="line">    env: <span class="string">'xx'</span>,</span><br><span class="line">    <span class="comment">// 根据你创建的区域来写,目前只有上海(ap-shanghai)、广州(ap-guangzhou)</span></span><br><span class="line">    region: <span class="string">'ap-shanghai'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取数据库引用</span></span><br><span class="line"><span class="keyword">const</span> db = app.database();</span><br></pre></td></tr></table></figure><p><code>env</code>的获取地址</p><p><img src="https://s.poetries.work/uploads/2022/06/45dad89cf73176e3.png" alt></p><p><code>secretId</code> 和<code>secretKey</code>获取：<a href="https://console.cloud.tencent.com/cam/capi" target="_blank" rel="noopener">https://console.cloud.tencent.com/cam/capi</a></p><p><img src="https://s.poetries.work/uploads/2022/06/8cab74708230b661.png" alt></p><h2 id="八、在VS-Code中使用Toolkit管理云开发项目"><a href="#八、在VS-Code中使用Toolkit管理云开发项目" class="headerlink" title="八、在VS Code中使用Toolkit管理云开发项目"></a>八、在VS Code中使用Toolkit管理云开发项目</h2><h3 id="8-1-基本使用介绍"><a href="#8-1-基本使用介绍" class="headerlink" title="8.1 基本使用介绍"></a>8.1 基本使用介绍</h3><blockquote><p>Tencent CloudBase Toolkit 是腾讯云 - 云开发发布的 VS Code（Visual Studio Code）插件。该插件可以让您更好地在本地进行云开发项目开发和代码调试，并且轻松将项目部署到云端。</p></blockquote><p><strong>通过 Tencent CloudBase Toolkit 插件，您可以：</strong></p><ul><li>在本地快速创建云开发项目</li><li>从多种模板快速创建云函数</li><li>同步云端的云函数列表，并下载函数代码到本地</li><li>部署云函数到云端，并进行云端安装依赖</li><li>对云函数进行管理，如删除云函数、查看云函数详细信息</li><li>增量更新云函数文件</li><li>删除云端的云函数文件</li><li>部署静态托管文件到云端</li></ul><p>同时，VS Code 插件也支持了云函数本地调试与云端调试，帮助你快速定位代码问题</p><p><img src="https://s.poetries.work/uploads/2022/06/b09bcd56a8afaba5.png" alt></p><p><strong>登录</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/79fedf80af936261.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/d64d37ed50ab8a11.png" alt></p><p><strong>创建新项目</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/8398b4d1b46da096.png" alt></p><blockquote><p><strong>注意</strong>：<code>CloudBase Toolkit</code> 插件依赖于 <code>cloudbaserc.json</code> 配置文件，<code>只有当前项目的根目录下存在 cloudbaserc.json 配置文件时</code>，才能使用 <code>CloudBase Toolkit</code> 插件进行相关操作。</p></blockquote><p>如果您还没有云开发项目，可以使用初始化操作创建一个全新的云开发项目，CloudBase Toolkit 提供了部分模板项目供选择。</p><blockquote><p><code>打开一个空的文件夹作为根目录</code>，点击侧边栏的云开发图标，点击下图示例中的条目</p></blockquote><ul><li>选择地区</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/6e62d9caf3ead536.png" alt></p><ul><li>选择地区关联的环境ID</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/c0077a6f7d345269.png" alt></p><ul><li>选择对应的模板</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/2fe16d3cb23b86fe.png" alt></p><ul><li>项目创建成功</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/c274c86297e0037e.png" alt></p><ul><li>项目目录结构</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/d0ea2cb4f67df0a8.png" alt></p><blockquote><p>VS Code 插件会默认使用当前窗口打开文件夹的根目录下的 <code>cloudbaserc.json</code> 配置文件，如果你使用了 VS Code 工作区，则会使用工作区中的第一个项目文件夹根目录下的配置文件</p></blockquote><p>关于 <code>cloudbaserc.json</code> <a href="https://docs.cloudbase.net/cli-v1/config" target="_blank" rel="noopener">配置文件的详情可以参考这里 🔗</a></p><ul><li>以上操作可以使用<code>tcb framework deploy</code>一键部署</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 函数和静态网站一起部署</span><br><span class="line">tcb framework deploy</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/7841d0aab3b6def2.png" alt></p><h3 id="8-2-云函数操作"><a href="#8-2-云函数操作" class="headerlink" title="8.2 云函数操作"></a>8.2 云函数操作</h3><blockquote><p>对云函数进行<code>部署/删除/下载</code>代码等操作时，<code>必须选中云函数文件夹</code>，否则会因为无法解析到准确的函数名称，而导致操作失败。</p></blockquote><p>右键选中函数文件夹，点击部署云函数即可。CloudBase Toolkit 支持同时选择多个云函数进行部署。</p><p><strong>CloudBase Toolkit 支持两种部署云函数的方式：</strong></p><ul><li>部署云函数（上传全部文件）：即将函数目录下的所有文件上传，也包含 <code>node_modules</code> 目录</li><li>部署云函数（云端安装依赖）：只部署代码文件，会忽略 <code>node_modules</code> 目录，云函数会自动在线安装依赖</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/7164c1d025fed2f2.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/f6436c7624819c45.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/27161771a757fa8c.png" alt></p><ul><li>查看函数配置信息</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/fd07b75bb7e5dfb9.png" alt></p><p><strong>下载函数代码</strong></p><p>使用下载函数代码功能，可以将云端函数代码下载到本地，进行操作时，需要选择云函数名称对应的目录。CloudBase Toolkit 支持同时选择多个云函数，下载云函数代码。</p><p><img src="https://s.poetries.work/uploads/2022/06/715c72c283832c56.png" alt></p><p><strong>增量更新</strong></p><p>CloudBase Toolkit 支持上传单个文件或文件夹到云函数中，而无需重新上传整个云函数</p><p><img src="https://s.poetries.work/uploads/2022/06/b474aafabd470e8e.png" alt></p><h3 id="8-3-静态网站"><a href="#8-3-静态网站" class="headerlink" title="8.3 静态网站"></a>8.3 静态网站</h3><blockquote><p>CloudBase Toolkit 支持上传文件/文件夹到静态网站存储中，同时支持文件多选，既可以同时选择多个文件上传。</p></blockquote><p>CloudBase Toolkit 提供了两种上传方法：</p><ul><li>上传到静态托管：需要输入云端存放文件（夹）的文件夹路径，选中的文件（夹）将被上传到此路径下。</li><li>上传到静态托管（根目录）：选中的文件（夹）将被直接上传到根目录下</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/5fda60ae03e5f96c.png" alt></p><h2 id="九、cloudBase之CMS内容管理系统"><a href="#九、cloudBase之CMS内容管理系统" class="headerlink" title="九、cloudBase之CMS内容管理系统"></a>九、cloudBase之CMS内容管理系统</h2><blockquote><ul><li>文档：<a href="https://docs.cloudbase.net/cms/intro" target="_blank" rel="noopener">https://docs.cloudbase.net/cms/intro</a></li><li>Github：<a href="https://github.com/TencentCloudBase/cloudbase-extension-cms" target="_blank" rel="noopener">https://github.com/TencentCloudBase/cloudbase-extension-cms</a></li></ul></blockquote><ul><li>CloudBase CMS 是云开发推出的，基于 Node.js 的 Headless 内容管理平台，提供了丰富的内容管理功能。CloudBase CMS 基于模型配置，动态生成内容管理界面，无须编写代码即可使用，快速管理云开发中的业务数据。支持字符串、数字、多媒体、图片、文件、富文本、Markdown、关联类型等数十种内容类型的可视化编辑。</li><li>CloudBase CMS 已在腾讯云扩展应用、小程序开发者工具中上线，支持一键安装到已有的环境中，管理小程序 / Web 等多端产生的内容数据。</li><li>同时，CloudBase CMS 已经在 GitHub 开源，可以直接在 CloudBase CMS 上进行二次开发，满足业务的多样化需求。</li></ul><blockquote><p>使用 CMS 扩展时将在当前环境创建云函数、云数据库等资源</p></blockquote><p>工作原理</p><p><img src="https://s.poetries.work/uploads/2022/06/eb1db5b08062b46c.png" alt></p><h3 id="9-1-控制台部署CMS"><a href="#9-1-控制台部署CMS" class="headerlink" title="9.1 控制台部署CMS"></a>9.1 控制台部署CMS</h3><blockquote><p>环境需要使用按量付费</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/f475b1efc04f182a.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/fa0e23cb97283134.png" alt></p><p>安装完成可以看到已经部署好的云函数、静态资源、云数据库</p><p><img src="https://s.poetries.work/uploads/2022/06/0078ed499a50ee78.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/ae2ae82d69b699f2.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/eb3ef08b8ab0bc95.png" alt></p><p>登录部署的CMS界面操作演示</p><p><img src="https://s.poetries.work/uploads/2022/06/b00248881e212a34.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/1ff5d829ce888659.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/a4850b81e9666030.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/5f57eee40dfb7381.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/f298c715b04eaf35.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/87fbb479196de69b.png" alt></p><h3 id="9-2-如有二次修改，我们可以使用源码方式部署"><a href="#9-2-如有二次修改，我们可以使用源码方式部署" class="headerlink" title="9.2 如有二次修改，我们可以使用源码方式部署"></a>9.2 如有二次修改，我们可以使用源码方式部署</h3><blockquote><ul><li>源码部署方式 <a href="https://docs.cloudbase.net/cms/install/source" target="_blank" rel="noopener">https://docs.cloudbase.net/cms/install/source</a></li><li>二次开发 <a href="https://docs.cloudbase.net/cms/reference/dev" target="_blank" rel="noopener">https://docs.cloudbase.net/cms/reference/dev</a></li></ul></blockquote><ul><li>安装 <code>npm install -g @cloudbase/cli@latest</code></li><li><a href="https://console.cloud.tencent.com/tcb/env/index?from=cli&amp;source=cloudbase-cms&amp;action=CreateEnv" target="_blank" rel="noopener">开通云开发服务，并创建按量计费环境</a></li></ul><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><blockquote><p>下面是基本的目录结构，采用了 Monorepo 的组织规范，并使用 lerna 进行管理</p></blockquote><ul><li><code>admin</code>： 前端管理界面</li><li><code>cms-api</code>：<code>RESTful API</code> 服务</li><li><code>cms-init</code>：CMS 部署初始化相关脚本</li><li><code>service</code>：后端服务，提供系统管理相关的服务</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── community</span><br><span class="line">├── packages</span><br><span class="line">│   ├── admin</span><br><span class="line">│   │   ├── config</span><br><span class="line">│   │   ├── dist</span><br><span class="line">│   │   ├── public</span><br><span class="line">│   │   ├── src</span><br><span class="line">│   │   │   ├── assets</span><br><span class="line">│   │   │   ├── common</span><br><span class="line">│   │   │   ├── components</span><br><span class="line">│   │   │   ├── layout</span><br><span class="line">│   │   │   ├── locales</span><br><span class="line">│   │   │   ├── models</span><br><span class="line">│   │   │   ├── pages</span><br><span class="line">│   │   │   ├── services</span><br><span class="line">│   │   │   └── utils</span><br><span class="line">│   │   └── typings</span><br><span class="line">│   ├── cms-api</span><br><span class="line">│   │   ├── dist</span><br><span class="line">│   │   ├── src</span><br><span class="line">│   │   │   ├── api</span><br><span class="line">│   │   │   ├── common</span><br><span class="line">│   │   │   ├── guards</span><br><span class="line">│   │   │   ├── interceptors</span><br><span class="line">│   │   │   ├── middlewares</span><br><span class="line">│   │   │   ├── services</span><br><span class="line">│   │   │   └── utils</span><br><span class="line">│   │   └── typings</span><br><span class="line">│   ├── cms-init</span><br><span class="line">│   └── service</span><br><span class="line">│       ├── dist</span><br><span class="line">│       ├── src</span><br><span class="line">│       │   ├── common</span><br><span class="line">│       │   ├── config</span><br><span class="line">│       │   ├── decorators</span><br><span class="line">│       │   ├── guards</span><br><span class="line">│       │   ├── interceptors</span><br><span class="line">│       │   ├── middlewares</span><br><span class="line">│       │   ├── modules</span><br><span class="line">│       │   │   ├── auth</span><br><span class="line">│       │   │   ├── file</span><br><span class="line">│       │   │   ├── projects</span><br><span class="line">│       │   │   ├── role</span><br><span class="line">│       │   │   ├── setting</span><br><span class="line">│       │   │   └── user</span><br><span class="line">│       │   ├── services</span><br><span class="line">│       │   └── utils</span><br><span class="line">│       └── typings</span><br><span class="line">└── scripts</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><blockquote><p>复制项目根目录下的 <code>.env.example</code> 为 <code>.env.local</code>，并填写相关的配置</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 您的云开发环境 Id</span></span><br><span class="line">TCB_ENVID=envId</span><br><span class="line"><span class="comment"># 管理员账户名，账号名长度需要大于 4 位，支持字母和数字</span></span><br><span class="line">administratorName=admin</span><br><span class="line"><span class="comment"># 管理员账号密码，8~32位，密码支持字母、数字、字符、不能由纯字母或存数字组成</span></span><br><span class="line">administratorPassword=123456</span><br><span class="line"><span class="comment"># CMS 控制台路径，如 /tcb-cms/，建议使用根路径 /</span></span><br><span class="line">deployPath=/</span><br><span class="line"><span class="comment"># 云接入自定义域名（选填），如 tencent.com</span></span><br><span class="line">accessDomain=</span><br><span class="line">TENCENTCLOUD_REGION=ap-guangzhou <span class="comment"># 环境ID所在的地区</span></span><br></pre></td></tr></table></figure><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>在项目根目录下运行下面的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install &amp;&amp; npm run setup</span><br></pre></td></tr></table></figure><blockquote><p>如果你使用 <code>npm run setup</code> 命令出现异常，你可以分别到 <code>packages</code> 目录下的文件内，手动执行 <code>npm install</code> 命令。</p></blockquote><p>在项目根目录下运行下面的命令，会将 <code>CloudBase CMS</code> 的管理控制台部署到静态网站，Node 服务部署到云函数中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run deploy</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/d937a67646160b02.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/39a38172b39daa80.png" alt></p><p><strong>控制台管理</strong></p><ul><li>我的应用</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/4f48480646204dd2.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/6742f2c96f05ad0e.png" alt></p><ul><li>云托管服务</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/ac2eddfa13237bd9.png" alt></p><blockquote><p><code>tcb-ext-cms-servic</code>：该服务提供登录鉴权功能，用户在 CMS 管理界面通过通过用户名和密码来进行登录时，会通过 HTTP 来请求该函数；提供 API 接口功能，所有对内容的操作和管理都会经过此函数调用，内容操作会根据用户权限来进行数据库操作。</p></blockquote><ul><li>管理云函数</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/107b9e3f346af8a5.png" alt></p><blockquote><ul><li><code>tcb-ext-cms-init</code>：提供初始化应用功能，安装扩展后，会通过该函数来进行静态资源的部署和密码的生成和设置，修改账号密码或者部署路径等扩展参数都会再次执行该函数来进行更新</li><li><code>tcb-ext-cms-api</code>：提供 <code>CMS RESTful API</code> 访问能力，所有 <code>RESTful API</code> 请求都会经过此函数调用</li></ul></blockquote><ul><li>云存储，存放静态网站</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/eaad8e647a753095.png" alt></p><blockquote><p>存储图片、文件等 CMS 系统上传的文件。</p></blockquote><ul><li>云数据库</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/4b866be7e0bf7cfe.png" alt></p><ul><li><code>tcb-ext-cms-projects</code> 集合：CMS 系统项目数据</li><li><code>tcb-ext-cms-schemas</code> 集合：CMS 系统内容配置数据，CMS 所有的系统内容类型配置、字段配置等信息都存储在该集合内</li><li><code>tcb-ext-cms-users</code> 集合：CMS 系统用户数据，存储 CMS 的用户信息，包括管理员和运营者的账号信息，包括角色信息等</li><li><code>tcb-ext-cms-webhooks</code> 集合： CMS 系统 webhook 集合，存储 CMS 系统的回调接口配置，CMS 系统数据的变更可以通过回调来进行同步。</li><li><code>tcb-ext-cms-user-roles</code> 集合：CMS 系统用户角色配置集合，存储 CMS 系统的自定义用户角色信息</li><li><code>tcb-ext-cms-settings</code> 集合：CMS 系统配置集合，存储 CMS 系统的设置</li></ul><h4 id="安装失败"><a href="#安装失败" class="headerlink" title="安装失败"></a>安装失败</h4><blockquote><p>请查看环境下云函数 <code>tcb-ext-cms-init</code> 的执行日志，获取失败原因。CloudBase CMS 安装时需要使用 <code>tcb-ext-cms-init</code> 函数执行初始化的工作，当出现异常时，会导致安装失败。</p></blockquote><h4 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h4><ol><li>复制根目录下的 <code>.env.example</code> 为 <code>.env.local</code>，并根据文件中的内容进行配置</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 您的云开发环境 Id</span></span><br><span class="line">ENV_ID=envId</span><br><span class="line"><span class="comment"># 管理员账户名，账号名长度需要大于 4 位，支持字母和数字</span></span><br><span class="line">administratorName=admin</span><br><span class="line"><span class="comment"># 管理员账号密码，8~32位，密码支持字母、数字、字符、不能由纯字母或存数字组成</span></span><br><span class="line">administratorPassword=123456</span><br><span class="line"><span class="comment"># CMS 控制台路径，如 /tcb-cms/，建议使用根路径 /</span></span><br><span class="line">deployPath=/</span><br><span class="line"><span class="comment"># 云接入自定义域名（选填），如 tencent.com</span></span><br><span class="line">accessDomain=</span><br><span class="line">TENCENTCLOUD_REGION=ap-guangzhou <span class="comment"># 环境ID所在的地区</span></span><br></pre></td></tr></table></figure><ol start="2"><li>复制 <code>packages/service/.env.example</code> 为 <code>packages/service/.env.local</code>，并根据文件中的内容进行配置</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TCB_ENVID=<span class="built_in">test</span>-xx <span class="comment"># 环境ID</span></span><br><span class="line">SECRETID=密钥ID <span class="comment"># 密钥ID</span></span><br><span class="line">SECRETKEY=密钥KEY <span class="comment"># 密钥KEY</span></span><br><span class="line">TENCENTCLOUD_REGION=ap-guangzhou <span class="comment"># 环境ID所在的地区</span></span><br></pre></td></tr></table></figure><ol start="3"><li>复制 <code>packages/admin/public/config.example.js</code> 为 <code>packages/admin/public/config.js</code>，并根据文件中的内容进行配置</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.TcbCmsConfig = &#123;</span><br><span class="line">  <span class="comment">// 可用区，默认上海，可选：ap-shanghai 或 ap-guangzhou</span></span><br><span class="line">  region: <span class="string">"ap-guangzhou"</span>,</span><br><span class="line">  <span class="comment">// 路由方式：hash 或 browser</span></span><br><span class="line">  history: <span class="string">"hash"</span>,</span><br><span class="line">  <span class="comment">// 环境 Id</span></span><br><span class="line">  envId: <span class="string">"test-9g9512mccb349a321275b"</span>,</span><br><span class="line">  <span class="comment">// 禁用通知</span></span><br><span class="line">  disableNotice: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 禁用帮助按钮</span></span><br><span class="line">  disableHelpButton: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 云接入默认域名/自定义域名 + 云接入路径，不带 https 协议符</span></span><br><span class="line">  <span class="comment">// https://console.cloud.tencent.com/tcb/env/access</span></span><br><span class="line">  <span class="comment">// 环境id+API密钥中的appid（https://console.cloud.tencent.com/cam/capi）</span></span><br><span class="line">  <span class="comment">// API密钥中的appid：1258157827</span></span><br><span class="line">  cloudAccessPath: <span class="string">'test-9g9512mccb349a321275b-1258157827.service.tcloudbase.com/tcb-ext-cms-service'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li>添加安全域名，否则本地开发会报跨域错误</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/c9c7dc7c0ebba705.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/c15711674e3c175d.png" alt></p><p><strong>安装依赖</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装 lerna 依赖</span><br><span class="line">npm install</span><br><span class="line"># 安装 package 依赖</span><br><span class="line">npm run setup</span><br></pre></td></tr></table></figure><p><strong>初始部署</strong></p><p>通过部署动作，触发初始化操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run deploy</span><br></pre></td></tr></table></figure><p><strong>启动开发</strong></p><p>运行下面的命令，成功后，可以访问 <code>http://localhost:8000/</code> 打开 CMS 管理界面</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd packages/admin &amp;&amp; npm run dev</span><br><span class="line">cd packages/service &amp;&amp; npm run dev</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/17ff255d213e43ac.png" alt></p><h4 id="微应用开发"><a href="#微应用开发" class="headerlink" title="微应用开发"></a>微应用开发</h4><p><strong>1. vue微应用接入</strong></p><blockquote><p>接入文档 <a href="https://docs.cloudbase.net/cms/microapp/dev" target="_blank" rel="noopener">https://docs.cloudbase.net/cms/microapp/dev</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建 Vue 微应用项目</span></span><br><span class="line">tcb new vue-app cms-microapp-vue</span><br></pre></td></tr></table></figure><ul><li>打包vue应用<code>npm run build</code></li></ul><p><img src="https://s.poetries.work/uploads/2022/06/065be64fc55c529a.png" alt></p><ul><li>上传微应用</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/ea112b0d249492c2.png" alt></p><p>新建</p><p><img src="https://s.poetries.work/uploads/2022/06/8c672f52136b621a.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/710cbc17f21b8d93.png" alt></p><blockquote><p>上传成功后，可以在管理后台中查看</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/534042fe753270f5.png" alt></p><ul><li>自定义菜单展示微应用</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/44a89633db979007.png" alt></p><ul><li>设置后，在关联的项目中可见</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/48a0980a8ea7075a.png" alt></p><p><strong>2. react微应用接入</strong></p><blockquote><p>接入文档 <a href="https://docs.cloudbase.net/cms/microapp/dev" target="_blank" rel="noopener">https://docs.cloudbase.net/cms/microapp/dev</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建 React 微应用项目</span></span><br><span class="line">tcb new react-app cms-microapp-react</span><br></pre></td></tr></table></figure><h4 id="Resful-API-形式访问"><a href="#Resful-API-形式访问" class="headerlink" title="Resful API 形式访问"></a>Resful API 形式访问</h4><blockquote><p>文档 <a href="https://docs.cloudbase.net/cms/usage/restful/intro" target="_blank" rel="noopener">https://docs.cloudbase.net/cms/usage/restful/intro</a></p></blockquote><p><strong>在系统设置中开启API访问</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/359d527fd134c1a3.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/a066957524d06f9d.png" alt></p><p><strong>在项目设置中的 API 访问 Tab 设置允许通过 RESTful API 访问</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/19a698c8050fa3eb.png" alt></p><p>然后复制访问连接，在postman中访问查看效果</p><p><img src="https://s.poetries.work/uploads/2022/06/3fefbba31221042c.png" alt></p><p><strong>API鉴权访问</strong></p><p>在系统设置中开启API鉴权访问，并创建token</p><p><img src="https://s.poetries.work/uploads/2022/06/26f7c1f886045461.png" alt></p><p>提示需要接口授权才可以访问</p><p><img src="https://s.poetries.work/uploads/2022/06/33b9b9370a87a245.png" alt></p><p>在请求头加入创建好的token即可</p><blockquote><p>当使用 API Token 调用 RESTful API 时，需要在 HTTP 请求 <code>Header</code> 中添加下面的配置</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer API_TOKEN</span><br></pre></td></tr></table></figure><p><code>API_Token</code> 为在系统设置中生成的 <code>Token</code>，<code>Bearer</code> 为固有字段，两者通过空格连接。</p><p><img src="https://s.poetries.work/uploads/2022/06/e083278e128641d0.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/2baff45a779d611a.png" alt></p><h3 id="9-3-微信开发者工具部署"><a href="#9-3-微信开发者工具部署" class="headerlink" title="9.3 微信开发者工具部署"></a>9.3 微信开发者工具部署</h3><blockquote><p>参考 <a href="https://docs.cloudbase.net/cms/install/mp" target="_blank" rel="noopener">https://docs.cloudbase.net/cms/install/mp</a></p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/4ba6ed3a0a6541da.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/81875bb480c85e7d.png" alt></p><h2 id="十、云开发部署腾讯微搭低代码"><a href="#十、云开发部署腾讯微搭低代码" class="headerlink" title="十、云开发部署腾讯微搭低代码"></a>十、云开发部署腾讯微搭低代码</h2><blockquote><p>文档地址 <a href="https://docs.cloudbase.net/lowcode/introduce" target="_blank" rel="noopener">https://docs.cloudbase.net/lowcode/introduce</a></p></blockquote><p>控制台 <a href="https://console.cloud.tencent.com/lowcode/overview/index" target="_blank" rel="noopener">https://console.cloud.tencent.com/lowcode/overview/index</a></p><h2 id="十一、参考文档"><a href="#十一、参考文档" class="headerlink" title="十一、参考文档"></a>十一、参考文档</h2><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://cloudbase.net/" target="_blank" rel="noopener">云开发 CloudBase 云原生一体化应用开发平台，快速构建小程序、Web、移动应用</a></li><li><a href="https://docs.cloudbase.net/database/introduce" target="_blank" rel="noopener">云开发 CloudBase文档</a></li><li><a href="https://cloud.tencent.com/document/product/876" target="_blank" rel="noopener">云开发 CloudBase官方文档</a></li><li><a href="https://docs.cloudbase.net/cli-v1/quick-start" target="_blank" rel="noopener">CloudBase CLI</a></li><li><a href="https://cloud.tencent.com/document/product/876/46332" target="_blank" rel="noopener">CloudBase SDK</a></li><li><a href="https://www.cloudbase.net/marketplace.html" target="_blank" rel="noopener">CloudBase 应用中心拥有各类热门应用，以及大量的生产级项目模板，案例模板，开发者可以自由选择，并将项目一键部署到云开发</a></li><li><a href="https://github.com/TencentCloudBase/cloudbase-action" target="_blank" rel="noopener">云开发 Tencent CloudBase Github Action 可以将 Github 项目自动部署到云开发环境</a></li><li><a href="https://github.com/Tencent/cloudbase-framework/tree/master/packages/framework-plugin-container" target="_blank" rel="noopener">cloudbase-framework-github</a></li><li><a href="https://github.com/TencentCloudBase" target="_blank" rel="noopener">Tencent CloudBase Github</a></li><li><a href="https://docs.cloudbase.net/cli-v1/config" target="_blank" rel="noopener">cloudbaserc.json 配置文件</a></li><li><a href="https://docs.cloudbase.net/cloudbase-ui/introduce" target="_blank" rel="noopener">云开发 React UI 组件 是云开发官方维护的 UI 组件库，提供基于云开发封装的一系列能力，目前已支持统一登录能力</a></li><li><a href="https://docs.cloudbase.net/cloudbase-vue/introduce" target="_blank" rel="noopener">云开发 Vue 插件是云开发官方维护的 Vue 插件，提供全局入口、Vue 逻辑组件等功能</a></li><li><a href="https://docs.cloudbase.net/api-reference/server/node-sdk/introduction" target="_blank" rel="noopener">Cloudbase Server Node.js SDK 让您可以在服务端（如腾讯云云函数或 云主机 等）使用 Node.js 服务访问 TCB 的的服务，如云函数调用，文件上传下载，数据库集合文档操作等，方便快速搭建应用</a></li><li><a href="https://docs.cloudbase.net/api-reference/webv2/initialization" target="_blank" rel="noopener">@cloudbase/js-sdk 让您可以在 Web 端（如 PC Web 页面、微信公众平台 H5 等）使用 JavaScript 访问 Cloudbase 服务和资源</a></li><li><a href="https://docs.cloudbase.net/cms/intro" target="_blank" rel="noopener">CloudBase CMS 是云开发推出的，基于 Node.js 的 Headless 内容管理平台，提供了丰富的内容管理功能</a></li><li><a href="https://webify.cloudbase.net/" target="_blank" rel="noopener">云开发 Webify：专为 Web 开发者打造的应用托管平台，极速开发、部署、上线</a></li><li><a href="https://github.com/TencentCloudBase/cloudbase-templates" target="_blank" rel="noopener">云开发工程模板示例，可通过 CloudBaseFramework 一键创建和部署</a></li><li><a href="https://framework-1258016615.tcloudbaseapp.com/mp-key-tool/" target="_blank" rel="noopener">微信小程序密钥工具</a></li></ul><h3 id="社区提问"><a href="#社区提问" class="headerlink" title="社区提问"></a>社区提问</h3><ul><li>「腾讯云·云开发」相关：<a href="https://support.qq.com/products/148793" target="_blank" rel="noopener">腾讯兔小巢</a> （云开发能力相关的首选这里）</li><li>「微信·云开发」相关：<a href="https://developers.weixin.qq.com/community/minihome/mixflow/1286298401038155776" target="_blank" rel="noopener">微信开放社区</a> （微信相关的都在这里问）</li><li>「微信·云托管」相关：<a href="https://developers.weixin.qq.com/community/minihome/mixflow/1919566493118201863" target="_blank" rel="noopener">微信开放社区</a> （云托管相关的都在这里问）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、关于云开发介绍&quot;&gt;&lt;a href=&quot;#一、关于云开发介绍&quot; class=&quot;headerlink&quot; title=&quot;一、关于云开发介绍&quot;&gt;&lt;/a&gt;一、关于云开发介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;云开发与serverless的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="部署" scheme="http://blog.poetries.top/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="云开发" scheme="http://blog.poetries.top/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信云托管入门与实践</title>
    <link href="http://blog.poetries.top/2022/06/19/wxcloud-intro/"/>
    <id>http://blog.poetries.top/2022/06/19/wxcloud-intro/</id>
    <published>2022-06-19T04:30:41.000Z</published>
    <updated>2025-03-30T13:54:29.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本简介"><a href="#基本简介" class="headerlink" title="基本简介"></a>基本简介</h2><h3 id="微信云托管是什么？"><a href="#微信云托管是什么？" class="headerlink" title="微信云托管是什么？"></a>微信云托管是什么？</h3><ul><li>微信云托管 是微信团队提供的以云原生为基础的，免运维、高可用服务上云解决方案，无需服务器，1分钟即可部署小程序/公众号服务端。</li><li>微信云托管支持目前绝大多数语言/框架项目，开发者可以从服务器平滑迁移；并且微信云托管的自动运维和扩缩容特性，无需开发者关心服务的可用性，专注于业务，极大节省人力和服务资源成本。</li><li>同时，微信云托管还集成持续交付部署，DevOps自动化，安全鉴权等众多能力，致力于帮助没有深层运维经验的业务开发者和研发团队，用最低的成本，打造出稳定性高，安全性强的后端服务。</li><li>最重要的，微信云托管与微信生态深度融合，具有免鉴权，云调用，消息推送，微信支付等众多微信优势特性，开发者可以非常轻松和高效的完成互通，并且在安全、可靠性方面有微信团队的专业保障。</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/1399e820bc230d5c.png" alt></p><h3 id="架构特点"><a href="#架构特点" class="headerlink" title="架构特点"></a>架构特点</h3><blockquote><p>微信云托管以容器服务为核心，提供方便易用的存储体系、微信生态、安全鉴权等服务能力；搭配简单易懂的操作面板，集成资源监控，资源告警，流水线等自动化功能，是一站式的后端云服务。</p></blockquote><p>微信云托管使用目前主流的容器平台Docker以及容器编排技术Kubernetes（简称K8S），来管理你的项目</p><p><img src="https://s.poetries.work/uploads/2022/06/9a112314718e46da.png" alt></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h3 id="云托管的作用是什么？"><a href="#云托管的作用是什么？" class="headerlink" title="云托管的作用是什么？"></a>云托管的作用是什么？</h3><blockquote><p>代替服务器部署小程序/公众号后端。</p></blockquote><h4 id="微信云托管和微信云开发的区别是什么，如何选择？"><a href="#微信云托管和微信云开发的区别是什么，如何选择？" class="headerlink" title="微信云托管和微信云开发的区别是什么，如何选择？"></a>微信云托管和微信云开发的区别是什么，如何选择？</h4><ul><li>微信云开发和微信云托管都是微信联合腾讯云打造的微信云服务生态的组成部分，都提供了免服务器免运维的能力，开发者可以根据自己的业务特点进行选择。</li><li>微信云开发以云函数提供计算能力，围绕 Node.js 技术栈，适合前端开发者简单快捷实现后端功能，或全栈开发者一体化开发； 微信云托管以容器提供计算能力，支持任意后端语言和框架，适合前后端分离项目的后端开发、传统模式后端项目迁移，对团队协作和企业级应用场景更友好</li></ul><h4 id="微信云托管和云开发中的云托管有何区别？"><a href="#微信云托管和云开发中的云托管有何区别？" class="headerlink" title="微信云托管和云开发中的云托管有何区别？"></a>微信云托管和云开发中的云托管有何区别？</h4><ul><li>微信云托管和之前云托管的区别除了品牌升级外，还做了独立的控制台。旧的云托管只是云开发的一个模块，只有单纯的容器引擎能力，升级为微信云托管后脱离云开发，成为完整的后端项目托管解决方案。 从代码管理到CI/CD流水线部署发布，提供全链路、低成本、企业级的云原生解决方案，功能更强大、体验更友好</li><li>云开发中的云托管能力已停止功能更新，仅支持存量业务继续运行。建议原云开发中的云托管的用户尽快将项目迁移到微信云托管。</li></ul><h4 id="微信云托管可以用于APP-网站-其他平台小程序吗？"><a href="#微信云托管可以用于APP-网站-其他平台小程序吗？" class="headerlink" title="微信云托管可以用于APP/网站/其他平台小程序吗？"></a>微信云托管可以用于APP/网站/其他平台小程序吗？</h4><blockquote><p>必须先有微信小程序/公众号才可以开通微信云托管，但部署在微信云托管上的服务可以通过公网访问，因此可以被APP/网站/其他平台小程序的前端调用，只是无法享受 callcontainer 内部链路带来的安全防DDoS/请求加速等优势。</p></blockquote><h4 id="微信云托管的环境可以在微信开发者工具的云开发控制台中看到吗？"><a href="#微信云托管的环境可以在微信开发者工具的云开发控制台中看到吗？" class="headerlink" title="微信云托管的环境可以在微信开发者工具的云开发控制台中看到吗？"></a>微信云托管的环境可以在微信开发者工具的云开发控制台中看到吗？</h4><blockquote><p>微信云托管和微信云开发是两套独立体系，微信云托管的环境只能在微信云托管控制台看到，在微信开发者工具的云开发控制台中不能看到</p></blockquote><h3 id="腾讯云和微信云托管有关系吗？云开发的云托管和微信云托管有什么区别？"><a href="#腾讯云和微信云托管有关系吗？云开发的云托管和微信云托管有什么区别？" class="headerlink" title="腾讯云和微信云托管有关系吗？云开发的云托管和微信云托管有什么区别？"></a>腾讯云和微信云托管有关系吗？云开发的云托管和微信云托管有什么区别？</h3><blockquote><p>微信云托管是整合了腾讯云底层资源和微信生态链路的综合解决方案。原云开发中的云托管独立出来，升级为微信云托管，补充数据库、ci/cd、灰度发布等更多完整后端功能和企业级devops能力。</p></blockquote><h3 id="云托管的时间相差8个小时？"><a href="#云托管的时间相差8个小时？" class="headerlink" title="云托管的时间相差8个小时？"></a>云托管的时间相差8个小时？</h3><p>容器系统时间默认为 UTC 协调世界时间 （Universal Time Coordinated），与本地所属时区 CST （上海时间）相差 8 个小时：</p><p>在构建基础镜像或在基础镜像的基础上制作自定义镜像时，在 <code>Dockerfile</code> 中创建时区文件即可解决单一容器内时区不一致问题，且后续使用该镜像时，将不再受时区问题困扰。</p><ol><li>打开 <code>Dockerfile</code> 文件。</li><li>写入以下内容，配置时区文件</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos as centos  COPY --from=centos  /usr/share/zoneinfo/Asia/Shanghai /etc/localtime RUN echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</span><br></pre></td></tr></table></figure><ol start="3"><li>重新构建容器镜像，使用新的镜像重新部署。或直接上传含新的 Dockerfile 的代码包重新部署</li></ol><h2 id="云托管部署"><a href="#云托管部署" class="headerlink" title="云托管部署"></a>云托管部署</h2><h3 id="云托管模板部署"><a href="#云托管模板部署" class="headerlink" title="云托管模板部署"></a>云托管模板部署</h3><blockquote><p>访问 <a href="https://cloud.weixin.qq.com/cloudrun/onekey" target="_blank" rel="noopener">https://cloud.weixin.qq.com/cloudrun/onekey</a></p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/faabdedf644f3e4e.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/938ddd4770eac635.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/ea9d4e50eebbc2c7.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/7fc8863ea615b727.png" alt></p><p><strong>小程序/公众号中调用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在小程序 app.js中初始化云托管</span></span><br><span class="line">onLaunch() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!wx.cloud) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'请使用 2.2.3 或以上的基础库以使用云能力'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wx.cloud.init(&#123;</span><br><span class="line">        env: <span class="string">'xxx'</span>, <span class="comment">// 填入云托管环境ID</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在小程序中调用云托管服务</span></span><br><span class="line">wx.cloud.callContainer(&#123;</span><br><span class="line">  <span class="string">"config"</span>: &#123;</span><br><span class="line">    <span class="string">"env"</span>: <span class="string">"prod-xx"</span> <span class="comment">// 填入云托管环境ID</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"path"</span>: <span class="string">"/api/count"</span>, <span class="comment">// 云托管服务请求路径</span></span><br><span class="line">  <span class="string">"header"</span>: &#123;</span><br><span class="line">    <span class="string">"X-WX-SERVICE"</span>: <span class="string">"express-4bnl"</span> <span class="comment">// 云托管服务名称</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"method"</span>: <span class="string">"POST"</span>,</span><br><span class="line">  <span class="string">"data"</span>: &#123;</span><br><span class="line">    <span class="string">"action"</span>: <span class="string">"inc"</span> <span class="comment">// 发起请求传入的参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="云托管自定义部署nestjs"><a href="#云托管自定义部署nestjs" class="headerlink" title="云托管自定义部署nestjs"></a>云托管自定义部署nestjs</h3><p><strong>初始化您的 Nest.js 项目</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -g @nestjs/cli</span><br><span class="line">nest <span class="keyword">new</span> nest-app</span><br></pre></td></tr></table></figure><p>在根目录下，执行以下命令在本地直接启动服务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd nest-app &amp;&amp; npm run start</span><br></pre></td></tr></table></figure><p>打开浏览器访问 <a href="http://localhost:3000，即可在本地完成" target="_blank" rel="noopener">http://localhost:3000，即可在本地完成</a> Nest.js 示例项目的访问。</p><p><strong>新建服务</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/d867bed19eb7d9ed.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/a94985c89c5a77d0.png" alt></p><p>点击发布后，云托管会执行<code>Dockerfile</code>构建流水线，到日志可以查看构建进度</p><p><img src="https://s.poetries.work/uploads/2022/06/28c702aebeea51f1.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/e381ee973e6b0128.png" alt></p><p><strong>微信云托管部署成功后，可以在实例列表，点击进入容器看到代码</strong>，这里里面的内容不能修改，在容器启动后会覆盖</p><p><img src="https://s.poetries.work/uploads/2022/06/f29ea9c2ac74fac7.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/a4a8d047a18b8846.png" alt></p><p><strong>调试接口</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/71e72ba06d6335db.png" alt></p><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloudrun/src/quickstart/custom/node.html" target="_blank" rel="noopener">详细示例</a></p></blockquote><h2 id="CLI工具使用"><a href="#CLI工具使用" class="headerlink" title="CLI工具使用"></a>CLI工具使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @wxcloud/cli</span><br><span class="line"></span><br><span class="line">wxcloud -h</span><br></pre></td></tr></table></figure><p><strong>获取 CLI 密钥</strong></p><p>CLI工具的登录采用了密钥形式，在使用前需要前往<a href="https://cloud.weixin.qq.com/cloudrun/settings/other" target="_blank" rel="noopener">微信云托管控制台 - 设置 -CLI 密钥</a>生成，生成时需要账号管理员扫码，可以新建多个密钥，用于在不同地方使用。</p><p>传入微信 APPID 和CLI密钥，操作登录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wxcloud login [OPTIONS]</span><br></pre></td></tr></table></figure><p><strong>查看登录账号下所有的环境列表</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wxcloud env:list [OPTIONS]</span><br></pre></td></tr></table></figure><p><strong>查看指定环境下的所有服务列表</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wxcloud service:list [OPTIONS]</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/32865ab6963c425e.png" alt></p><h2 id="云托管本地调试"><a href="#云托管本地调试" class="headerlink" title="云托管本地调试"></a>云托管本地调试</h2><h3 id="本地docker调试"><a href="#本地docker调试" class="headerlink" title="本地docker调试"></a>本地docker调试</h3><ul><li>安装<a href="https://docs.docker.com/get-docker/" target="_blank" rel="noopener">docker</a></li><li>安装<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html" target="_blank" rel="noopener">微信开发者工具最新版</a></li><li>安装vscode <a href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker" target="_blank" rel="noopener">Docker拓展</a></li><li>在 VSCode 拓展栏搜索 weixin-cloudbase 然后安装</li></ul><p><strong>以koa作为后端演示</strong></p><p>全局安装 <code>koa-generator</code> 脚手架.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g koa-generator</span><br></pre></td></tr></table></figure><p>创建项目</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用ejs引擎</span><br><span class="line">koa2 -e wxcloud-debug-koa</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd wxcloud-debug-koa // 进入项目根目录</span><br><span class="line">npm install // 安装项目依赖</span><br></pre></td></tr></table></figure><ul><li>修改<code>www/bin</code>中的端口为<code>9000</code></li><li>修改<code>routes/index</code>中代码为</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    message: <span class="string">'请求头'</span>,</span><br><span class="line">    header: ctx.header</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打开浏览器访问 <a href="http://localhost:9000，即可在本地完成" target="_blank" rel="noopener">http://localhost:9000，即可在本地完成</a> <code>koa</code> 示例项目的访问。</p><p><strong>编写dockerfile</strong></p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> daocloud.io/library/node:<span class="number">14.7</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai \</span><br><span class="line">    DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -fs /usr/share/zoneinfo/<span class="variable">$&#123;TZ&#125;</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;TZ&#125;</span> &gt; /etc/timezone &amp;&amp; dpkg-reconfigure --frontend noninteractive tzdata &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制当前代码到/app工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 源，选用国内镜像源以提高下载速度</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> node app.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9000</span></span><br></pre></td></tr></table></figure><blockquote><p>如只在 VSCode 中同时编辑调试一个服务，<code>可直接打开服务代码目录作为根目录</code>（暂不支持 VSCode Workspace 工作区），保证根目录下有 <code>Dockerfile</code> 文件，插件面板中会显示该服务的名字</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/66fece8795fb4d24.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/ac09af2107358e03.png" alt></p><blockquote><p>调试过程中因需要获取微信信息，会使用云托管 CLI Key，因此需在 VSCode 插件配置填入小程序 appid 和 cli key，点击插件面板的 ⚙ 图标打开配置：</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/ce3c104e40011d61.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/9ae3be753faf6d15.png" alt></p><p><strong>构建镜像，启动容器</strong></p><p>右键服务名，选择 start，将构建镜像并启动容器</p><p><img src="https://s.poetries.work/uploads/2022/06/fcd6a583112c5092.png" alt></p><p>可以看到构建过程</p><p><img src="https://s.poetries.work/uploads/2022/06/edf9e52ecc8be079.png" alt></p><p>启动容器需要相应的容器配置信息（<code>.cloudbase/container/debug.json</code>），如果没有会提示创建，配置文件字段和含义如下：</p><p><img src="https://s.poetries.work/uploads/2022/06/f012165c8689c0d7.png" alt></p><blockquote><p>其中需特别注意端口号 <code>containerPort</code>、<code>Dockerfile</code> 路径 <code>dockerfilePath</code>、自定义环境变量 <code>envParams</code></p></blockquote><p>此时出现异常，我们修改<code>.cloudbase/container/debug.json</code>中的<code>containerPort</code>为koa服务中定义的9000端口，重新构建即可</p><p><img src="https://s.poetries.work/uploads/2022/06/45bf31849d1ea025.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/170ccb5736623b06.png" alt></p><p>容器构建和启动成功后，在插件面板状态 icon 会相应更新：</p><p><img src="https://s.poetries.work/uploads/2022/06/119ccbcb1b5bda86.png" alt></p><p>也可以通过<code>docker ps</code>查看已启动的服务</p><p><img src="https://s.poetries.work/uploads/2022/06/bffee56613a1852b.png" alt></p><p>我们在云托管后台可以看到此时默认启动了一个调试服务，我们不要去修改它</p><p><img src="https://s.poetries.work/uploads/2022/06/b9628146f2936d6d.png" alt></p><blockquote><p>此时可以请求容器了，在插件面板旁会展示两个端口号，通过第一个端口访问容器会带有微信相关信息（header 中包含 appid 等），通过第二个端口访问容器不会带有微信相关信息而是直接请求到容器内部，右键服务选择 Open in browser (via WX server) 和 Open in browser (no WX auth) 可以在浏览器中打开，分别对应这两种情况，也可以写代码或通过 POSTMAN 等工具请求</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/08a189b22f22d644.png" alt></p><p><strong>请求不经过微信服务器返回</strong>：<a href="http://127.0.0.1:27081/" target="_blank" rel="noopener">http://127.0.0.1:27081/</a></p><blockquote><p>不带微信信息的端口，直接访问即可，适合在浏览器调试</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/219c2a545a680211.png" alt></p><p><strong>请求经过微信服务器返回</strong>：<a href="http://127.0.0.1:27082/" target="_blank" rel="noopener">http://127.0.0.1:27082/</a></p><blockquote><p>微信端口，请求时会模拟微信用户信息的 Header，如 x-wx-openid，适合微信开发者工具中使用</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/61300f5e0ee71be1.png" alt></p><p><strong>在微信开发者工具中，可以选择连接到 VSCode 启动的容器，从而在小程序模拟器中访问本地云托管容器</strong></p><blockquote><p>此能力需要使用微信开发者工具 v1.05.2202242 及以上版本，并更新 VSCode 插件到 v1.0.12 以上。</p></blockquote><p><strong>创建一个小程序测试项目</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/0682d26a6cb9733d.png" alt></p><blockquote><p>在 微信开发者工具 的 <code>Docker</code> 面板中，找到 「<code>Running Containers</code>」，右击容器名称，选择 <code>Attach Weixin Devtools</code>，即可在小程序代码中，使用 <code>wx.cloud.callContainer</code> 访问容器。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/24939ce50c3f697d.png" alt></p><p>需要退出再次<code>Detach Weixin Devtools</code></p><p><img src="https://s.poetries.work/uploads/2022/06/c7e521ee38851161.png" alt></p><blockquote><p>调用时，需要注意 <code>Header</code> 中的 <code>X-WX-SERVICE</code> 需要与容器名保持一致</p></blockquote><p>修改小程序<code>app.js</code>代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line">App(&#123;</span><br><span class="line">  onLaunch: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> wx.cloud.init(&#123;</span><br><span class="line">      <span class="comment">// env: "其他云开发环境，也可以不填"    // 此处 init 的环境 ID 和微信云托管没有作用关系，没用就留空</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> wx.cloud.callContainer(&#123;</span><br><span class="line">      config: &#123;</span><br><span class="line">        env: <span class="string">"prod-xx"</span>, <span class="comment">// 微信云托管环境ID，不能为空，替换自己的</span></span><br><span class="line">      &#125;,</span><br><span class="line">      path: <span class="string">'/'</span>, </span><br><span class="line">      method: <span class="string">'GET'</span>,</span><br><span class="line">      header: &#123;</span><br><span class="line">        <span class="string">'X-WX-SERVICE'</span>: <span class="string">'wxcloud-debug-koa'</span>, <span class="comment">// 替换成本地要调试的容器名称</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// 在控制台里查看打印</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/3c82a5b4cd77cb7e.png" alt></p><p><strong>查看请求日志</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/e789dfef49932c98.png" alt></p><p>或者通过<code>docker logs</code>查看</p><p><img src="https://s.poetries.work/uploads/2022/06/9e869917426b77ad.png" alt></p><p><strong>进入终端</strong></p><blockquote><p>如果需要进入到容器内部终端调试定位问题，可以右键服务名选择 Attach Shell 进入容器内终端</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/333fccccae7df026.png" alt></p><h3 id="本地docker实时调试"><a href="#本地docker实时调试" class="headerlink" title="本地docker实时调试"></a>本地docker实时调试</h3><blockquote><p>通过微信云托管 VSCode 插件，可以实现实时开发，即代码变动时，不需要重新构建和启动容器，即可查看变动后的效果。</p></blockquote><p><strong>选择 Live Coding</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/34196636c57afd14.png" alt></p><blockquote><p>右键点击需要调试的容器，选择 <code>Live Coding</code>，将自动生成 <code>Dockerfile.development</code> 和 <code>docker-compose.yml</code> 2 个文件并启动容器。</p></blockquote><p>如果生成失败，我们需要自行配置</p><p><img src="https://s.poetries.work/uploads/2022/06/312e14d5e6ca8287.png" alt></p><p><strong>开发模式的 docker-compose.yml</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发模式的 docker-compose.yml</span></span><br><span class="line"><span class="comment"># 实时开发将使用项目目录下的 docker-compose.yml 将当前目录映射到容器中。</span></span><br><span class="line"><span class="comment"># 大多数情况下，插件将根据项目的 Dockerfile 自动生成本文件，不需要手动编写。</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  app:</span></span><br><span class="line"><span class="attr">    build:</span> </span><br><span class="line"><span class="attr">      context:</span> <span class="string">.</span> <span class="comment"># 构建上下文</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">Dockerfile.development</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">.:/app</span> <span class="comment"># 需要映射的目录（即代码目录）</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/app/node_modules</span> <span class="comment"># 映射 node_modules 目录，如果有构建产物与代码目录同级，需要单独映射避免无法运行</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">27081</span><span class="string">:9000</span> <span class="comment"># 监听端口，主机端口：容器端口 修改为koa服务端口</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">wxcloud_wxcloud-debug-koa</span> <span class="comment"># 容器名称</span></span><br><span class="line"><span class="attr">    labels:</span> <span class="comment"># 容器标签，一般不需改动</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">wxPort=27082</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">hostPort=27081</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">wxcloud=wxcloud-debug-koa</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">role=container</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line">      <span class="comment"># 使用本地调试 MySQL 时，需要填入如下环境变量，并启动 MySQL 代理服务</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MYSQL_USERNAME=</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MYSQL_PASSWORD=</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MYSQL_ADDRESS=</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  default:</span></span><br><span class="line"><span class="attr">    external:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">wxcb0</span> <span class="comment"># 容器网络打通，一般不需改动</span></span><br></pre></td></tr></table></figure><p>修改端口 9000</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ports:</span><br><span class="line">  - 27081:9000 # 监听端口，主机端口：容器端口 修改为koa服务端口</span><br></pre></td></tr></table></figure><p><strong>实时开发使用项目目录下的 Dockerfile.development</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dockerfile.development</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时开发使用项目目录下的 Dockerfile.development 作为开发期间的容器的 Dockerfile</span></span><br><span class="line"><span class="comment"># 大多数情况下，插件将根据项目的 Dockerfile 自动生成本文件，不需要手动编写。</span></span><br><span class="line"><span class="comment"># 开发模式的 Dockerfile 与正式模式的 Dockerfile 的区别在于：</span></span><br><span class="line"><span class="comment"># 单阶段构建</span></span><br><span class="line"><span class="comment"># 将编译命令转换为启动命令，如 Spring Boot 模板的 mvn package 会转换为 spring-boot:run</span></span><br><span class="line"><span class="comment"># 拉取实时开发的工具套件，安装到 /usr/bin 下</span></span><br><span class="line"><span class="comment"># 通过实时开发工具套件启动用户程序，在代码发生更改时，自动重启进程。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auto-generated by weixin cloudbase vscode extension</span></span><br><span class="line"><span class="string">FROM</span> <span class="string">ccr.ccs.tencentyun.com/weixincloud/wxcloud-livecoding-toolkit:latest</span> <span class="string">AS</span> <span class="string">toolkit</span></span><br><span class="line"><span class="string">FROM</span> <span class="attr">node:lts-slim</span></span><br><span class="line"><span class="string">COPY</span> <span class="bullet">--from=toolkit</span> <span class="string">nodemon</span> <span class="string">/usr/bin/nodemon</span></span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">ln</span> <span class="bullet">-fs</span> <span class="string">/usr/share/zoneinfo/$&#123;TZ&#125;</span> <span class="string">/etc/localtime</span> <span class="string">&amp;&amp;</span> <span class="string">echo</span> <span class="string">$&#123;TZ&#125;</span> <span class="string">&gt; /etc/timezone &amp;&amp; dpkg-reconfigure --frontend noninteractive tzdata &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="string">WORKDIR /app</span></span><br><span class="line"><span class="string">COPY package*.json ./</span></span><br><span class="line"><span class="string"># --only=production 只安装生产环境的依赖</span></span><br><span class="line"><span class="string">RUN npm install --only=production &amp;&amp; npm install pm2 -g</span></span><br><span class="line"><span class="string">COPY . ./</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 修改nest启动入口 node bin/www</span></span><br><span class="line"><span class="string">CMD [ "nodemon", "-x", "node bin/www", "-w", "/app", "-e", "java, js, mjs, json, ts, cs, py, go" ]</span></span><br></pre></td></tr></table></figure><blockquote><p>修改koa启动入口 <code>node www/bin</code></p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/8a10761b7b5e317a.png" alt></p><p><strong>启动实时服务</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/27e38dab008bc840.png" alt></p><blockquote><p>修改本地代码，不用重启容器即可查看效果</p></blockquote><h3 id="本地调试中使用「开放接口服务」"><a href="#本地调试中使用「开放接口服务」" class="headerlink" title="本地调试中使用「开放接口服务」"></a>本地调试中使用「开放接口服务」</h3><ul><li>在 VSCode 拓展栏搜索 <code>weixin-cloudbase</code> 然后安装</li><li>完成配置后，在左侧 <code>Docker</code> 面板内，右击 <code>Proxy nodes for VPC access</code> 中的 <code>api.weixin.qq.com</code>，点击启动（<code>Start</code>）</li><li>右击用户容器，点击启动（<code>Start</code>），容器内即可访问本地云调用</li></ul><p>填入环境ID</p><p><img src="https://s.poetries.work/uploads/2022/06/fb7e7d5bb09d2714.png" alt></p><p>启动<code>api.weixin.qq.com</code>服务</p><p><img src="https://s.poetries.work/uploads/2022/06/00ae0c2d76672797.png" alt></p><p>启动自己的业务服务，在业务服务运行过程中，启动 vpc 中的 <code>api.weixin.qq.com</code> 服务</p><blockquote><p>插件将会在你的云托管环境中开启一个代理服务，用于和本地 <code>api.weixin.qq.com</code> 服务，同时和业务服务共享同一个网络，就实现了本地的「开放接口服务」，需要注意，本地调试中只是模拟了业务服务的所处环境，不是真实的线上部署情况。</p></blockquote><h2 id="云托管中使用云调用"><a href="#云托管中使用云调用" class="headerlink" title="云托管中使用云调用"></a>云托管中使用云调用</h2><blockquote><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloudrun/src/guide/weixin/token.html" target="_blank" rel="noopener">云调用</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/" target="_blank" rel="noopener">服务端接口</a></li></ul></blockquote><p>云调用是具有「免鉴权调用微信开放服务接口」特性的能力，是云开发/云托管中微信生态的一部分。</p><p>在云调用出现之前，微信开放服务接口的正常调用，需要开发者使用密钥信息获取<code>access_token</code>，并自己维护 <code>token</code> 的有效期和安全。而获取<code>access_token</code>，涉及到密钥交互请求，容易暴漏密钥导致被盗用，对开发者和微信服务都有消极的影响。</p><p>云调用主要打造免鉴权，也就是免密钥，全程不暴漏任何信息，开发者无需维护<code>access_token</code>，那对于接口请求的合法性判定，完全由与微信同链路的微信云托管参与实施。</p><h3 id="配置云调用权限"><a href="#配置云调用权限" class="headerlink" title="配置云调用权限"></a>配置云调用权限</h3><p>前往<a href="https://cloud.weixin.qq.com/cloudrun/openapi" target="_blank" rel="noopener">控制台 - 云调用 - 云调用权限配置</a>，按照自己的业务需要配置接口。</p><p>比如你要在服务中调用文字安全检测接口</p><p>此接口的调用地址如下：<code>https://api.weixin.qq.com/wxa/msg_sec_check?access_token=ACCESS_TOKEN</code></p><p>在配置时，只需要 <code>api.weixin.qq.com</code> 之后，<code>?</code>参数之前的部分，所以应该在配置输入框里填写如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/wxa/msg_sec_check</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/0fe1195da2601738.png" alt></p><blockquote><p>在云托管服务中，微信后台周期性的将开放接口所必须要的 <code>access_token</code>，推送到服务的容器实例中。在使用时只需要从容器本地读取令牌，就可以包装请求去调用了：</p></blockquote><blockquote><p><code>access_token</code> 推送的时间间隔为 <code>10</code> 分钟，令牌的有效期为 <code>30</code> 分钟； 挂载路径为：<code>/.tencentcloudbase/wx/cloudbase_access_token</code>； 在同一个环境中所有的容器实例，推送的 <code>access_token</code> 相同</p></blockquote><blockquote><p>接口调用凭证 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html</a></p></blockquote><p><strong>查看容器内access_token</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/0ada5a6c6b6248c9.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/b336245a70f0df92.png" alt></p><p>如果需要获取容器内的<code>access_token</code>调试接口，需要在接口中填入<code>cloudbase_access_token=容器内的access_token</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://developers.weixin.qq.com/miniprogram/dev/wxcloudrun/src/guide/weixin/token.html</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)</span><br><span class="line"><span class="comment">// 容器内的access_token</span></span><br><span class="line"><span class="keyword">const</span> token = fs.readFileSync(<span class="string">'/.tencentcloudbase/wx/cloudbase_access_token'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  request(&#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    <span class="comment">// 可本地调试用cloudbase_access_token</span></span><br><span class="line">    url: <span class="string">`https://api.weixin.qq.com/wxa/msg_sec_check?cloudbase_access_token=<span class="subst">$&#123;token&#125;</span>`</span>,</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      openid: <span class="string">'用户的openid'</span>, <span class="comment">// 可以从请求的 header 中直接获取 req.headers['x-wx-openid']</span></span><br><span class="line">      version: <span class="number">2</span>,</span><br><span class="line">      scene: <span class="number">2</span>,</span><br><span class="line">      content: <span class="string">'安全检测文本'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,<span class="function"><span class="keyword">function</span> (<span class="params">error, response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'接口返回内容'</span>, response.body)</span><br><span class="line">    resolve(<span class="built_in">JSON</span>.parse(response.body))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="云托管内调用服务端文字检测接口"><a href="#云托管内调用服务端文字检测接口" class="headerlink" title="云托管内调用服务端文字检测接口"></a>云托管内调用服务端文字检测接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i request request-promise -S</span><br></pre></td></tr></table></figure><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/security.msgSecCheck-v1.html#HTTPS%20%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">服务端接口地址</a></p><p>在代码<code>routes/home</code>中添加</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/msg_sec_check'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> ACCESS_TOKEN = <span class="string">''</span></span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> rp(&#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    <span class="comment">// 在云托管容器环境中，可以拿到access_token，而且免鉴权、这里不需要填写</span></span><br><span class="line">    <span class="comment">// https://developers.weixin.qq.com/miniprogram/dev/wxcloudrun/src/guide/weixin/open.html</span></span><br><span class="line">    <span class="comment">// 这里填http协议、在云托管中不需要填access_token、需要在云托管-云调用中填写接口白名单前缀、开启侧边栏proxy代理后可以免输入本地调试</span></span><br><span class="line">    uri: <span class="string">`http://api.weixin.qq.com/wxa/msg_sec_check`</span>,</span><br><span class="line">    body: &#123;</span><br><span class="line">      openid: ctx.header[<span class="string">'x-wx-openid'</span>],  <span class="comment">// 用户的openid 可以从请求的 header 中直接获取 req.headers['x-wx-openid']</span></span><br><span class="line">      version: <span class="number">2</span>,</span><br><span class="line">      scene: <span class="number">2</span>,</span><br><span class="line">      content: <span class="string">'安全检测文本'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    json: <span class="literal">true</span></span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      code: <span class="number">-1</span>,</span><br><span class="line">      message: error</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> error</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    data,</span><br><span class="line">    code: <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在云托管权限控制台添加接口权限</p><p><img src="https://s.poetries.work/uploads/2022/06/4ebb3911f85d34fa.png" alt></p><p>开启 <code>api.poetries.top</code> 本地调试服务</p><p><img src="https://s.poetries.work/uploads/2022/06/528449d25dd3fe4b.png" alt></p><p>通过微信服务器模拟小程序请求</p><p><img src="https://s.poetries.work/uploads/2022/06/2599830982d2a3f9.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/d0513c38eda2f996.png" alt></p><p>也可以在小程序中访问</p><p><img src="https://s.poetries.work/uploads/2022/06/b662201bc3f48b26.png" alt></p><h3 id="云托管内调用服务端云函数接口"><a href="#云托管内调用服务端云函数接口" class="headerlink" title="云托管内调用服务端云函数接口"></a>云托管内调用服务端云函数接口</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-http-api/functions/invokeCloudFunction.html" target="_blank" rel="noopener">接口地址</a></p><p>在代码<code>routes/home</code>中添加</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 云托管内调用云函数</span></span><br><span class="line">router.get(<span class="string">'/call-fn-banner'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ACCESS_TOKEN = <span class="string">''</span></span><br><span class="line">  <span class="keyword">const</span> weappEnvId = <span class="string">'poetry-prod-6gj3fpxa137552a6'</span> <span class="comment">// 小程序云开发envId</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> rp(&#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    <span class="comment">// 在云托管容器环境中，可以拿到access_token，而且免鉴权、这里不需要填写</span></span><br><span class="line">    <span class="comment">// https://developers.weixin.qq.com/miniprogram/dev/wxcloudrun/src/guide/weixin/open.html</span></span><br><span class="line">    <span class="comment">// 这里填http协议、在云托管中不需要填access_token、需要在云托管-云调用中填写接口白名单前缀、开启侧边栏proxy代理后可以免输入本地调试</span></span><br><span class="line">    uri: <span class="string">`http://api.weixin.qq.com/tcb/invokecloudfunction?env=<span class="subst">$&#123;weappEnvId&#125;</span>&amp;name=banner`</span>,</span><br><span class="line">    body: &#123;</span><br><span class="line">      $url: <span class="string">'queryBanner'</span>,</span><br><span class="line">      ...ctx.request.query</span><br><span class="line">    &#125;,</span><br><span class="line">    json: <span class="literal">true</span></span><br><span class="line">  &#125;).then(<span class="keyword">async</span> res=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callCloudFn res'</span>, res)</span><br><span class="line">    <span class="keyword">if</span>(res &amp;&amp; res.errcode === <span class="number">40001</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> data = res.resp_data ? <span class="built_in">JSON</span>.parse(res.resp_data) : &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      code: error.errcode,</span><br><span class="line">      message: error.errmsg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> error</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  ctx.body = data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>小程序云函数banner代码</p><p><img src="https://s.poetries.work/uploads/2022/06/cabf11a53af60f09.png" alt></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 云函数入口文件</span></span><br><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">'wx-server-sdk'</span>)</span><br><span class="line"></span><br><span class="line">cloud.init(&#123;</span><br><span class="line">  env: <span class="string">'poetry-prod-xx'</span> <span class="comment">// 环境ID</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TcbRouter = <span class="built_in">require</span>(<span class="string">'tcb-router'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = cloud.database()</span><br><span class="line"><span class="keyword">const</span> bannersCollection = db.collection(<span class="string">'banners'</span>) <span class="comment">// banners集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 云函数入口函数</span></span><br><span class="line">exports.main = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> TcbRouter(&#123;event&#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// banner列表</span></span><br><span class="line">   app.router(<span class="string">'queryBanner'</span>, <span class="keyword">async</span> (ctx,next)=&gt;&#123;</span><br><span class="line">     <span class="keyword">const</span> &#123;pageSize = <span class="number">20</span>, pageNum = <span class="number">1</span>, orderBy, sort&#125; = event</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">await</span> bannersCollection.skip(<span class="built_in">Number</span>((pageNum - <span class="number">1</span>)*pageSize)).limit(<span class="built_in">Number</span>(pageSize)).orderBy(orderBy || <span class="string">'createTime'</span>, sort || <span class="string">'desc'</span>).get().then(<span class="function"><span class="params">res</span>=&gt;</span>res.data)</span><br><span class="line">        <span class="keyword">let</span> &#123;total&#125; = <span class="keyword">await</span> bannersCollection.count()</span><br><span class="line">        ctx.body = &#123;</span><br><span class="line">          message: <span class="string">'查询成功'</span>,</span><br><span class="line">          code: <span class="number">200</span>,</span><br><span class="line">          data: &#123;</span><br><span class="line">            list: data,</span><br><span class="line">            total,</span><br><span class="line">            pageSize,</span><br><span class="line">            pageNum</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        ctx.body = &#123; <span class="attr">message</span>: error, <span class="attr">code</span>: <span class="number">-1</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app.serve()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在云托管权限控制台添加接口权限</p><p><img src="https://s.poetries.work/uploads/2022/06/4015858c85719a6a.png" alt></p><p>开启 <code>api.poetries.top</code> 本地调试服务</p><p><img src="https://s.poetries.work/uploads/2022/06/528449d25dd3fe4b.png" alt></p><p>通过微信服务器模拟小程序请求</p><p><img src="https://s.poetries.work/uploads/2022/06/2599830982d2a3f9.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/7629d70d78672b4e.png" alt></p><p>也可以在小程序中访问</p><p><img src="https://s.poetries.work/uploads/2022/06/0b93736939cab19a.png" alt></p><h3 id="云托管内调用服务端获取小程序码接口"><a href="#云托管内调用服务端获取小程序码接口" class="headerlink" title="云托管内调用服务端获取小程序码接口"></a>云托管内调用服务端获取小程序码接口</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html#HTTPS%20%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">接口地址</a></p><p>在代码<code>routes/home</code>中添加</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 云托管内获取小程序码</span></span><br><span class="line">router.get(<span class="string">'/getweappCode'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> ACCESS_TOKEN = <span class="string">''</span></span><br><span class="line">  <span class="keyword">let</span> buffer = <span class="keyword">await</span> rp(&#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    <span class="comment">// 在云托管容器环境中，可以拿到access_token，而且免鉴权、这里不需要填写</span></span><br><span class="line">    <span class="comment">// https://developers.weixin.qq.com/miniprogram/dev/wxcloudrun/src/guide/weixin/open.html</span></span><br><span class="line">    <span class="comment">// 这里填http协议、在云托管中不需要填access_token、需要在云托管-云调用中填写接口白名单前缀、开启侧边栏proxy代理后可以免输入本地调试</span></span><br><span class="line">    uri: <span class="string">`http://api.weixin.qq.com/wxa/getwxacode`</span>,</span><br><span class="line">    body: &#123;</span><br><span class="line">      path: <span class="string">'/pages/article/index'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    json: <span class="literal">true</span></span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      code: <span class="number">-1</span>,</span><br><span class="line">      message: error</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> error</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    data: buffer,</span><br><span class="line">    code: <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在云托管权限控制台添加接口权限</p><p><img src="https://s.poetries.work/uploads/2022/06/f3bd515a0476f6bc.png" alt></p><p>开启 <code>api.poetries.top</code> 本地调试服务</p><p><img src="https://s.poetries.work/uploads/2022/06/528449d25dd3fe4b.png" alt></p><p>通过微信服务器模拟小程序请求</p><p><img src="https://s.poetries.work/uploads/2022/06/2599830982d2a3f9.png" alt></p><p>也可以在小程序中访问</p><p><img src="https://s.poetries.work/uploads/2022/06/426afbcda167a0d1.png" alt></p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloudrun/src/basic/intro.html" target="_blank" rel="noopener">微信云托管开发者文档</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloudrun/src/guide/cli/" target="_blank" rel="noopener">CLI工具</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloudrun/src/guide/debug/" target="_blank" rel="noopener">本地调试</a></li><li><a href="https://github.com/WeixinCloud" target="_blank" rel="noopener">云托管官方GitHub</a></li><li><a href="https://cloudbase.vip/kw/" target="_blank" rel="noopener">tencent云开发知识库首页</a></li><li><a href="https://developers.weixin.qq.com/community/business/course/00068c2c0106c0667f5b01d015b80d" target="_blank" rel="noopener">微信学堂快速上手微信云托管</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloudrun/src/quickstart/plan/real.html" target="_blank" rel="noopener">微信云托管学习路径</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本简介&quot;&gt;&lt;a href=&quot;#基本简介&quot; class=&quot;headerlink&quot; title=&quot;基本简介&quot;&gt;&lt;/a&gt;基本简介&lt;/h2&gt;&lt;h3 id=&quot;微信云托管是什么？&quot;&gt;&lt;a href=&quot;#微信云托管是什么？&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="部署" scheme="http://blog.poetries.top/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="云托管" scheme="http://blog.poetries.top/tags/%E4%BA%91%E6%89%98%E7%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>serverless部署前后端项目实践</title>
    <link href="http://blog.poetries.top/2022/06/18/serverless-deploy-summary/"/>
    <id>http://blog.poetries.top/2022/06/18/serverless-deploy-summary/</id>
    <published>2022-06-18T02:10:24.000Z</published>
    <updated>2025-03-30T13:54:29.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、serverless架构介绍及安装serverless"><a href="#一、serverless架构介绍及安装serverless" class="headerlink" title="一、serverless架构介绍及安装serverless"></a>一、serverless架构介绍及安装serverless</h1><ul><li><code>Serverless</code>又名无服务器,所谓无服务器并非是说不需要依赖和依靠服务器等资源,而是开发者再也不用过多考虑服务器的问题,可以更专注在产品代码上。</li><li><code>Serverless</code>是一种软件系统架构的思想和方法，它不是软件框架、类库或者工具。它与传统架构的不同之处在于，完全由第三方管理，由事件触发，存在于无状态(<code>Stateless</code>)、 暂存(可能只存在于一次调用的过程中)计算容器内。构建无服务器应用程序意味着开发者可以专注在产品代码上，而无须管理和操作云端或本地的服务器或运行时(运行时通俗的讲 就是运行环境，比如 <code>nodejs</code>环境，<code>java</code> 环境，<code>php</code> 环境)。<code>Serverless</code> 真正做到了部署应用 无需涉及基础设施的建设，自动构建、部署和启动服务。</li></ul><p><strong>通俗的讲：Serverless 是构建和运行软件时不需要关心服务器的一种架构思想</strong></p><p>虚拟主机已经是快被淘汰掉的上一代产物了。云计算涌现出很多改变传统 IT 架构和运维方 式的新技术，比如虚拟机、容器、微服务，无论这些技术应用在哪些场景，降低成本、提升 效率是云服务永恒的主题。<strong>Serverless 的出现真正的解决了降低成本、提升效率的问题</strong>。它真正做到了<code>弹性伸缩</code>、<code>高并发</code>、<code>按需收费</code>、<code>备份容灾</code>、日<code>志监控</code>等。</p><h2 id="1-1-传统的开发模式与serverless开发模式对比"><a href="#1-1-传统的开发模式与serverless开发模式对比" class="headerlink" title="1.1 传统的开发模式与serverless开发模式对比"></a>1.1 传统的开发模式与serverless开发模式对比</h2><p>传统的开发模式</p><p><img src="https://s.poetries.work/uploads/2022/06/f328901c0adb56de.png" alt></p><p>新型的serverless开发模式</p><p><img src="https://s.poetries.work/uploads/2022/06/bcc852ef2bc8fbd7.png" alt></p><p>Serverless 正在改变未来软件开发的模式和流程</p><p><img src="https://s.poetries.work/uploads/2022/07/44fa5d83bc09c564.png" alt></p><h2 id="1-2-Serverless-和-ServerFul-架构的区别"><a href="#1-2-Serverless-和-ServerFul-架构的区别" class="headerlink" title="1.2 Serverless 和 ServerFul 架构的区别"></a>1.2 Serverless 和 ServerFul 架构的区别</h2><h3 id="传统的-ServerFul-架构模式"><a href="#传统的-ServerFul-架构模式" class="headerlink" title="传统的 ServerFul 架构模式"></a>传统的 ServerFul 架构模式</h3><p>ServerFul 架构就是 n 台 Server 通过 网络通信 的 方式 协作在一起，也可以说 ServerFul 架构是基于 Server 和 网络通信（分布式计算） 的 软件实现架构 ， Server 可 以是 虚拟机 物理机 ，以及基于硬件实现的云的云服务器</p><p><img src="https://s.poetries.work/uploads/2022/07/a6ac5a7905e6f81c.png" alt></p><h3 id="Serverless-架构模式"><a href="#Serverless-架构模式" class="headerlink" title="Serverless 架构模式"></a>Serverless 架构模式</h3><p>Serverless 的核心特点就是实现自动弹性伸缩和按量付费</p><p><img src="https://s.poetries.work/uploads/2022/07/3d5b8a8b53bd5315.png" alt></p><h2 id="1-3-使用serverless的优势"><a href="#1-3-使用serverless的优势" class="headerlink" title="1.3 使用serverless的优势"></a>1.3 使用serverless的优势</h2><ul><li><strong>资源分配</strong>: 在 <code>Serverless</code> 架构中，你不用关心应用运行的资源(比如服务配置、磁盘大小)只提供一份代码就行。</li><li><strong>计费方式</strong>: 在<code>Serverless</code> 架构中，计费方式按实际使用量计费(比如函数调用次数、运 行时长)，不按传统的执行代码所需的资源计费(比如固定 <code>CPU</code>)。计费粒度也精确到了毫 秒级，而不是传统的小时级别。个别云厂商推出了每个月的免费额度，比如腾讯云提供了每 个月 40 万 GBs 的资源使用额度和 100 万次调用次数的免费额度。中小企业的网站访问量不 是特别大的话完全可以免费使用。</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/4f400ccd6d34b420.png" alt></p><ul><li><strong>弹性伸缩</strong>:<code>Serverless</code> 架构的弹性伸缩更自动化、更精确，可以快速根据业务并发扩容更 多的实例，甚至允许缩容到零实例状态来实现零费用，对用户来说是完全无感知的。而传统 架构对服务器(虚拟机)进行扩容，虚拟机的启动速度也比较慢，需要几分钟甚至更久。</li></ul><h2 id="1-4-Serverless-组成"><a href="#1-4-Serverless-组成" class="headerlink" title="1.4 Serverless 组成"></a>1.4 Serverless 组成</h2><ul><li><strong>广义的 Serverless</strong> 更多是指一种技术理念：Serverless 是构建和运行软件时不需要关心服务 器的一种架构思想。刚开始学 Serverless 你可以把它理解为虚拟主机的升级版本</li><li><strong>狭义的 Serverless</strong> 是指现阶段主流的技术实现：狭义的 Serverless 是 <code>FaaS</code>和 <code>BaaS</code> 组成</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/e445b52f9d9a9958.png" alt></p><h2 id="1-5-Serverless-开发流程"><a href="#1-5-Serverless-开发流程" class="headerlink" title="1.5 Serverless 开发流程"></a>1.5 Serverless 开发流程</h2><p><img src="https://s.poetries.work/uploads/2022/07/1aa3208070a48915.png" alt></p><h2 id="1-6-为什么要学-Serverless"><a href="#1-6-为什么要学-Serverless" class="headerlink" title="1.6 为什么要学 Serverless"></a>1.6 为什么要学 Serverless</h2><p>先看看招聘信息</p><p><img src="https://s.poetries.work/uploads/2022/07/c50918e799e3068b.png" alt></p><p>看看最近 2 年 Github 的 start 数量和周下载量</p><p><img src="https://s.poetries.work/uploads/2022/07/9c63657e6a3dadb2.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/07/c7c5fe6b663fbe4f.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/07/750e45e4a038a162.png" alt></p><p>目前已经使用了 serverless 的大公司</p><p><img src="https://s.poetries.work/uploads/2022/07/d0ace73fab7e28ba.png" alt></p><h2 id="1-7-Serverless-的能力"><a href="#1-7-Serverless-的能力" class="headerlink" title="1.7 Serverless 的能力"></a>1.7 Serverless 的能力</h2><h3 id="计算能力"><a href="#计算能力" class="headerlink" title="计算能力"></a>计算能力</h3><ul><li>资源按需分配，无需申请资原</li><li>Mwm：租户级别强镜离 Docker：进程级别隔离</li><li>Mwm+Docker 轻量级资源毫秒级启动</li><li>实时扩容，阶梯缩容</li><li>按需收费</li></ul><h3 id="系统运维能力"><a href="#系统运维能力" class="headerlink" title="系统运维能力"></a>系统运维能力</h3><ul><li>性能保障：整个链路耗时毫秒级内,并支持 VPC 内网访问</li><li>安全保障<ul><li>资源对用户不可见,安全由腾讯云提供专业的保障</li><li>提供进程级和用户级安全隔离</li><li>访问控制管理</li></ul></li><li>自动性护缩容<ul><li>根据 CPU 内容网络 IO 自动扩容底层资源</li><li>根据请求数自动扩缩容函数实例，业务高峰期扩容，满足业务高并发需求，业务低 峰期缩容，释放资源，降低成本</li></ul></li><li>自愈能力：每一次请求都是一个健康的实例</li></ul><blockquote><p>Serverless 中云函数被第一次调用会执行冷启动，Serverless 中云函数被多次连续调用会 执行热启动</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/07/527e0cfb402fa738.png" alt></p><ul><li><strong>冷启动</strong> 是指你在服务器中新开辟一块空间供一个函数实例运行，这个过程有点像你把这 个函数放到虚拟机里去运行，每次运行前都要先启动虚拟机加载这个函数，以前冷启动非常 耗时，但是目前云厂商已经能做到毫秒级别的冷启动，这个过程我们也不需要关心，但是需 要注意的是使用 Seesion 的时候可能会导致 Session 丢失，所以我们的 Seesion 建议保存到数 据库。</li><li><strong>热启动</strong> 则是说如果一个云函数被持续触发，那我就先不释放这个云函数实例，下次请求 仍然由之前已经创建了的云函数实例来运行，就好比我们打开虚拟机运行完这个函数之后没 有关闭虚拟机，而是让它待机，等待下一次被重新触发调用运行，这样做的好处就是省去了 给虚拟机「开机」的一个耗时环节，缺点是要一直维持这个虚拟机的激活状态，系统开销会 大一些。</li></ul><h3 id="业务运维能力"><a href="#业务运维能力" class="headerlink" title="业务运维能力"></a>业务运维能力</h3><ul><li>工具建设：vscode 插件、WebIDE、Command Line、云 api、Sdk</li><li>版本管理、操作管理等</li><li>故障排查</li><li>监控报警</li><li>容灾处理</li></ul><h2 id="1-8-serverless厂家"><a href="#1-8-serverless厂家" class="headerlink" title="1.8 serverless厂家"></a>1.8 serverless厂家</h2><ul><li><a href="https://aws.amazon.com/cn/lambda/" target="_blank" rel="noopener">亚马逊 AWS Lambda </a></li><li><a href="https://cloud.google.com/functions" target="_blank" rel="noopener">谷歌 Google Cloud Functions</a></li><li><a href="https://www.azure.cn/" target="_blank" rel="noopener">微软 Microsoft Azure</a></li><li><a href="https://www.aliyun.com/product/fc" target="_blank" rel="noopener">阿里云函数计算</a></li><li><a href="https://cloud.tencent.com/product/scf" target="_blank" rel="noopener">腾讯云 云函数 SCF(Serverless Cloud Function)</a></li><li><a href="https://www.huaweicloud.com/product/functiongraph.html" target="_blank" rel="noopener">华为云 FunctionGraph</a></li></ul><h2 id="1-9-云函数和serverless的区别"><a href="#1-9-云函数和serverless的区别" class="headerlink" title="1.9 云函数和serverless的区别"></a>1.9 云函数和serverless的区别</h2><blockquote><p>通过前面的介绍，我们认识到了云函数和<code>serverless</code>，但是可能会有一个很迷惑云函数和<code>serverless</code>到底有什么区别，他们之间有什么联系，为什么我在创建云函数的时候选择模板方式创建最后创建的是<code>serverless</code>，而不是云函数呢。下面我们将解答云函数和<code>serverless</code>的区别</p></blockquote><ul><li><code>Serverless Framework</code> 是<code>Serverless</code>公司推出的一个开源的<code>Serverless</code> 应用开发框架</li><li><code>Serverless Framework</code>是由 <code>Serverless Framework Plugin</code> 和 <code>Serverless Framework Components</code> 组成</li><li><code>Serverless Framework Plugin</code> 实际上是一个函数的管理工具，使用这个工具，可以很轻松的 <strong>部署函数、删除函数、触发函数、查看函数信息、查看函数日志、回滚函数、查看函数</strong> 数据等。简单的概括就是<code>serverless</code>其实就<strong>云函数的集合体</strong>，使用<code>serverless</code>后我们创建的云函数不需要手动去创建触发器等操作</li></ul><p><strong>官方地址</strong></p><ul><li><a href="https://www.serverless.com/" target="_blank" rel="noopener">serverless官网地址</a></li><li><a href="https://cn.serverless.com" target="_blank" rel="noopener">serverless中文官网</a></li><li><a href="https://github.com/serverless/serverless" target="_blank" rel="noopener">github地址</a></li></ul><h2 id="1-20-创建serverless的方式"><a href="#1-20-创建serverless的方式" class="headerlink" title="1.20 创建serverless的方式"></a>1.20 创建serverless的方式</h2><ul><li>在腾讯<code>serverless</code>控制面板上创建，然后在<code>vscode</code>中使用插件的方式下载到本地（<strong>注意: </strong> 编辑器上要选择和创建<code>serverless</code>地区相同，才能看到项目，否则是看不到项目代码的）</li><li>使用客户端<code>serverless cli</code>命令方式创建，个人也更推荐使用这种方式创建，修改代码，然后部署到后台腾讯云服务上</li></ul><h1 id="二、serverless-脚手架安装、WebIDE中创建、vscode中配置"><a href="#二、serverless-脚手架安装、WebIDE中创建、vscode中配置" class="headerlink" title="二、serverless 脚手架安装、WebIDE中创建、vscode中配置"></a>二、serverless 脚手架安装、WebIDE中创建、vscode中配置</h1><h2 id="2-1-脚手架安装-三分钟部署一个项目"><a href="#2-1-脚手架安装-三分钟部署一个项目" class="headerlink" title="2.1 脚手架安装-三分钟部署一个项目"></a>2.1 脚手架安装-三分钟部署一个项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i serverless -g</span><br><span class="line"></span><br><span class="line">serverless -v</span><br></pre></td></tr></table></figure><p>查看支持的框架部署</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sls registry</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者输入sls</span></span><br><span class="line">sls</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/bb939fc00c99aa5a.png" alt></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如初始化egg项目</span></span><br><span class="line"></span><br><span class="line">serverless init eggjs-starter(可以替换成sls registry已有的模板) --name egg-example</span><br></pre></td></tr></table></figure><p>部署 </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sls deploy</span><br></pre></td></tr></table></figure><h2 id="2-2-在vscode中配置插件来开发serverless"><a href="#2-2-在vscode中配置插件来开发serverless" class="headerlink" title="2.2 在vscode中配置插件来开发serverless"></a>2.2 在vscode中配置插件来开发serverless</h2><p>通过该 VS Code 插件，您可以</p><ul><li>拉取云端的云函数列表，并触发云函数</li><li>在本地快速创建云函数项目</li><li>使用模拟的 COS、CMQ、CKafka、API 网关等触发器事件来触发函数运行</li><li>上传函数代码到云端，更新函数配置</li><li>在云端运行、调试函数代码</li></ul><p><strong>界面上创建应用</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/18c3d872701f1cfc.png" alt></p><ul><li>在<code>vscode</code>上安装插件</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/0b0cf6ae03f9277b.png" alt></p><ul><li>在<code>vscode</code>安装后插件登录并且拉取应用</li></ul><blockquote><p>密钥地址 <a href="https://console.cloud.tencent.com/cam/capi" target="_blank" rel="noopener">https://console.cloud.tencent.com/cam/capi</a> 填入appID、secretID、secretKey即可拉取云函数到本地</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/07/66d614b9bba52dbf.png" alt></p><ul><li>切换地域查看函数</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/d5010c1e04560057.png" alt></p><ul><li>点击云函数，可以查看函数基本配置信息</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/9e081856b313fc45.png" alt></p><ul><li>下载函数代码到本地调试，点击下载图标选择要保存的路径</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/a7b44ad3928be60f.png" alt></p><ul><li>本地修改完代码后，上传函数代码到云端</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/9e2f3c3bc5832035.png" alt><br><img src="https://s.poetries.work/uploads/2022/07/f497c782f6070744.png" alt></p><ul><li>本地调试云函数</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/99f7dc28e086be60.png" alt></p><h2 id="2-3-WebIDE创建云函数实践"><a href="#2-3-WebIDE创建云函数实践" class="headerlink" title="2.3 WebIDE创建云函数实践"></a>2.3 WebIDE创建云函数实践</h2><p><strong>创建一个云函数</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/dd99f3d6323b8e15.png" alt></p><p><strong>给云函数创建触发器来访问</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/894bd8fb7cee9aa8.png" alt></p><p>创建了触发器后，就可以通过触发器里面的访问路径来访问云函数</p><p><img src="https://s.poetries.work/uploads/2022/06/6ea1e2875196d30e.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/535aa49e41c50789.png" alt></p><blockquote><p>我们可以在控制台修改代码，然后重新部署云函数，或者开启自动安装依赖等</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/07/e5f68c50a4296d47.png" alt></p><h1 id="三、Serverless-Framework部署项目实战"><a href="#三、Serverless-Framework部署项目实战" class="headerlink" title="三、Serverless Framework部署项目实战"></a>三、Serverless Framework部署项目实战</h1><h2 id="3-1-Serverless-Framework简介及应用场景"><a href="#3-1-Serverless-Framework简介及应用场景" class="headerlink" title="3.1 Serverless Framework简介及应用场景"></a>3.1 Serverless Framework简介及应用场景</h2><ul><li>Serverless Framework 是 Serverless 公司推出的一个开源的 Serverless 应用开发框架</li><li>Serverless Framework 是 由 Serverless Framework Plugin 和 Serverless Framework Components 组成</li><li>Serverless Framework Plugin 实际上是一个函数的管理工具，使用这个工具，可以很轻 松的部署函数、删除函数、触发函数、查看函数信息、查看函数日志、回滚函数、查看函数 数据等</li></ul><blockquote><p>Serverless Framework Components 可以看作是一个组件集，这里面包括了很多的 Components，有基础的 Components，例如 cos、scf、apigateway 等，也有一些拓展的 Components，例如在 cos 上拓展出来的 website，可以直接部署静态网站等，还有一些框 架级的，例如 Koa，Express等</p></blockquote><ul><li>Serverless Framework 官网：<a href="https://www.serverless.com/" target="_blank" rel="noopener">https://www.serverless.com/</a> </li><li>Serverless Framework 中文网站：<a href="https://www.serverless.com/cn" target="_blank" rel="noopener">https://www.serverless.com/cn</a> </li><li>Github 地址：<a href="https://github.com/serverless/serverless" target="_blank" rel="noopener">https://github.com/serverless/serverless</a></li></ul><h3 id="Serverless-Framework-应用场景"><a href="#Serverless-Framework-应用场景" class="headerlink" title="Serverless Framework 应用场景"></a>Serverless Framework 应用场景</h3><blockquote><p>上面既然介绍了云函数和<code>serverless</code>的区别，现在我们介绍下什么场景下需要使用<code>serverless</code>，而不是使用云函数，其实在实际开发过程中，我们都是使用<code>serverless</code>而不去使用云函数，毕竟云函数的使用场景受限，或者说比较基础。打一个简单的比方，在写<code>js</code>操作<code>dom</code>的时候，你会选择用原生<code>js</code>还是会使用<code>jquery</code>一样的比喻</p></blockquote><p><strong>基于云函数的命令行开发工具</strong></p><blockquote><p>通过 <code>Serverless Framework</code>，开发者可以在命令行完成函数的开发、部署、调试。还可以结合前端服务、 API 网关、数据库等其它云上资源，实现全栈应用的快速部署。</p></blockquote><p><strong>传统应用框架的快速迁移</strong></p><blockquote><p><code>Serverless Framework</code> 提供了一套通用的框架迁移方案，通过使用 <code>Serverless Framework</code>提供的框架组件(<code>Egg/Koa/Express</code> 等，<a href="https://github.com/serverless" target="_blank" rel="noopener">更多的框架支持可以参考</a>)，原有应用仅需几行代码简单改造， 即可快速迁移到函数平台。同时支持命令行与控制台的开发方式。</p></blockquote><h3 id="Serverless-Framework-支持的平台"><a href="#Serverless-Framework-支持的平台" class="headerlink" title="Serverless Framework 支持的平台"></a>Serverless Framework 支持的平台</h3><blockquote><p><a href="https://github.com/serverless/serverless/tree/master/docs/providers" target="_blank" rel="noopener">https://github.com/serverless/serverless/tree/master/docs/providers</a></p></blockquote><p><img src="https://s.poetries.work/uploads/2022/07/228c4a131acdb03c.png" alt></p><h2 id="3-2-Serverless-Components-支持组件列表"><a href="#3-2-Serverless-Components-支持组件列表" class="headerlink" title="3.2 Serverless Components 支持组件列表"></a>3.2 Serverless Components 支持组件列表</h2><h3 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h3><ul><li><a href="https://github.com/serverless-components/tencent-postgresql/tree/master" target="_blank" rel="noopener">@serverless/tencent-postgresql</a> - 腾讯云 PG DB Serverless 数据库组件</li><li><a href="https://github.com/serverless-components/tencent-apigateway" target="_blank" rel="noopener">@serverless/tencent-apigateway</a> - 腾讯云 API 网关组件</li><li><a href="https://github.com/serverless-components/tencent-cos" target="_blank" rel="noopener">@serverless/tencent-cos</a> - 腾讯云对象存储组件</li><li><a href="https://github.com/serverless-components/tencent-scf/tree/master" target="_blank" rel="noopener">@serverless/tencent-scf</a> - 腾讯云云函数组件</li><li><a href="https://github.com/serverless-components/tencent-cdn" target="_blank" rel="noopener">@serverless/tencent-cdn</a> - 腾讯云 CDN 组件</li><li><a href="https://github.com/serverless-components/tencent-vpc/tree/master" target="_blank" rel="noopener">@serverless/tencent-vpc</a> - 腾讯云 VPC 私有网络组件</li></ul><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><ul><li><a href="https://github.com/serverless-components/tencent-nextjs/tree/master" target="_blank" rel="noopener">@serverless/tencent-nextjs</a> - 快速部署基于 Next.js 框架到腾讯云函数的组件</li><li><a href="https://github.com/serverless-components/tencent-nuxtjs/tree/master" target="_blank" rel="noopener">@serverless/tencent-nuxtjs</a> - 快速部署基于 Nuxt.js 框架到腾讯云函数的组件</li><li><a href="https://github.com/serverless-components/tencent-express/tree/master" target="_blank" rel="noopener">@serverless/tencent-express</a> - 快速部署基于 Express.js 的后端服务到腾讯云函数的组件</li><li><a href="https://github.com/serverless-components/tencent-egg/tree/master" target="_blank" rel="noopener">@serverless/tencent-egg</a> - 快速部署基于 Egg.js 的后端服务到腾讯云函数的组件</li><li><a href="https://github.com/serverless-components/tencent-koa/tree/master" target="_blank" rel="noopener">@serverless/tencent-koa</a> - 快速部署基于 Koa.js 的后端服务到腾讯云函数的组件</li><li><a href="https://github.com/serverless-components/tencent-flask" target="_blank" rel="noopener">@serverless/tencent-flask</a> - 腾讯云 Python Flask RESTful API 组件</li><li><a href="https://github.com/serverless-tencent/tencent-django/tree/master" target="_blank" rel="noopener">@serverless/tencent-django</a> - 腾讯云 Python Django RESTful API 组件</li><li><a href="https://github.com/serverless-components/tencent-laravel" target="_blank" rel="noopener">@serverless/tencent-laravel</a> - 腾讯云 PHP Laravel RESTful API 组件</li><li><a href="https://github.com/serverless-components/tencent-thinkphp" target="_blank" rel="noopener">@serverless/tencent-thinkphp</a> - 腾讯云 ThinkPHP RESTful API 组件</li><li><a href="https://github.com/serverless-components/tencent-website/tree/master" target="_blank" rel="noopener">@serverless/tencent-website</a> - 快速部署静态网站到腾讯云的组件</li></ul><h2 id="3-3-sls部署egg项目"><a href="#3-3-sls部署egg项目" class="headerlink" title="3.3 sls部署egg项目"></a>3.3 sls部署egg项目</h2><blockquote><p>egg 框架中默认已经配置好了静态资源，我们可以直接访问。要注意的是 serverless 服务器 上面只有根目录的 tmp 目录有写入权限，所以需要配置 egg 日志存储的目录。默认创建好 项目以后有如下配置。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/config.default.js </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">appInfo</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...,</span><br><span class="line">    rundir: <span class="string">'/tmp'</span>,</span><br><span class="line">    logger: &#123;</span><br><span class="line">      dir: <span class="string">'/tmp'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制台创建部署-模板部署"><a href="#控制台创建部署-模板部署" class="headerlink" title="控制台创建部署-模板部署"></a>控制台创建部署-模板部署</h3><ol><li>登录控制台 <a href="https://console.cloud.tencent.com/sls" target="_blank" rel="noopener">https://console.cloud.tencent.com/sls</a></li><li>单击新建应用，选择Web 应用&gt;Egg 框架，如下图所示：</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/fbf0b03c839cd73e.png" alt></p><ol start="3"><li>单击“下一步”，完成基础配置选择。</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/58b123659a00b194.png" alt></p><ol start="4"><li>上传方式，选择示例代码直接部署，单击完成，即可开始应用的部署。</li><li>部署完成后，您可在应用详情页面，查看示例应用的基本信息，并通过 API 网关生成的访问路径 URL 进行访问，查看您部署的 Egg 项目。</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/c4c3e330b1a6af68.png" alt></p><h3 id="控制台创建部署-自定义部署-推荐"><a href="#控制台创建部署-自定义部署-推荐" class="headerlink" title="控制台创建部署-自定义部署(推荐)"></a>控制台创建部署-自定义部署(推荐)</h3><blockquote><p>如果除了代码部署外，您还需要更多能力或资源创建，如自动创建层托管依赖、一键实现静态资源分离、支持代码仓库直接拉取等，可以通过应用控制台，完成 Web 应用的创建工作</p></blockquote><p><strong>初始化项目</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir egg-example &amp;&amp; cd egg-example</span><br><span class="line">npm init egg --type=simple</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p><strong>部署上云</strong></p><blockquote><p>接下来执行以下步骤，对本地已创建完成的项目进行简单修改，使其可以通过 Web Function 快速部署，对于 Egg 框架，具体改造说明如下：</p></blockquote><ul><li>修改监听地址与端口为 <code>0.0.0.0:9000</code>。</li><li>修改写入路径，serverless 环境下只有 <code>/tmp</code> 目录可读写。</li><li>新增 <code>scf_bootstrap</code> 启动文件。</li></ul><p><strong>1. (可选)配置 scf_bootstrap 启动文件</strong></p><p>您也可以在控制台完成该模块配置。</p><p><img src="https://s.poetries.work/uploads/2022/06/85b3d73ea922f0ea.png" alt></p><blockquote><p>在项目根目录下新建 <code>scf_bootstrap</code> 启动文件，在该文件添加如下内容（用于配置环境变量和启动服务，此处仅为示例，具体操作请以您实际业务场景来调整）：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/var/lang/node12/bin/node</span></span><br><span class="line"></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * docker 中 node 路径：/var/lang/node12/bin/node</span></span><br><span class="line"><span class="comment"> * 由于 serverless 函数只有 /tmp 读写权限，所以在启动时需要修改两个环境变量</span></span><br><span class="line"><span class="comment"> * NODE_LOG_DIR 是为了改写 egg-scripts 默认 node 写入路径（~/logs）-&gt; /tmp</span></span><br><span class="line"><span class="comment"> * EGG_APP_CONFIG 是为了修改 egg 应有的默认当前目录 -&gt; /tmp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">process.env.EGG_SERVER_ENV = <span class="string">'prod'</span>;</span><br><span class="line">process.env.NODE_ENV = <span class="string">'production'</span>;</span><br><span class="line">process.env.NODE_LOG_DIR = <span class="string">'/tmp'</span>;</span><br><span class="line">process.env.EGG_APP_CONFIG = <span class="string">'&#123;"rundir":"/tmp","logger":&#123;"dir":"/tmp"&#125;&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Application &#125; = <span class="built_in">require</span>(<span class="string">'egg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果通过层部署 node_modules 就需要修改 eggPath</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Application.prototype, <span class="built_in">Symbol</span>.for(<span class="string">'egg#eggPath'</span>), &#123;</span><br><span class="line">  value: <span class="string">'/opt'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Application(&#123;</span><br><span class="line">  mode: <span class="string">'single'</span>,</span><br><span class="line">  env: <span class="string">'prod'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9000</span>, <span class="string">'0.0.0.0'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server start on http://0.0.0.0:9000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>新建完成后，还需执行以下命令修改文件可执行权限，默认需要 777 或 755 权限才可正常启动。示例如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 scf_bootstrap</span><br></pre></td></tr></table></figure><p><strong>2. 控制台上传</strong></p><blockquote><p>您可以在控制台完成启动文件 scf_bootstrap 内容配置，配置完成后，控制台将为您自动生成 启动文件，和项目代码一起打包部署</p></blockquote><p>启动文件以项目内文件为准，如果您的项目里已经包含 <code>scf_bootstrap</code> 文件，将不会覆盖该内容。</p><p><img src="https://s.poetries.work/uploads/2022/06/a96ce1c3799f5951.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/ce48d9dd73af824f.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/9a0e3dfa25a6ed3d.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/e9dd1225bf0d37cd.png" alt></p><p>查看函数，修改代码查看日志等</p><p><img src="https://s.poetries.work/uploads/2022/06/ca238c35541dd8df.png" alt></p><p><strong>高级配置管理</strong></p><blockquote><p>您可在“高级配置”里进行更多应用管理操作，如创建层、绑定自定义域名、配置环境变量等。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/4ab13bbb74bcdf89.png" alt></p><h3 id="HTTP-组件方式部署-推荐"><a href="#HTTP-组件方式部署-推荐" class="headerlink" title="HTTP 组件方式部署(推荐)"></a>HTTP 组件方式部署(推荐)</h3><blockquote><p>目前推荐使用 web 函数，也就是 <code>HTTP 组件</code>，现在所有的serverless web 应用都是基于 <code>component: http</code> 组件的。</p></blockquote><blockquote><p>通过 <code>Serverless Framework</code> 的 <code>HTTP 组件</code>，完成 Web 应用的本地部署</p></blockquote><p><strong>前提条件</strong></p><blockquote><p>已开通服务并完成 <a href="https://cloud.tencent.com/document/product/1154/43006" target="_blank" rel="noopener">Serverless Framework 的 权限配置</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化egg项目</span></span><br><span class="line"></span><br><span class="line">serverless init eggjs-starter(可以替换成sls registry已有的模板) --name egg-example</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编写完善配置文件 serverless.yml</span></span><br><span class="line"><span class="comment"># https://github.com/serverless-components/tencent-http/blob/master/docs/configure.md</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">egg-example-fa63d20e9</span> <span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">http</span> <span class="comment"># http组件</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">egg-demo</span> <span class="comment"># 实例名称</span></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span> <span class="comment"># 云函数所在区域</span></span><br><span class="line"><span class="attr">  src:</span> <span class="comment"># 部署当前目录下的文件代码，并打包成zip上传到bucket上</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./</span> <span class="comment"># 当前目录</span></span><br><span class="line"><span class="attr">    exclude:</span> <span class="comment"># 被排除的文件或目录</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">.env</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">'node_modules/**'</span> <span class="comment"># 忽略node_modules，在控制台WEBIDE开启安装依赖</span></span><br><span class="line">  <span class="comment"># src: # 在指定存储桶bucket中已经存在了object代码，直接部署</span></span><br><span class="line">  <span class="comment">#   bucket: bucket01 # bucket name，当前会默认在bucket name后增加 appid 后缀, 本例中为 bucket01-appid</span></span><br><span class="line">  <span class="comment">#   object: cos.zip  # bucket key 指定存储桶内的文件</span></span><br><span class="line"><span class="attr">  faas:</span> <span class="comment"># 函数配置相关</span></span><br><span class="line"><span class="attr">    runtime:</span> <span class="string">Nodejs12.16</span> <span class="comment"># 运行时</span></span><br><span class="line">    <span class="comment"># 支持的框架查看 https://cloud.tencent.com/document/product/1154/59447#framework</span></span><br><span class="line"><span class="attr">    framework:</span> <span class="string">egg</span> <span class="comment"># #选择框架，此处以 egg 为例 </span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">$&#123;name&#125;</span> <span class="comment"># 云函数名称，通过变量形式获取name的值</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">60</span> <span class="comment"># 超时时间，单位秒</span></span><br><span class="line"><span class="attr">    memorySize:</span> <span class="number">512</span> <span class="comment"># 内存大小，默认 512 MB</span></span><br><span class="line">    <span class="comment"># layers:</span></span><br><span class="line">    <span class="comment">#   - name: layerName #  layer名称</span></span><br><span class="line">    <span class="comment">#     version: 1 #  版本</span></span><br><span class="line"><span class="attr">    environments:</span> <span class="comment">#  配置环境变量，同时也可以直接在 scf 控制台配置 </span></span><br><span class="line"><span class="attr">        - key:</span> <span class="string">NODE_ENV</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">production</span></span><br><span class="line">    <span class="comment"># vpc: # 私有网络配置</span></span><br><span class="line">    <span class="comment">#   vpcId: 'vpc-xxx' # 私有网络的Id</span></span><br><span class="line">    <span class="comment">#   subnetId: 'subnet-xxx' # 子网ID</span></span><br><span class="line">    <span class="comment"># tags:</span></span><br><span class="line">    <span class="comment">#   - key: tagKey</span></span><br><span class="line">    <span class="comment">#     value: tagValue</span></span><br><span class="line"><span class="attr">  apigw:</span> <span class="comment"># http 组件会默认帮忙创建一个 API 网关服务</span></span><br><span class="line"><span class="attr">    isDisabled:</span> <span class="literal">false</span> <span class="comment"># 是否禁用自动创建 API 网关功能</span></span><br><span class="line">    <span class="comment"># id: service-xx # api网关服务ID，不填则自动新建网关</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">serverless</span> <span class="comment"># api网关服务名称</span></span><br><span class="line"><span class="attr">    api:</span> <span class="comment"># 创建的 API 相关配置</span></span><br><span class="line"><span class="attr">      cors:</span> <span class="literal">true</span> <span class="comment">#  允许跨域</span></span><br><span class="line"><span class="attr">      timeout:</span> <span class="number">30</span> <span class="comment"># API 超时时间</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">apiName</span> <span class="comment"># API 名称</span></span><br><span class="line"><span class="attr">      qualifier:</span> <span class="string">$DEFAULT</span> <span class="comment"># API 关联的版本</span></span><br><span class="line"><span class="attr">    protocols:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">http</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    environment:</span> <span class="string">test</span></span><br><span class="line">    <span class="comment"># tags:</span></span><br><span class="line">    <span class="comment">#   - key: tagKey</span></span><br><span class="line">    <span class="comment">#     value: tagValue</span></span><br><span class="line">    <span class="comment"># customDomains: # 自定义域名绑定</span></span><br><span class="line">    <span class="comment">#   - domain: abc.com # 待绑定的自定义的域名</span></span><br><span class="line">    <span class="comment">#     certId: abcdefg # 待绑定自定义域名的证书唯一 ID</span></span><br><span class="line">    <span class="comment">#     # 如要设置自定义路径映射，(customMap = true isDefaultMapping = false)必须两者同时出现 其余情况都是默认路径</span></span><br><span class="line">    <span class="comment">#     customMap: true</span></span><br><span class="line">    <span class="comment">#     isDefaultMapping: false</span></span><br><span class="line">    <span class="comment">#     # 自定义路径映射的路径。使用自定义映射时，可一次仅映射一个 path 到一个环境，也可映射多个 path 到多个环境。并且一旦使用自定义映射，原本的默认映射规则不再生效，只有自定义映射路径生效。</span></span><br><span class="line">    <span class="comment">#     pathMap:</span></span><br><span class="line">    <span class="comment">#       - path: /</span></span><br><span class="line">    <span class="comment">#         environment: release</span></span><br><span class="line">    <span class="comment">#     protocols: # 绑定自定义域名的协议类型，默认与服务的前端协议一致。</span></span><br><span class="line">    <span class="comment">#       - http # 支持http协议</span></span><br><span class="line">    <span class="comment">#       - https # 支持https协议</span></span><br><span class="line">    <span class="comment"># app: #  应用授权配置</span></span><br><span class="line">    <span class="comment">#   id: app-xxx</span></span><br><span class="line">    <span class="comment">#   name: app_demo</span></span><br><span class="line">    <span class="comment">#   description: app description</span></span><br></pre></td></tr></table></figure><blockquote><p>全部配置详细查看  <a href="https://github.com/serverless-components/tencent-http/blob/master/docs/configure.md" target="_blank" rel="noopener">https://github.com/serverless-components/tencent-http/blob/master/docs/configure.md</a></p></blockquote><p><strong>部署</strong></p><blockquote><p>创建完成后，在根目录下执行 <code>sls deploy</code> 进行部署，组件会根据选择的框架类型，自动生成 <code>scf_bootstrap</code> 启动文件进行部署</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/8e11d14d715ba443.png" alt></p><p>我们也可以在项目跟目录自己创建启动文件<code>scf_bootstrap</code> ，然后<code>chmod 777 scf_bootstrap</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scf_bootstrap</span></span><br><span class="line"><span class="meta">#!/var/lang/node12/bin/node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * docker 中 node 路径：/var/lang/node12/bin/node</span></span><br><span class="line"><span class="comment"> * 由于 serverless 函数只有 /tmp 读写权限，所以在启动时需要修改两个环境变量</span></span><br><span class="line"><span class="comment"> * NODE_LOG_DIR 是为了改写 egg-scripts 默认 node 写入路径（~/logs）-&gt; /tmp</span></span><br><span class="line"><span class="comment"> * EGG_APP_CONFIG 是为了修改 egg 应有的默认当前目录 -&gt; /tmp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">process.env.EGG_SERVER_ENV = <span class="string">'prod'</span>;</span><br><span class="line">process.env.NODE_ENV = <span class="string">'production'</span>;</span><br><span class="line">process.env.NODE_LOG_DIR = <span class="string">'/tmp'</span>;</span><br><span class="line">process.env.EGG_APP_CONFIG = <span class="string">'&#123;"rundir":"/tmp","logger":&#123;"dir":"/tmp"&#125;&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Application &#125; = <span class="built_in">require</span>(<span class="string">'egg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果通过层部署 node_modules 就需要修改 eggPath</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Application.prototype, <span class="built_in">Symbol</span>.for(<span class="string">'egg#eggPath'</span>), &#123;</span><br><span class="line">  value: <span class="string">'/opt'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Application(&#123;</span><br><span class="line">  mode: <span class="string">'single'</span>,</span><br><span class="line">  env: <span class="string">'prod'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9000</span>, <span class="string">'0.0.0.0'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server start on http://0.0.0.0:9000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 微信扫码即可 </span></span><br><span class="line"><span class="comment"># 微信扫码授权部署有过期时间，如果想要持久授权，请参考账号配置(https://cloud.tencent.com/document/product/1154/45874#account)</span></span><br><span class="line"><span class="comment"># 当前默认支持 CLI 扫描二维码登录，如您希望配置持久的环境变量/密钥信息，也可以本地创建 .env 文件：</span></span><br><span class="line"><span class="comment"># 在 .env 文件中配置腾讯云的 SecretId 和 SecretKey 信息并保存。</span></span><br><span class="line"><span class="comment"># API密钥管理 https://console.cloud.tencent.com/cam/capi</span></span><br><span class="line"><span class="comment"># .env</span></span><br><span class="line"><span class="comment">#TENCENT_SECRET_ID=123</span></span><br><span class="line"><span class="comment">#TENCENT_SECRET_KEY=123</span></span><br><span class="line"></span><br><span class="line">sls deploy</span><br></pre></td></tr></table></figure><blockquote><p>注意：由于启动文件逻辑与用户业务逻辑强关联，默认生成的启动文件可能导致框架无法正常启动，建议您根据实际业务需求，手动配置启动文件，<a href="https://cloud.tencent.com/document/product/1154/59447" target="_blank" rel="noopener">详情参考各框架的部署指引文档</a>。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/9d3580eef444d80f.png" alt></p><blockquote><p>如果部署过程遇到问题不好排除，如以下问题：</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/6d5fd5ba537850dd.png" alt></p><p>来到控制台创建项目</p><p><img src="https://s.poetries.work/uploads/2022/06/1ac3905f67789812.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/715ea0e1c4d12298.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/a3921110151f0ba3.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/f91266106e6e1d78.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/2117adef0814c390.png" alt></p><p><strong>在控制台安装依赖包</strong></p><blockquote><p>我们在<code>sls deploy</code>忽略了<code>node_modules</code>，因此需要在控制台安装依赖</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/d47f6e73f93d5055.png" alt></p><p>访问应用</p><p><img src="https://s.poetries.work/uploads/2022/06/9ad37b26fbab516d.png" alt></p><p>到控制台查看</p><p><img src="https://s.poetries.work/uploads/2022/06/14c5cc6d18060612.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/369867cf3dc9a1e1.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/3cdd7bf1c596d876.png" alt></p><p>删除应用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sls remove</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/9db881d3d57a0c59.png" alt></p><h3 id="使用Layer-来减小项目文件大小"><a href="#使用Layer-来减小项目文件大小" class="headerlink" title="使用Layer 来减小项目文件大小"></a>使用Layer 来减小项目文件大小</h3><p>随着项目复杂度的增加，<code>deploy</code> 上传会变慢。所以，让我们再优化一下，在项目根目录创建 <code>layer/serverless.yml</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># layer/serverless.yml</span></span><br><span class="line"><span class="comment"># https://cloud.tencent.com/document/product/1154/51133</span></span><br><span class="line"><span class="comment"># https://github.com/serverless-components/tencent-layer/blob/master/docs/configure.md</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#应用组织信息（可选）</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">egg-demo</span></span><br><span class="line"><span class="attr">stage:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#组件信息</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">layer</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">egg-demo-layer</span> <span class="comment"># 层名称 必须</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组件参数配置，根据每个组件，实现具体的资源信息配置</span></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr"> name:</span> <span class="string">$&#123;name&#125;</span> <span class="comment"># 名称跟上面一致即可</span></span><br><span class="line"><span class="attr"> region:</span> <span class="string">ap-guangzhou</span> <span class="comment"># 地区 必须</span></span><br><span class="line"><span class="attr"> src:</span> <span class="string">../node_modules</span> <span class="comment">#需要上传的目标文件路径 必须 </span></span><br><span class="line">  <span class="comment"># src: # 代码路径。与 object 不能同时存在。</span></span><br><span class="line">  <span class="comment">#   src: ./node_modules</span></span><br><span class="line">  <span class="comment">#   targetDir: /node_modules</span></span><br><span class="line">  <span class="comment">#   exclude:   # 被排除的文件或目录 不包含的文件或路径, 遵守 glob 语法</span></span><br><span class="line">  <span class="comment">#     - .env</span></span><br><span class="line">  <span class="comment">#     - node_modules</span></span><br><span class="line">  <span class="comment"># src:</span></span><br><span class="line">  <span class="comment"># bucket 名称。如果配置了 src，表示部署 src 的代码并压缩成 zip 后上传到 bucket-appid 对应的存储桶中；如果配置了 object，表示获取 bucket-appid 对应存储桶中 object 对应的代码进行部署。</span></span><br><span class="line">  <span class="comment">#   bucket: layers</span></span><br><span class="line">  <span class="comment">#   object: sls-layer-test-1584524206.zip # 部署的代码在存储桶中的路径。</span></span><br><span class="line">  <span class="comment">#   exclude:   # 被排除的文件或目录</span></span><br><span class="line">  <span class="comment">#     - .env</span></span><br><span class="line">  <span class="comment">#     - node_modules</span></span><br><span class="line"><span class="attr"> runtimes:</span> <span class="comment"># 层支持的运行环境</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">Nodejs12.16</span> </span><br><span class="line"><span class="attr"> description:</span> <span class="string">layer</span> <span class="string">description</span> <span class="comment"># 否 描述</span></span><br></pre></td></tr></table></figure><p>创建后可见层对应信息</p><p><img src="https://s.poetries.work/uploads/2022/06/7e5abeb49a56f460.png" alt></p><p>我们也可以在控制台新建层绑定到对应的函数即可</p><p><img src="https://s.poetries.work/uploads/2022/06/d10f5ea7b0cac331.png" alt></p><p>控制台上传层有大小限制</p><p><img src="https://s.poetries.work/uploads/2022/06/683f6152002db3a9.png" alt></p><p>文件夹支持250M</p><p><img src="https://s.poetries.work/uploads/2022/06/6495e575646c3035.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/740312afd66bc342.png" alt></p><p><strong>修改以上项目下的serverless.yml加入层配置</strong></p><p>回到项目根目录，调整一下根目录的 <code>serverless.yml</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编写完善配置文件 serverless.yml</span></span><br><span class="line"><span class="comment"># https://github.com/serverless-components/tencent-http/blob/master/docs/configure.md</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">egg-example-fa63d20e9</span> <span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">http</span> <span class="comment"># http组件</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">egg-demo</span> <span class="comment"># 实例名称</span></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span> <span class="comment"># 云函数所在区域</span></span><br><span class="line"><span class="attr">  src:</span> <span class="comment"># 部署当前目录下的文件代码，并打包成zip上传到bucket上</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./</span> <span class="comment"># 当前目录</span></span><br><span class="line"><span class="attr">    exclude:</span> <span class="comment"># 被排除的文件或目录</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">.env</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"node_modules/**"</span> <span class="comment"># deploy 时排除 node_modules [需要注意] 使用layer的node_modules</span></span><br><span class="line"><span class="attr">  faas:</span> <span class="comment"># 函数配置相关</span></span><br><span class="line"><span class="attr">    runtime:</span> <span class="string">Nodejs12.16</span> <span class="comment"># 运行时</span></span><br><span class="line">    <span class="comment"># 支持的框架查看 https://cloud.tencent.com/document/product/1154/59447#framework</span></span><br><span class="line"><span class="attr">    framework:</span> <span class="string">egg</span> <span class="comment"># #选择框架，此处以 egg 为例 </span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">$&#123;name&#125;</span> <span class="comment"># 云函数名称，通过变量形式获取name的值</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">60</span> <span class="comment"># 超时时间，单位秒</span></span><br><span class="line"><span class="attr">    memorySize:</span> <span class="number">512</span> <span class="comment"># 内存大小，默认 512 MB</span></span><br><span class="line">    <span class="comment"># 加入层配置 引用格式请参考 变量引用说明 https://github.com/AprilJC/Serverless-Framework-Docs/blob/main/docs/%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8.md#%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8%E8%AF%B4%E6%98%8E</span></span><br><span class="line"><span class="attr">    layers:</span> </span><br><span class="line"><span class="attr">      - name:</span> <span class="string">$&#123;output:$&#123;stage&#125;:$&#123;app&#125;:$&#123;name&#125;-layer.name&#125;</span> <span class="comment"># 配置对应的 layer</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">$&#123;output:$&#123;stage&#125;:$&#123;app&#125;:$&#123;name&#125;-layer.version&#125;</span> <span class="comment"># 配置对应的 layer 版本</span></span><br><span class="line"><span class="attr">    environments:</span> <span class="comment">#  配置环境变量，同时也可以直接在 scf 控制台配置 </span></span><br><span class="line"><span class="attr">        - key:</span> <span class="string">NODE_ENV</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">production</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="comment"># 标签</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">tagKey</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">tagValue</span></span><br><span class="line"><span class="attr">  apigw:</span> <span class="comment"># http 组件会默认帮忙创建一个 API 网关服务</span></span><br><span class="line"><span class="attr">    isDisabled:</span> <span class="literal">false</span> <span class="comment"># 是否禁用自动创建 API 网关功能</span></span><br><span class="line">    <span class="comment"># id: service-xxx # api网关服务ID，不填则自动新建网关</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">serverless</span> <span class="comment"># api网关服务名称</span></span><br><span class="line"><span class="attr">    api:</span> <span class="comment"># 创建的 API 相关配置</span></span><br><span class="line"><span class="attr">      cors:</span> <span class="literal">true</span> <span class="comment">#  允许跨域</span></span><br><span class="line"><span class="attr">      timeout:</span> <span class="number">30</span> <span class="comment"># API 超时时间</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">apiName</span> <span class="comment"># API 名称</span></span><br><span class="line"><span class="attr">      qualifier:</span> <span class="string">$DEFAULT</span> <span class="comment"># API 关联的版本</span></span><br><span class="line"><span class="attr">    protocols:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">http</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    environment:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>排除<code>node_modules</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">exclude:</span> <span class="comment"># 被排除的文件或目录</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">.env</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules/**</span> <span class="comment"># deploy 时排除 node_modules [需要注意] 使用layer的node_modules</span></span><br></pre></td></tr></table></figure><p>配置层</p><blockquote><p>引用格式请参考 变量引用说明 <a href="https://github.com/AprilJC/Serverless-Framework-Docs/blob/main/docs/%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8.md#%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">https://github.com/AprilJC/Serverless-Framework-Docs/blob/main/docs/%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8.md#%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8%E8%AF%B4%E6%98%8E</a></p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">layers:</span> </span><br><span class="line"><span class="attr">    - name:</span> <span class="string">$&#123;output:$&#123;stage&#125;:$&#123;app&#125;:$&#123;name&#125;-layer.name&#125;</span> <span class="comment"># 配置对应的 layer</span></span><br><span class="line"><span class="attr">    version:</span> <span class="string">$&#123;output:$&#123;stage&#125;:$&#123;app&#125;:$&#123;name&#125;-layer.version&#125;</span> <span class="comment"># 配置对应的 layer 版本</span></span><br></pre></td></tr></table></figure><p>通过配置层layer，代码和<code>node_modules</code>分离，<code>sls deploy</code>更快</p><blockquote><p>接着执行命令 <code>sls deploy --target=./layer</code>部署层，然后再次部署<code>sls deploy</code>看看速度应该更快了</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/f5d5c8b90fdf942c.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/6683161cf18fc51c.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/88d1098b222f184b.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/b5b0c69b6962434d.png" alt></p><p>每次<code>node_modules</code>改变都需要 </p><ul><li>执行 <code>sls deploy --target=./layer</code> 部署层， 更新 <code>node_modules</code> 层</li><li>执行 <code>sls deploy</code> 重新部署</li></ul><p><strong>layer 的加载与访问</strong></p><blockquote><p>layer 会在函数运行时，将内容解压到 <code>/opt</code> 目录下，如果存在多个 <code>layer</code>，那么会按时间循序进行解压。如果需要访问 <code>layer</code> 内的文件，可以直接通过 <code>/opt/xxx</code> 访问。如果是访问 <code>node_module</code> 则可以直接 <code>import</code>，因为 <code>scf</code> 的 <code>NODE_PATH</code> 环境变量默认已包含 <code>/opt/node_modules</code> 路径。</p></blockquote><h3 id="使用serverless-fromwork的高阶egg组件方式部署-不推荐"><a href="#使用serverless-fromwork的高阶egg组件方式部署-不推荐" class="headerlink" title="使用serverless fromwork的高阶egg组件方式部署(不推荐)"></a>使用serverless fromwork的高阶egg组件方式部署(不推荐)</h3><blockquote><p>目前推荐使用 web 函数，也就是 <code>HTTP 组件</code>，现在所有的serverless web 应用都是基于 <code>component: http</code> 组件的。</p></blockquote><ol><li>在项目根目录下创建 <code>serverless.yml</code>文件</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i serverless -g</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/serverless-components/tencent-egg/blob/master/docs/configure.md</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># serverless.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">component:</span> <span class="string">egg</span> <span class="comment"># (必选) 组件名称，在该实例中为egg</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">egg-demo</span> <span class="comment"># 必选) 组件实例名称.</span></span><br><span class="line"><span class="comment"># org: orgDemo # (可选) 用于记录组织信息，默认值为您的腾讯云账户 appid，必须为字符串</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">egg-demo</span> <span class="comment"># (可选) 用于记录组织信息. 默认与name相同，必须为字符串</span></span><br><span class="line"><span class="attr">stage:</span> <span class="string">dev</span> <span class="comment"># (可选) 用于区分环境信息，默认值是 dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span> <span class="comment"># 云函数所在区域</span></span><br><span class="line"><span class="attr">  functionName:</span> <span class="string">egg-demo</span> <span class="comment"># 云函数名称</span></span><br><span class="line">  <span class="comment"># serviceName: egg-demo # api网关服务名称</span></span><br><span class="line"><span class="attr">  runtime:</span> <span class="string">Nodejs12.16</span> <span class="comment"># 运行环境</span></span><br><span class="line">  <span class="comment"># serviceId: service-np1uloxw # api网关服务ID</span></span><br><span class="line">  <span class="comment"># entryFile: sls.js # 自定义 server 的入口文件名，默认为 sls.js，如果不想修改文件名为 sls.js 可以自定义</span></span><br><span class="line">  <span class="comment"># src: ./ # 第一种为string时，会打包src对应目录下的代码上传到默认cos上。</span></span><br><span class="line"><span class="attr">  src:</span>  <span class="comment"># 第二种，部署src下的文件代码，并打包成zip上传到bucket上</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./</span>  <span class="comment"># 本地需要打包的文件目录</span></span><br><span class="line">    <span class="comment"># bucket: bucket01 # bucket name，当前会默认在bucket name后增加 appid 后缀, 本例中为 bucket01-appid</span></span><br><span class="line"><span class="attr">    exclude:</span>   <span class="comment"># 被排除的文件或目录</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">.env</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"node_modules/**"</span></span><br><span class="line">  <span class="comment"># src: # 第三种，在指定存储桶bucket中已经存在了object代码，直接部署</span></span><br><span class="line">  <span class="comment">#   bucket: bucket01 # bucket name，当前会默认在bucket name后增加 appid 后缀, 本例中为 bucket01-appid</span></span><br><span class="line">  <span class="comment">#   object: cos.zip  # bucket key 指定存储桶内的文件</span></span><br><span class="line">  <span class="comment"># layers: </span></span><br><span class="line">  <span class="comment">#   - name: $&#123;output:$&#123;stage&#125;:$&#123;app&#125;:egg-demo-layer.name&#125; # 配置对应的 layer</span></span><br><span class="line">  <span class="comment">#     version: $&#123;output:$&#123;stage&#125;:$&#123;app&#125;:egg-demo-layer.version&#125; # 配置对应的 layer 版本</span></span><br><span class="line"><span class="attr">  functionConf:</span> <span class="comment"># 函数配置相关</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">60</span> <span class="comment"># 超时时间，单位秒</span></span><br><span class="line"><span class="attr">    eip:</span> <span class="literal">false</span> <span class="comment"># 是否固定出口IP</span></span><br><span class="line"><span class="attr">    memorySize:</span> <span class="number">512</span> <span class="comment"># 内存大小，单位MB</span></span><br><span class="line"><span class="attr">    environment:</span> <span class="comment">#  环境变量</span></span><br><span class="line"><span class="attr">      variables:</span> <span class="comment">#  环境变量数组</span></span><br><span class="line"><span class="attr">        NODE_ENV:</span> <span class="string">production</span></span><br><span class="line">    <span class="comment"># vpcConfig: # 私有网络配置</span></span><br><span class="line">      <span class="comment"># vpcId: '' # 私有网络的Id</span></span><br><span class="line">      <span class="comment"># subnetId: '' # 子网ID</span></span><br><span class="line"><span class="attr">  apigatewayConf:</span> <span class="comment">#  api网关配置</span></span><br><span class="line"><span class="attr">    isDisabled:</span> <span class="literal">false</span> <span class="comment"># 是否禁用自动创建 API 网关功能</span></span><br><span class="line"><span class="attr">    enableCORS:</span> <span class="literal">true</span> <span class="comment">#  允许跨域</span></span><br><span class="line">    <span class="comment"># customDomains: # 自定义域名绑定</span></span><br><span class="line">    <span class="comment">#   - domain: abc.com # 待绑定的自定义的域名</span></span><br><span class="line">    <span class="comment">#     certificateId: abcdefg # 待绑定自定义域名的证书唯一 ID</span></span><br><span class="line">    <span class="comment">#     # 如要设置自定义路径映射，请设置为 false</span></span><br><span class="line">    <span class="comment">#     isDefaultMapping: false</span></span><br><span class="line">    <span class="comment">#     # 自定义路径映射的路径。使用自定义映射时，可一次仅映射一个 path 到一个环境，也可映射多个 path 到多个环境。并且一旦使用自定义映射，原本的默认映射规则不再生效，只有自定义映射路径生效。</span></span><br><span class="line">    <span class="comment">#     pathMappingSet:</span></span><br><span class="line">    <span class="comment">#       - path: /</span></span><br><span class="line">    <span class="comment">#         environment: release</span></span><br><span class="line">    <span class="comment">#     protocols: # 绑定自定义域名的协议类型，默认与服务的前端协议一致。</span></span><br><span class="line">    <span class="comment">#       - http # 支持http协议</span></span><br><span class="line">    <span class="comment">#       - https # 支持https协议</span></span><br><span class="line"><span class="attr">    protocols:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">http</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    environment:</span> <span class="string">release</span> <span class="comment"># 网关环境</span></span><br><span class="line"><span class="attr">    serviceTimeout:</span> <span class="number">60</span> <span class="comment"># 网关超时</span></span><br><span class="line">    <span class="comment"># usagePlan: #  用户使用计划</span></span><br><span class="line">    <span class="comment">#   usagePlanId: 1111</span></span><br><span class="line">    <span class="comment">#   usagePlanName: slscmp</span></span><br><span class="line">    <span class="comment">#   usagePlanDesc: sls create</span></span><br><span class="line">    <span class="comment">#   maxRequestNum: 1000</span></span><br><span class="line">    <span class="comment"># auth: #  密钥</span></span><br><span class="line">    <span class="comment">#   secretName: secret</span></span><br><span class="line">    <span class="comment">#   secretIds:</span></span><br><span class="line">    <span class="comment">#     - xxx</span></span><br></pre></td></tr></table></figure><ol start="2"><li>将代码推送到云端</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sls deploy # sls deploy --debug可以查看日志</span><br></pre></td></tr></table></figure><ol start="3"><li>扫描登录部署会在项目下创建一个<code>.env</code>的<code>serverless</code>的登录信息</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/4bb68977c923970f.png" alt></p><ol start="4"><li>部署成功，打开地址访问，此时会报错，我们没有把node_modules一起上传</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/b6d50b9d2070559c.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/fecba16d7e2071eb.png" alt></p><p>浏览器打开提示缺少模块</p><p><img src="https://s.poetries.work/uploads/2022/06/08a0618ffe147378.png" alt></p><p>我们在控制台上点击</p><p><img src="https://s.poetries.work/uploads/2022/06/e6454fd010815c3f.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/50bcc5c01f3af862.png" alt></p><p>打开自动安装依赖后重新部署即可看到<code>node_modules</code>，这时再次访问浏览器地址</p><p><img src="https://s.poetries.work/uploads/2022/06/fd6229e7d654a470.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/53fa2c373a8a69cd.png" alt></p><h2 id="3-4-sls部署nestjs项目"><a href="#3-4-sls部署nestjs项目" class="headerlink" title="3.4 sls部署nestjs项目"></a>3.4 sls部署nestjs项目</h2><h3 id="模板部署-–-部署-Nest-js-示例代码"><a href="#模板部署-–-部署-Nest-js-示例代码" class="headerlink" title="模板部署 – 部署 Nest.js 示例代码"></a>模板部署 – 部署 Nest.js 示例代码</h3><ol><li>登录 <a href="https://console.cloud.tencent.com/sls" target="_blank" rel="noopener">Serverless 应用控制台</a>。</li><li>单击新建应用，选择Web 应用&gt;Nest.js 框架，如下图所示：</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/c05fcae4ea2a8593.png" alt></p><ol start="3"><li>单击“下一步”，完成基础配置选择</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/c23d3219be7ab860.png" alt></p><ul><li>上传方式，选择示例代码直接部署，单击完成，即可开始应用的部署。</li><li>部署完成后，您可在应用详情页面，查看示例应用的基本信息，并通过 API 网关生成的访问路径 URL 进行访问，查看您部署的 Nest.js 项目</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/60f6e95248310f40.png" alt></p><h3 id="自定义模板部署nest-推荐"><a href="#自定义模板部署nest-推荐" class="headerlink" title="自定义模板部署nest(推荐)"></a>自定义模板部署nest(推荐)</h3><p><strong>初始化您的 Nest.js 项目</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g @nestjs/cli</span><br><span class="line">nest new nest-app</span><br></pre></td></tr></table></figure><p>在根目录下，执行以下命令在本地直接启动服务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd nest-app &amp;&amp; npm run start</span><br></pre></td></tr></table></figure><p>打开浏览器访问 <a href="http://localhost:3000，即可在本地完成" target="_blank" rel="noopener">http://localhost:3000，即可在本地完成</a> Nest.js 示例项目的访问。</p><p><strong>部署上云</strong></p><p>接下来执行以下步骤，对已初始化的项目进行简单修改，使其可以通过 Web Function 快速部署，此处项目改造通常分为以下两步：</p><ul><li>新增 <code>scf_bootstrap</code> 启动文件。</li><li>修改监听地址与端口为 <code>0.0.0.0:9000</code>。</li></ul><ol><li>修改启动文件<code>main.ts</code>，监听端口改为<code>9000</code>:</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/12736ad9dda9b911.png" alt></p><ol start="2"><li>在项目根目录下新建 <code>scf_bootstrap</code> 启动文件，在该文件添加如下内容（用于启动服务）：</li></ol><p>您也可以在控制台完成该模块配置。</p><p><img src="https://s.poetries.work/uploads/2022/06/9a96d63935762fc3.png" alt></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scf_bootstrap</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">SERVERLESS=1 /var/lang/node12/bin/node ./dist/main.js</span><br></pre></td></tr></table></figure><p>新建完成后，还需执行以下命令修改文件可执行权限，默认需要 777 或 755 权限才可正常启动。示例如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 scf_bootstrap</span><br></pre></td></tr></table></figure><p>本地配置完成后，执行启动文件，确保您的服务可以本地正常启动，接下来，登录 Serverless 应用控制台，选择Web 应用&gt;Nest.js 框架，上传方式可以选择本地上传或代码仓库拉取</p><blockquote><p>注意：启动文件以项目内文件为准，如果您的项目里已经包含 scf_bootstrap 文件，将不会覆盖该内容。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/c1fe93fe050d5f5c.png" alt></p><h3 id="使用http组件-推荐"><a href="#使用http组件-推荐" class="headerlink" title="使用http组件(推荐)"></a>使用http组件(推荐)</h3><blockquote><p>目前推荐使用 web 函数，也就是 <code>HTTP 组件</code>，现在所有的serverless web 应用都是基于 <code>component: http</code> 组件的。</p></blockquote><blockquote><p>详情查看：<a href="https://github.com/serverless-components/tencent-http" target="_blank" rel="noopener">https://github.com/serverless-components/tencent-http</a> </p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编写完善配置文件 serverless.yml</span></span><br><span class="line"><span class="comment"># https://github.com/serverless-components/tencent-http/blob/master/docs/configure.md</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">nest-app</span> <span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">http</span> <span class="comment"># http组件</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">nest-demo</span> <span class="comment"># 实例名称</span></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span> <span class="comment"># 云函数所在区域</span></span><br><span class="line"><span class="attr">  src:</span> <span class="comment"># 部署当前目录下的文件代码，并打包成zip上传到bucket上</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./</span> <span class="comment"># 当前目录</span></span><br><span class="line"><span class="attr">    exclude:</span> <span class="comment"># 被排除的文件或目录</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">.env</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">'node_modules/**'</span> <span class="comment"># 忽略node_modules，在控制台安装</span></span><br><span class="line">  <span class="comment"># src: # 在指定存储桶bucket中已经存在了object代码，直接部署</span></span><br><span class="line">  <span class="comment">#   bucket: bucket01 # bucket name，当前会默认在bucket name后增加 appid 后缀, 本例中为 bucket01-appid</span></span><br><span class="line">  <span class="comment">#   object: cos.zip  # bucket key 指定存储桶内的文件</span></span><br><span class="line"><span class="attr">  faas:</span> <span class="comment"># 函数配置相关</span></span><br><span class="line"><span class="attr">    runtime:</span> <span class="string">Nodejs12.16</span> <span class="comment"># 运行时</span></span><br><span class="line">    <span class="comment"># 支持的框架查看 https://cloud.tencent.com/document/product/1154/59447#framework</span></span><br><span class="line"><span class="attr">    framework:</span> <span class="string">nestjs</span> <span class="comment"># #选择框架，此处以 egg 为例 </span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">$&#123;name&#125;</span> <span class="comment"># 云函数名称，通过变量形式获取name的值</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">60</span> <span class="comment"># 超时时间，单位秒</span></span><br><span class="line"><span class="attr">    memorySize:</span> <span class="number">512</span> <span class="comment"># 内存大小，默认 512 MB</span></span><br><span class="line">    <span class="comment"># layers:</span></span><br><span class="line">    <span class="comment">#   - name: layerName #  layer名称</span></span><br><span class="line">    <span class="comment">#     version: 1 #  版本</span></span><br><span class="line"><span class="attr">    environments:</span> <span class="comment">#  配置环境变量，同时也可以直接在 scf 控制台配置 </span></span><br><span class="line"><span class="attr">        - key:</span> <span class="string">NODE_ENV</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">production</span></span><br><span class="line">    <span class="comment"># vpc: # 私有网络配置</span></span><br><span class="line">    <span class="comment">#   vpcId: 'vpc-xxx' # 私有网络的Id</span></span><br><span class="line">    <span class="comment">#   subnetId: 'subnet-xxx' # 子网ID</span></span><br><span class="line">    <span class="comment"># tags:</span></span><br><span class="line">    <span class="comment">#   - key: tagKey</span></span><br><span class="line">    <span class="comment">#     value: tagValue</span></span><br><span class="line"><span class="attr">  apigw:</span> <span class="comment"># http 组件会默认帮忙创建一个 API 网关服务</span></span><br><span class="line"><span class="attr">    isDisabled:</span> <span class="literal">false</span> <span class="comment"># 是否禁用自动创建 API 网关功能</span></span><br><span class="line">    <span class="comment"># id: service-xx # api网关服务ID，不填则自动新建网关</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">serverless</span> <span class="comment"># api网关服务名称</span></span><br><span class="line"><span class="attr">    api:</span> <span class="comment"># 创建的 API 相关配置</span></span><br><span class="line"><span class="attr">      cors:</span> <span class="literal">true</span> <span class="comment">#  允许跨域</span></span><br><span class="line"><span class="attr">      timeout:</span> <span class="number">30</span> <span class="comment"># API 超时时间</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">apiName</span> <span class="comment"># API 名称</span></span><br><span class="line"><span class="attr">      qualifier:</span> <span class="string">$DEFAULT</span> <span class="comment"># API 关联的版本</span></span><br><span class="line"><span class="attr">    protocols:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">http</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    environment:</span> <span class="string">test</span></span><br><span class="line">    <span class="comment"># tags:</span></span><br><span class="line">    <span class="comment">#   - key: tagKey</span></span><br><span class="line">    <span class="comment">#     value: tagValue</span></span><br><span class="line">    <span class="comment"># customDomains: # 自定义域名绑定</span></span><br><span class="line">    <span class="comment">#   - domain: abc.com # 待绑定的自定义的域名</span></span><br><span class="line">    <span class="comment">#     certId: abcdefg # 待绑定自定义域名的证书唯一 ID</span></span><br><span class="line">    <span class="comment">#     # 如要设置自定义路径映射，(customMap = true isDefaultMapping = false)必须两者同时出现 其余情况都是默认路径</span></span><br><span class="line">    <span class="comment">#     customMap: true</span></span><br><span class="line">    <span class="comment">#     isDefaultMapping: false</span></span><br><span class="line">    <span class="comment">#     # 自定义路径映射的路径。使用自定义映射时，可一次仅映射一个 path 到一个环境，也可映射多个 path 到多个环境。并且一旦使用自定义映射，原本的默认映射规则不再生效，只有自定义映射路径生效。</span></span><br><span class="line">    <span class="comment">#     pathMap:</span></span><br><span class="line">    <span class="comment">#       - path: /</span></span><br><span class="line">    <span class="comment">#         environment: release</span></span><br><span class="line">    <span class="comment">#     protocols: # 绑定自定义域名的协议类型，默认与服务的前端协议一致。</span></span><br><span class="line">    <span class="comment">#       - http # 支持http协议</span></span><br><span class="line">    <span class="comment">#       - https # 支持https协议</span></span><br><span class="line">    <span class="comment"># app: #  应用授权配置</span></span><br><span class="line">    <span class="comment">#   id: app-xxx</span></span><br><span class="line">    <span class="comment">#   name: app_demo</span></span><br><span class="line">    <span class="comment">#   description: app description</span></span><br></pre></td></tr></table></figure><p>在项目根目录下新建 <code>scf_bootstrap</code> 启动文件，在该文件添加如下内容（用于启动服务）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">SERVERLESS=1 /var/lang/node12/bin/node ./dist/main.js</span><br></pre></td></tr></table></figure><p>忽略<code>node_modules</code>文件上传</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># serverless.yml</span></span><br><span class="line"><span class="attr">exclude:</span> <span class="comment"># 被排除的文件或目录</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">.env</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules/**</span></span><br></pre></td></tr></table></figure><p>执行 <code>sls deploy</code> （<code>sls deploy --debug</code> 查看部署日志）</p><p><img src="https://s.poetries.work/uploads/2022/06/15d73875b2f56fd4.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/903af650eb01b169.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/a47a05e9bd8eb7c9.png" alt></p><p><strong>查看部署信息</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sls info</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/68b296819ee39d4f.png" alt></p><p><strong>实时开发并上传</strong></p><blockquote><p>每次改动文件，都实时部署</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sls dev</span><br></pre></td></tr></table></figure><p><strong>删除部署项目</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sls remove</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/1c33faad7da0be9c.png" alt></p><h3 id="使用Layer-来减小项目文件大小-1"><a href="#使用Layer-来减小项目文件大小-1" class="headerlink" title="使用Layer 来减小项目文件大小"></a>使用Layer 来减小项目文件大小</h3><p>随着项目复杂度的增加，<code>deploy</code> 上传会变慢。所以，让我们再优化一下，在项目根目录创建 <code>layer/serverless.yml</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># layer/serverless.yml</span></span><br><span class="line"><span class="comment"># https://cloud.tencent.com/document/product/1154/51133</span></span><br><span class="line"><span class="comment"># https://github.com/serverless-components/tencent-layer/blob/master/docs/configure.md</span></span><br><span class="line"></span><br><span class="line"><span class="attr">app:</span> <span class="string">nestjs-demo</span></span><br><span class="line"><span class="attr">stage:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">layer</span> <span class="comment"># 组件</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">nestjs-demo-layer</span> <span class="comment"># 层名称 必须</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组件参数配置，根据每个组件，实现具体的资源信息配置</span></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nestjs-demo-layer</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span></span><br><span class="line"><span class="attr">  src:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">../node_modules</span></span><br><span class="line"><span class="attr">    targetDir:</span> <span class="string">/node_modules</span></span><br><span class="line"><span class="attr">  runtimes:</span> <span class="comment"># 层支持的运行环境</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">Nodejs12.16</span></span><br><span class="line"><span class="attr">  description:</span> <span class="string">layer</span> <span class="string">description</span> <span class="comment"># 否 描述</span></span><br></pre></td></tr></table></figure><p><strong>修改以上项目下的serverless.yml加入层配置</strong></p><p>回到项目根目录，调整一下根目录的 <code>serverless.yml</code>下的<code>layers</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编写完善配置文件 serverless.yml</span></span><br><span class="line"><span class="comment"># https://github.com/serverless-components/tencent-http/blob/master/docs/configure.md</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">nestjs-demo</span> <span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">stage:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">http</span> <span class="comment"># http组件</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">http-nestjs</span> <span class="comment"># 实例名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  src:</span> <span class="comment"># 部署当前目录下的文件代码，并打包成zip上传到bucket上</span></span><br><span class="line"><span class="attr">    dist:</span> <span class="string">./</span> <span class="comment"># build后的包</span></span><br><span class="line"><span class="attr">    hook:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="comment"># 先构建在上传</span></span><br><span class="line"><span class="attr">    exclude:</span> <span class="comment"># 排除的文件</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">.env</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node_modules/**</span> <span class="comment"># deploy 时排除 node_modules [需要注意] 使用layer的node_modules</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./</span> <span class="comment"># 当前目录</span></span><br><span class="line"><span class="attr">  faas:</span> <span class="comment"># 函数配置相关</span></span><br><span class="line"><span class="attr">    runtime:</span> <span class="string">Nodejs12.16</span> <span class="comment"># 运行时</span></span><br><span class="line"><span class="attr">    framework:</span> <span class="string">nestjs</span> <span class="comment"># #选择框架，此处以 nestjs 为例 </span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">'$&#123;name&#125;'</span> <span class="comment"># 云函数名称，通过变量形式获取name的值</span></span><br><span class="line"><span class="attr">    eip:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">60</span> <span class="comment"># 超时时间，单位秒</span></span><br><span class="line"><span class="attr">    memorySize:</span> <span class="number">512</span> <span class="comment"># 内存大小，默认 512 MB</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">    environments:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">    layers:</span> <span class="comment"># 配置对应的 layer</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">$&#123;output:$&#123;stage&#125;:$&#123;app&#125;:nestjs-demo-layer.name&#125;</span> <span class="comment"># 配置对应的 layer</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">$&#123;output:$&#123;stage&#125;:$&#123;app&#125;:nestjs-demo-layer.version&#125;</span> <span class="comment"># 配置对应的 layer 版本</span></span><br><span class="line"><span class="attr">  apigw:</span></span><br><span class="line"><span class="attr">    protocols:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">http</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">    environment:</span> <span class="string">release</span></span><br><span class="line"><span class="attr">    customDomains:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span> <span class="comment"># 云函数所在区域</span></span><br><span class="line"><span class="attr">  isAutoCiDeploy:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>排除<code>node_modules</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">exclude:</span> <span class="comment"># 被排除的文件或目录</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">.env</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules/**</span> <span class="comment"># deploy 时排除 node_modules [需要注意] 使用layer的node_modules</span></span><br></pre></td></tr></table></figure><p>配置层</p><blockquote><p>引用格式请参考 变量引用说明 <a href="https://github.com/AprilJC/Serverless-Framework-Docs/blob/main/docs/%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8.md#%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">https://github.com/AprilJC/Serverless-Framework-Docs/blob/main/docs/%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8.md#%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8%E8%AF%B4%E6%98%8E</a></p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">layers:</span> <span class="comment"># 配置对应的 layer</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">$&#123;output:$&#123;stage&#125;:$&#123;app&#125;:nestjs-demo-layer.name&#125;</span> <span class="comment"># 配置对应的 layer</span></span><br><span class="line"><span class="attr">    version:</span> <span class="string">$&#123;output:$&#123;stage&#125;:$&#123;app&#125;:nestjs-demo-layer.version&#125;</span> <span class="comment"># 配置对应的 layer 版本</span></span><br></pre></td></tr></table></figure><p>通过配置层layer，代码和<code>node_modules</code>分离，<code>sls deploy</code>更快</p><blockquote><p>接着执行命令 <code>sls deploy --target=./layer</code>部署层，然后再次部署<code>sls deploy</code>看看速度应该更快了</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/b1a9175c8c6d1404.png" alt></p><p>每次<code>node_modules</code>改变都需要 </p><ul><li>执行 <code>sls deploy --target=./layer</code> 先部署层， 更新 <code>node_modules</code> 层</li><li>执行 <code>sls deploy</code> 重新部署</li></ul><p><strong>layer 的加载与访问</strong></p><blockquote><p>layer 会在函数运行时，将内容解压到 <code>/opt</code> 目录下，如果存在多个 <code>layer</code>，那么会按时间循序进行解压。如果需要访问 <code>layer</code> 内的文件，可以直接通过 <code>/opt/xxx</code> 访问。如果是访问 <code>node_module</code> 则可以直接 <code>import</code>，因为 <code>scf</code> 的 <code>NODE_PATH</code> 环境变量默认已包含 <code>/opt/node_modules</code> 路径。</p></blockquote><h3 id="使用serverless-framework的高阶nestjs组件部署-不推荐"><a href="#使用serverless-framework的高阶nestjs组件部署-不推荐" class="headerlink" title="使用serverless framework的高阶nestjs组件部署(不推荐)"></a>使用serverless framework的高阶nestjs组件部署(不推荐)</h3><blockquote><p>目前推荐使用 web 函数，也就是 <code>HTTP 组件</code>，现在所有的serverless web 应用都是基于 <code>component: http</code> 组件的。</p></blockquote><p><strong>初始化项目</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g @nestjs/cli</span><br><span class="line">nest new nest-app</span><br></pre></td></tr></table></figure><p>在根目录下，执行以下命令在本地直接启动服务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd nest-app &amp;&amp; npm run start</span><br></pre></td></tr></table></figure><p><strong>编写项目根目录下serverless.yml文件</strong></p><p><strong>全部配置详情</strong></p><blockquote><p><a href="https://github.com/serverless-components/tencent-nestjs/blob/master/docs/configure.md" target="_blank" rel="noopener">https://github.com/serverless-components/tencent-nestjs/blob/master/docs/configure.md</a></p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># serverless.yml</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">nestjs</span> <span class="comment"># (必选) 组件名称，在该实例中为nestjs</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">nest-demo</span> <span class="comment"># 必选) 组件实例名称.</span></span><br><span class="line"><span class="comment"># org: orgDemo # (可选) 用于记录组织信息，默认值为您的腾讯云账户 appid，必须为字符串</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">app-nest-demo</span> <span class="comment"># (可选) 用于记录组织信息. 默认与name相同，必须为字符串</span></span><br><span class="line"><span class="attr">stage:</span> <span class="string">dev</span> <span class="comment"># (可选) 用于区分环境信息，默认值是 dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span> <span class="comment"># 云函数所在区域</span></span><br><span class="line"><span class="attr">  functionName:</span> <span class="string">nest-demo</span> <span class="comment"># 云函数名称</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">nest-demo</span> <span class="comment"># api网关服务名称</span></span><br><span class="line"><span class="attr">  runtime:</span> <span class="string">Nodejs12.16</span> <span class="comment"># 运行环境</span></span><br><span class="line">  <span class="comment"># serviceId: service-jfdasew2112 # api网关服务ID 不填默认创建</span></span><br><span class="line">  <span class="comment"># entryFile: sls.js # 自定义 server 的入口文件名，默认为 sls.js，如果不想修改文件名为 sls.js 可以自定义</span></span><br><span class="line">  <span class="comment"># src: ./ # 第一种为string时，会打包src对应目录下的代码上传到默认cos上。</span></span><br><span class="line"><span class="attr">  src:</span>  <span class="comment"># 第二种，部署src下的文件代码，并打包成zip上传到bucket上</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./</span>  <span class="comment"># 本地需要打包的文件目录</span></span><br><span class="line">    <span class="comment"># bucket: bucket01 # bucket name，当前会默认在bucket name后增加 appid 后缀, 本例中为 bucket01-appid</span></span><br><span class="line"><span class="attr">    exclude:</span>   <span class="comment"># 被排除的文件或目录</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">.env</span></span><br><span class="line">      <span class="comment">#- "node_modules/**"</span></span><br><span class="line">  <span class="comment"># src: # 第三种，在指定存储桶bucket中已经存在了object代码，直接部署</span></span><br><span class="line">  <span class="comment">#   bucket: bucket01 # bucket name，当前会默认在bucket name后增加 appid 后缀, 本例中为 bucket01-appid</span></span><br><span class="line">  <span class="comment">#   object: cos.zip  # bucket key 指定存储桶内的文件</span></span><br><span class="line">  <span class="comment"># layers: </span></span><br><span class="line">    <span class="comment">#   - name: $&#123;output:$&#123;stage&#125;:$&#123;app&#125;:$&#123;name&#125;-layer.name&#125; # 配置对应的 layer</span></span><br><span class="line">    <span class="comment">#     version: $&#123;output:$&#123;stage&#125;:$&#123;app&#125;:$&#123;name&#125;-layer.version&#125; # 配置对应的 layer 版本</span></span><br><span class="line"><span class="attr">  functionConf:</span> <span class="comment"># 函数配置相关</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">60</span> <span class="comment"># 超时时间，单位秒</span></span><br><span class="line"><span class="attr">    eip:</span> <span class="literal">false</span> <span class="comment"># 是否固定出口IP</span></span><br><span class="line"><span class="attr">    memorySize:</span> <span class="number">512</span> <span class="comment"># 内存大小，单位MB</span></span><br><span class="line"><span class="attr">    environment:</span> <span class="comment">#  环境变量</span></span><br><span class="line"><span class="attr">      variables:</span> <span class="comment">#  环境变量数组</span></span><br><span class="line"><span class="attr">        NODE_ENV:</span> <span class="string">production</span></span><br><span class="line">    <span class="comment"># vpcConfig: # 私有网络配置</span></span><br><span class="line">      <span class="comment"># vpcId: '' # 私有网络的Id</span></span><br><span class="line">      <span class="comment"># subnetId: '' # 子网ID</span></span><br><span class="line"><span class="attr">  apigatewayConf:</span> <span class="comment">#  api网关配置</span></span><br><span class="line"><span class="attr">    isDisabled:</span> <span class="literal">false</span> <span class="comment"># 是否禁用自动创建 API 网关功能</span></span><br><span class="line"><span class="attr">    enableCORS:</span> <span class="literal">true</span> <span class="comment">#  允许跨域</span></span><br><span class="line">    <span class="comment"># customDomains: # 自定义域名绑定</span></span><br><span class="line">    <span class="comment">#   - domain: abc.com # 待绑定的自定义的域名</span></span><br><span class="line">    <span class="comment">#     certificateId: abcdefg # 待绑定自定义域名的证书唯一 ID</span></span><br><span class="line">    <span class="comment">#     # 如要设置自定义路径映射，请设置为 false</span></span><br><span class="line">    <span class="comment">#     isDefaultMapping: false</span></span><br><span class="line">    <span class="comment">#     # 自定义路径映射的路径。使用自定义映射时，可一次仅映射一个 path 到一个环境，也可映射多个 path 到多个环境。并且一旦使用自定义映射，原本的默认映射规则不再生效，只有自定义映射路径生效。</span></span><br><span class="line">    <span class="comment">#     pathMappingSet:</span></span><br><span class="line">    <span class="comment">#       - path: /</span></span><br><span class="line">    <span class="comment">#         environment: release</span></span><br><span class="line">    <span class="comment">#     protocols: # 绑定自定义域名的协议类型，默认与服务的前端协议一致。</span></span><br><span class="line">    <span class="comment">#       - http # 支持http协议</span></span><br><span class="line">    <span class="comment">#       - https # 支持https协议</span></span><br><span class="line"><span class="attr">    protocols:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">http</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    environment:</span> <span class="string">test</span> <span class="comment"># 网关环境</span></span><br><span class="line"><span class="attr">    serviceTimeout:</span> <span class="number">60</span> <span class="comment"># 网关超时</span></span><br><span class="line">    <span class="comment"># usagePlan: #  用户使用计划</span></span><br><span class="line">    <span class="comment">#   usagePlanId: 1111</span></span><br><span class="line">    <span class="comment">#   usagePlanName: slscmp</span></span><br><span class="line">    <span class="comment">#   usagePlanDesc: sls create</span></span><br><span class="line">    <span class="comment">#   maxRequestNum: 1000</span></span><br><span class="line">    <span class="comment"># auth: #  密钥</span></span><br><span class="line">    <span class="comment">#   secretName: secret</span></span><br><span class="line">    <span class="comment">#   secretIds:</span></span><br><span class="line">    <span class="comment">#     - xxx</span></span><br></pre></td></tr></table></figure><h2 id="3-5-sls部署koa项目"><a href="#3-5-sls部署koa项目" class="headerlink" title="3.5 sls部署koa项目"></a>3.5 sls部署koa项目</h2><h3 id="控制台部署"><a href="#控制台部署" class="headerlink" title="控制台部署"></a>控制台部署</h3><ol><li>登录 <a href="https://console.cloud.tencent.com/sls" target="_blank" rel="noopener">Serverless 应用控制台</a>。</li><li>单击新建应用，选择Web 应用&gt;Koa 框架，如下图所示：</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/6382481121ebc584.png" alt></p><ol start="3"><li>单击“下一步”，完成基础配置选择。</li><li>上传方式，选择示例代码直接部署，单击完成，即可开始应用的部署。</li><li>部署完成后，您可在应用详情页面，查看示例应用的基本信息，并通过 API 网关生成的访问路径 URL 进行访问，查看您部署的 Koa 项目</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/6ab832e2d0343c64.png" alt></p><h3 id="自定义模板部署"><a href="#自定义模板部署" class="headerlink" title="自定义模板部署"></a>自定义模板部署</h3><p>全局安装 <code>koa-generator</code> 脚手架.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g koa-generator</span><br></pre></td></tr></table></figure><p>创建项目</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用ejs引擎</span><br><span class="line">koa2 -e koa-demo</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd koa-demo // 进入项目根目录</span><br><span class="line">npm install // 安装项目依赖</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p><strong>部署上云</strong></p><p>接下来执行以下步骤，对已初始化的项目进行简单修改，使其可以通过 Web Function 快速部署，此处项目改造通常分为以下两步：</p><ul><li>修改监听地址与端口为 <code>0.0.0.0:9000</code>。</li></ul><p><strong>具体步骤如下：</strong></p><p>在 Koa 示例项目中，修改监听端口到 <code>9000</code></p><p><img src="https://s.poetries.work/uploads/2022/06/6be48886a199d8df.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/dd5fd8c12cb5d46a.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/f4edaeba5e1bd1f2.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/92152ad6865809d8.png" alt></p><h3 id="使用HTTP组件部署"><a href="#使用HTTP组件部署" class="headerlink" title="使用HTTP组件部署"></a>使用HTTP组件部署</h3><p><strong>编写serverless.yml</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文档 https://github.com/serverless-components/tencent-http/blob/master/docs/configure.md</span></span><br><span class="line"><span class="comment"># https://cloud.tencent.com/document/product/1154/59447</span></span><br><span class="line"><span class="comment"># org: '1258157827'</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">koa-demo</span></span><br><span class="line"><span class="attr">stage:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">http</span> <span class="comment"># http组件</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">koa-demo</span></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  src:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">    exclude:</span> <span class="comment"># 排除文件，在控制台WEBIDE开启自动安装依赖</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">.env</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span></span><br><span class="line"><span class="attr">  isAutoCiDeploy:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  faas:</span></span><br><span class="line"><span class="attr">    runtime:</span> <span class="string">Nodejs12.16</span></span><br><span class="line"><span class="attr">    eip:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">    memorySize:</span> <span class="number">512</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">    framework:</span> <span class="string">koa</span> <span class="comment"># koa框架</span></span><br><span class="line"><span class="attr">    environments:</span> <span class="string">[]</span></span><br><span class="line">    <span class="comment"># layers:</span></span><br><span class="line">    <span class="comment">#   - name: '$&#123;output:$&#123;stage&#125;:$&#123;app&#125;:koa-demo-layer.name&#125;'</span></span><br><span class="line">    <span class="comment">#     version: '$&#123;output:$&#123;stage&#125;:$&#123;app&#125;:koa-demo-layer.version&#125;'</span></span><br><span class="line"><span class="attr">  apigw:</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">    protocols:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">http</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    environment:</span> <span class="string">release</span></span><br><span class="line"><span class="attr">    customDomains:</span> <span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>项目根目录新增 scf_bootstrap 启动文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch scf_bootstrap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还需执行以下命令修改文件可执行权限，默认需要 777 或 755 权限才可正常启动</span></span><br><span class="line">chmod 777 scf_bootstrap</span><br></pre></td></tr></table></figure><blockquote><p>scf_bootstrap</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/var/lang/node12/bin/node bin/www <span class="comment"># 修改入口为bin/www，并且修改bin/www下端口为9000</span></span><br></pre></td></tr></table></figure><p><strong>部署</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sls deploy</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/74ac915db74d3dd6.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/34fceabfeb33c9e9.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/4dcbaf2dbb72cef4.png" alt></p><p><strong>查看部署信息</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sls info</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/80ed7651618d4bd1.png" alt></p><p><strong>移除</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sls remove</span><br></pre></td></tr></table></figure><h1 id="四、部署静态网站"><a href="#四、部署静态网站" class="headerlink" title="四、部署静态网站"></a>四、部署静态网站</h1><ul><li>全部配置 <a href="https://github.com/serverless-components/tencent-website/blob/master/docs/configure.md" target="_blank" rel="noopener">https://github.com/serverless-components/tencent-website/blob/master/docs/configure.md</a></li><li>部署文档 <a href="https://cloud.tencent.com/document/product/1154/39276" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/1154/39276</a></li></ul><blockquote><p>部署的静态资源会存储到COS中</p></blockquote><h2 id="4-1-sls部署vue项目"><a href="#4-1-sls部署vue项目" class="headerlink" title="4.1 sls部署vue项目"></a>4.1 sls部署vue项目</h2><p><strong>初始化项目</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init webpack vue-demo</span><br></pre></td></tr></table></figure><p><strong>编写serverless.yml</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/serverless-components/tencent-website/blob/master/docs/configure.md</span></span><br><span class="line"><span class="comment"># https://cloud.tencent.com/document/product/1154/39276</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">website</span> <span class="comment"># (必填) 引用 component 的名称，当前用到的是 tencent-website 组件</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">vue-demo</span> <span class="comment"># (必填) 该 website 组件创建的实例名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">app:</span> <span class="string">vue-demo</span> <span class="comment"># (可选) 该 website 应用名称</span></span><br><span class="line"><span class="attr">stage:</span> <span class="string">dev</span> <span class="comment"># (可选) 用于区分环境信息，默认值是 dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  src:</span></span><br><span class="line">    <span class="comment"># 部署项目的目录路径</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./</span> </span><br><span class="line"><span class="attr">    dist:</span> <span class="string">./dist</span> <span class="comment"># build 完成后输出目录，如果配置 hook， 此参数必填</span></span><br><span class="line"><span class="attr">    index:</span> <span class="string">index.html</span> <span class="comment"># 网站主页入口文件</span></span><br><span class="line"><span class="attr">    error:</span> <span class="number">404.</span><span class="string">html</span> <span class="comment"># 网站错误入口文件</span></span><br><span class="line"><span class="attr">    hook:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="comment">#  构建命令,在代码上传之前执行</span></span><br><span class="line">    <span class="comment"># websitePath: ./</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span></span><br><span class="line"><span class="attr">  bucketName:</span> <span class="string">vue-test-demo</span> <span class="comment"># OSS存储桶名称</span></span><br><span class="line"><span class="attr">  protocol:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">  replace:</span> <span class="literal">false</span> <span class="comment"># 是否覆盖式部署</span></span><br><span class="line"><span class="attr">  ignoreHtmlExt:</span> <span class="literal">false</span> <span class="comment"># 是否是否忽略 html 扩展名，默认 false</span></span><br><span class="line"><span class="attr">  disableErrorStatus:</span> <span class="literal">false</span> <span class="comment"># 是否禁用错误码，默认 false</span></span><br><span class="line"><span class="attr">  autoSetupAcl:</span> <span class="literal">true</span> <span class="comment"># 自动配置 bucket 访问权限为 ”公有读私有写“</span></span><br><span class="line"><span class="attr">  autoSetupPolicy:</span> <span class="literal">false</span> <span class="comment"># 自动配置 bucket 的 Policy 权限为 ”所有用户资源可读“</span></span><br><span class="line">  <span class="comment"># env: # 配置前端环境变量</span></span><br><span class="line">  <span class="comment">#   API_URL: https://api.com</span></span><br><span class="line">  <span class="comment"># hosts:</span></span><br><span class="line">  <span class="comment">#   - host: test.com # 自定义域名</span></span><br><span class="line">  <span class="comment">#     async: false # 是否同步等待 CDN 配置。配置为 false 时，参数 autoRefresh 自动刷新才会生效，如果关联多域名时，为防止超时建议配置为 true。</span></span><br><span class="line">  <span class="comment">#     autoRefresh: true #开启自动 CDN 刷新，用于快速更新和同步加速域名中展示的站点内容</span></span><br></pre></td></tr></table></figure><p>执行部署</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sls deploy</span><br></pre></td></tr></table></figure><blockquote><p>如果希望查看更多部署过程的信息，可以通过<code>sls deploy --debug</code> 命令查看部署过程中的实时日志信息</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/22914c1b39955760.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/84f4b895e0ef3e1a.png" alt></p><p><strong>开发调试</strong></p><blockquote><p>部署了静态网站应用后，可以通过开发调试能力对该项目进行二次开发，从而开发一个生产应用。在本地修改和更新代码后，不需要每次都运行 <code>serverless deploy</code> 命令来反复部署。您可以直接通过 <code>serverless dev</code> 命令对本地代码的改动进行检测和自动上传。</p></blockquote><ul><li>可以通过在 <code>serverless.yml</code> 文件所在的目录下运行 <code>serverless dev</code> 命令开启开发调试能力。</li><li><code>serverless dev</code> 同时支持实时输出云端日志，每次部署完毕后，对项目进行访问，即可在命令行中实时输出调用日志，便于查看业务情况和排障。</li></ul><p><strong>查看状态</strong></p><p>在<code>serverless.yml</code>文件所在的目录下，通过如下命令查看部署状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serverless info</span><br></pre></td></tr></table></figure><p><strong>移除</strong></p><p>在<code>serverless.yml</code>文件所在的目录下，通过以下命令移除部署的静态网站 <code>Website</code> 服务。移除后该组件会对应删除云上部署时所创建的所有相关资源。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ serverless remove</span><br></pre></td></tr></table></figure><blockquote><p>和部署类似，支持通过 <code>sls remove --debug</code> 命令查看移除过程中的实时日志信息</p></blockquote><h2 id="4-2-sls部署react项目"><a href="#4-2-sls部署react项目" class="headerlink" title="4.2 sls部署react项目"></a>4.2 sls部署react项目</h2><p><strong>初始化项目</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i create-umi -g</span><br><span class="line">create-umi react-demo</span><br></pre></td></tr></table></figure><p><strong>编写serverless.yml</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/serverless-components/tencent-website/blob/master/docs/configure.md</span></span><br><span class="line"><span class="comment"># https://cloud.tencent.com/document/product/1154/39276</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">website</span> <span class="comment"># (必填) 引用 component 的名称，当前用到的是 tencent-website 组件</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">react-demo</span> <span class="comment"># (必填) 该 website 组件创建的实例名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">app:</span> <span class="string">react-demo</span> <span class="comment"># (可选) 该 website 应用名称</span></span><br><span class="line"><span class="attr">stage:</span> <span class="string">dev</span> <span class="comment"># (可选) 用于区分环境信息，默认值是 dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  src:</span></span><br><span class="line">    <span class="comment"># 执行目录路径</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./</span> </span><br><span class="line"><span class="attr">    dist:</span> <span class="string">./dist</span> <span class="comment"># 部署目录路劲</span></span><br><span class="line"><span class="attr">    index:</span> <span class="string">index.html</span> <span class="comment"># 网站主页入口文件</span></span><br><span class="line"><span class="attr">    error:</span> <span class="number">404.</span><span class="string">html</span> <span class="comment"># 网站错误入口文件</span></span><br><span class="line"><span class="attr">    hook:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="comment">#  构建命令,在代码上传之前执行</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span></span><br><span class="line"><span class="attr">  bucketName:</span> <span class="string">react-test-demo</span> <span class="comment"># OSS存储桶名称</span></span><br><span class="line"><span class="attr">  protocol:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">  replace:</span> <span class="literal">false</span> <span class="comment"># 是否覆盖式部署</span></span><br><span class="line"><span class="attr">  ignoreHtmlExt:</span> <span class="literal">false</span> <span class="comment"># 是否是否忽略 html 扩展名，默认 false</span></span><br><span class="line"><span class="attr">  disableErrorStatus:</span> <span class="literal">false</span> <span class="comment"># 是否禁用错误码，默认 false</span></span><br><span class="line"><span class="attr">  autoSetupAcl:</span> <span class="literal">true</span> <span class="comment"># 自动配置 bucket 访问权限为 ”公有读私有写“</span></span><br><span class="line"><span class="attr">  autoSetupPolicy:</span> <span class="literal">false</span> <span class="comment"># 自动配置 bucket 的 Policy 权限为 ”所有用户资源可读“</span></span><br><span class="line">  <span class="comment"># env: # 配置前端环境变量</span></span><br><span class="line">  <span class="comment">#   API_URL: https://api.com</span></span><br><span class="line">  <span class="comment"># hosts:</span></span><br><span class="line">  <span class="comment">#   - host: test.com # 自定义域名</span></span><br><span class="line">  <span class="comment">#     async: false # 是否同步等待 CDN 配置。配置为 false 时，参数 autoRefresh 自动刷新才会生效，如果关联多域名时，为防止超时建议配置为 true。</span></span><br><span class="line">  <span class="comment">#     autoRefresh: true #开启自动 CDN 刷新，用于快速更新和同步加速域名中展示的站点内容</span></span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/8614efb6787a455f.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/4048c87e395ebe98.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/6aa33661c29780c8.png" alt></p><p>实时监控项目部署</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sls dev</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/a226acca0bb48bed.png" alt></p><h2 id="4-3-sls部署vuepress项目"><a href="#4-3-sls部署vuepress项目" class="headerlink" title="4.3 sls部署vuepress项目"></a>4.3 sls部署vuepress项目</h2><p><img src="https://s.poetries.work/uploads/2022/06/3e7f22a3df08fa4b.png" alt></p><p><strong>编写serverless.yml配置</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/serverless-components/tencent-website/blob/master/docs/configure.md</span></span><br><span class="line"><span class="comment"># https://cloud.tencent.com/document/product/1154/39276</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">website</span> <span class="comment"># (必填) 引用 component 的名称，当前用到的是 tencent-website 组件</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">vuepress-demo</span> <span class="comment"># (必填) 该 website 组件创建的实例名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">app:</span> <span class="string">vuepress-demo</span> <span class="comment"># (可选) 该 website 应用名称</span></span><br><span class="line"><span class="attr">stage:</span> <span class="string">dev</span> <span class="comment"># (可选) 用于区分环境信息，默认值是 dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  src:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">.vuepress</span> <span class="comment"># (必填) .vuepress源文件夹路径</span></span><br><span class="line"><span class="attr">    dist:</span> <span class="string">.vuepress/dist</span> <span class="comment"># 部署目录路径</span></span><br><span class="line"><span class="attr">    index:</span> <span class="string">index.html</span> <span class="comment"># 网站主页入口文件</span></span><br><span class="line"><span class="attr">    error:</span> <span class="number">404.</span><span class="string">html</span> <span class="comment"># 网站错误入口文件</span></span><br><span class="line"><span class="attr">    hook:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="comment">#  构建命令,在代码上传之前执行</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span></span><br><span class="line"><span class="attr">  bucketName:</span> <span class="string">vuepress-test-demo</span> <span class="comment"># OSS存储桶名称</span></span><br><span class="line"><span class="attr">  protocol:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">  replace:</span> <span class="literal">false</span> <span class="comment"># 是否覆盖式部署</span></span><br><span class="line"><span class="attr">  ignoreHtmlExt:</span> <span class="literal">false</span> <span class="comment"># 是否是否忽略 html 扩展名，默认 false</span></span><br><span class="line"><span class="attr">  disableErrorStatus:</span> <span class="literal">false</span> <span class="comment"># 是否禁用错误码，默认 false</span></span><br><span class="line"><span class="attr">  autoSetupAcl:</span> <span class="literal">true</span> <span class="comment"># 自动配置 bucket 访问权限为 ”公有读私有写“</span></span><br><span class="line"><span class="attr">  autoSetupPolicy:</span> <span class="literal">false</span> <span class="comment"># 自动配置 bucket 的 Policy 权限为 ”所有用户资源可读“</span></span><br><span class="line">  <span class="comment"># hosts:</span></span><br><span class="line">  <span class="comment">#   - host: test.com # 自定义域名</span></span><br><span class="line">  <span class="comment">#     async: false # 是否同步等待 CDN 配置。配置为 false 时，参数 autoRefresh 自动刷新才会生效，如果关联多域名时，为防止超时建议配置为 true。</span></span><br><span class="line">  <span class="comment">#     autoRefresh: true #开启自动 CDN 刷新，用于快速更新和同步加速域名中展示的站点内容</span></span><br></pre></td></tr></table></figure><p><strong>执行部署</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sls deploy</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/f150204a59359b6d.png" alt></p><p><strong>移除</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sls remove</span><br></pre></td></tr></table></figure><h1 id="五、综合实战"><a href="#五、综合实战" class="headerlink" title="五、综合实战"></a>五、综合实战</h1><h2 id="5-1-Serverless中使用Node操作Mysql、Mongodb数据库、以及配置VPC私有网络"><a href="#5-1-Serverless中使用Node操作Mysql、Mongodb数据库、以及配置VPC私有网络" class="headerlink" title="5.1 Serverless中使用Node操作Mysql、Mongodb数据库、以及配置VPC私有网络"></a>5.1 Serverless中使用Node操作Mysql、Mongodb数据库、以及配置VPC私有网络</h2><h3 id="云函数接入数据库"><a href="#云函数接入数据库" class="headerlink" title="云函数接入数据库"></a>云函数接入数据库</h3><blockquote><p>参考：<a href="https://cloud.tencent.com/document/product/583/51935" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/583/51935</a></p></blockquote><p><strong>注意</strong>：配置私有网络的服务器需要在同一个地区</p><p><img src="https://s.poetries.work/uploads/2022/07/1063776f916665ad.png" alt></p><h3 id="Nodejs-Serverless-中操作-Mysql"><a href="#Nodejs-Serverless-中操作-Mysql" class="headerlink" title="Nodejs Serverless 中操作 Mysql"></a>Nodejs Serverless 中操作 Mysql</h3><ul><li>准备工作：首先需要购买云数据库、或者自己在服务器上面搭建一个数据库</li><li>云函数操作 Mysql</li></ul><p><strong>购买云数据库mysql</strong></p><p><img src="https://s.poetries.work/uploads/2022/07/a32767996808f68f.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/07/ca2c192149944c02.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/07/fb6f3d7a624a73f6.png" alt></p><p><strong>新建mysql云函数</strong></p><p><img src="https://s.poetries.work/uploads/2022/07/968044649cbdbfee.png" alt></p><ul><li>选择和mysql同一个地域，程序之间通过VPC网络连接</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/e7285b3cba07f7bf.png" alt></p><ul><li>选择私有网络，和mysql所在网络一致</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/c31cd4d7d163bb89.png" alt><br><img src="https://s.poetries.work/uploads/2022/07/1d3382cca02d0f05.png" alt></p><p>如果没有需要新建私有网络，需要和msyql实例同一个地区，选择了新建的私有网络，mysql实例那边网络需要修改一致</p><p><img src="https://s.poetries.work/uploads/2022/07/e848fe3eabb20b49.png" alt><br><img src="https://s.poetries.work/uploads/2022/07/e5dfce33f28ac2f0.png" alt></p><ul><li>登录mysql数据库增加测试数据</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/765e9fdf679b9661.png" alt></p><p>新建test数据库</p><p><img src="https://s.poetries.work/uploads/2022/07/794bc6fe87c43f55.png" alt></p><p>创建user表</p><p><img src="https://s.poetries.work/uploads/2022/07/bc6c668125921773.png" alt></p><ul><li>修改云函数代码，保存部署即可</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/0ec0d7030a1a171a.png" alt></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************************</span></span><br><span class="line"><span class="comment">Node8.9-Mysql</span></span><br><span class="line"><span class="comment">Reference: mysql api---https://www.npmjs.com/package/mysql</span></span><br><span class="line"><span class="comment">Reference: How to access database---https://cloud.tencent.com/document/product/236/3130</span></span><br><span class="line"><span class="comment">Reference: How to connect api gateway with scf---https://cloud.tencent.com/document/product/628/11983</span></span><br><span class="line"><span class="comment">***************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapPromise</span>(<span class="params">connection, sql</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    connection.query(sql, <span class="function"><span class="keyword">function</span>(<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        rej(error)</span><br><span class="line">      &#125;</span><br><span class="line">      res(results)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exports.main_handler = <span class="keyword">async</span> (event, context, callback) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line">  <span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">    host: <span class="string">'167.16.0.17'</span>, <span class="comment">// The ip address of cloud database instance, 云数据库实例ip地址</span></span><br><span class="line">    user: <span class="string">'root'</span>, <span class="comment">// The name of cloud database, for example, root, 云数据库用户名，如root</span></span><br><span class="line">    password: <span class="string">'xx'</span>, <span class="comment">// Password of cloud database, 云数据库密码</span></span><br><span class="line">    database: <span class="string">'test'</span>, <span class="comment">// Name of the cloud database, 数据库名称</span></span><br><span class="line">    port: <span class="string">"3306"</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  connection.connect();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> querySql = <span class="string">`SELECT * from user`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> queryResult = <span class="keyword">await</span> wrapPromise(connection, querySql)</span><br><span class="line">  </span><br><span class="line">  connection.end();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> queryResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新部署</p><p><img src="https://s.poetries.work/uploads/2022/07/be2ad63b73cd90cb.png" alt></p><ul><li>创建API网关触发器，在浏览器中访问</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/4d25248bad953017.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/07/280e12f1381ad19b.png" alt></p><p>浏览器中访问查看效果</p><p><img src="https://s.poetries.work/uploads/2022/07/3bf2e7588ef4db51.png" alt></p><h3 id="Nodejs-Serverless-中操作-Mongodb"><a href="#Nodejs-Serverless-中操作-Mongodb" class="headerlink" title="Nodejs Serverless 中操作 Mongodb"></a>Nodejs Serverless 中操作 Mongodb</h3><ul><li>准备工作：首先需要购买云数据库、或者自己在服务器上面搭建一个数据库</li><li>云函数操作 Mongodb</li></ul><p><strong>购买MongoDB数据库</strong></p><p><img src="https://s.poetries.work/uploads/2022/07/88f6da606016085b.png" alt><br><img src="https://s.poetries.work/uploads/2022/07/81895e9b9ae7dac9.png" alt></p><p><strong>创建云函数</strong></p><p><img src="https://s.poetries.work/uploads/2022/07/ada2715770b68f92.png" alt></p><ul><li>选择地区</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/cdc6c87499019a46.png" alt></p><ul><li>选择私有网络，和mongodb所在网络一致</li></ul><p><img src="https://s.poetries.work/uploads/2022/07/cfdd4a0e3e82ee18.png" alt></p><ul><li>修改云函数代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;promisify&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="keyword">const</span> mongodb = <span class="built_in">require</span>(<span class="string">'mongodb'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mongoClient = mongodb.MongoClient,</span><br><span class="line">    assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> connect = promisify(mongodb.connect)</span><br><span class="line"></span><br><span class="line"><span class="comment">// URL combination</span></span><br><span class="line"><span class="comment">// var url = 'mongodb://mason_mongodb:mason12345@10.10.11.19:27017/admin';</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url=<span class="string">"mongodb://mongouser:password@10.0.0.13:27017,10.0.0.8:27017,10.0.0.11:27017/admin?authSource=admin&amp;replicaSet=cmgo-e23piswf_0"</span></span><br><span class="line"></span><br><span class="line">exports.main_handler = <span class="keyword">async</span> (event, context, callback) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start main handler'</span>)</span><br><span class="line">    <span class="keyword">const</span> MongoClient = <span class="built_in">require</span>(<span class="string">"mongodb"</span>).MongoClient;</span><br><span class="line">    <span class="keyword">const</span> mc = <span class="keyword">await</span> MongoClient.connect(url,&#123;<span class="attr">useNewUrlParser</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">    <span class="keyword">const</span> db = mc.db(<span class="string">'testdb'</span>) </span><br><span class="line">    <span class="keyword">const</span> collection = db.collection(<span class="string">'demoCol'</span>)</span><br><span class="line">    <span class="keyword">await</span> collection.insertOne(&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">something</span>:<span class="string">'你好 serverless'</span>&#125;)</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">as</span> = <span class="keyword">await</span> collection.find().toArray()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">as</span>)</span><br><span class="line"></span><br><span class="line">    mc.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">as</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建触发器</p><p><img src="https://s.poetries.work/uploads/2022/07/1da43f40efc683d6.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/07/5a8d14fb5d7417c0.png" alt></p><h2 id="5-2-Serverless-BaaS-对象云存储Cos介绍、Node操作Cos、实现图片上传到Cos中"><a href="#5-2-Serverless-BaaS-对象云存储Cos介绍、Node操作Cos、实现图片上传到Cos中" class="headerlink" title="5.2 Serverless BaaS 对象云存储Cos介绍、Node操作Cos、实现图片上传到Cos中"></a>5.2 Serverless BaaS 对象云存储Cos介绍、Node操作Cos、实现图片上传到Cos中</h2><h3 id="对象云存储-Cos-介绍"><a href="#对象云存储-Cos-介绍" class="headerlink" title="对象云存储 Cos 介绍"></a>对象云存储 Cos 介绍</h3><p>狭义的 Serverless 是指现阶段主流的技术实现：狭义的 Serverless 是 <code>FaaS</code> 和 <code>BaaS</code> 组成</p><p><img src="https://s.poetries.work/uploads/2022/07/396be7b44eb9dd81.png" alt></p><blockquote><p>对象存储（Cloud Object Storage，COS）是一种存储海量文件的分布式存储服务，具有高扩 展性、低成本、可靠安全等优点。通过控制台、API、SDK 和工具等多样化方式，用户可简 单、快速地接入 COS，进行多格式文件的上传、下载和管理，实现海量数据存储和管理。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/07/0fc384f78966e294.png" alt></p><h3 id="Nodejs-操作-Cos"><a href="#Nodejs-操作-Cos" class="headerlink" title="Nodejs 操作 Cos"></a>Nodejs 操作 Cos</h3><blockquote><p>参考官方文档：<a href="https://cloud.tencent.com/document/product/436/8629" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/436/8629</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm i cos-nodejs-sdk-v5 --save</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> COS = <span class="built_in">require</span>(<span class="string">'cos-nodejs-sdk-v5'</span>);</span><br><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置cos的sdk  https://console.cloud.tencent.com/cam/capi</span></span><br><span class="line"><span class="keyword">var</span> cos = <span class="keyword">new</span> COS(&#123;</span><br><span class="line">    SecretId: <span class="string">'xx'</span>,</span><br><span class="line">    SecretKey: <span class="string">'xx'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上传本地图片到对象云存储里面</span></span><br><span class="line">cos.putObject(&#123;</span><br><span class="line">    Bucket: <span class="string">'express-demo-1251179943'</span>, <span class="comment">/* 必须存储桶名称 */</span></span><br><span class="line">    Region: <span class="string">'ap-guangzhou'</span>,    <span class="comment">/* 必须 区域*/</span></span><br><span class="line">    Key: <span class="string">'a.png'</span>,              <span class="comment">/* 必须   目录/文件的名称  */</span></span><br><span class="line">    StorageClass: <span class="string">'STANDARD'</span>,</span><br><span class="line">    Body: fs.createReadStream(<span class="string">'./a.png'</span>), <span class="comment">// 上传文件对象</span></span><br><span class="line">    onProgress: <span class="function"><span class="keyword">function</span>(<span class="params">progressData</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(progressData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err || data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Express-在-Serverless-中实现图片上传到-Cos-中"><a href="#Express-在-Serverless-中实现图片上传到-Cos-中" class="headerlink" title="Express 在 Serverless 中实现图片上传到 Cos 中"></a>Express 在 Serverless 中实现图片上传到 Cos 中</h3><p>安装模块 multer <a href="https://github.com/expressjs/multer" target="_blank" rel="noopener">https://github.com/expressjs/multer</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save multer</span><br></pre></td></tr></table></figure><p>配置 form 表单</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- views/index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Serverless Component - Express.js<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/basic.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/doUpload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">      用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      头 像 : <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"face"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>配置内存存储引擎 (<code>MemoryStorage</code>)，内存存储引擎将文件存储在内存中的 <code>Buffer</code> 对象，它没有任何选项</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> storage = multer.memoryStorage()</span><br><span class="line"><span class="keyword">var</span> upload = multer(&#123; <span class="attr">storage</span>: storage &#125;)</span><br></pre></td></tr></table></figure><p>接收文件上传文件到云存储</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">"ejs"</span>);</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"><span class="keyword">var</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line"><span class="keyword">var</span> tools = <span class="built_in">require</span>(<span class="string">'./services/tools.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置上传</span></span><br><span class="line"><span class="keyword">var</span> storage = multer.memoryStorage();</span><br><span class="line"><span class="keyword">var</span> upload = multer(&#123; <span class="attr">storage</span>: storage &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置中间件</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置模板引擎</span></span><br><span class="line">app.engine(<span class="string">"html"</span>, ejs.__express)</span><br><span class="line">app.set(<span class="string">"view engine"</span>, <span class="string">"html"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//会对指定类型进行 Base64 编码</span></span><br><span class="line">app.binaryTypes = [<span class="string">'*/*'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态web服务</span></span><br><span class="line">app.use(express.static(<span class="string">"public"</span>));</span><br><span class="line"><span class="comment">// Routes</span></span><br><span class="line">app.get(<span class="string">`/`</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.render(<span class="string">"index"</span>, &#123;</span><br><span class="line">    title: <span class="string">"你好serverless"</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：https://github.com/serverless-components/tencent-koa/blob/master/docs/upload.md</span></span><br><span class="line">app.post(<span class="string">`/doUpload`</span>, upload.single(<span class="string">"face"</span>), <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.body);</span><br><span class="line">  <span class="built_in">console</span>.log(req.file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//上传本地图片到对象云存储里面   注意异步</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> tools.uploadCos(req.file.originalname, req.file.buffer)</span><br><span class="line"></span><br><span class="line">  res.send(&#123;</span><br><span class="line">    body: req.body,</span><br><span class="line">    result: result</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Error handler</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">  res.status(<span class="number">500</span>).send(<span class="string">'Internal Serverless Error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// services/tools.js</span></span><br><span class="line"><span class="keyword">const</span> COS = <span class="built_in">require</span>(<span class="string">'cos-nodejs-sdk-v5'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">  uploadCos(filename,source)&#123;</span><br><span class="line">    <span class="keyword">let</span> cos = <span class="keyword">new</span> COS(&#123;</span><br><span class="line">      SecretId: <span class="string">'xx'</span>,</span><br><span class="line">      SecretKey: <span class="string">'xx'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      cos.putObject(&#123;</span><br><span class="line">        Bucket: <span class="string">'test-xx'</span>, <span class="comment">/* 必须 */</span></span><br><span class="line">        Region: <span class="string">'ap-beijing'</span>,    <span class="comment">/* 必须 */</span></span><br><span class="line">        Key: <span class="string">'test/'</span> + filename,              <span class="comment">/* 必须 test为目录名称 */</span></span><br><span class="line">        StorageClass: <span class="string">'STANDARD'</span>,</span><br><span class="line">        Body: source, <span class="comment">// 上传文件对象</span></span><br><span class="line">        onProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressData</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(progressData));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(err)&#123;</span><br><span class="line">              reject(err);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              reslove(data);</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上传文件需要注意</strong></p><blockquote><p><a href="https://github.com/serverless-components/tencent-koa/blob/master/docs/upload.md" target="_blank" rel="noopener">https://github.com/serverless-components/tencent-koa/blob/master/docs/upload.md</a></p></blockquote><p><img src="https://s.poetries.work/uploads/2022/07/d959441445eecfb5.png" alt></p><p>修改<code>serverless.yml</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">app:</span> <span class="string">appDemo</span></span><br><span class="line"><span class="attr">stage:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">koa</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">koaDemo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line">  <span class="comment"># 省略...</span></span><br><span class="line"><span class="attr">  apigatewayConf:</span></span><br><span class="line"><span class="attr">    isBase64Encoded:</span> <span class="literal">true</span> <span class="comment"># 需要加上，否则上传图片到cos预览有问题</span></span><br><span class="line">    <span class="comment"># 省略...</span></span><br><span class="line">  <span class="comment"># 省略...</span></span><br></pre></td></tr></table></figure><p><strong>完整serverless.yml</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">app:</span> <span class="string">expressdemo</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">express</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">expressDemo</span></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  runtime:</span> <span class="string">Nodejs10.15</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span></span><br><span class="line"><span class="attr">  src:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">    exclude:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">.env</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">.git</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">  apigatewayConf:</span></span><br><span class="line"><span class="attr">    enableCORS:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    isBase64Encoded:</span> <span class="literal">true</span> <span class="comment"># 需要加上，否则上传图片到cos预览有问题</span></span><br><span class="line"><span class="attr">    protocols:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">http</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    environment:</span> <span class="string">release</span></span><br></pre></td></tr></table></figure><p>部署，然后在webIDE开启自动安装依赖 </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sls deploy</span><br></pre></td></tr></table></figure><h2 id="5-3-Serverless、Cos中配置域名访问以及Serverless中配置https访问"><a href="#5-3-Serverless、Cos中配置域名访问以及Serverless中配置https访问" class="headerlink" title="5.3 Serverless、Cos中配置域名访问以及Serverless中配置https访问"></a>5.3 Serverless、Cos中配置域名访问以及Serverless中配置https访问</h2><h3 id="Serverless-中配置域名访问"><a href="#Serverless-中配置域名访问" class="headerlink" title="Serverless 中配置域名访问"></a>Serverless 中配置域名访问</h3><p>找到云函数对应的 api 网关</p><p><img src="https://s.poetries.work/uploads/2022/07/7c53c0ead5e166f7.png" alt></p><p>编辑 api 网关 点击域名管理</p><p><img src="https://s.poetries.work/uploads/2022/07/fa2e097f55e8460b.png" alt></p><p>新建域名</p><p><img src="https://s.poetries.work/uploads/2022/07/9f4acfb1d41d15ec.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/07/cbc5cd59595597bc.png" alt></p><p>解析域名</p><p><img src="https://s.poetries.work/uploads/2022/07/c2dc26b03c9b36be.png" alt></p><h3 id="Serverless-中配置-https-访问"><a href="#Serverless-中配置-https-访问" class="headerlink" title="Serverless 中配置 https 访问"></a>Serverless 中配置 https 访问</h3><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。 </p><p>HTTPS 是在 HTTP 的基础上添加了安全层，从原来的明文传输变成密文传输，当然加密与解 密是需要一些时间代价与开销的，不完全统计有 10 倍的差异。</p><blockquote><p>在当下的网络环境下可以忽 略不计，已经成为一种必然趋势。 目前微信小程序请求 Api 必须用 https、Ios 请求 api 接口必须用 https</p></blockquote><p><strong>https 证书类型</strong></p><ul><li>域名型 https 证书（DVSSL）：信任等级一般，只需验证网站的真实性便可颁发证书保护网站</li><li>企业型 https 证书（OVSSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高</li><li>增强型 https 证书（EVSSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高， 同时可以激活绿色网址栏</li></ul><p><strong>创建证书</strong></p><p><img src="https://s.poetries.work/uploads/2022/07/c0bd93006ea724cd.png" alt></p><p>选择证书</p><p><img src="https://s.poetries.work/uploads/2022/07/c7ecd5414acc9881.png" alt></p><h3 id="Cos-中配置域名"><a href="#Cos-中配置域名" class="headerlink" title="Cos 中配置域名"></a>Cos 中配置域名</h3><p>配置域名</p><p><img src="https://s.poetries.work/uploads/2022/07/565fff50504ea193.png" alt></p><p>域名解析</p><p><img src="https://s.poetries.work/uploads/2022/07/08646a66aeb4c8fb.png" alt></p><h1 id="六、QA"><a href="#六、QA" class="headerlink" title="六、QA"></a>六、QA</h1><h2 id="scf-bootstrap启动文件与sls-js启动文件区别"><a href="#scf-bootstrap启动文件与sls-js启动文件区别" class="headerlink" title="scf_bootstrap启动文件与sls.js启动文件区别"></a>scf_bootstrap启动文件与sls.js启动文件区别</h2><p><img src="https://s.poetries.work/uploads/2022/06/c70fc14a6975b58d.png" alt></p><ul><li><code>scf_bootstrap</code> 文件是针对 <code>web</code> 函数的，</li><li><code>sls.js</code> 入口文件是针对事件函数，主要是 <code>serverless</code> 封装了一些开源框架，改造的入口文件。</li></ul><h2 id="关于serverless-yml写法问题，是更推荐HTTP组件方式吗"><a href="#关于serverless-yml写法问题，是更推荐HTTP组件方式吗" class="headerlink" title="关于serverless.yml写法问题，是更推荐HTTP组件方式吗"></a>关于serverless.yml写法问题，是更推荐HTTP组件方式吗</h2><p><img src="https://s.poetries.work/uploads/2022/06/bf28a299163edd25.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/73dd2079f12bc9e2.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/2fd1b2033733a2f9.png" alt></p><blockquote><p>目前推荐使用 web 函数，也就是 <code>HTTP 组件</code>，现在所有的serverless web 应用都是基于 <code>component: http</code> 组件的。</p></blockquote><h2 id="关于配额问题如何处理"><a href="#关于配额问题如何处理" class="headerlink" title="关于配额问题如何处理"></a>关于配额问题如何处理</h2><p>云函数 scf 针对每个用户帐号，均有一定的配额限制：</p><p><img src="https://s.poetries.work/uploads/2022/06/a75c8ba81b1830ac.png" alt></p><blockquote><p>其中需要重点关注的就是单个函数代码体积 <code>500mb</code> 的上限。在实际操作中，云函数虽然提供了 <code>500mb</code>。但也存在着一个 <code>deploy</code> 解压上限。</p></blockquote><p><strong>关于绕过配额问题：</strong></p><ul><li>如果超的不多，那么使用 <code>npm install --production</code> 就能解决问题</li><li>如果超的太多，那就通过挂载 <code>cfs</code> 文件系统来进行规避（<a href="https://zhuanlan.zhihu.com/p/218803108?utm_source=wechat_session" target="_blank" rel="noopener">参考文章</a>）</li></ul><h1 id="七、官方文档"><a href="#七、官方文档" class="headerlink" title="七、官方文档"></a>七、官方文档</h1><ul><li><a href="https://cloud.tencent.com/document/product/1154/59447" target="_blank" rel="noopener">serverless官方应用中心文档</a></li><li><a href="https://cn.serverless.com/framework/docs" target="_blank" rel="noopener">serverless帮助文档</a></li><li><a href="https://github.com/serverless-components" target="_blank" rel="noopener">Serverless Components Github主页</a></li><li><a href="https://github.com/serverless-components/tencent-framework-components" target="_blank" rel="noopener">serverless-components/tencent-framework-components</a></li><li><a href="https://github.com/serverless-components/tencent-nestjs" target="_blank" rel="noopener">serverless-components/tencent-nestjs</a></li><li><a href="https://github.com/serverless-components/tencent-egg" target="_blank" rel="noopener">serverless-components/tencent-egg</a></li><li><a href="https://github.com/serverless-components/tencent-http" target="_blank" rel="noopener">serverless-components/tencent-http</a></li><li><a href="https://github.com/serverless/serverless-tencent/issues" target="_blank" rel="noopener">serverless 官方bug提交</a></li><li><a href="https://github.com/serverless/serverless-tencent/discussions" target="_blank" rel="noopener">serverless 官方社区文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、serverless架构介绍及安装serverless&quot;&gt;&lt;a href=&quot;#一、serverless架构介绍及安装serverless&quot; class=&quot;headerlink&quot; title=&quot;一、serverless架构介绍及安装serverless&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="部署" scheme="http://blog.poetries.top/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="serverless" scheme="http://blog.poetries.top/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose/微信云托管/serverless之部署Nestjs项目</title>
    <link href="http://blog.poetries.top/2022/06/17/nest-deploy-summary/"/>
    <id>http://blog.poetries.top/2022/06/17/nest-deploy-summary/</id>
    <published>2022-06-17T14:40:24.000Z</published>
    <updated>2025-03-30T13:54:29.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、云服务器docker-compose部署"><a href="#一、云服务器docker-compose部署" class="headerlink" title="一、云服务器docker-compose部署"></a>一、云服务器docker-compose部署</h2><h3 id="安装docker环境"><a href="#安装docker环境" class="headerlink" title="安装docker环境"></a>安装docker环境</h3><h4 id="安装工具包"><a href="#安装工具包" class="headerlink" title="安装工具包"></a>安装工具包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install yum-utils device-mapper-persistent-data lvm2 -y</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/e0f4f8f2621b11c0.png" alt></p><h4 id="设置阿里镜像源"><a href="#设置阿里镜像源" class="headerlink" title="设置阿里镜像源"></a>设置阿里镜像源</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/0b017f9a76914c6e.png" alt></p><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br></pre></td></tr></table></figure><h4 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机启动</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h4 id="设置docker镜像源"><a href="#设置docker镜像源" class="headerlink" title="设置docker镜像源"></a>设置docker镜像源</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://register.docker-cn.com/"</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续拉取镜像直接从 <a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> 网站拉取速度更快</p><p><strong>重启docker</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h4 id="安装mysql镜像测试"><a href="#安装mysql镜像测试" class="headerlink" title="安装mysql镜像测试"></a>安装mysql镜像测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull daocloud.io/library/mysql:8.0.20</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/dad88a1878a7a12f.png" alt></p><p><strong>运行mysql镜像</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3307:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456(设置登录密码) be0dbf01a0f3(镜像ID)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/fb606d9823c4f0ff.png" alt></p><p><strong>进入mysql容器内部</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/3a9f7618e1baf34f.png" alt></p><blockquote><p>至此mysql镜像搭建成功，下面我们使用<code>docker-compose</code>来管理docker容器，不在单独一个个安装MySQL、redis、nginx</p></blockquote><h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用国内源安装</span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p><strong>设置docker-compose执行权限</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p><strong>创建软链</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p><strong>测试是否安装成功：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line"></span><br><span class="line">docker-compose version 1.22.0, build f46880fe</span><br></pre></td></tr></table></figure><h3 id="编写docker-compose"><a href="#编写docker-compose" class="headerlink" title="编写docker-compose"></a>编写docker-compose</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.0"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="comment"># docker容器启动的redis默认是没有redis.conf的配置文件，所以用docker启动redis之前，需要先去官网下载redis.conf的配置文件</span></span><br><span class="line"><span class="attr">    redis:</span> <span class="comment"># 服务名称</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">redis</span> <span class="comment"># 容器名称</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">daocloud.io/library/redis:6.0.3-alpine3.11</span> <span class="comment"># 使用官方镜像</span></span><br><span class="line">        <span class="comment"># 配置redis.conf方式启动</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">redis-server</span> <span class="string">/usr/local/etc/redis/redis.conf</span> <span class="bullet">--requirepass</span> <span class="number">123456</span> <span class="bullet">--appendonly</span> <span class="literal">yes</span> <span class="comment"># 设置redis登录密码 123456、--appendonly yes：这个命令是用于开启redis数据持久化</span></span><br><span class="line">        <span class="comment"># 无需配置文件方式启动</span></span><br><span class="line">        <span class="comment"># command: redis-server --requirepass 123456 --appendonly yes # 设置redis登录密码 123456</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="number">6380</span><span class="string">:6379</span> <span class="comment"># 本机端口:容器端口</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">on-failure</span> <span class="comment"># 自动重启</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/redis/db:/data</span> <span class="comment"># 把持久化数据挂载到宿主机</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf</span>  <span class="comment"># 把redis的配置文件挂载到宿主机</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/redis/logs:/logs</span> <span class="comment"># 用来存放日志</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">TZ=Asia/Shanghai</span>  <span class="comment"># 解决容器 时区的问题</span></span><br><span class="line"><span class="attr">        networks:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">my-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    mysql:</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">daocloud.io/library/mysql:8.0.20</span> <span class="comment"># 使用官方镜像</span></span><br><span class="line"><span class="attr">        ports:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="number">3307</span><span class="string">:3306</span> <span class="comment"># 本机端口:容器端口</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">        environment:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">MYSQL_ROOT_PASSWORD=993412</span> <span class="comment"># root用户密码</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/mysql/db:/var/lib/mysql</span> <span class="comment"># 用来存放了数据库表文件</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/mysql/conf/my.cnf:/etc/my.cnf</span> <span class="comment"># 存放自定义的配置文件</span></span><br><span class="line">            <span class="comment"># 我们在启动MySQL容器时自动创建我们需要的数据库和表</span></span><br><span class="line">            <span class="comment"># mysql官方镜像中提供了容器启动时自动docker-entrypoint-initdb.d下的脚本的功能</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/mysql/init:/docker-entrypoint-initdb.d/</span> <span class="comment"># 存放初始化的脚本</span></span><br><span class="line"><span class="attr">        networks:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">my-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    server:</span> <span class="comment"># egg服务</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">        build:</span> <span class="comment"># 根据Dockerfile构建镜像</span></span><br><span class="line"><span class="attr">            context:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">            dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">        ports:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="number">9000</span><span class="string">:9000</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">on-failure</span> <span class="comment"># 设置自动重启，这一步必须设置，主要是存在mysql还没有启动完成就启动了node服务</span></span><br><span class="line"><span class="attr">        networks:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">my-server</span></span><br><span class="line"><span class="attr">        depends_on:</span> <span class="comment"># node服务依赖于mysql和redis</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">redis</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一下网桥  my-server。</span></span><br><span class="line"><span class="comment"># 重要：将所有服务都挂载在同一网桥即可通过容器名来互相通信了</span></span><br><span class="line"><span class="comment"># 如egg连接mysql和redis，可以通过容器名来互相通信</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">    my-server:</span></span><br></pre></td></tr></table></figure><h3 id="nestjs-Dockerfile"><a href="#nestjs-Dockerfile" class="headerlink" title="nestjs/Dockerfile"></a>nestjs/Dockerfile</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">daocloud.io/library/node:14.7.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">TZ=Asia/Shanghai</span> <span class="string">\</span></span><br><span class="line">    <span class="string">DEBIAN_FRONTEND=noninteractive</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">ln</span> <span class="bullet">-fs</span> <span class="string">/usr/share/zoneinfo/$&#123;TZ&#125;</span> <span class="string">/etc/localtime</span> <span class="string">&amp;&amp;</span> <span class="string">echo</span> <span class="string">$&#123;TZ&#125;</span> <span class="string">&gt; /etc/timezone &amp;&amp; dpkg-reconfigure --frontend noninteractive tzdata &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 创建工作目录</span></span><br><span class="line"><span class="string">RUN mkdir -p /app</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 指定工作目录</span></span><br><span class="line"><span class="string">WORKDIR /app</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 复制当前代码到/app工作目录</span></span><br><span class="line"><span class="string">COPY . ./</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># npm 源，选用国内镜像源以提高下载速度</span></span><br><span class="line"><span class="string"># RUN npm config set registry https://registry.npm.taobao.org/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># npm 安装依赖</span></span><br><span class="line"><span class="string">RUN npm install </span></span><br><span class="line"><span class="string"># 打包</span></span><br><span class="line"><span class="string">RUN npm run build</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 启动服务</span></span><br><span class="line"><span class="string"># "start:prod": "cross-env NODE_ENV=production node ./dist/src/main.js",</span></span><br><span class="line"><span class="string">CMD npm run start:prod</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EXPOSE 9000</span></span><br></pre></td></tr></table></figure><h3 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h3><p><img src="https://s.poetries.work/uploads/2022/06/2827b63a2e6f0f0d.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/1c61fcd0896b6cf7.png" alt></p><h3 id="开放云服务器端口"><a href="#开放云服务器端口" class="headerlink" title="开放云服务器端口"></a>开放云服务器端口</h3><blockquote><p>开放端口9000、6380、3307</p></blockquote><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><blockquote><p><code>docker-compose -h</code> 查看命令</p></blockquote><ul><li><code>docker-compose up</code> 启动服务，控制台可见日志</li><li><code>docker-compose up -d</code> 后台启动服务</li><li><code>docker-compose build --no-cache</code> 重新构建镜像不使用缓存(最后<code>docker-compose up -d</code>启动)</li><li>停止服务 <code>docker-compose down</code></li><li>下载镜像过程 <code>docker-compose pull</code></li><li>重启服务 <code>docker-compose restart</code></li></ul><p>后台启动服务 <code>docker-compose up -d</code></p><p><img src="https://s.poetries.work/uploads/2022/06/c25e29446892db10.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/256b13bf9feaaf58.png" alt></p><p><strong>测试</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/9cdd8f0acb5d3dcb.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/3dc4c4f36e6312e1.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/5f5872e59b2223d1.png" alt></p><h2 id="二、微信云托管部署"><a href="#二、微信云托管部署" class="headerlink" title="二、微信云托管部署"></a>二、微信云托管部署</h2><blockquote><p>云托管流水线部署更方便</p></blockquote><h3 id="redis服务"><a href="#redis服务" class="headerlink" title="redis服务"></a>redis服务</h3><p>这里我们上面部署使用的自建服务器上docker搭建的redis服务作为演示</p><p><img src="https://s.poetries.work/uploads/2022/06/c74e6e89043a20d6.png" alt></p><h3 id="mysql服务"><a href="#mysql服务" class="headerlink" title="mysql服务"></a>mysql服务</h3><p>这里我们上面部署使用的自建服务器上docker搭建的mysql服务作为演示</p><p><img src="https://s.poetries.work/uploads/2022/06/1e17df55d9c3634f.png" alt></p><h3 id="修改代码-1"><a href="#修改代码-1" class="headerlink" title="修改代码"></a>修改代码</h3><p><img src="https://s.poetries.work/uploads/2022/06/39bc4b170e313188.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/a9b9c54861994788.png" alt></p><p>然后上传代码到github，通过云托管流水线构建</p><h3 id="新建服务"><a href="#新建服务" class="headerlink" title="新建服务"></a>新建服务</h3><p><img src="https://s.poetries.work/uploads/2022/06/d867bed19eb7d9ed.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/a94985c89c5a77d0.png" alt></p><p>点击发布后，云托管会执行Dockerfile构建流水线，到日志可以查看构建进度</p><p><img src="https://s.poetries.work/uploads/2022/06/28c702aebeea51f1.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/e381ee973e6b0128.png" alt></p><p><strong>微信云托管部署成功后，可以在实例列表，点击进入容器看到代码</strong>，这里里面的内容不能修改，在容器启动后会覆盖</p><p><img src="https://s.poetries.work/uploads/2022/06/f29ea9c2ac74fac7.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/a4a8d047a18b8846.png" alt></p><h3 id="调试接口"><a href="#调试接口" class="headerlink" title="调试接口"></a>调试接口</h3><p><img src="https://s.poetries.work/uploads/2022/06/c4c5c0161d3a9b2b.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/71e72ba06d6335db.png" alt></p><p>测试redis</p><p><img src="https://s.poetries.work/uploads/2022/06/e6aed26d47dea7f0.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/08a1d6894d2178ab.png" alt></p><h2 id="三、腾讯云serverless部署"><a href="#三、腾讯云serverless部署" class="headerlink" title="三、腾讯云serverless部署"></a>三、腾讯云serverless部署</h2><p>需要注意，云函数的代码包不能超过500M</p><p><img src="https://s.poetries.work/uploads/2022/06/41b9fcbf9242921f.png" alt></p><h3 id="模板部署-–-部署-Nest-js-示例代码"><a href="#模板部署-–-部署-Nest-js-示例代码" class="headerlink" title="模板部署 – 部署 Nest.js 示例代码"></a>模板部署 – 部署 Nest.js 示例代码</h3><ol><li>登录 <a href="https://console.cloud.tencent.com/sls" target="_blank" rel="noopener">Serverless 应用控制台</a>。</li><li>单击新建应用，选择Web 应用&gt;Nest.js 框架，如下图所示：</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/c05fcae4ea2a8593.png" alt></p><ol start="3"><li>单击“下一步”，完成基础配置选择</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/c23d3219be7ab860.png" alt></p><ul><li>上传方式，选择示例代码直接部署，单击完成，即可开始应用的部署。</li><li>部署完成后，您可在应用详情页面，查看示例应用的基本信息，并通过 API 网关生成的访问路径 URL 进行访问，查看您部署的 Nest.js 项目</li></ul><p><img src="https://s.poetries.work/uploads/2022/06/60f6e95248310f40.png" alt></p><h3 id="自定义部署nest"><a href="#自定义部署nest" class="headerlink" title="自定义部署nest"></a>自定义部署nest</h3><p><strong>初始化您的 Nest.js 项目</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g @nestjs/cli</span><br><span class="line">nest new nest-app</span><br></pre></td></tr></table></figure><p>在根目录下，执行以下命令在本地直接启动服务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd nest-app &amp;&amp; npm run start</span><br></pre></td></tr></table></figure><p>打开浏览器访问 <a href="http://localhost:3000，即可在本地完成" target="_blank" rel="noopener">http://localhost:3000，即可在本地完成</a> Nest.js 示例项目的访问。</p><p><strong>部署上云</strong></p><p>接下来执行以下步骤，对已初始化的项目进行简单修改，使其可以通过 Web Function 快速部署，此处项目改造通常分为以下两步：</p><ul><li>新增 <code>scf_bootstrap</code> 启动文件。</li><li>修改监听地址与端口为 <code>0.0.0.0:9000</code>。</li></ul><ol><li>修改启动文件<code>main.ts</code>，监听端口改为<code>9000</code>:</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/12736ad9dda9b911.png" alt></p><ol start="2"><li>在项目根目录下新建 <code>scf_bootstrap</code> 启动文件，在该文件添加如下内容（用于启动服务）：</li></ol><p>您也可以在控制台完成该模块配置。</p><p><img src="https://s.poetries.work/uploads/2022/06/9a96d63935762fc3.png" alt></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scf_bootstrap</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">SERVERLESS=1 /var/lang/node12/bin/node ./dist/main.js</span><br></pre></td></tr></table></figure><p>新建完成后，还需执行以下命令修改文件可执行权限，默认需要 777 或 755 权限才可正常启动。示例如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 scf_bootstrap</span><br></pre></td></tr></table></figure><p>本地配置完成后，执行启动文件，确保您的服务可以本地正常启动，接下来，登录 Serverless 应用控制台，选择Web 应用&gt;Nest.js 框架，上传方式可以选择本地上传或代码仓库拉取</p><blockquote><p>注意：启动文件以项目内文件为准，如果您的项目里已经包含 scf_bootstrap 文件，将不会覆盖该内容。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/c1fe93fe050d5f5c.png" alt></p><blockquote><p>单个函数代码体积 500mb 的上限。在实际操作中，云函数虽然提供了 500mb</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/d74ceea7780a3f9d.png" alt></p><p><strong>关于绕过配额问题：</strong></p><p>如果超的不多，那么使用 <code>npm install --production</code> 就能解决问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、云服务器docker-compose部署&quot;&gt;&lt;a href=&quot;#一、云服务器docker-compose部署&quot; class=&quot;headerlink&quot; title=&quot;一、云服务器docker-compose部署&quot;&gt;&lt;/a&gt;一、云服务器docker-compose
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="部署" scheme="http://blog.poetries.top/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="Nest" scheme="http://blog.poetries.top/tags/Nest/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose/微信云托管/serverless之部署Egg项目</title>
    <link href="http://blog.poetries.top/2022/06/17/egg-deploy-summary/"/>
    <id>http://blog.poetries.top/2022/06/17/egg-deploy-summary/</id>
    <published>2022-06-17T14:35:24.000Z</published>
    <updated>2025-03-30T13:54:29.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、本地docker环境搭建"><a href="#一、本地docker环境搭建" class="headerlink" title="一、本地docker环境搭建"></a>一、本地docker环境搭建</h1><p>mac下安装docker: <code>brew install docker</code></p><blockquote><p><a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> 拉取镜像速度比较慢，我们推荐使用国内的镜像源访问速度较快 <a href="https://hub.daocloud.io" target="_blank" rel="noopener">https://hub.daocloud.io</a></p></blockquote><h2 id="1-1-设置国内镜像源"><a href="#1-1-设置国内镜像源" class="headerlink" title="1.1 设置国内镜像源"></a>1.1 设置国内镜像源</h2><p><img src="https://s.poetries.work/uploads/2022/06/82cdc649caaa9a4d.png" alt></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://register.docker-cn.com/"</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入该网站<code>https://hub.daocloud.io</code>获取镜像的下载地址</p><h2 id="1-2-docker命令基础"><a href="#1-2-docker命令基础" class="headerlink" title="1.2 docker命令基础"></a>1.2 docker命令基础</h2><ul><li><code>docker images</code> 查看镜像</li><li><code>docker ps</code> 查看启动的容器 (<code>-a</code> 查看全部)</li><li><code>docker rmi 镜像ID</code> 删除镜像</li><li><code>docker rm 容器ID</code> 删除容器</li><li><code>docker exec -it 1a8eca716169(容器ID:docker ps获取) sh</code> 进入容器内部</li><li><code>docker inspect bf70019da487(容器ID)</code> 查看容器内的信息 </li></ul><blockquote><p>删除none的镜像，要先删除镜像中的容器。要删除镜像中的容器，必须先停止容器。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker rmi $(docker images | grep &quot;none&quot; | awk &apos;&#123;print $3&#125;&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker stop $(docker ps -a | grep &quot;Exited&quot; | awk &apos;&#123;print $1 &#125;&apos;) //停止容器</span><br><span class="line"></span><br><span class="line">$ docker rm $(docker ps -a | grep &quot;Exited&quot; | awk &apos;&#123;print $1 &#125;&apos;) //删除容器</span><br><span class="line"></span><br><span class="line">$ docker rmi $(docker images | grep &quot;none&quot; | awk &apos;&#123;print $3&#125;&apos;) //删除镜像</span><br></pre></td></tr></table></figure><h2 id="1-3-环境准备"><a href="#1-3-环境准备" class="headerlink" title="1.3 环境准备"></a>1.3 环境准备</h2><p>这里拉取<code>nginx</code>、<code>node</code>、<code>redis</code>、<code>mysql</code>镜像</p><h3 id="1、安装node镜像"><a href="#1、安装node镜像" class="headerlink" title="1、安装node镜像"></a>1、安装node镜像</h3><p>进入<code>https://hub.daocloud.io</code> 搜索node，切换到版本获取下载地址</p><ul><li><code>docker pull daocloud.io/library/node:12.18</code></li><li><code>docker tag 28faf336034d node</code> 重命名镜像</li></ul><p>重命名镜像后IMAGE ID都是一样的</p><p><img src="https://s.poetries.work/uploads/2022/06/59d83f0139c878de.png" alt></p><p>也可以导出镜像到本地备份 <code>docker save -o node.image(导出镜像要起的名称) 28faf336034d(要导出的镜像的ID)</code></p><p><img src="https://s.poetries.work/uploads/2022/06/7b993abfdc8f07b6.png" alt></p><p>我们先删除之前的镜像 <code>docker rmi 28faf336034d -f</code> 强制删除</p><p><img src="https://s.poetries.work/uploads/2022/06/df79f11b704aae4d.png" alt></p><p>再次导入本地镜像</p><p><code>docker load -i node.image(导入的镜像名称)</code></p><p><img src="https://s.poetries.work/uploads/2022/06/566d2f2270c40840.png" alt></p><p>然后再次重命名镜像即可</p><p><code>docker tag 28faf336034d node:v1.0(版本v1.0)</code></p><p><img src="https://s.poetries.work/uploads/2022/06/129f0a59b6d7c5d4.png" alt></p><h3 id="2、安装MySQL镜像"><a href="#2、安装MySQL镜像" class="headerlink" title="2、安装MySQL镜像"></a>2、安装MySQL镜像</h3><p>进入<code>https://hub.daocloud.io</code> 搜索mysql，切换到版本获取下载地址</p><p><img src="https://s.poetries.work/uploads/2022/06/a6a34ed8d66f7cdc.png" alt></p><ul><li><code>docker pull daocloud.io/library/mysql:8.0.20</code></li></ul><p><img src="https://s.poetries.work/uploads/2022/06/f7e34f9ea2331ffb.png" alt></p><p><strong>启动MySQL镜像</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d(后台运行) -p 3307:3306(本机端口:MySQL运行端口) --name mysql(容器名称) -e MYSQL_ROOT_PASSWORD=123456(设置mysql密码) be0dbf01a0f3(mysql镜像ID)</span><br></pre></td></tr></table></figure><p><strong>查看当前正在运行的镜像</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a(正在运行和停止的镜像-a都可见)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/5ba00266271ef558.png" alt></p><p><strong>删除容器</strong></p><p>删除之前需要stop：<code>docker stop bac2692e2b9a(容器ID)</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm bac2692e2b9a(容器ID：docker ps获取)</span><br></pre></td></tr></table></figure><p><strong>进入容器内部</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it bac2692e2b9a(容器ID) sh(指定进入方式)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/16c4541cf84b6e48.png" alt></p><p>我们使用Navicat新建一个连接测试一下</p><p><img src="https://s.poetries.work/uploads/2022/06/65357b17bf38f12e.png" alt></p><p>说明我们使用docker安装MySQL的方式是没问题的</p><p><strong>查看MySQL容器日志</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs -f(查看最后几条)  bac2692e2b9a(容器ID)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/639c44fb75dfe354.png" alt></p><p><strong>重启容器</strong></p><p>如果修改了容器配置，我们需要重新启动容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart bac2692e2b9a(容器ID)</span><br></pre></td></tr></table></figure><p><strong>设置MySQL权限</strong></p><blockquote><p>mysql8.0后，需要设置，否则node连接不上</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it bac2692e2b9a sh</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 远程连接权限</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新加密规则</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'password'</span> PASSWORD EXPIRE NEVER;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新用户密码</span></span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/2ce28bda82ab01d4.png" alt></p><h3 id="3、安装redis镜像"><a href="#3、安装redis镜像" class="headerlink" title="3、安装redis镜像"></a>3、安装redis镜像</h3><p><img src="https://s.poetries.work/uploads/2022/06/b38b5f228f3bcafe.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull daocloud.io/library/redis:6.0.3-alpine3.11</span><br></pre></td></tr></table></figure><p><strong>启动Redis镜像</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6380:6379 --name redis 29c713657d31(镜像ID) --requirepass 123456(redis登录密码)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/57a4ce88939753b0.png" alt></p><p>或进入redis镜像后在输入密码</p><p><img src="https://s.poetries.work/uploads/2022/06/b6183fc0a23c353d.png" alt></p><p><strong>交互式进入redis容器</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 9751cbc96861(容器ID) sh</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/ab4cf5d68cdd846b.png" alt></p><h3 id="4、安装Nginx镜像"><a href="#4、安装Nginx镜像" class="headerlink" title="4、安装Nginx镜像"></a>4、安装Nginx镜像</h3><p><img src="https://s.poetries.work/uploads/2022/06/49bb3cc9f49c2dd1.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull daocloud.io/library/nginx:1.13.0-alpine</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/1f9aea9f1c9a18fc.png" alt></p><p><strong>启动Nginx镜像</strong></p><p>服务器上启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name nginx(起一个容器名称) -d(后台运行) -p 80:80(本机:容器) -v(映射Nginx容器的运行目录本机) /root/nginx/log:/var/log/nginx(本机目录:容器目录) -v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf(本机目录:容器内nginx配置所在目录) -v /root/nginx/conf.d:/etc/nginx/conf.d -v /root/nginx/html:/usr/share/nginx/html f00ab1b3ac6d(nginx镜像ID)</span><br></pre></td></tr></table></figure><p>本地电脑启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name nginx -d -p 8666:80 -v /Users/poetry/Downloads/docker/nginx/log:/var/log/nginx -v /Users/poetry/Downloads/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /Users/poetry/Downloads/docker/nginx/conf.d:/etc/nginx/conf.d -v /Users/poetry/Downloads/docker/nginx/html:/usr/share/nginx/html f00ab1b3ac6d</span><br></pre></td></tr></table></figure><blockquote><p>把docker容器中的Nginx服务配置映射本地方便管理</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/691129b326f9fb23.png" alt></p><p>访问docker暴露的8666端口即可</p><p><img src="https://s.poetries.work/uploads/2022/06/6d9b07b85c22e0b5.png" alt></p><p>当我们修改了html中的文件，无需重启容器即可看到效果</p><p><img src="https://s.poetries.work/uploads/2022/06/d0ded5a28d96ce59.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/cb0109ef19b551e4.png" alt></p><h2 id="1-4-部署egg代码"><a href="#1-4-部署egg代码" class="headerlink" title="1.4 部署egg代码"></a>1.4 部署egg代码</h2><blockquote><p>构建egg镜像，进入到egg目录</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 构建egg镜像，版本v1.0</span><br><span class="line">docker build -t egg:v1.0 .</span><br></pre></td></tr></table></figure><p><code>Dockerfile文件如下</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用node镜像</span></span><br><span class="line">FROM daocloud.io/library/node:12.18</span><br><span class="line"><span class="comment"># 在容器中新建目录文件夹 egg</span></span><br><span class="line">RUN mkdir -p /egg</span><br><span class="line"><span class="comment"># 将 /egg 设置为默认工作目录</span></span><br><span class="line">WORKDIR /egg</span><br><span class="line"><span class="comment"># 将 package.json 复制默认工作目录</span></span><br><span class="line">COPY package.json /egg/package.json</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">RUN yarn config <span class="built_in">set</span> register https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 只安装dependencies的包</span></span><br><span class="line">RUN yarn --production</span><br><span class="line"><span class="comment"># 再copy代码至容器</span></span><br><span class="line">COPY ./ /egg</span><br><span class="line"><span class="comment"># 7001端口</span></span><br><span class="line">EXPOSE 7001</span><br><span class="line"><span class="comment"># 等容器启动之后执行脚本</span></span><br><span class="line">CMD yarn prod</span><br></pre></td></tr></table></figure><h3 id="启动egg镜像"><a href="#启动egg镜像" class="headerlink" title="启动egg镜像"></a>启动egg镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d(后台启动) -p 7001:7001(本机:容器) --name server(容器名称) af9360186a24(镜像ID)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/1332f6a87ae0879f.png" alt></p><h1 id="二、docker-compose部署"><a href="#二、docker-compose部署" class="headerlink" title="二、docker-compose部署"></a>二、docker-compose部署</h1><h2 id="2-1-编写docker-compose-yml文件"><a href="#2-1-编写docker-compose-yml文件" class="headerlink" title="2.1 编写docker-compose.yml文件"></a>2.1 编写docker-compose.yml文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.0"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line"><span class="attr">    redis:</span> <span class="comment"># 服务名称</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">redis</span> <span class="comment"># 容器名称</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">daocloud.io/library/redis:6.0.3-alpine3.11</span> <span class="comment"># 使用官方镜像</span></span><br><span class="line"><span class="attr">        ports:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="number">6380</span><span class="string">:6379</span> <span class="comment"># 本机端口:容器端口</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">on-failure</span> <span class="comment"># 自动重启</span></span><br><span class="line"><span class="attr">        networks:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">my-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    mysql:</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">daocloud.io/library/mysql:8.0.20</span> <span class="comment"># 使用官方镜像</span></span><br><span class="line"><span class="attr">        ports:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="number">3307</span><span class="string">:3306</span> <span class="comment"># 本机端口:容器端口</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">        environment:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span> <span class="comment"># root用户密码</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/mysql/db:/var/lib/mysql</span> <span class="comment"># 用来存放了数据库表文件</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/mysql/conf/my.cnf:/etc/my.cnf</span> <span class="comment"># 存放自定义的配置文件</span></span><br><span class="line">            <span class="comment"># 我们在启动MySQL容器时自动创建我们需要的数据库和表</span></span><br><span class="line">            <span class="comment"># mysql官方镜像中提供了容器启动时自动docker-entrypoint-initdb.d下的脚本的功能</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/mysql/init:/docker-entrypoint-initdb.d/</span> <span class="comment"># 存放初始化的脚本</span></span><br><span class="line"><span class="attr">        networks:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">my-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    server:</span> <span class="comment"># egg服务</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">        build:</span> <span class="comment"># 根据Dockerfile构建镜像</span></span><br><span class="line"><span class="attr">            context:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">            dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">        ports:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="number">7001</span><span class="string">:7001</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">on-failure</span> <span class="comment"># 设置自动重启，这一步必须设置，主要是存在mysql还没有启动完成就启动了node服务</span></span><br><span class="line"><span class="attr">        networks:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">my-server</span></span><br><span class="line"><span class="attr">        depends_on:</span> <span class="comment"># node服务依赖于mysql和redis</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">redis</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    nginx:</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">daocloud.io/library/nginx:1.13.0-alpine</span> <span class="comment"># 使用官方镜像</span></span><br><span class="line"><span class="attr">        ports:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="number">8900</span><span class="string">:80</span> <span class="comment"># 本地端口:容器端口</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">        volumes:</span> <span class="comment"># 映射本地目录到容器目录</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/nginx/conf/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/nginx/html:/usr/share/nginx/html</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/nginx/log:/var/log/nginx</span></span><br><span class="line"><span class="attr">        networks:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">my-server</span></span><br><span class="line"><span class="attr">        depends_on:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">redis</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">mysql</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一下网桥  my-server。</span></span><br><span class="line"><span class="comment"># 重要：将所有服务都挂载在同一网桥即可通过容器名来互相通信了</span></span><br><span class="line"><span class="comment"># 如egg连接mysql和redis，可以通过容器名来互相通信</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">    my-server:</span></span><br></pre></td></tr></table></figure><h2 id="2-2-启动服务"><a href="#2-2-启动服务" class="headerlink" title="2.2 启动服务"></a>2.2 启动服务</h2><p><strong>修改egg服务代码</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/a799a68a83398d4b.png" alt></p><p><strong>常用命令</strong></p><blockquote><p><code>docker-compose -h</code> 查看命令</p></blockquote><ul><li><code>docker-compose up</code> 启动服务，控制台可见日志</li><li><code>docker-compose up -d</code> 后台启动服务</li><li><code>docker-compose build --no-cache</code> 重新构建镜像不使用缓存(最后<code>docker-compose up -d</code>启动)</li><li>停止服务 <code>docker-compose down</code></li><li>下载镜像过程 <code>docker-compose pull</code></li><li>重启服务 <code>docker-compose restart</code></li></ul><p>后台启动服务 <code>docker-compose up -d</code></p><p><img src="https://s.poetries.work/uploads/2022/06/e8a4d267eb9342c1.png" alt></p><p>查看应用状态 <code>docker-compose ps</code></p><p><img src="https://s.poetries.work/uploads/2022/06/85c0f4122baf860d.png" alt></p><p>停止服务 <code>docker-compose down</code></p><h1 id="三、Nginx容器内部署前端"><a href="#三、Nginx容器内部署前端" class="headerlink" title="三、Nginx容器内部署前端"></a>三、Nginx容器内部署前端</h1><p>把前端打包的文件放到Nginx目录下访问</p><p><img src="https://s.poetries.work/uploads/2022/06/8ec0512b8a2a0652.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/4a710e9a2a883e24.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/0bb97a6d629301ac.png" alt></p><h1 id="四、docker部署到云服务器"><a href="#四、docker部署到云服务器" class="headerlink" title="四、docker部署到云服务器"></a>四、docker部署到云服务器</h1><h2 id="4-1-安装docker环境"><a href="#4-1-安装docker环境" class="headerlink" title="4.1 安装docker环境"></a>4.1 安装docker环境</h2><h3 id="安装工具包"><a href="#安装工具包" class="headerlink" title="安装工具包"></a>安装工具包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install yum-utils device-mapper-persistent-data lvm2 -y</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/e0f4f8f2621b11c0.png" alt></p><h3 id="设置阿里镜像源"><a href="#设置阿里镜像源" class="headerlink" title="设置阿里镜像源"></a>设置阿里镜像源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/0b017f9a76914c6e.png" alt></p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br></pre></td></tr></table></figure><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 设为开机启动</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h3 id="设置docker镜像源"><a href="#设置docker镜像源" class="headerlink" title="设置docker镜像源"></a>设置docker镜像源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://register.docker-cn.com/"</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续拉取镜像直接从 <a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> 网站拉取速度更快</p><p><strong>重启docker</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="安装mysql镜像测试"><a href="#安装mysql镜像测试" class="headerlink" title="安装mysql镜像测试"></a>安装mysql镜像测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull daocloud.io/library/mysql:8.0.20</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/dad88a1878a7a12f.png" alt></p><p><strong>运行mysql镜像</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3307:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456(设置登录密码) be0dbf01a0f3(镜像ID)</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/fb606d9823c4f0ff.png" alt></p><p><strong>进入mysql容器内部</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/3a9f7618e1baf34f.png" alt></p><blockquote><p>至此mysql镜像搭建成功，下面我们使用<code>docker-compose</code>来管理docker容器，不在单独一个个安装MySQL、redis、nginx</p></blockquote><h2 id="4-2-安装docker-compose"><a href="#4-2-安装docker-compose" class="headerlink" title="4.2 安装docker-compose"></a>4.2 安装docker-compose</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用国内源安装</span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p><strong>设置docker-compose执行权限</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p><strong>创建软链</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p><strong>测试是否安装成功：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line"></span><br><span class="line">docker-compose version 1.22.0, build f46880fe</span><br></pre></td></tr></table></figure><h2 id="4-3-开放服务器端口"><a href="#4-3-开放服务器端口" class="headerlink" title="4.3 开放服务器端口"></a>4.3 开放服务器端口</h2><p>登录服务器后台放行对应端口</p><p><img src="https://s.poetries.work/uploads/2022/06/e4657b28bcea9b61.png" alt></p><h2 id="4-4-部署egg项目"><a href="#4-4-部署egg项目" class="headerlink" title="4.4 部署egg项目"></a>4.4 部署egg项目</h2><h3 id="修改代码和配置"><a href="#修改代码和配置" class="headerlink" title="修改代码和配置"></a>修改代码和配置</h3><p><strong>修改Nginx配置</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/bcaf72ea48991732.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/1bf0445f94a779a6.png" alt></p><p><strong>修改config/config.prod.js</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/2744890d4980cfc8.png" alt></p><p><strong>docker-compose.yml</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.0"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="comment"># docker容器启动的redis默认是没有redis.conf的配置文件，所以用docker启动redis之前，需要先去官网下载redis.conf的配置文件</span></span><br><span class="line"><span class="attr">    redis:</span> <span class="comment"># 服务名称</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">redis</span> <span class="comment"># 容器名称</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">daocloud.io/library/redis:6.0.3-alpine3.11</span> <span class="comment"># 使用官方镜像</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">redis-server</span> <span class="string">/usr/local/etc/redis/redis.conf</span> <span class="bullet">--requirepass</span> <span class="number">123456</span> <span class="bullet">--appendonly</span> <span class="literal">yes</span> <span class="comment"># 设置redis登录密码 123456、--appendonly yes：这个命令是用于开启redis数据持久化</span></span><br><span class="line">        <span class="comment"># command: redis-server --requirepass 123456 --appendonly yes # 设置redis登录密码 123456</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="number">6380</span><span class="string">:6379</span> <span class="comment"># 本机端口:容器端口</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">on-failure</span> <span class="comment"># 自动重启</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/redis/db:/data</span> <span class="comment"># 把持久化数据挂载到宿主机</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf</span>  <span class="comment"># 把redis的配置文件挂载到宿主机</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/redis/logs:/logs</span> <span class="comment"># 用来存放日志</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">TZ=Asia/Shanghai</span>  <span class="comment"># 解决容器 时区的问题</span></span><br><span class="line"><span class="attr">        networks:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">my-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    mysql:</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">daocloud.io/library/mysql:8.0.20</span> <span class="comment"># 使用官方镜像</span></span><br><span class="line"><span class="attr">        ports:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="number">3307</span><span class="string">:3306</span> <span class="comment"># 本机端口:容器端口</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">        environment:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">MYSQL_ROOT_PASSWORD=993412</span> <span class="comment"># root用户密码</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/mysql/db:/var/lib/mysql</span> <span class="comment"># 用来存放了数据库表文件</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/mysql/conf/my.cnf:/etc/my.cnf</span> <span class="comment"># 存放自定义的配置文件</span></span><br><span class="line">            <span class="comment"># 我们在启动MySQL容器时自动创建我们需要的数据库和表</span></span><br><span class="line">            <span class="comment"># mysql官方镜像中提供了容器启动时自动docker-entrypoint-initdb.d下的脚本的功能</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/mysql/init:/docker-entrypoint-initdb.d/</span> <span class="comment"># 存放初始化的脚本</span></span><br><span class="line"><span class="attr">        networks:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">my-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    server:</span> <span class="comment"># egg服务</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">        build:</span> <span class="comment"># 根据Dockerfile构建镜像</span></span><br><span class="line"><span class="attr">            context:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">            dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">        ports:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="number">7001</span><span class="string">:7001</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">on-failure</span> <span class="comment"># 设置自动重启，这一步必须设置，主要是存在mysql还没有启动完成就启动了node服务</span></span><br><span class="line"><span class="attr">        networks:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">my-server</span></span><br><span class="line"><span class="attr">        depends_on:</span> <span class="comment"># node服务依赖于mysql和redis</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">redis</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    nginx:</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">daocloud.io/library/nginx:1.13.0-alpine</span> <span class="comment"># 使用官方镜像</span></span><br><span class="line"><span class="attr">        ports:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="number">8900</span><span class="string">:80</span> <span class="comment"># 本地端口:容器端口</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">        volumes:</span> <span class="comment"># 映射本地目录到容器目录</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/nginx/conf/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/nginx/html:/usr/share/nginx/html</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./deploy/nginx/log:/var/log/nginx</span></span><br><span class="line"><span class="attr">        networks:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">my-server</span></span><br><span class="line"><span class="attr">        depends_on:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">redis</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">mysql</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一下网桥  my-server。</span></span><br><span class="line"><span class="comment"># 重要：将所有服务都挂载在同一网桥即可通过容器名来互相通信了</span></span><br><span class="line"><span class="comment"># 如egg连接mysql和redis，可以通过容器名来互相通信</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">    my-server:</span></span><br></pre></td></tr></table></figure><p><strong>egg Dockerfile</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用node镜像</span></span><br><span class="line"><span class="string">FROM</span> <span class="string">daocloud.io/library/node:12.18</span></span><br><span class="line"><span class="comment"># 在容器中新建目录文件夹 egg</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">mkdir</span> <span class="bullet">-p</span> <span class="string">/egg</span></span><br><span class="line"><span class="comment"># 将 /egg 设置为默认工作目录</span></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">/egg</span></span><br><span class="line"><span class="comment"># 将 package.json 复制默认工作目录</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">package.json</span> <span class="string">/egg/package.json</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">yarn</span> <span class="string">config</span> <span class="string">set</span> <span class="string">register</span> <span class="attr">https://registry.npm.taobao.org</span></span><br><span class="line"><span class="comment"># 只安装dependencies的包</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">yarn</span> <span class="bullet">--production</span></span><br><span class="line"><span class="comment"># 再copy代码至容器</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">./</span> <span class="string">/egg</span></span><br><span class="line"><span class="comment"># 7001端口</span></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">7001</span></span><br><span class="line"><span class="comment">#等容器启动之后执行脚本</span></span><br><span class="line"><span class="string">CMD</span> <span class="string">yarn</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure><p><strong>./deploy/redis/conf/redis.conf</strong></p><p>需要设置的地方</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#指定日志级别，notice适用于生产环境</span><br><span class="line"># 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span><br><span class="line"># debug (很多信息, 对开发／测试比较有用)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (moderately verbose, what you want in production probably)</span><br><span class="line"># warning (only very important / critical messages are logged)</span><br><span class="line">loglevel verbose</span><br><span class="line"></span><br><span class="line">#指定log日志位置</span><br><span class="line">logfile /logs/redis.log</span><br></pre></td></tr></table></figure><p>全部配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Redis configuration file example.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that in order to read the configuration file, Redis must be</span></span><br><span class="line"><span class="comment"># started with the file path as first argument:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ./redis-server /path/to/redis.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note on units: when memory size is needed, it is possible to specify</span></span><br><span class="line"><span class="comment"># it in the usual form of 1k 5GB 4M and so forth:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1k =&gt; 1000 bytes</span></span><br><span class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="comment"># 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="comment"># 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## INCLUDES ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include one or more other config files here.  This is useful if you</span></span><br><span class="line"><span class="comment"># have a standard template that goes to all Redis servers but also need</span></span><br><span class="line"><span class="comment"># to customize a few per-server settings.  Include files can include</span></span><br><span class="line"><span class="comment"># other files, so use this wisely.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Notice option "include" won't be rewritten by command "CONFIG REWRITE"</span></span><br><span class="line"><span class="comment"># from admin or Redis Sentinel. Since Redis always uses the last processed</span></span><br><span class="line"><span class="comment"># line as value of a configuration directive, you'd better put includes</span></span><br><span class="line"><span class="comment"># at the beginning of this file to avoid overwriting config change at runtime.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If instead you are interested in using includes to override configuration</span></span><br><span class="line"><span class="comment"># options, it is better to use include as the last line.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># include /path/to/local.conf</span></span><br><span class="line"><span class="comment"># include /path/to/other.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## MODULES #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load modules at startup. If the server is not able to load modules</span></span><br><span class="line"><span class="comment"># it will abort. It is possible to use multiple loadmodule directives.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># loadmodule /path/to/my_module.so</span></span><br><span class="line"><span class="comment"># loadmodule /path/to/other_module.so</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## NETWORK #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, if no "bind" configuration directive is specified, Redis listens</span></span><br><span class="line"><span class="comment"># for connections from all the network interfaces available on the server.</span></span><br><span class="line"><span class="comment"># It is possible to listen to just one or multiple selected interfaces using</span></span><br><span class="line"><span class="comment"># the "bind" configuration directive, followed by one or more IP addresses.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Examples:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># bind 192.168.1.100 10.0.0.1</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1 ::1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span></span><br><span class="line"><span class="comment"># internet, binding to all the interfaces is dangerous and will expose the</span></span><br><span class="line"><span class="comment"># instance to everybody on the internet. So by default we uncomment the</span></span><br><span class="line"><span class="comment"># following bind directive, that will force Redis to listen only into</span></span><br><span class="line"><span class="comment"># the IPv4 loopback interface address (this means Redis will be able to</span></span><br><span class="line"><span class="comment"># accept connections only from clients running into the same computer it</span></span><br><span class="line"><span class="comment"># is running).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span></span><br><span class="line"><span class="comment"># JUST COMMENT THE FOLLOWING LINE.</span></span><br><span class="line"><span class="comment"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># redis绑定的ip或者主机名，注意如果此处绑定设置为127.0.0.1，将会出现其他服务器上的服务连接至此台redis失败的情况</span></span><br><span class="line"><span class="comment"># 绑定的主机地址</span></span><br><span class="line"><span class="comment"># 你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Protected mode is a layer of security protection, in order to avoid that</span></span><br><span class="line"><span class="comment"># Redis instances left open on the internet are accessed and exploited.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When protected mode is on and if:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) The server is not binding explicitly to a set of addresses using the</span></span><br><span class="line"><span class="comment">#    "bind" directive.</span></span><br><span class="line"><span class="comment"># 2) No password is configured.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The server only accepts connections from clients connecting from the</span></span><br><span class="line"><span class="comment"># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span></span><br><span class="line"><span class="comment"># sockets.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default protected mode is enabled. You should disable it only if</span></span><br><span class="line"><span class="comment"># you are sure you want clients from other hosts to connect to Redis</span></span><br><span class="line"><span class="comment"># even if no authentication is configured, nor a specific set of interfaces</span></span><br><span class="line"><span class="comment"># are explicitly listed using the "bind" directive.</span></span><br><span class="line"><span class="string">protected-mode</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Accept connections on the specified port, default is 6379 (IANA #815344).</span></span><br><span class="line"><span class="comment"># If port 0 is specified Redis will not listen on a TCP socket.</span></span><br><span class="line"><span class="comment"># 指定redis启动占用的端口</span></span><br><span class="line"><span class="string">port</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP listen() backlog.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In high requests-per-second environments you need an high backlog in order</span></span><br><span class="line"><span class="comment"># to avoid slow clients connections issues. Note that the Linux kernel</span></span><br><span class="line"><span class="comment"># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span></span><br><span class="line"><span class="comment"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span></span><br><span class="line"><span class="comment"># in order to get the desired effect.</span></span><br><span class="line"><span class="comment">#此项配置内容属于redis优化内容</span></span><br><span class="line"><span class="string">tcp-backlog</span> <span class="number">511</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Unix socket.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Specify the path for the Unix socket that will be used to listen for</span></span><br><span class="line"><span class="comment"># incoming connections. There is no default, so Redis will not listen</span></span><br><span class="line"><span class="comment"># on a unix socket when not specified.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># unixsocket /tmp/redis.sock</span></span><br><span class="line"><span class="comment"># unixsocketperm 700</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Close the connection after a client is idle for N seconds (0 to disable)</span></span><br><span class="line"><span class="comment"># 指定socket连接空闲时间（秒），如果连接空闲超时将会关闭连接，设置为0表示用不超时</span></span><br><span class="line"><span class="string">timeout</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP keepalive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span></span><br><span class="line"><span class="comment"># of communication. This is useful for two reasons:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) Detect dead peers.</span></span><br><span class="line"><span class="comment"># 2) Take the connection alive from the point of view of network</span></span><br><span class="line"><span class="comment">#    equipment in the middle.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span></span><br><span class="line"><span class="comment"># Note that to close the connection the double of the time is needed.</span></span><br><span class="line"><span class="comment"># On other kernels the period depends on the kernel configuration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A reasonable value for this option is 300 seconds, which is the new</span></span><br><span class="line"><span class="comment"># Redis default starting with Redis 3.2.1.</span></span><br><span class="line"><span class="comment">#指定tcp连接是否为长连接，长连接将会额外增加server端的开支，默认为0表示禁用</span></span><br><span class="line"><span class="string">tcp-keepalive</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################# TLS/SSL #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, TLS/SSL is disabled. To enable it, the "tls-port" configuration</span></span><br><span class="line"><span class="comment"># directive can be used to define TLS-listening ports. To enable TLS on the</span></span><br><span class="line"><span class="comment"># default port, use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># port 0</span></span><br><span class="line"><span class="comment"># tls-port 6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure a X.509 certificate and private key to use for authenticating the</span></span><br><span class="line"><span class="comment"># server to connected clients, masters or cluster peers.  These files should be</span></span><br><span class="line"><span class="comment"># PEM formatted.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-cert-file redis.crt </span></span><br><span class="line"><span class="comment"># tls-key-file redis.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-dh-params-file redis.dh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure a CA certificate(s) bundle or directory to authenticate TLS/SSL</span></span><br><span class="line"><span class="comment"># clients and peers.  Redis requires an explicit configuration of at least one</span></span><br><span class="line"><span class="comment"># of these, and will not implicitly use the system wide configuration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-ca-cert-file ca.crt</span></span><br><span class="line"><span class="comment"># tls-ca-cert-dir /etc/ssl/certs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, clients (including replica servers) on a TLS port are required</span></span><br><span class="line"><span class="comment"># to authenticate using valid client side certificates.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is possible to disable authentication using this directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-auth-clients no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, a Redis replica does not attempt to establish a TLS connection</span></span><br><span class="line"><span class="comment"># with its master.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use the following directive to enable TLS on replication links.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-replication yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, the Redis Cluster bus uses a plain TCP connection. To enable</span></span><br><span class="line"><span class="comment"># TLS for the bus protocol, use the following directive:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-cluster yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Explicitly specify TLS versions to support. Allowed values are case insensitive</span></span><br><span class="line"><span class="comment"># and include "TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3" (OpenSSL &gt;= 1.1.1) or</span></span><br><span class="line"><span class="comment"># any combination. To enable only TLSv1.2 and TLSv1.3, use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-protocols "TLSv1.2 TLSv1.3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure allowed ciphers.  See the ciphers(1ssl) manpage for more information</span></span><br><span class="line"><span class="comment"># about the syntax of this string.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note: this configuration applies only to &lt;= TLSv1.2.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-ciphers DEFAULT:!MEDIUM</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure allowed TLSv1.3 ciphersuites.  See the ciphers(1ssl) manpage for more</span></span><br><span class="line"><span class="comment"># information about the syntax of this string, and specifically for TLSv1.3</span></span><br><span class="line"><span class="comment"># ciphersuites.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When choosing a cipher, use the server's preference instead of the client</span></span><br><span class="line"><span class="comment"># preference. By default, the server follows the client's preference.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-prefer-server-ciphers yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################# GENERAL #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis does not run as a daemon. Use 'yes' if you need it.</span></span><br><span class="line"><span class="comment"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span></span><br><span class="line"><span class="comment"># 默认以后台方式运行 yes 则以后台方式运行</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If you run Redis from upstart or systemd, Redis can interact with your</span></span><br><span class="line"><span class="comment"># supervision tree. Options:</span></span><br><span class="line"><span class="comment">#   supervised no      - no supervision interaction</span></span><br><span class="line"><span class="comment">#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span></span><br><span class="line"><span class="comment">#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET</span></span><br><span class="line"><span class="comment">#   supervised auto    - detect upstart or systemd method based on</span></span><br><span class="line"><span class="comment">#                        UPSTART_JOB or NOTIFY_SOCKET environment variables</span></span><br><span class="line"><span class="comment"># Note: these supervision methods only signal "process is ready."</span></span><br><span class="line"><span class="comment">#       They do not enable continuous liveness pings back to your supervisor.</span></span><br><span class="line"><span class="string">supervised</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If a pid file is specified, Redis writes it where specified at startup</span></span><br><span class="line"><span class="comment"># and removes it at exit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When the server runs non daemonized, no pid file is created if none is</span></span><br><span class="line"><span class="comment"># specified in the configuration. When the server is daemonized, the pid file</span></span><br><span class="line"><span class="comment"># is used even if not specified, defaulting to "/var/run/redis.pid".</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Creating a pid file is best effort: if Redis is not able to create it</span></span><br><span class="line"><span class="comment"># nothing bad happens, the server will start and run normally.</span></span><br><span class="line"><span class="comment"># 指定redis pid文件</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/var/run/redis_6379.pid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the server verbosity level.</span></span><br><span class="line"><span class="comment"># This can be one of:</span></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line"><span class="comment">#指定日志级别，notice适用于生产环境</span></span><br><span class="line"><span class="comment"># 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span></span><br><span class="line"><span class="comment"># debug (很多信息, 对开发／测试比较有用)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line"><span class="string">loglevel</span> <span class="string">verbose</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the log file name. Also the empty string can be used to force</span></span><br><span class="line"><span class="comment"># Redis to log on the standard output. Note that if you use standard</span></span><br><span class="line"><span class="comment"># output for logging but daemonize, logs will be sent to /dev/null</span></span><br><span class="line"><span class="comment">#指定log日志位置</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">/logs/redis.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To enable logging to the system logger, just set 'syslog-enabled' to yes,</span></span><br><span class="line"><span class="comment"># and optionally update the other syslog parameters to suit your needs.</span></span><br><span class="line"><span class="comment">#是否将日志输出到系统日志，默认为no</span></span><br><span class="line"><span class="string">syslog-enabled</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the syslog identity.</span></span><br><span class="line"><span class="comment">#指定syslog的标示符，如果'syslog-enabled'是no，则这个选项无效</span></span><br><span class="line"><span class="string">syslog-ident</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span></span><br><span class="line"><span class="comment"># syslog-facility local0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the number of databases. The default database is DB 0, you can select</span></span><br><span class="line"><span class="comment"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span></span><br><span class="line"><span class="comment"># dbid is a number between 0 and 'databases'-1</span></span><br><span class="line"><span class="comment"># 设定redis所允许的最大"db簇"的个数,默认为16个簇</span></span><br><span class="line"><span class="string">databases</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis shows an ASCII art logo only when started to log to the</span></span><br><span class="line"><span class="comment"># standard output and if the standard output is a TTY. Basically this means</span></span><br><span class="line"><span class="comment"># that normally a logo is displayed only in interactive sessions.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However it is possible to force the pre-4.0 behavior and always show a</span></span><br><span class="line"><span class="comment"># ASCII art logo in startup logs by setting the following option to yes.</span></span><br><span class="line"><span class="string">always-show-logo</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Save the DB on disk:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Will save the DB if both the given number of seconds and the given</span></span><br><span class="line"><span class="comment">#   number of write operations against the DB occurred.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   In the example below the behaviour will be to save:</span></span><br><span class="line"><span class="comment">#   after 900 sec (15 min) if at least 1 key changed</span></span><br><span class="line"><span class="comment">#   after 300 sec (5 min) if at least 10 keys changed</span></span><br><span class="line"><span class="comment">#   after 60 sec if at least 10000 keys changed</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Note: you can disable saving completely by commenting out all "save" lines.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   It is also possible to remove all the previously configured save</span></span><br><span class="line"><span class="comment">#   points by adding a save directive with a single empty string argument</span></span><br><span class="line"><span class="comment">#   like in the following example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   save ""</span></span><br><span class="line"></span><br><span class="line"><span class="string">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">10</span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis will stop accepting writes if RDB snapshots are enabled</span></span><br><span class="line"><span class="comment"># (at least one save point) and the latest background save failed.</span></span><br><span class="line"><span class="comment"># This will make the user aware (in a hard way) that data is not persisting</span></span><br><span class="line"><span class="comment"># on disk properly, otherwise chances are that no one will notice and some</span></span><br><span class="line"><span class="comment"># disaster will happen.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the background saving process will start working again Redis will</span></span><br><span class="line"><span class="comment"># automatically allow writes again.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However if you have setup your proper monitoring of the Redis server</span></span><br><span class="line"><span class="comment"># and persistence, you may want to disable this feature so that Redis will</span></span><br><span class="line"><span class="comment"># continue to work as usual even if there are problems with disk,</span></span><br><span class="line"><span class="comment"># permissions, and so forth.</span></span><br><span class="line"><span class="comment">#如果snapshot过程中出现错误,即数据持久化失败,是否终止所有的客户端write请求</span></span><br><span class="line"><span class="string">stop-writes-on-bgsave-error</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compress string objects using LZF when dump .rdb databases?</span></span><br><span class="line"><span class="comment"># For default that's set to 'yes' as it's almost always a win.</span></span><br><span class="line"><span class="comment"># If you want to save some CPU in the saving child set it to 'no' but</span></span><br><span class="line"><span class="comment"># the dataset will likely be bigger if you have compressible values or keys.</span></span><br><span class="line"><span class="comment">#是否启用rdb文件压缩手段,默认为yes</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span></span><br><span class="line"><span class="comment"># This makes the format more resistant to corruption but there is a performance</span></span><br><span class="line"><span class="comment"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span></span><br><span class="line"><span class="comment"># for maximum performances.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># RDB files created with checksum disabled have a checksum of zero that will</span></span><br><span class="line"><span class="comment"># tell the loading code to skip the check.</span></span><br><span class="line"><span class="comment"># 是否对rdb文件使用CRC64校验和,默认为"yes",那么每个rdb文件内容的末尾都会追加CRC校验和</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The filename where to dump the DB</span></span><br><span class="line"><span class="comment">#指定rdb文件的名称</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove RDB files used by replication in instances without persistence</span></span><br><span class="line"><span class="comment"># enabled. By default this option is disabled, however there are environments</span></span><br><span class="line"><span class="comment"># where for regulations or other security concerns, RDB files persisted on</span></span><br><span class="line"><span class="comment"># disk by masters in order to feed replicas, or stored on disk by replicas</span></span><br><span class="line"><span class="comment"># in order to load them for the initial synchronization, should be deleted</span></span><br><span class="line"><span class="comment"># ASAP. Note that this option ONLY WORKS in instances that have both AOF</span></span><br><span class="line"><span class="comment"># and RDB persistence disabled, otherwise is completely ignored.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># An alternative (and sometimes better) way to obtain the same effect is</span></span><br><span class="line"><span class="comment"># to use diskless replication on both master and replicas instances. However</span></span><br><span class="line"><span class="comment"># in the case of replicas, diskless is not always an option.</span></span><br><span class="line"><span class="string">rdb-del-sync-files</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The working directory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The DB will be written inside this directory, with the filename specified</span></span><br><span class="line"><span class="comment"># above using the 'dbfilename' configuration directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Append Only File will also be created inside this directory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that you must specify a directory here, not a file name.</span></span><br><span class="line"><span class="comment">#指定rdb/AOF文件的目录位置</span></span><br><span class="line"><span class="string">dir</span> <span class="string">./</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################# REPLICATION #################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Master-Replica replication. Use replicaof to make a Redis instance a copy of</span></span><br><span class="line"><span class="comment"># another Redis server. A few things to understand ASAP about Redis replication.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   +------------------+      +---------------+</span></span><br><span class="line"><span class="comment">#   |      Master      | ---&gt; |    Replica    |</span></span><br><span class="line"><span class="comment">#   | (receive writes) |      |  (exact copy) |</span></span><br><span class="line"><span class="comment">#   +------------------+      +---------------+</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) Redis replication is asynchronous, but you can configure a master to</span></span><br><span class="line"><span class="comment">#    stop accepting writes if it appears to be not connected with at least</span></span><br><span class="line"><span class="comment">#    a given number of replicas.</span></span><br><span class="line"><span class="comment"># 2) Redis replicas are able to perform a partial resynchronization with the</span></span><br><span class="line"><span class="comment">#    master if the replication link is lost for a relatively small amount of</span></span><br><span class="line"><span class="comment">#    time. You may want to configure the replication backlog size (see the next</span></span><br><span class="line"><span class="comment">#    sections of this file) with a sensible value depending on your needs.</span></span><br><span class="line"><span class="comment"># 3) Replication is automatic and does not need user intervention. After a</span></span><br><span class="line"><span class="comment">#    network partition replicas automatically try to reconnect to masters</span></span><br><span class="line"><span class="comment">#    and resynchronize with them.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If the master is password protected (using the "requirepass" configuration</span></span><br><span class="line"><span class="comment"># directive below) it is possible to tell the replica to authenticate before</span></span><br><span class="line"><span class="comment"># starting the replication synchronization process, otherwise the master will</span></span><br><span class="line"><span class="comment"># refuse the replica request.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However this is not enough if you are using Redis ACLs (for Redis version</span></span><br><span class="line"><span class="comment"># 6 or greater), and the default user is not capable of running the PSYNC</span></span><br><span class="line"><span class="comment"># command and/or other commands needed for replication. In this case it's</span></span><br><span class="line"><span class="comment"># better to configure a special user to use with replication, and specify the</span></span><br><span class="line"><span class="comment"># masteruser configuration as such:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># masteruser &lt;username&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When masteruser is specified, the replica will authenticate against its</span></span><br><span class="line"><span class="comment"># master using the new AUTH form: AUTH &lt;username&gt; &lt;password&gt;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When a replica loses its connection with the master, or when the replication</span></span><br><span class="line"><span class="comment"># is still in progress, the replica can act in two different ways:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will</span></span><br><span class="line"><span class="comment">#    still reply to client requests, possibly with out of date data, or the</span></span><br><span class="line"><span class="comment">#    data set may just be empty if this is the first synchronization.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2) if replica-serve-stale-data is set to 'no' the replica will reply with</span></span><br><span class="line"><span class="comment">#    an error "SYNC with master in progress" to all the kind of commands</span></span><br><span class="line"><span class="comment">#    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,</span></span><br><span class="line"><span class="comment">#    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,</span></span><br><span class="line"><span class="comment">#    COMMAND, POST, HOST: and LATENCY.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="string">replica-serve-stale-data</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can configure a replica instance to accept writes or not. Writing against</span></span><br><span class="line"><span class="comment"># a replica instance may be useful to store some ephemeral data (because data</span></span><br><span class="line"><span class="comment"># written on a replica will be easily deleted after resync with the master) but</span></span><br><span class="line"><span class="comment"># may also cause problems if clients are writing to it because of a</span></span><br><span class="line"><span class="comment"># misconfiguration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Since Redis 2.6 by default replicas are read-only.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note: read only replicas are not designed to be exposed to untrusted clients</span></span><br><span class="line"><span class="comment"># on the internet. It's just a protection layer against misuse of the instance.</span></span><br><span class="line"><span class="comment"># Still a read only replica exports by default all the administrative commands</span></span><br><span class="line"><span class="comment"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span></span><br><span class="line"><span class="comment"># security of read only replicas using 'rename-command' to shadow all the</span></span><br><span class="line"><span class="comment"># administrative / dangerous commands.</span></span><br><span class="line"><span class="string">replica-read-only</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication SYNC strategy: disk or socket.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># New replicas and reconnecting replicas that are not able to continue the</span></span><br><span class="line"><span class="comment"># replication process just receiving differences, need to do what is called a</span></span><br><span class="line"><span class="comment"># "full synchronization". An RDB file is transmitted from the master to the</span></span><br><span class="line"><span class="comment"># replicas.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The transmission can happen in two different ways:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span></span><br><span class="line"><span class="comment">#                 file on disk. Later the file is transferred by the parent</span></span><br><span class="line"><span class="comment">#                 process to the replicas incrementally.</span></span><br><span class="line"><span class="comment"># 2) Diskless: The Redis master creates a new process that directly writes the</span></span><br><span class="line"><span class="comment">#              RDB file to replica sockets, without touching the disk at all.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># With disk-backed replication, while the RDB file is generated, more replicas</span></span><br><span class="line"><span class="comment"># can be queued and served with the RDB file as soon as the current child</span></span><br><span class="line"><span class="comment"># producing the RDB file finishes its work. With diskless replication instead</span></span><br><span class="line"><span class="comment"># once the transfer starts, new replicas arriving will be queued and a new</span></span><br><span class="line"><span class="comment"># transfer will start when the current one terminates.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When diskless replication is used, the master waits a configurable amount of</span></span><br><span class="line"><span class="comment"># time (in seconds) before starting the transfer in the hope that multiple</span></span><br><span class="line"><span class="comment"># replicas will arrive and the transfer can be parallelized.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># With slow disks and fast (large bandwidth) networks, diskless replication</span></span><br><span class="line"><span class="comment"># works better.</span></span><br><span class="line"><span class="string">repl-diskless-sync</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When diskless replication is enabled, it is possible to configure the delay</span></span><br><span class="line"><span class="comment"># the server waits in order to spawn the child that transfers the RDB via socket</span></span><br><span class="line"><span class="comment"># to the replicas.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is important since once the transfer starts, it is not possible to serve</span></span><br><span class="line"><span class="comment"># new replicas arriving, that will be queued for the next RDB transfer, so the</span></span><br><span class="line"><span class="comment"># server waits a delay in order to let more replicas arrive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The delay is specified in seconds, and by default is 5 seconds. To disable</span></span><br><span class="line"><span class="comment"># it entirely just set it to 0 seconds and the transfer will start ASAP.</span></span><br><span class="line"><span class="string">repl-diskless-sync-delay</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># WARNING: RDB diskless load is experimental. Since in this setup the replica</span></span><br><span class="line"><span class="comment"># does not immediately store an RDB on disk, it may cause data loss during</span></span><br><span class="line"><span class="comment"># failovers. RDB diskless load + Redis modules not handling I/O reads may also</span></span><br><span class="line"><span class="comment"># cause Redis to abort in case of I/O errors during the initial synchronization</span></span><br><span class="line"><span class="comment"># stage with the master. Use only if your do what you are doing.</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Replica can load the RDB it reads from the replication link directly from the</span></span><br><span class="line"><span class="comment"># socket, or store the RDB to a file and read that file after it was completely</span></span><br><span class="line"><span class="comment"># recived from the master.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In many cases the disk is slower than the network, and storing and loading</span></span><br><span class="line"><span class="comment"># the RDB file may increase replication time (and even increase the master's</span></span><br><span class="line"><span class="comment"># Copy on Write memory and salve buffers).</span></span><br><span class="line"><span class="comment"># However, parsing the RDB file directly from the socket may mean that we have</span></span><br><span class="line"><span class="comment"># to flush the contents of the current database before the full rdb was</span></span><br><span class="line"><span class="comment"># received. For this reason we have the following options:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># "disabled"    - Don't use diskless load (store the rdb file to the disk first)</span></span><br><span class="line"><span class="comment"># "on-empty-db" - Use diskless load only when it is completely safe.</span></span><br><span class="line"><span class="comment"># "swapdb"      - Keep a copy of the current db contents in RAM while parsing</span></span><br><span class="line"><span class="comment">#                 the data directly from the socket. note that this requires</span></span><br><span class="line"><span class="comment">#                 sufficient memory, if you don't have it, you risk an OOM kill.</span></span><br><span class="line"><span class="string">repl-diskless-load</span> <span class="string">disabled</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replicas send PINGs to server in a predefined interval. It's possible to</span></span><br><span class="line"><span class="comment"># change this interval with the repl_ping_replica_period option. The default</span></span><br><span class="line"><span class="comment"># value is 10 seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-ping-replica-period 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The following option sets the replication timeout for:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) Bulk transfer I/O during SYNC, from the point of view of replica.</span></span><br><span class="line"><span class="comment"># 2) Master timeout from the point of view of replicas (data, pings).</span></span><br><span class="line"><span class="comment"># 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is important to make sure that this value is greater than the value</span></span><br><span class="line"><span class="comment"># specified for repl-ping-replica-period otherwise a timeout will be detected</span></span><br><span class="line"><span class="comment"># every time there is low traffic between the master and the replica.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-timeout 60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable TCP_NODELAY on the replica socket after SYNC?</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you select "yes" Redis will use a smaller number of TCP packets and</span></span><br><span class="line"><span class="comment"># less bandwidth to send data to replicas. But this can add a delay for</span></span><br><span class="line"><span class="comment"># the data to appear on the replica side, up to 40 milliseconds with</span></span><br><span class="line"><span class="comment"># Linux kernels using a default configuration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you select "no" the delay for data to appear on the replica side will</span></span><br><span class="line"><span class="comment"># be reduced but more bandwidth will be used for replication.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default we optimize for low latency, but in very high traffic conditions</span></span><br><span class="line"><span class="comment"># or when the master and replicas are many hops away, turning this to "yes" may</span></span><br><span class="line"><span class="comment"># be a good idea.</span></span><br><span class="line"><span class="string">repl-disable-tcp-nodelay</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the replication backlog size. The backlog is a buffer that accumulates</span></span><br><span class="line"><span class="comment"># replica data when replicas are disconnected for some time, so that when a</span></span><br><span class="line"><span class="comment"># replica wants to reconnect again, often a full resync is not needed, but a</span></span><br><span class="line"><span class="comment"># partial resync is enough, just passing the portion of data the replica</span></span><br><span class="line"><span class="comment"># missed while disconnected.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The bigger the replication backlog, the longer the time the replica can be</span></span><br><span class="line"><span class="comment"># disconnected and later be able to perform a partial resynchronization.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The backlog is only allocated once there is at least a replica connected.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-backlog-size 1mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># After a master has no longer connected replicas for some time, the backlog</span></span><br><span class="line"><span class="comment"># will be freed. The following option configures the amount of seconds that</span></span><br><span class="line"><span class="comment"># need to elapse, starting from the time the last replica disconnected, for</span></span><br><span class="line"><span class="comment"># the backlog buffer to be freed.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that replicas never free the backlog for timeout, since they may be</span></span><br><span class="line"><span class="comment"># promoted to masters later, and should be able to correctly "partially</span></span><br><span class="line"><span class="comment"># resynchronize" with the replicas: hence they should always accumulate backlog.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A value of 0 means to never release the backlog.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-backlog-ttl 3600</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The replica priority is an integer number published by Redis in the INFO</span></span><br><span class="line"><span class="comment"># output. It is used by Redis Sentinel in order to select a replica to promote</span></span><br><span class="line"><span class="comment"># into a master if the master is no longer working correctly.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A replica with a low priority number is considered better for promotion, so</span></span><br><span class="line"><span class="comment"># for instance if there are three replicas with priority 10, 100, 25 Sentinel</span></span><br><span class="line"><span class="comment"># will pick the one with priority 10, that is the lowest.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However a special priority of 0 marks the replica as not able to perform the</span></span><br><span class="line"><span class="comment"># role of master, so a replica with priority of 0 will never be selected by</span></span><br><span class="line"><span class="comment"># Redis Sentinel for promotion.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default the priority is 100.</span></span><br><span class="line"><span class="string">replica-priority</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># It is possible for a master to stop accepting writes if there are less than</span></span><br><span class="line"><span class="comment"># N replicas connected, having a lag less or equal than M seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The N replicas need to be in "online" state.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The lag in seconds, that must be &lt;= the specified value, is calculated from</span></span><br><span class="line"><span class="comment"># the last ping received from the replica, that is usually sent every second.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This option does not GUARANTEE that N replicas will accept the write, but</span></span><br><span class="line"><span class="comment"># will limit the window of exposure for lost writes in case not enough replicas</span></span><br><span class="line"><span class="comment"># are available, to the specified number of seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># min-replicas-to-write 3</span></span><br><span class="line"><span class="comment"># min-replicas-max-lag 10</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Setting one or the other to 0 disables the feature.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default min-replicas-to-write is set to 0 (feature disabled) and</span></span><br><span class="line"><span class="comment"># min-replicas-max-lag is set to 10.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A Redis master is able to list the address and port of the attached</span></span><br><span class="line"><span class="comment"># replicas in different ways. For example the "INFO replication" section</span></span><br><span class="line"><span class="comment"># offers this information, which is used, among other tools, by</span></span><br><span class="line"><span class="comment"># Redis Sentinel in order to discover replica instances.</span></span><br><span class="line"><span class="comment"># Another place where this info is available is in the output of the</span></span><br><span class="line"><span class="comment"># "ROLE" command of a master.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The listed IP and address normally reported by a replica is obtained</span></span><br><span class="line"><span class="comment"># in the following way:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   IP: The address is auto detected by checking the peer address</span></span><br><span class="line"><span class="comment">#   of the socket used by the replica to connect with the master.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Port: The port is communicated by the replica during the replication</span></span><br><span class="line"><span class="comment">#   handshake, and is normally the port that the replica is using to</span></span><br><span class="line"><span class="comment">#   listen for connections.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However when port forwarding or Network Address Translation (NAT) is</span></span><br><span class="line"><span class="comment"># used, the replica may be actually reachable via different IP and port</span></span><br><span class="line"><span class="comment"># pairs. The following two options can be used by a replica in order to</span></span><br><span class="line"><span class="comment"># report to its master a specific set of IP and port, so that both INFO</span></span><br><span class="line"><span class="comment"># and ROLE will report those values.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># There is no need to use both the options if you need to override just</span></span><br><span class="line"><span class="comment"># the port or the IP address.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># replica-announce-ip 5.5.5.5</span></span><br><span class="line"><span class="comment"># replica-announce-port 1234</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################### KEYS TRACKING #################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis implements server assisted support for client side caching of values.</span></span><br><span class="line"><span class="comment"># This is implemented using an invalidation table that remembers, using</span></span><br><span class="line"><span class="comment"># 16 millions of slots, what clients may have certain subsets of keys. In turn</span></span><br><span class="line"><span class="comment"># this is used in order to send invalidation messages to clients. Please</span></span><br><span class="line"><span class="comment"># to understand more about the feature check this page:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   https://redis.io/topics/client-side-caching</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When tracking is enabled for a client, all the read only queries are assumed</span></span><br><span class="line"><span class="comment"># to be cached: this will force Redis to store information in the invalidation</span></span><br><span class="line"><span class="comment"># table. When keys are modified, such information is flushed away, and</span></span><br><span class="line"><span class="comment"># invalidation messages are sent to the clients. However if the workload is</span></span><br><span class="line"><span class="comment"># heavily dominated by reads, Redis could use more and more memory in order</span></span><br><span class="line"><span class="comment"># to track the keys fetched by many clients.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For this reason it is possible to configure a maximum fill value for the</span></span><br><span class="line"><span class="comment"># invalidation table. By default it is set to 1M of keys, and once this limit</span></span><br><span class="line"><span class="comment"># is reached, Redis will start to evict keys in the invalidation table</span></span><br><span class="line"><span class="comment"># even if they were not modified, just to reclaim memory: this will in turn</span></span><br><span class="line"><span class="comment"># force the clients to invalidate the cached values. Basically the table</span></span><br><span class="line"><span class="comment"># maximum size is a trade off between the memory you want to spend server</span></span><br><span class="line"><span class="comment"># side to track information about who cached what, and the ability of clients</span></span><br><span class="line"><span class="comment"># to retain cached objects in memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you set the value to 0, it means there are no limits, and Redis will</span></span><br><span class="line"><span class="comment"># retain as many keys as needed in the invalidation table.</span></span><br><span class="line"><span class="comment"># In the "stats" INFO section, you can find information about the number of</span></span><br><span class="line"><span class="comment"># keys in the invalidation table at every given moment.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note: when key tracking is used in broadcasting mode, no memory is used</span></span><br><span class="line"><span class="comment"># in the server side so this setting is useless.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tracking-table-max-keys 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## SECURITY ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Warning: since Redis is pretty fast an outside user can try up to</span></span><br><span class="line"><span class="comment"># 1 million passwords per second against a modern box. This means that you</span></span><br><span class="line"><span class="comment"># should use very strong passwords, otherwise they will be very easy to break.</span></span><br><span class="line"><span class="comment"># Note that because the password is really a shared secret between the client</span></span><br><span class="line"><span class="comment"># and the server, and should not be memorized by any human, the password</span></span><br><span class="line"><span class="comment"># can be easily a long string from /dev/urandom or whatever, so by using a</span></span><br><span class="line"><span class="comment"># long and unguessable password no brute force attack will be possible.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis ACL users are defined in the following format:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   user &lt;username&gt; ... acl rules ...</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The special username "default" is used for new connections. If this user</span></span><br><span class="line"><span class="comment"># has the "nopass" rule, then new connections will be immediately authenticated</span></span><br><span class="line"><span class="comment"># as the "default" user without the need of any password provided via the</span></span><br><span class="line"><span class="comment"># AUTH command. Otherwise if the "default" user is not flagged with "nopass"</span></span><br><span class="line"><span class="comment"># the connections will start in not authenticated state, and will require</span></span><br><span class="line"><span class="comment"># AUTH (or the HELLO command AUTH option) in order to be authenticated and</span></span><br><span class="line"><span class="comment"># start to work.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The ACL rules that describe what an user can do are the following:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  on           Enable the user: it is possible to authenticate as this user.</span></span><br><span class="line"><span class="comment">#  off          Disable the user: it's no longer possible to authenticate</span></span><br><span class="line"><span class="comment">#               with this user, however the already authenticated connections</span></span><br><span class="line"><span class="comment">#               will still work.</span></span><br><span class="line"><span class="comment">#  +&lt;command&gt;   Allow the execution of that command</span></span><br><span class="line"><span class="comment">#  -&lt;command&gt;   Disallow the execution of that command</span></span><br><span class="line"><span class="comment">#  +@&lt;category&gt; Allow the execution of all the commands in such category</span></span><br><span class="line"><span class="comment">#               with valid categories are like @admin, @set, @sortedset, ...</span></span><br><span class="line"><span class="comment">#               and so forth, see the full list in the server.c file where</span></span><br><span class="line"><span class="comment">#               the Redis command table is described and defined.</span></span><br><span class="line"><span class="comment">#               The special category @all means all the commands, but currently</span></span><br><span class="line"><span class="comment">#               present in the server, and that will be loaded in the future</span></span><br><span class="line"><span class="comment">#               via modules.</span></span><br><span class="line"><span class="comment">#  +&lt;command&gt;|subcommand    Allow a specific subcommand of an otherwise</span></span><br><span class="line"><span class="comment">#                           disabled command. Note that this form is not</span></span><br><span class="line"><span class="comment">#                           allowed as negative like -DEBUG|SEGFAULT, but</span></span><br><span class="line"><span class="comment">#                           only additive starting with "+".</span></span><br><span class="line"><span class="comment">#  allcommands  Alias for +@all. Note that it implies the ability to execute</span></span><br><span class="line"><span class="comment">#               all the future commands loaded via the modules system.</span></span><br><span class="line"><span class="comment">#  nocommands   Alias for -@all.</span></span><br><span class="line"><span class="comment">#  ~&lt;pattern&gt;   Add a pattern of keys that can be mentioned as part of</span></span><br><span class="line"><span class="comment">#               commands. For instance ~* allows all the keys. The pattern</span></span><br><span class="line"><span class="comment">#               is a glob-style pattern like the one of KEYS.</span></span><br><span class="line"><span class="comment">#               It is possible to specify multiple patterns.</span></span><br><span class="line"><span class="comment">#  allkeys      Alias for ~*</span></span><br><span class="line"><span class="comment">#  resetkeys    Flush the list of allowed keys patterns.</span></span><br><span class="line"><span class="comment">#  &gt;&lt;password&gt;  Add this passowrd to the list of valid password for the user.</span></span><br><span class="line"><span class="comment">#               For example &gt;mypass will add "mypass" to the list.</span></span><br><span class="line"><span class="comment">#               This directive clears the "nopass" flag (see later).</span></span><br><span class="line"><span class="comment">#  &lt;&lt;password&gt;  Remove this password from the list of valid passwords.</span></span><br><span class="line"><span class="comment">#  nopass       All the set passwords of the user are removed, and the user</span></span><br><span class="line"><span class="comment">#               is flagged as requiring no password: it means that every</span></span><br><span class="line"><span class="comment">#               password will work against this user. If this directive is</span></span><br><span class="line"><span class="comment">#               used for the default user, every new connection will be</span></span><br><span class="line"><span class="comment">#               immediately authenticated with the default user without</span></span><br><span class="line"><span class="comment">#               any explicit AUTH command required. Note that the "resetpass"</span></span><br><span class="line"><span class="comment">#               directive will clear this condition.</span></span><br><span class="line"><span class="comment">#  resetpass    Flush the list of allowed passwords. Moreover removes the</span></span><br><span class="line"><span class="comment">#               "nopass" status. After "resetpass" the user has no associated</span></span><br><span class="line"><span class="comment">#               passwords and there is no way to authenticate without adding</span></span><br><span class="line"><span class="comment">#               some password (or setting it as "nopass" later).</span></span><br><span class="line"><span class="comment">#  reset        Performs the following actions: resetpass, resetkeys, off,</span></span><br><span class="line"><span class="comment">#               -@all. The user returns to the same state it has immediately</span></span><br><span class="line"><span class="comment">#               after its creation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ACL rules can be specified in any order: for instance you can start with</span></span><br><span class="line"><span class="comment"># passwords, then flags, or key patterns. However note that the additive</span></span><br><span class="line"><span class="comment"># and subtractive rules will CHANGE MEANING depending on the ordering.</span></span><br><span class="line"><span class="comment"># For instance see the following example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   user alice on +@all -DEBUG ~* &gt;somepassword</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This will allow "alice" to use all the commands with the exception of the</span></span><br><span class="line"><span class="comment"># DEBUG command, since +@all added all the commands to the set of the commands</span></span><br><span class="line"><span class="comment"># alice can use, and later DEBUG was removed. However if we invert the order</span></span><br><span class="line"><span class="comment"># of two ACL rules the result will be different:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   user alice on -DEBUG +@all ~* &gt;somepassword</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Now DEBUG was removed when alice had yet no commands in the set of allowed</span></span><br><span class="line"><span class="comment"># commands, later all the commands are added, so the user will be able to</span></span><br><span class="line"><span class="comment"># execute everything.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Basically ACL rules are processed left-to-right.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information about ACL configuration please refer to</span></span><br><span class="line"><span class="comment"># the Redis web site at https://redis.io/topics/acl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ACL LOG</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The ACL Log tracks failed commands and authentication events associated</span></span><br><span class="line"><span class="comment"># with ACLs. The ACL Log is useful to troubleshoot failed commands blocked </span></span><br><span class="line"><span class="comment"># by ACLs. The ACL Log is stored in and consumes memory. There is no limit</span></span><br><span class="line"><span class="comment"># to its length.You can reclaim memory with ACL LOG RESET or set a maximum</span></span><br><span class="line"><span class="comment"># length below.</span></span><br><span class="line"><span class="string">acllog-max-len</span> <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using an external ACL file</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Instead of configuring users here in this file, it is possible to use</span></span><br><span class="line"><span class="comment"># a stand-alone file just listing users. The two methods cannot be mixed:</span></span><br><span class="line"><span class="comment"># if you configure users here and at the same time you activate the exteranl</span></span><br><span class="line"><span class="comment"># ACL file, the server will refuse to start.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The format of the external ACL user file is exactly the same as the</span></span><br><span class="line"><span class="comment"># format that is used inside redis.conf to describe users.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># aclfile /etc/redis/users.acl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IMPORTANT <span class="doctag">NOTE:</span> starting with Redis 6 "requirepass" is just a compatiblity</span></span><br><span class="line"><span class="comment"># layer on top of the new ACL system. The option effect will be just setting</span></span><br><span class="line"><span class="comment"># the password for the default user. Clients will still authenticate using</span></span><br><span class="line"><span class="comment"># AUTH &lt;password&gt; as usually, or more explicitly with AUTH default &lt;password&gt;</span></span><br><span class="line"><span class="comment"># if they follow the new protocol: both will work.</span></span><br><span class="line"><span class="comment"># 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过auth &lt;password&gt;命令提供密码，默认关闭</span></span><br><span class="line"><span class="comment"># requirepass 123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Command renaming (DEPRECATED).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># WARNING: avoid using this option if possible. Instead use ACLs to remove</span></span><br><span class="line"><span class="comment"># commands from the default user, and put them only in some admin user you</span></span><br><span class="line"><span class="comment"># create for administrative purposes.</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is possible to change the name of dangerous commands in a shared</span></span><br><span class="line"><span class="comment"># environment. For instance the CONFIG command may be renamed into something</span></span><br><span class="line"><span class="comment"># hard to guess so that it will still be available for internal-use tools</span></span><br><span class="line"><span class="comment"># but not available for general clients.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is also possible to completely kill a command by renaming it into</span></span><br><span class="line"><span class="comment"># an empty string:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rename-command CONFIG ""</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please note that changing the name of commands that are logged into the</span></span><br><span class="line"><span class="comment"># AOF file or transmitted to replicas may cause problems.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################### CLIENTS ####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the max number of connected clients at the same time. By default</span></span><br><span class="line"><span class="comment"># this limit is set to 10000 clients, however if the Redis server is not</span></span><br><span class="line"><span class="comment"># able to configure the process file limit to allow for the specified limit</span></span><br><span class="line"><span class="comment"># the max number of allowed clients is set to the current file limit</span></span><br><span class="line"><span class="comment"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Once the limit is reached Redis will close all the new connections sending</span></span><br><span class="line"><span class="comment"># an error 'max number of clients reached'.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxclients 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################## MEMORY MANAGEMENT ################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set a memory usage limit to the specified amount of bytes.</span></span><br><span class="line"><span class="comment"># When the memory limit is reached Redis will try to remove keys</span></span><br><span class="line"><span class="comment"># according to the eviction policy selected (see maxmemory-policy).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If Redis can't remove keys according to the policy, or if the policy is</span></span><br><span class="line"><span class="comment"># set to 'noeviction', Redis will start to reply with errors to commands</span></span><br><span class="line"><span class="comment"># that would use more memory, like SET, LPUSH, and so on, and will continue</span></span><br><span class="line"><span class="comment"># to reply to read-only commands like GET.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This option is usually useful when using Redis as an LRU or LFU cache, or to</span></span><br><span class="line"><span class="comment"># set a hard memory limit for an instance (using the 'noeviction' policy).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># WARNING: If you have replicas attached to an instance with maxmemory on,</span></span><br><span class="line"><span class="comment"># the size of the output buffers needed to feed the replicas are subtracted</span></span><br><span class="line"><span class="comment"># from the used memory count, so that network problems / resyncs will</span></span><br><span class="line"><span class="comment"># not trigger a loop where keys are evicted, and in turn the output</span></span><br><span class="line"><span class="comment"># buffer of replicas is full with DELs of keys evicted triggering the deletion</span></span><br><span class="line"><span class="comment"># of more keys, and so forth until the database is completely emptied.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In short... if you have replicas attached it is suggested that you set a lower</span></span><br><span class="line"><span class="comment"># limit for maxmemory so that there is some free RAM on the system for replica</span></span><br><span class="line"><span class="comment"># output buffers (but this is not needed if the policy is 'noeviction').</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#设置redis占用最大内存数，如果超过redis会试图删除即将过期的key，而保护具有较长生命周期的key</span></span><br><span class="line"><span class="string">maxmemory</span> <span class="number">5</span><span class="string">gb</span></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span></span><br><span class="line"><span class="comment"># is reached. You can select one from the following behaviors:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span></span><br><span class="line"><span class="comment"># allkeys-lru -&gt; Evict any key using approximated LRU.</span></span><br><span class="line"><span class="comment"># volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.</span></span><br><span class="line"><span class="comment"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span></span><br><span class="line"><span class="comment"># volatile-random -&gt; Remove a random key having an expire set.</span></span><br><span class="line"><span class="comment"># allkeys-random -&gt; Remove a random key, any key.</span></span><br><span class="line"><span class="comment"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span></span><br><span class="line"><span class="comment"># noeviction -&gt; Don't evict anything, just return an error on write operations.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LRU means Least Recently Used</span></span><br><span class="line"><span class="comment"># LFU means Least Frequently Used</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Both LRU, LFU and volatile-ttl are implemented using approximated</span></span><br><span class="line"><span class="comment"># randomized algorithms.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note: with any of the above policies, Redis will return an error on write</span></span><br><span class="line"><span class="comment">#       operations, when there are no suitable keys for eviction.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       At the date of writing these commands are: set setnx setex append</span></span><br><span class="line"><span class="comment">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span></span><br><span class="line"><span class="comment">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span></span><br><span class="line"><span class="comment">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span></span><br><span class="line"><span class="comment">#       getset mset msetnx exec sort</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#当内存占用超过maxmemory限定时，触发主动清理策略</span></span><br><span class="line"><span class="comment">#清理策略方式如下：</span></span><br><span class="line"><span class="comment">#volatile-lru：只对设置了过期时间的key进行LRU（默认值）</span></span><br><span class="line"><span class="comment">#allkeys-lru ： 删除lru算法的key</span></span><br><span class="line"><span class="comment">#volatile-random：随机删除即将过期key</span></span><br><span class="line"><span class="comment">#allkeys-random：随机删除</span></span><br><span class="line"><span class="comment">#volatile-ttl ： 删除即将过期的</span></span><br><span class="line"><span class="comment">#noeviction ： 永不过期，返回错误</span></span><br><span class="line"><span class="string">maxmemory-policy</span> <span class="string">allkeys-lru</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span></span><br><span class="line"><span class="comment"># algorithms (in order to save memory), so you can tune it for speed or</span></span><br><span class="line"><span class="comment"># accuracy. For default Redis will check five keys and pick the one that was</span></span><br><span class="line"><span class="comment"># used less recently, you can change the sample size using the following</span></span><br><span class="line"><span class="comment"># configuration directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default of 5 produces good enough results. 10 Approximates very closely</span></span><br><span class="line"><span class="comment"># true LRU but costs more CPU. 3 is faster but not very accurate.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory-samples 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Starting from Redis 5, by default a replica will ignore its maxmemory setting</span></span><br><span class="line"><span class="comment"># (unless it is promoted to master after a failover or manually). It means</span></span><br><span class="line"><span class="comment"># that the eviction of keys will be just handled by the master, sending the</span></span><br><span class="line"><span class="comment"># DEL commands to the replica as keys evict in the master side.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This behavior ensures that masters and replicas stay consistent, and is usually</span></span><br><span class="line"><span class="comment"># what you want, however if your replica is writable, or you want the replica</span></span><br><span class="line"><span class="comment"># to have a different memory setting, and you are sure all the writes performed</span></span><br><span class="line"><span class="comment"># to the replica are idempotent, then you may change this default (but be sure</span></span><br><span class="line"><span class="comment"># to understand what you are doing).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that since the replica by default does not evict, it may end using more</span></span><br><span class="line"><span class="comment"># memory than the one set via maxmemory (there are certain buffers that may</span></span><br><span class="line"><span class="comment"># be larger on the replica, or data structures may sometimes take more memory</span></span><br><span class="line"><span class="comment"># and so forth). So make sure you monitor your replicas and make sure they</span></span><br><span class="line"><span class="comment"># have enough memory to never hit a real out-of-memory condition before the</span></span><br><span class="line"><span class="comment"># master hits the configured maxmemory setting.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># replica-ignore-maxmemory yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis reclaims expired keys in two ways: upon access when those keys are</span></span><br><span class="line"><span class="comment"># found to be expired, and also in background, in what is called the</span></span><br><span class="line"><span class="comment"># "active expire key". The key space is slowly and interactively scanned</span></span><br><span class="line"><span class="comment"># looking for expired keys to reclaim, so that it is possible to free memory</span></span><br><span class="line"><span class="comment"># of keys that are expired and will never be accessed again in a short time.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default effort of the expire cycle will try to avoid having more than</span></span><br><span class="line"><span class="comment"># ten percent of expired keys still in memory, and will try to avoid consuming</span></span><br><span class="line"><span class="comment"># more than 25% of total memory and to add latency to the system. However</span></span><br><span class="line"><span class="comment"># it is possible to increase the expire "effort" that is normally set to</span></span><br><span class="line"><span class="comment"># "1", to a greater value, up to the value "10". At its maximum value the</span></span><br><span class="line"><span class="comment"># system will use more CPU, longer cycles (and technically may introduce</span></span><br><span class="line"><span class="comment"># more latency), and will tollerate less already expired keys still present</span></span><br><span class="line"><span class="comment"># in the system. It's a tradeoff betweeen memory, CPU and latecy.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># active-expire-effort 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# LAZY FREEING ####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis has two primitives to delete keys. One is called DEL and is a blocking</span></span><br><span class="line"><span class="comment"># deletion of the object. It means that the server stops processing new commands</span></span><br><span class="line"><span class="comment"># in order to reclaim all the memory associated with an object in a synchronous</span></span><br><span class="line"><span class="comment"># way. If the key deleted is associated with a small object, the time needed</span></span><br><span class="line"><span class="comment"># in order to execute the DEL command is very small and comparable to most other</span></span><br><span class="line"><span class="comment"># O(1) or O(log_N) commands in Redis. However if the key is associated with an</span></span><br><span class="line"><span class="comment"># aggregated value containing millions of elements, the server can block for</span></span><br><span class="line"><span class="comment"># a long time (even seconds) in order to complete the operation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For the above reasons Redis also offers non blocking deletion primitives</span></span><br><span class="line"><span class="comment"># such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span></span><br><span class="line"><span class="comment"># FLUSHDB commands, in order to reclaim memory in background. Those commands</span></span><br><span class="line"><span class="comment"># are executed in constant time. Another thread will incrementally free the</span></span><br><span class="line"><span class="comment"># object in the background as fast as possible.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span></span><br><span class="line"><span class="comment"># It's up to the design of the application to understand when it is a good</span></span><br><span class="line"><span class="comment"># idea to use one or the other. However the Redis server sometimes has to</span></span><br><span class="line"><span class="comment"># delete keys or flush the whole database as a side effect of other operations.</span></span><br><span class="line"><span class="comment"># Specifically Redis deletes objects independently of a user call in the</span></span><br><span class="line"><span class="comment"># following scenarios:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) On eviction, because of the maxmemory and maxmemory policy configurations,</span></span><br><span class="line"><span class="comment">#    in order to make room for new data, without going over the specified</span></span><br><span class="line"><span class="comment">#    memory limit.</span></span><br><span class="line"><span class="comment"># 2) Because of expire: when a key with an associated time to live (see the</span></span><br><span class="line"><span class="comment">#    EXPIRE command) must be deleted from memory.</span></span><br><span class="line"><span class="comment"># 3) Because of a side effect of a command that stores data on a key that may</span></span><br><span class="line"><span class="comment">#    already exist. For example the RENAME command may delete the old key</span></span><br><span class="line"><span class="comment">#    content when it is replaced with another one. Similarly SUNIONSTORE</span></span><br><span class="line"><span class="comment">#    or SORT with STORE option may delete existing keys. The SET command</span></span><br><span class="line"><span class="comment">#    itself removes any old content of the specified key in order to replace</span></span><br><span class="line"><span class="comment">#    it with the specified string.</span></span><br><span class="line"><span class="comment"># 4) During replication, when a replica performs a full resynchronization with</span></span><br><span class="line"><span class="comment">#    its master, the content of the whole database is removed in order to</span></span><br><span class="line"><span class="comment">#    load the RDB file just transferred.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In all the above cases the default is to delete objects in a blocking way,</span></span><br><span class="line"><span class="comment"># like if DEL was called. However you can configure each case specifically</span></span><br><span class="line"><span class="comment"># in order to instead release memory in a non-blocking way like if UNLINK</span></span><br><span class="line"><span class="comment"># was called, using the following configuration directives.</span></span><br><span class="line"></span><br><span class="line"><span class="string">lazyfree-lazy-eviction</span> <span class="literal">no</span></span><br><span class="line"><span class="string">lazyfree-lazy-expire</span> <span class="literal">no</span></span><br><span class="line"><span class="string">lazyfree-lazy-server-del</span> <span class="literal">no</span></span><br><span class="line"><span class="string">replica-lazy-flush</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># It is also possible, for the case when to replace the user code DEL calls</span></span><br><span class="line"><span class="comment"># with UNLINK calls is not easy, to modify the default behavior of the DEL</span></span><br><span class="line"><span class="comment"># command to act exactly like UNLINK, using the following configuration</span></span><br><span class="line"><span class="comment"># directive:</span></span><br><span class="line"></span><br><span class="line"><span class="string">lazyfree-lazy-user-del</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ THREADED I/O #################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis is mostly single threaded, however there are certain threaded</span></span><br><span class="line"><span class="comment"># operations such as UNLINK, slow I/O accesses and other things that are</span></span><br><span class="line"><span class="comment"># performed on side threads.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Now it is also possible to handle Redis clients socket reads and writes</span></span><br><span class="line"><span class="comment"># in different I/O threads. Since especially writing is so slow, normally</span></span><br><span class="line"><span class="comment"># Redis users use pipelining in order to speedup the Redis performances per</span></span><br><span class="line"><span class="comment"># core, and spawn multiple instances in order to scale more. Using I/O</span></span><br><span class="line"><span class="comment"># threads it is possible to easily speedup two times Redis without resorting</span></span><br><span class="line"><span class="comment"># to pipelining nor sharding of the instance.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default threading is disabled, we suggest enabling it only in machines</span></span><br><span class="line"><span class="comment"># that have at least 4 or more cores, leaving at least one spare core.</span></span><br><span class="line"><span class="comment"># Using more than 8 threads is unlikely to help much. We also recommend using</span></span><br><span class="line"><span class="comment"># threaded I/O only if you actually have performance problems, with Redis</span></span><br><span class="line"><span class="comment"># instances being able to use a quite big percentage of CPU time, otherwise</span></span><br><span class="line"><span class="comment"># there is no point in using this feature.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># So for instance if you have a four cores boxes, try to use 2 or 3 I/O</span></span><br><span class="line"><span class="comment"># threads, if you have a 8 cores, try to use 6 threads. In order to</span></span><br><span class="line"><span class="comment"># enable I/O threads use the following configuration directive:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># io-threads 4</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Setting io-threads to 1 will just use the main thread as usually.</span></span><br><span class="line"><span class="comment"># When I/O threads are enabled, we only use threads for writes, that is</span></span><br><span class="line"><span class="comment"># to thread the write(2) syscall and transfer the client buffers to the</span></span><br><span class="line"><span class="comment"># socket. However it is also possible to enable threading of reads and</span></span><br><span class="line"><span class="comment"># protocol parsing using the following configuration directive, by setting</span></span><br><span class="line"><span class="comment"># it to yes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># io-threads-do-reads no</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Usually threading reads doesn't help much.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># NOTE 1: This configuration directive cannot be changed at runtime via</span></span><br><span class="line"><span class="comment"># CONFIG SET. Aso this feature currently does not work when SSL is</span></span><br><span class="line"><span class="comment"># enabled.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># NOTE 2: If you want to test the Redis speedup using redis-benchmark, make</span></span><br><span class="line"><span class="comment"># sure you also run the benchmark itself in threaded mode, using the</span></span><br><span class="line"><span class="comment"># --threads option to match the number of Redis theads, otherwise you'll not</span></span><br><span class="line"><span class="comment"># be able to notice the improvements.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis asynchronously dumps the dataset on disk. This mode is</span></span><br><span class="line"><span class="comment"># good enough in many applications, but an issue with the Redis process or</span></span><br><span class="line"><span class="comment"># a power outage may result into a few minutes of writes lost (depending on</span></span><br><span class="line"><span class="comment"># the configured save points).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Append Only File is an alternative persistence mode that provides</span></span><br><span class="line"><span class="comment"># much better durability. For instance using the default data fsync policy</span></span><br><span class="line"><span class="comment"># (see later in the config file) Redis can lose just one second of writes in a</span></span><br><span class="line"><span class="comment"># dramatic event like a server power outage, or a single write if something</span></span><br><span class="line"><span class="comment"># wrong with the Redis process itself happens, but the operating system is</span></span><br><span class="line"><span class="comment"># still running correctly.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># AOF and RDB persistence can be enabled at the same time without problems.</span></span><br><span class="line"><span class="comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class="line"><span class="comment"># with the better durability guarantees.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please check http://redis.io/topics/persistence for more information.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否开启aof功能,"yes"表示开启,在开启情况下,aof文件同步功能才生效,默认为"no",对master机器,建议使用AOF,对于slave,建议关闭</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the append only file (default: "appendonly.aof")</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The fsync() call tells the Operating System to actually write data on disk</span></span><br><span class="line"><span class="comment"># instead of waiting for more data in the output buffer. Some OS will really flush</span></span><br><span class="line"><span class="comment"># data on disk, some other OS will just try to do it ASAP.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis supports three different modes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># no: don't fsync, just let the OS flush the data when it wants. Faster.</span></span><br><span class="line"><span class="comment"># always: fsync after every write to the append only log. Slow, Safest.</span></span><br><span class="line"><span class="comment"># everysec: fsync only one time every second. Compromise.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is "everysec", as that's usually the right compromise between</span></span><br><span class="line"><span class="comment"># speed and data safety. It's up to you to understand if you can relax this to</span></span><br><span class="line"><span class="comment"># "no" that will let the operating system flush the output buffer when</span></span><br><span class="line"><span class="comment"># it wants, for better performances (but if you can live with the idea of</span></span><br><span class="line"><span class="comment"># some data loss consider the default persistence mode that's snapshotting),</span></span><br><span class="line"><span class="comment"># or on the contrary, use "always" that's very slow but a bit safer than</span></span><br><span class="line"><span class="comment"># everysec.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># More details please check the following article:</span></span><br><span class="line"><span class="comment"># http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If unsure, use "everysec".</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line"><span class="comment">#任何一个aof记录都立即进行文件同步(磁盘写入),安全性最高;如果write请求比较密集,将会造成较高的磁盘IO开支和响应延迟，everysec每秒同步一次</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span></span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When the AOF fsync policy is set to always or everysec, and a background</span></span><br><span class="line"><span class="comment"># saving process (a background save or AOF log background rewriting) is</span></span><br><span class="line"><span class="comment"># performing a lot of I/O against the disk, in some Linux configurations</span></span><br><span class="line"><span class="comment"># Redis may block too long on the fsync() call. Note that there is no fix for</span></span><br><span class="line"><span class="comment"># this currently, as even performing fsync in a different thread will block</span></span><br><span class="line"><span class="comment"># our synchronous write(2) call.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to mitigate this problem it's possible to use the following option</span></span><br><span class="line"><span class="comment"># that will prevent fsync() from being called in the main process while a</span></span><br><span class="line"><span class="comment"># BGSAVE or BGREWRITEAOF is in progress.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This means that while another child is saving, the durability of Redis is</span></span><br><span class="line"><span class="comment"># the same as "appendfsync none". In practical terms, this means that it is</span></span><br><span class="line"><span class="comment"># possible to lose up to 30 seconds of log in the worst scenario (with the</span></span><br><span class="line"><span class="comment"># default Linux settings).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you have latency problems turn this to "yes". Otherwise leave it as</span></span><br><span class="line"><span class="comment"># "no" that is the safest pick from the point of view of durability.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在aof rewrite期间,是否对aof新记录的append暂缓使用文件同步策略,主要考虑磁盘IO开支和请求阻塞时间，默认为no,表示"不暂缓",新的aof记录仍然会被立即同步</span></span><br><span class="line"><span class="literal">no</span><span class="bullet">-appendfsync-on-rewrite</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatic rewrite of the append only file.</span></span><br><span class="line"><span class="comment"># Redis is able to automatically rewrite the log file implicitly calling</span></span><br><span class="line"><span class="comment"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is how it works: Redis remembers the size of the AOF file after the</span></span><br><span class="line"><span class="comment"># latest rewrite (if no rewrite has happened since the restart, the size of</span></span><br><span class="line"><span class="comment"># the AOF at startup is used).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This base size is compared to the current size. If the current size is</span></span><br><span class="line"><span class="comment"># bigger than the specified percentage, the rewrite is triggered. Also</span></span><br><span class="line"><span class="comment"># you need to specify a minimal size for the AOF file to be rewritten, this</span></span><br><span class="line"><span class="comment"># is useful to avoid rewriting the AOF file even if the percentage increase</span></span><br><span class="line"><span class="comment"># is reached but it is still pretty small.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Specify a percentage of zero in order to disable the automatic AOF</span></span><br><span class="line"><span class="comment"># rewrite feature.</span></span><br><span class="line"><span class="comment">#aof每次rewrite之后，都会记住当前aof文件的大小，当文件增长到一定比例后，继续进行aof rewrite</span></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage</span> <span class="number">100</span></span><br><span class="line"><span class="comment">#aof rewrite触发时机，最小文件尺寸</span></span><br><span class="line"><span class="string">auto-aof-rewrite-min-size</span> <span class="number">64</span><span class="string">mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># An AOF file may be found to be truncated at the end during the Redis</span></span><br><span class="line"><span class="comment"># startup process, when the AOF data gets loaded back into memory.</span></span><br><span class="line"><span class="comment"># This may happen when the system where Redis is running</span></span><br><span class="line"><span class="comment"># crashes, especially when an ext4 filesystem is mounted without the</span></span><br><span class="line"><span class="comment"># data=ordered option (however this can't happen when Redis itself</span></span><br><span class="line"><span class="comment"># crashes or aborts but the operating system still works correctly).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis can either exit with an error when this happens, or load as much</span></span><br><span class="line"><span class="comment"># data as possible (the default now) and start if the AOF file is found</span></span><br><span class="line"><span class="comment"># to be truncated at the end. The following option controls this behavior.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span></span><br><span class="line"><span class="comment"># the Redis server starts emitting a log to inform the user of the event.</span></span><br><span class="line"><span class="comment"># Otherwise if the option is set to no, the server aborts with an error</span></span><br><span class="line"><span class="comment"># and refuses to start. When the option is set to no, the user requires</span></span><br><span class="line"><span class="comment"># to fix the AOF file using the "redis-check-aof" utility before to restart</span></span><br><span class="line"><span class="comment"># the server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that if the AOF file will be found to be corrupted in the middle</span></span><br><span class="line"><span class="comment"># the server will still exit with an error. This option only applies when</span></span><br><span class="line"><span class="comment"># Redis will try to read more data from the AOF file but not enough bytes</span></span><br><span class="line"><span class="comment"># will be found.</span></span><br><span class="line"><span class="string">aof-load-truncated</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span></span><br><span class="line"><span class="comment"># AOF file for faster rewrites and recoveries. When this option is turned</span></span><br><span class="line"><span class="comment"># on the rewritten AOF file is composed of two different stanzas:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   [RDB file][AOF tail]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When loading Redis recognizes that the AOF file starts with the "REDIS"</span></span><br><span class="line"><span class="comment"># string and loads the prefixed RDB file, and continues loading the AOF</span></span><br><span class="line"><span class="comment"># tail.</span></span><br><span class="line"><span class="string">aof-use-rdb-preamble</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ LUA SCRIPTING  ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Max execution time of a Lua script in milliseconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the maximum execution time is reached Redis will log that a script is</span></span><br><span class="line"><span class="comment"># still in execution after the maximum allowed time and will start to</span></span><br><span class="line"><span class="comment"># reply to queries with an error.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When a long running script exceeds the maximum execution time only the</span></span><br><span class="line"><span class="comment"># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span></span><br><span class="line"><span class="comment"># used to stop a script that did not yet called write commands. The second</span></span><br><span class="line"><span class="comment"># is the only way to shut down the server in the case a write command was</span></span><br><span class="line"><span class="comment"># already issued by the script but the user doesn't want to wait for the natural</span></span><br><span class="line"><span class="comment"># termination of the script.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set it to 0 or a negative value for unlimited execution without warnings.</span></span><br><span class="line"><span class="comment">#lua脚本运行的最大时间</span></span><br><span class="line"><span class="string">lua-time-limit</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ REDIS CLUSTER  ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Normal Redis instances can't be part of a Redis Cluster; only nodes that are</span></span><br><span class="line"><span class="comment"># started as cluster nodes can. In order to start a Redis instance as a</span></span><br><span class="line"><span class="comment"># cluster node enable the cluster support uncommenting the following:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-enabled yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Every cluster node has a cluster configuration file. This file is not</span></span><br><span class="line"><span class="comment"># intended to be edited by hand. It is created and updated by Redis nodes.</span></span><br><span class="line"><span class="comment"># Every Redis Cluster node requires a different cluster configuration file.</span></span><br><span class="line"><span class="comment"># Make sure that instances running in the same system do not have</span></span><br><span class="line"><span class="comment"># overlapping cluster configuration file names.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-config-file nodes-6379.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster node timeout is the amount of milliseconds a node must be unreachable</span></span><br><span class="line"><span class="comment"># for it to be considered in failure state.</span></span><br><span class="line"><span class="comment"># Most other internal time limits are multiple of the node timeout.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-node-timeout 15000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A replica of a failing master will avoid to start a failover if its data</span></span><br><span class="line"><span class="comment"># looks too old.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># There is no simple way for a replica to actually have an exact measure of</span></span><br><span class="line"><span class="comment"># its "data age", so the following two checks are performed:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) If there are multiple replicas able to failover, they exchange messages</span></span><br><span class="line"><span class="comment">#    in order to try to give an advantage to the replica with the best</span></span><br><span class="line"><span class="comment">#    replication offset (more data from the master processed).</span></span><br><span class="line"><span class="comment">#    Replicas will try to get their rank by offset, and apply to the start</span></span><br><span class="line"><span class="comment">#    of the failover a delay proportional to their rank.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2) Every single replica computes the time of the last interaction with</span></span><br><span class="line"><span class="comment">#    its master. This can be the last ping or command received (if the master</span></span><br><span class="line"><span class="comment">#    is still in the "connected" state), or the time that elapsed since the</span></span><br><span class="line"><span class="comment">#    disconnection with the master (if the replication link is currently down).</span></span><br><span class="line"><span class="comment">#    If the last interaction is too old, the replica will not try to failover</span></span><br><span class="line"><span class="comment">#    at all.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The point "2" can be tuned by user. Specifically a replica will not perform</span></span><br><span class="line"><span class="comment"># the failover if, since the last interaction with the master, the time</span></span><br><span class="line"><span class="comment"># elapsed is greater than:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   (node-timeout * replica-validity-factor) + repl-ping-replica-period</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># So for example if node-timeout is 30 seconds, and the replica-validity-factor</span></span><br><span class="line"><span class="comment"># is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</span></span><br><span class="line"><span class="comment"># replica will not try to failover if it was not able to talk with the master</span></span><br><span class="line"><span class="comment"># for longer than 310 seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A large replica-validity-factor may allow replicas with too old data to failover</span></span><br><span class="line"><span class="comment"># a master, while a too small value may prevent the cluster from being able to</span></span><br><span class="line"><span class="comment"># elect a replica at all.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For maximum availability, it is possible to set the replica-validity-factor</span></span><br><span class="line"><span class="comment"># to a value of 0, which means, that replicas will always try to failover the</span></span><br><span class="line"><span class="comment"># master regardless of the last time they interacted with the master.</span></span><br><span class="line"><span class="comment"># (However they'll always try to apply a delay proportional to their</span></span><br><span class="line"><span class="comment"># offset rank).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Zero is the only value able to guarantee that when all the partitions heal</span></span><br><span class="line"><span class="comment"># the cluster will always be able to continue.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-replica-validity-factor 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster replicas are able to migrate to orphaned masters, that are masters</span></span><br><span class="line"><span class="comment"># that are left without working replicas. This improves the cluster ability</span></span><br><span class="line"><span class="comment"># to resist to failures as otherwise an orphaned master can't be failed over</span></span><br><span class="line"><span class="comment"># in case of failure if it has no working replicas.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Replicas migrate to orphaned masters only if there are still at least a</span></span><br><span class="line"><span class="comment"># given number of other working replicas for their old master. This number</span></span><br><span class="line"><span class="comment"># is the "migration barrier". A migration barrier of 1 means that a replica</span></span><br><span class="line"><span class="comment"># will migrate only if there is at least 1 other working replica for its master</span></span><br><span class="line"><span class="comment"># and so forth. It usually reflects the number of replicas you want for every</span></span><br><span class="line"><span class="comment"># master in your cluster.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Default is 1 (replicas migrate only if their masters remain with at least</span></span><br><span class="line"><span class="comment"># one replica). To disable migration just set it to a very large value.</span></span><br><span class="line"><span class="comment"># A value of 0 can be set but is useful only for debugging and dangerous</span></span><br><span class="line"><span class="comment"># in production.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-migration-barrier 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis Cluster nodes stop accepting queries if they detect there</span></span><br><span class="line"><span class="comment"># is at least an hash slot uncovered (no available node is serving it).</span></span><br><span class="line"><span class="comment"># This way if the cluster is partially down (for example a range of hash slots</span></span><br><span class="line"><span class="comment"># are no longer covered) all the cluster becomes, eventually, unavailable.</span></span><br><span class="line"><span class="comment"># It automatically returns available as soon as all the slots are covered again.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However sometimes you want the subset of the cluster which is working,</span></span><br><span class="line"><span class="comment"># to continue to accept queries for the part of the key space that is still</span></span><br><span class="line"><span class="comment"># covered. In order to do so, just set the cluster-require-full-coverage</span></span><br><span class="line"><span class="comment"># option to no.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-require-full-coverage yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This option, when set to yes, prevents replicas from trying to failover its</span></span><br><span class="line"><span class="comment"># master during master failures. However the master can still perform a</span></span><br><span class="line"><span class="comment"># manual failover, if forced to do so.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is useful in different scenarios, especially in the case of multiple</span></span><br><span class="line"><span class="comment"># data center operations, where we want one side to never be promoted if not</span></span><br><span class="line"><span class="comment"># in the case of a total DC failure.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-replica-no-failover no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This option, when set to yes, allows nodes to serve read traffic while the</span></span><br><span class="line"><span class="comment"># the cluster is in a down state, as long as it believes it owns the slots. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is useful for two cases.  The first case is for when an application </span></span><br><span class="line"><span class="comment"># doesn't require consistency of data during node failures or network partitions.</span></span><br><span class="line"><span class="comment"># One example of this is a cache, where as long as the node has the data it</span></span><br><span class="line"><span class="comment"># should be able to serve it. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The second use case is for configurations that don't meet the recommended  </span></span><br><span class="line"><span class="comment"># three shards but want to enable cluster mode and scale later. A </span></span><br><span class="line"><span class="comment"># master outage in a 1 or 2 shard configuration causes a read/write outage to the</span></span><br><span class="line"><span class="comment"># entire cluster without this option set, with it set there is only a write outage.</span></span><br><span class="line"><span class="comment"># Without a quorum of masters, slot ownership will not change automatically. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-allow-reads-when-down no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In order to setup your cluster make sure to read the documentation</span></span><br><span class="line"><span class="comment"># available at http://redis.io web site.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########################## CLUSTER DOCKER/NAT support  ########################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In certain deployments, Redis Cluster nodes address discovery fails, because</span></span><br><span class="line"><span class="comment"># addresses are NAT-ted or because ports are forwarded (the typical case is</span></span><br><span class="line"><span class="comment"># Docker and other containers).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to make Redis Cluster working in such environments, a static</span></span><br><span class="line"><span class="comment"># configuration where each node knows its public address is needed. The</span></span><br><span class="line"><span class="comment"># following two options are used for this scope, and are:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># * cluster-announce-ip</span></span><br><span class="line"><span class="comment"># * cluster-announce-port</span></span><br><span class="line"><span class="comment"># * cluster-announce-bus-port</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Each instruct the node about its address, client port, and cluster message</span></span><br><span class="line"><span class="comment"># bus port. The information is then published in the header of the bus packets</span></span><br><span class="line"><span class="comment"># so that other nodes will be able to correctly map the address of the node</span></span><br><span class="line"><span class="comment"># publishing the information.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the above options are not used, the normal Redis Cluster auto-detection</span></span><br><span class="line"><span class="comment"># will be used instead.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that when remapped, the bus port may not be at the fixed offset of</span></span><br><span class="line"><span class="comment"># clients port + 10000, so you can specify any port and bus-port depending</span></span><br><span class="line"><span class="comment"># on how they get remapped. If the bus-port is not set, a fixed offset of</span></span><br><span class="line"><span class="comment"># 10000 will be used as usually.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-announce-ip 10.1.1.5</span></span><br><span class="line"><span class="comment"># cluster-announce-port 6379</span></span><br><span class="line"><span class="comment"># cluster-announce-bus-port 6380</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## SLOW LOG ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Redis Slow Log is a system to log queries that exceeded a specified</span></span><br><span class="line"><span class="comment"># execution time. The execution time does not include the I/O operations</span></span><br><span class="line"><span class="comment"># like talking with the client, sending the reply and so forth,</span></span><br><span class="line"><span class="comment"># but just the time needed to actually execute the command (this is the only</span></span><br><span class="line"><span class="comment"># stage of command execution where the thread is blocked and can not serve</span></span><br><span class="line"><span class="comment"># other requests in the meantime).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You can configure the slow log with two parameters: one tells Redis</span></span><br><span class="line"><span class="comment"># what is the execution time, in microseconds, to exceed in order for the</span></span><br><span class="line"><span class="comment"># command to get logged, and the other parameter is the length of the</span></span><br><span class="line"><span class="comment"># slow log. When a new command is logged the oldest one is removed from the</span></span><br><span class="line"><span class="comment"># queue of logged commands.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The following time is expressed in microseconds, so 1000000 is equivalent</span></span><br><span class="line"><span class="comment"># to one second. Note that a negative number disables the slow log, while</span></span><br><span class="line"><span class="comment"># a value of zero forces the logging of every command.</span></span><br><span class="line"><span class="comment">#慢操作日志记录</span></span><br><span class="line"><span class="string">slowlog-log-slower-than</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># There is no limit to this length. Just be aware that it will consume memory.</span></span><br><span class="line"><span class="comment"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span></span><br><span class="line"><span class="comment">#慢操作日志保留的最大条数</span></span><br><span class="line"><span class="string">slowlog-max-len</span> <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ LATENCY MONITOR ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Redis latency monitoring subsystem samples different operations</span></span><br><span class="line"><span class="comment"># at runtime in order to collect data related to possible sources of</span></span><br><span class="line"><span class="comment"># latency of a Redis instance.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Via the LATENCY command this information is available to the user that can</span></span><br><span class="line"><span class="comment"># print graphs and obtain reports.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The system only logs operations that were performed in a time equal or</span></span><br><span class="line"><span class="comment"># greater than the amount of milliseconds specified via the</span></span><br><span class="line"><span class="comment"># latency-monitor-threshold configuration directive. When its value is set</span></span><br><span class="line"><span class="comment"># to zero, the latency monitor is turned off.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default latency monitoring is disabled since it is mostly not needed</span></span><br><span class="line"><span class="comment"># if you don't have latency issues, and collecting data has a performance</span></span><br><span class="line"><span class="comment"># impact, that while very small, can be measured under big load. Latency</span></span><br><span class="line"><span class="comment"># monitoring can easily be enabled at runtime using the command</span></span><br><span class="line"><span class="comment"># "CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;" if needed.</span></span><br><span class="line"><span class="string">latency-monitor-threshold</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# EVENT NOTIFICATION ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis can notify Pub/Sub clients about events happening in the key space.</span></span><br><span class="line"><span class="comment"># This feature is documented at http://redis.io/topics/notifications</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For instance if keyspace events notification is enabled, and a client</span></span><br><span class="line"><span class="comment"># performs a DEL operation on key "foo" stored in the Database 0, two</span></span><br><span class="line"><span class="comment"># messages will be published via Pub/Sub:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># PUBLISH __keyspace@0__:foo del</span></span><br><span class="line"><span class="comment"># PUBLISH __keyevent@0__:del foo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is possible to select the events that Redis will notify among a set</span></span><br><span class="line"><span class="comment"># of classes. Every class is identified by a single character:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="comment">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="comment">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span></span><br><span class="line"><span class="comment">#  $     String commands</span></span><br><span class="line"><span class="comment">#  l     List commands</span></span><br><span class="line"><span class="comment">#  s     Set commands</span></span><br><span class="line"><span class="comment">#  h     Hash commands</span></span><br><span class="line"><span class="comment">#  z     Sorted set commands</span></span><br><span class="line"><span class="comment">#  x     Expired events (events generated every time a key expires)</span></span><br><span class="line"><span class="comment">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span></span><br><span class="line"><span class="comment">#  t     Stream commands</span></span><br><span class="line"><span class="comment">#  m     Key-miss events (Note: It is not included in the 'A' class)</span></span><br><span class="line"><span class="comment">#  A     Alias for g$lshzxet, so that the "AKE" string means all the events</span></span><br><span class="line"><span class="comment">#        (Except key-miss events which are excluded from 'A' due to their</span></span><br><span class="line"><span class="comment">#         unique nature).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  The "notify-keyspace-events" takes as argument a string that is composed</span></span><br><span class="line"><span class="comment">#  of zero or multiple characters. The empty string means that notifications</span></span><br><span class="line"><span class="comment">#  are disabled.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Example: to enable list and generic events, from the point of view of the</span></span><br><span class="line"><span class="comment">#           event name, use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  notify-keyspace-events Elg</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Example 2: to get the stream of the expired keys subscribing to channel</span></span><br><span class="line"><span class="comment">#             name __keyevent@0__:expired use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  notify-keyspace-events Ex</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  By default all notifications are disabled because most users don't need</span></span><br><span class="line"><span class="comment">#  this feature and the feature has some overhead. Note that if you don't</span></span><br><span class="line"><span class="comment">#  specify at least one of K or E, no events will be delivered.</span></span><br><span class="line"><span class="comment">#键空间通知，""表示关闭</span></span><br><span class="line"><span class="string">notify-keyspace-events</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################### GOPHER SERVER #################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis contains an implementation of the Gopher protocol, as specified in</span></span><br><span class="line"><span class="comment"># the RFC 1436 (https://www.ietf.org/rfc/rfc1436.txt).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Gopher protocol was very popular in the late '90s. It is an alternative</span></span><br><span class="line"><span class="comment"># to the web, and the implementation both server and client side is so simple</span></span><br><span class="line"><span class="comment"># that the Redis server has just 100 lines of code in order to implement this</span></span><br><span class="line"><span class="comment"># support.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># What do you do with Gopher nowadays? Well Gopher never *really* died, and</span></span><br><span class="line"><span class="comment"># lately there is a movement in order for the Gopher more hierarchical content</span></span><br><span class="line"><span class="comment"># composed of just plain text documents to be resurrected. Some want a simpler</span></span><br><span class="line"><span class="comment"># internet, others believe that the mainstream internet became too much</span></span><br><span class="line"><span class="comment"># controlled, and it's cool to create an alternative space for people that</span></span><br><span class="line"><span class="comment"># want a bit of fresh air.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Anyway for the 10nth birthday of the Redis, we gave it the Gopher protocol</span></span><br><span class="line"><span class="comment"># as a gift.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># --- HOW IT WORKS? ---</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Redis Gopher support uses the inline protocol of Redis, and specifically</span></span><br><span class="line"><span class="comment"># two kind of inline requests that were anyway illegal: an empty request</span></span><br><span class="line"><span class="comment"># or any request that starts with "/" (there are no Redis commands starting</span></span><br><span class="line"><span class="comment"># with such a slash). Normal RESP2/RESP3 requests are completely out of the</span></span><br><span class="line"><span class="comment"># path of the Gopher protocol implementation and are served as usually as well.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you open a connection to Redis when Gopher is enabled and send it</span></span><br><span class="line"><span class="comment"># a string like "/foo", if there is a key named "/foo" it is served via the</span></span><br><span class="line"><span class="comment"># Gopher protocol.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to create a real Gopher "hole" (the name of a Gopher site in Gopher</span></span><br><span class="line"><span class="comment"># talking), you likely need a script like the following:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   https://github.com/antirez/gopher2redis</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># --- SECURITY WARNING ---</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you plan to put Redis on the internet in a publicly accessible address</span></span><br><span class="line"><span class="comment"># to server Gopher pages MAKE SURE TO SET A PASSWORD to the instance.</span></span><br><span class="line"><span class="comment"># Once a password is set:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   1. The Gopher server (when enabled, not by default) will still serve</span></span><br><span class="line"><span class="comment">#      content via Gopher.</span></span><br><span class="line"><span class="comment">#   2. However other commands cannot be called before the client will</span></span><br><span class="line"><span class="comment">#      authenticate.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># So use the 'requirepass' option to protect your instance.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To enable Gopher support uncomment the following line and set</span></span><br><span class="line"><span class="comment"># the option from no (the default) to yes.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># gopher-enabled no</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################### ADVANCED CONFIG ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hashes are encoded using a memory efficient data structure when they have a</span></span><br><span class="line"><span class="comment"># small number of entries, and the biggest entry does not exceed a given</span></span><br><span class="line"><span class="comment"># threshold. These thresholds can be configured using the following directives.</span></span><br><span class="line"><span class="comment">##ziplist中允许存储的最大条目个数</span></span><br><span class="line"><span class="string">hash-max-ziplist-entries</span> <span class="number">512</span></span><br><span class="line"><span class="comment">#ziplist中允许条目value值最大字节数</span></span><br><span class="line"><span class="string">hash-max-ziplist-value</span> <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Lists are also encoded in a special way to save a lot of space.</span></span><br><span class="line"><span class="comment"># The number of entries allowed per internal list node can be specified</span></span><br><span class="line"><span class="comment"># as a fixed maximum size or a maximum number of elements.</span></span><br><span class="line"><span class="comment"># For a fixed maximum size, use -5 through -1, meaning:</span></span><br><span class="line"><span class="comment"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span></span><br><span class="line"><span class="comment"># -4: max size: 32 Kb  &lt;-- not recommended</span></span><br><span class="line"><span class="comment"># -3: max size: 16 Kb  &lt;-- probably not recommended</span></span><br><span class="line"><span class="comment"># -2: max size: 8 Kb   &lt;-- good</span></span><br><span class="line"><span class="comment"># -1: max size: 4 Kb   &lt;-- good</span></span><br><span class="line"><span class="comment"># Positive numbers mean store up to _exactly_ that number of elements</span></span><br><span class="line"><span class="comment"># per list node.</span></span><br><span class="line"><span class="comment"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span></span><br><span class="line"><span class="comment"># but if your use case is unique, adjust the settings as necessary.</span></span><br><span class="line"><span class="string">list-max-ziplist-size</span> <span class="bullet">-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Lists may also be compressed.</span></span><br><span class="line"><span class="comment"># Compress depth is the number of quicklist ziplist nodes from *each* side of</span></span><br><span class="line"><span class="comment"># the list to *exclude* from compression.  The head and tail of the list</span></span><br><span class="line"><span class="comment"># are always uncompressed for fast push/pop operations.  Settings are:</span></span><br><span class="line"><span class="comment"># 0: disable all list compression</span></span><br><span class="line"><span class="comment"># 1: depth 1 means "don't start compressing until after 1 node into the list,</span></span><br><span class="line"><span class="comment">#    going from either the head or tail"</span></span><br><span class="line"><span class="comment">#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span></span><br><span class="line"><span class="comment">#    [head], [tail] will always be uncompressed; inner nodes will compress.</span></span><br><span class="line"><span class="comment"># 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span></span><br><span class="line"><span class="comment">#    2 here means: don't compress head or head-&gt;next or tail-&gt;prev or tail,</span></span><br><span class="line"><span class="comment">#    but compress all nodes between them.</span></span><br><span class="line"><span class="comment"># 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span></span><br><span class="line"><span class="comment"># etc.</span></span><br><span class="line"><span class="string">list-compress-depth</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets have a special encoding in just one case: when a set is composed</span></span><br><span class="line"><span class="comment"># of just strings that happen to be integers in radix 10 in the range</span></span><br><span class="line"><span class="comment"># of 64 bit signed integers.</span></span><br><span class="line"><span class="comment"># The following configuration setting sets the limit in the size of the</span></span><br><span class="line"><span class="comment"># set in order to use this special memory saving encoding.</span></span><br><span class="line"><span class="comment">#intset中允许保存的最大条目个数,如果达到阀值,intset将会被重构为hashtable</span></span><br><span class="line"><span class="string">set-max-intset-entries</span> <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Similarly to hashes and lists, sorted sets are also specially encoded in</span></span><br><span class="line"><span class="comment"># order to save a lot of space. This encoding is only used when the length and</span></span><br><span class="line"><span class="comment"># elements of a sorted set are below the following limits:</span></span><br><span class="line"><span class="comment">#设置同上</span></span><br><span class="line"><span class="string">zset-max-ziplist-entries</span> <span class="number">128</span></span><br><span class="line"><span class="string">zset-max-ziplist-value</span> <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HyperLogLog sparse representation bytes limit. The limit includes the</span></span><br><span class="line"><span class="comment"># 16 bytes header. When an HyperLogLog using the sparse representation crosses</span></span><br><span class="line"><span class="comment"># this limit, it is converted into the dense representation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A value greater than 16000 is totally useless, since at that point the</span></span><br><span class="line"><span class="comment"># dense representation is more memory efficient.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The suggested value is ~ 3000 in order to have the benefits of</span></span><br><span class="line"><span class="comment"># the space efficient encoding without slowing down too much PFADD,</span></span><br><span class="line"><span class="comment"># which is O(N) with the sparse encoding. The value can be raised to</span></span><br><span class="line"><span class="comment"># ~ 10000 when CPU is not a concern, but space is, and the data set is</span></span><br><span class="line"><span class="comment"># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span></span><br><span class="line"><span class="string">hll-sparse-max-bytes</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Streams macro node max size / items. The stream data structure is a radix</span></span><br><span class="line"><span class="comment"># tree of big nodes that encode multiple items inside. Using this configuration</span></span><br><span class="line"><span class="comment"># it is possible to configure how big a single node can be in bytes, and the</span></span><br><span class="line"><span class="comment"># maximum number of items it may contain before switching to a new node when</span></span><br><span class="line"><span class="comment"># appending new stream entries. If any of the following settings are set to</span></span><br><span class="line"><span class="comment"># zero, the limit is ignored, so for instance it is possible to set just a</span></span><br><span class="line"><span class="comment"># max entires limit by setting max-bytes to 0 and max-entries to the desired</span></span><br><span class="line"><span class="comment"># value.</span></span><br><span class="line"><span class="string">stream-node-max-bytes</span> <span class="number">4096</span></span><br><span class="line"><span class="string">stream-node-max-entries</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span></span><br><span class="line"><span class="comment"># order to help rehashing the main Redis hash table (the one mapping top-level</span></span><br><span class="line"><span class="comment"># keys to values). The hash table implementation Redis uses (see dict.c)</span></span><br><span class="line"><span class="comment"># performs a lazy rehashing: the more operation you run into a hash table</span></span><br><span class="line"><span class="comment"># that is rehashing, the more rehashing "steps" are performed, so if the</span></span><br><span class="line"><span class="comment"># server is idle the rehashing is never complete and some more memory is used</span></span><br><span class="line"><span class="comment"># by the hash table.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is to use this millisecond 10 times every second in order to</span></span><br><span class="line"><span class="comment"># actively rehash the main dictionaries, freeing memory when possible.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If unsure:</span></span><br><span class="line"><span class="comment"># use "activerehashing no" if you have hard latency requirements and it is</span></span><br><span class="line"><span class="comment"># not a good thing in your environment that Redis can reply from time to time</span></span><br><span class="line"><span class="comment"># to queries with 2 milliseconds delay.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># use "activerehashing yes" if you don't have such hard requirements but</span></span><br><span class="line"><span class="comment"># want to free memory asap when possible.</span></span><br><span class="line"><span class="comment">#是否开启顶层数据结构的rehash功能,如果内存允许,请开启</span></span><br><span class="line"><span class="string">activerehashing</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The client output buffer limits can be used to force disconnection of clients</span></span><br><span class="line"><span class="comment"># that are not reading data from the server fast enough for some reason (a</span></span><br><span class="line"><span class="comment"># common reason is that a Pub/Sub client can't consume messages as fast as the</span></span><br><span class="line"><span class="comment"># publisher can produce them).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The limit can be set differently for the three different classes of clients:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># normal -&gt; normal clients including MONITOR clients</span></span><br><span class="line"><span class="comment"># replica  -&gt; replica clients</span></span><br><span class="line"><span class="comment"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The syntax of every client-output-buffer-limit directive is the following:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A client is immediately disconnected once the hard limit is reached, or if</span></span><br><span class="line"><span class="comment"># the soft limit is reached and remains reached for the specified number of</span></span><br><span class="line"><span class="comment"># seconds (continuously).</span></span><br><span class="line"><span class="comment"># So for instance if the hard limit is 32 megabytes and the soft limit is</span></span><br><span class="line"><span class="comment"># 16 megabytes / 10 seconds, the client will get disconnected immediately</span></span><br><span class="line"><span class="comment"># if the size of the output buffers reach 32 megabytes, but will also get</span></span><br><span class="line"><span class="comment"># disconnected if the client reaches 16 megabytes and continuously overcomes</span></span><br><span class="line"><span class="comment"># the limit for 10 seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default normal clients are not limited because they don't receive data</span></span><br><span class="line"><span class="comment"># without asking (in a push way), but just after a request, so only</span></span><br><span class="line"><span class="comment"># asynchronous clients may create a scenario where data is requested faster</span></span><br><span class="line"><span class="comment"># than it can read.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Instead there is a default limit for pubsub and replica clients, since</span></span><br><span class="line"><span class="comment"># subscribers and replicas receive data in a push fashion.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Both the hard or the soft limit can be disabled by setting them to zero.</span></span><br><span class="line"><span class="comment">#客户端buffer控制</span></span><br><span class="line"><span class="string">client-output-buffer-limit</span> <span class="string">normal</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="string">client-output-buffer-limit</span> <span class="string">replica</span> <span class="number">256</span><span class="string">mb</span> <span class="number">64</span><span class="string">mb</span> <span class="number">60</span></span><br><span class="line"><span class="string">client-output-buffer-limit</span> <span class="string">pubsub</span> <span class="number">32</span><span class="string">mb</span> <span class="number">8</span><span class="string">mb</span> <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Client query buffers accumulate new commands. They are limited to a fixed</span></span><br><span class="line"><span class="comment"># amount by default in order to avoid that a protocol desynchronization (for</span></span><br><span class="line"><span class="comment"># instance due to a bug in the client) will lead to unbound memory usage in</span></span><br><span class="line"><span class="comment"># the query buffer. However you can configure it here if you have very special</span></span><br><span class="line"><span class="comment"># needs, such us huge multi/exec requests or alike.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># client-query-buffer-limit 1gb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In the Redis protocol, bulk requests, that are, elements representing single</span></span><br><span class="line"><span class="comment"># strings, are normally limited ot 512 mb. However you can change this limit</span></span><br><span class="line"><span class="comment"># here.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># proto-max-bulk-len 512mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis calls an internal function to perform many background tasks, like</span></span><br><span class="line"><span class="comment"># closing connections of clients in timeout, purging expired keys that are</span></span><br><span class="line"><span class="comment"># never requested, and so forth.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Not all tasks are performed with the same frequency, but Redis checks for</span></span><br><span class="line"><span class="comment"># tasks to perform according to the specified "hz" value.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default "hz" is set to 10. Raising the value will use more CPU when</span></span><br><span class="line"><span class="comment"># Redis is idle, but at the same time will make Redis more responsive when</span></span><br><span class="line"><span class="comment"># there are many keys expiring at the same time, and timeouts may be</span></span><br><span class="line"><span class="comment"># handled with more precision.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The range is between 1 and 500, however a value over 100 is usually not</span></span><br><span class="line"><span class="comment"># a good idea. Most users should use the default of 10 and raise this up to</span></span><br><span class="line"><span class="comment"># 100 only in environments where very low latency is required.</span></span><br><span class="line"><span class="comment">#Redis server执行后台任务的频率,默认为10,此值越大表示redis对"间歇性task"的执行次数越频繁</span></span><br><span class="line"><span class="string">hz</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Normally it is useful to have an HZ value which is proportional to the</span></span><br><span class="line"><span class="comment"># number of clients connected. This is useful in order, for instance, to</span></span><br><span class="line"><span class="comment"># avoid too many clients are processed for each background task invocation</span></span><br><span class="line"><span class="comment"># in order to avoid latency spikes.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Since the default HZ value by default is conservatively set to 10, Redis</span></span><br><span class="line"><span class="comment"># offers, and enables by default, the ability to use an adaptive HZ value</span></span><br><span class="line"><span class="comment"># which will temporary raise when there are many connected clients.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When dynamic HZ is enabled, the actual configured HZ will be used</span></span><br><span class="line"><span class="comment"># as a baseline, but multiples of the configured HZ value will be actually</span></span><br><span class="line"><span class="comment"># used as needed once more clients are connected. In this way an idle</span></span><br><span class="line"><span class="comment"># instance will use very little CPU time while a busy instance will be</span></span><br><span class="line"><span class="comment"># more responsive.</span></span><br><span class="line"><span class="string">dynamic-hz</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When a child rewrites the AOF file, if the following option is enabled</span></span><br><span class="line"><span class="comment"># the file will be fsync-ed every 32 MB of data generated. This is useful</span></span><br><span class="line"><span class="comment"># in order to commit the file to the disk more incrementally and avoid</span></span><br><span class="line"><span class="comment"># big latency spikes.</span></span><br><span class="line"><span class="comment">#aof rewrite过程中,是否采取增量"文件同步"策略,默认为"yes",而且必须为yes</span></span><br><span class="line"><span class="string">aof-rewrite-incremental-fsync</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When redis saves RDB file, if the following option is enabled</span></span><br><span class="line"><span class="comment"># the file will be fsync-ed every 32 MB of data generated. This is useful</span></span><br><span class="line"><span class="comment"># in order to commit the file to the disk more incrementally and avoid</span></span><br><span class="line"><span class="comment"># big latency spikes.</span></span><br><span class="line"><span class="string">rdb-save-incremental-fsync</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span></span><br><span class="line"><span class="comment"># idea to start with the default settings and only change them after investigating</span></span><br><span class="line"><span class="comment"># how to improve the performances and how the keys LFU change over time, which</span></span><br><span class="line"><span class="comment"># is possible to inspect via the OBJECT FREQ command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># There are two tunable parameters in the Redis LFU implementation: the</span></span><br><span class="line"><span class="comment"># counter logarithm factor and the counter decay time. It is important to</span></span><br><span class="line"><span class="comment"># understand what the two parameters mean before changing them.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis</span></span><br><span class="line"><span class="comment"># uses a probabilistic increment with logarithmic behavior. Given the value</span></span><br><span class="line"><span class="comment"># of the old counter, when a key is accessed, the counter is incremented in</span></span><br><span class="line"><span class="comment"># this way:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1. A random number R between 0 and 1 is extracted.</span></span><br><span class="line"><span class="comment"># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span></span><br><span class="line"><span class="comment"># 3. The counter is incremented only if R &lt; P.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default lfu-log-factor is 10. This is a table of how the frequency</span></span><br><span class="line"><span class="comment"># counter changes with a different number of accesses with different</span></span><br><span class="line"><span class="comment"># logarithmic factors:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 0      | 104        | 255        | 255        | 255        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 1      | 18         | 49         | 255        | 255        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 10     | 10         | 18         | 142        | 255        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 100    | 8          | 11         | 49         | 143        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> The above table was obtained by running the following commands:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   redis-benchmark -n 1000000 incr foo</span></span><br><span class="line"><span class="comment">#   redis-cli object freq foo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span></span><br><span class="line"><span class="comment"># to accumulate hits.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The counter decay time is the time, in minutes, that must elapse in order</span></span><br><span class="line"><span class="comment"># for the key counter to be divided by two (or decremented if it has a value</span></span><br><span class="line"><span class="comment"># less &lt;= 10).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default value for the lfu-decay-time is 1. A Special value of 0 means to</span></span><br><span class="line"><span class="comment"># decay the counter every time it happens to be scanned.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># lfu-log-factor 10</span></span><br><span class="line"><span class="comment"># lfu-decay-time 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########################### ACTIVE DEFRAGMENTATION #######################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># What is active defragmentation?</span></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Active (online) defragmentation allows a Redis server to compact the</span></span><br><span class="line"><span class="comment"># spaces left between small allocations and deallocations of data in memory,</span></span><br><span class="line"><span class="comment"># thus allowing to reclaim back memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Fragmentation is a natural process that happens with every allocator (but</span></span><br><span class="line"><span class="comment"># less so with Jemalloc, fortunately) and certain workloads. Normally a server</span></span><br><span class="line"><span class="comment"># restart is needed in order to lower the fragmentation, or at least to flush</span></span><br><span class="line"><span class="comment"># away all the data and create it again. However thanks to this feature</span></span><br><span class="line"><span class="comment"># implemented by Oran Agra for Redis 4.0 this process can happen at runtime</span></span><br><span class="line"><span class="comment"># in an "hot" way, while the server is running.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Basically when the fragmentation is over a certain level (see the</span></span><br><span class="line"><span class="comment"># configuration options below) Redis will start to create new copies of the</span></span><br><span class="line"><span class="comment"># values in contiguous memory regions by exploiting certain specific Jemalloc</span></span><br><span class="line"><span class="comment"># features (in order to understand if an allocation is causing fragmentation</span></span><br><span class="line"><span class="comment"># and to allocate it in a better place), and at the same time, will release the</span></span><br><span class="line"><span class="comment"># old copies of the data. This process, repeated incrementally for all the keys</span></span><br><span class="line"><span class="comment"># will cause the fragmentation to drop back to normal values.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Important things to understand:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1. This feature is disabled by default, and only works if you compiled Redis</span></span><br><span class="line"><span class="comment">#    to use the copy of Jemalloc we ship with the source code of Redis.</span></span><br><span class="line"><span class="comment">#    This is the default with Linux builds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2. You never need to enable this feature if you don't have fragmentation</span></span><br><span class="line"><span class="comment">#    issues.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 3. Once you experience fragmentation, you can enable this feature when</span></span><br><span class="line"><span class="comment">#    needed with the command "CONFIG SET activedefrag yes".</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The configuration parameters are able to fine tune the behavior of the</span></span><br><span class="line"><span class="comment"># defragmentation process. If you are not sure about what they mean it is</span></span><br><span class="line"><span class="comment"># a good idea to leave the defaults untouched.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enabled active defragmentation</span></span><br><span class="line"><span class="comment"># activedefrag no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Minimum amount of fragmentation waste to start active defrag</span></span><br><span class="line"><span class="comment"># active-defrag-ignore-bytes 100mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Minimum percentage of fragmentation to start active defrag</span></span><br><span class="line"><span class="comment"># active-defrag-threshold-lower 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Maximum percentage of fragmentation at which we use maximum effort</span></span><br><span class="line"><span class="comment"># active-defrag-threshold-upper 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Minimal effort for defrag in CPU percentage, to be used when the lower</span></span><br><span class="line"><span class="comment"># threshold is reached</span></span><br><span class="line"><span class="comment"># active-defrag-cycle-min 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Maximal effort for defrag in CPU percentage, to be used when the upper</span></span><br><span class="line"><span class="comment"># threshold is reached</span></span><br><span class="line"><span class="comment"># active-defrag-cycle-max 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Maximum number of set/hash/zset/list fields that will be processed from</span></span><br><span class="line"><span class="comment"># the main dictionary scan</span></span><br><span class="line"><span class="comment"># active-defrag-max-scan-fields 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Jemalloc background thread for purging will be enabled by default</span></span><br><span class="line"><span class="string">jemalloc-bg-thread</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># It is possible to pin different threads and processes of Redis to specific</span></span><br><span class="line"><span class="comment"># CPUs in your system, in order to maximize the performances of the server.</span></span><br><span class="line"><span class="comment"># This is useful both in order to pin different Redis threads in different</span></span><br><span class="line"><span class="comment"># CPUs, but also in order to make sure that multiple Redis instances running</span></span><br><span class="line"><span class="comment"># in the same host will be pinned to different CPUs.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Normally you can do this using the "taskset" command, however it is also</span></span><br><span class="line"><span class="comment"># possible to this via Redis configuration directly, both in Linux and FreeBSD.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You can pin the server/IO threads, bio threads, aof rewrite child process, and</span></span><br><span class="line"><span class="comment"># the bgsave child process. The syntax to specify the cpu list is the same as</span></span><br><span class="line"><span class="comment"># the taskset command:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set redis server/io threads to cpu affinity 0,2,4,6:</span></span><br><span class="line"><span class="comment"># server_cpulist 0-7:2</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set bio threads to cpu affinity 1,3:</span></span><br><span class="line"><span class="comment"># bio_cpulist 1,3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set aof rewrite child process to cpu affinity 8,9,10,11:</span></span><br><span class="line"><span class="comment"># aof_rewrite_cpulist 8-11</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set bgsave child process to cpu affinity 1,10,11</span></span><br><span class="line"><span class="comment"># bgsave_cpulist 1,10-11</span></span><br></pre></td></tr></table></figure><h3 id="上传本地egg服务端代码到服务器"><a href="#上传本地egg服务端代码到服务器" class="headerlink" title="上传本地egg服务端代码到服务器"></a>上传本地egg服务端代码到服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -rp egg.zip root@43.138.12.18:/home</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/0327d670f6d365a3.png" alt></p><p><strong>解压</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip -u -d server egg.zip</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/1b6745e93aa9117b.png" alt></p><h3 id="启动egg服务"><a href="#启动egg服务" class="headerlink" title="启动egg服务"></a>启动egg服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd egg</span><br><span class="line"># -d 后台方式启动</span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/bc579093039d5dff.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/e0867be8b406e212.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/b2cacc63e98f5a06.png" alt></p><h3 id="测试服务"><a href="#测试服务" class="headerlink" title="测试服务"></a>测试服务</h3><p><strong>vscode本地连接线上数据库测试</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/1f3bfb1ae436d23a.png" alt></p><p><strong>redis服务连接测试</strong></p><p>无需密码登录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 43.23.121.12 -p 6380</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/eda7643690d38f9d.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/52c4f5f008df9f52.png" alt></p><p>设置密码后的登录方式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 43.31.121.12 -p 6380</span><br><span class="line"></span><br><span class="line">keys *</span><br><span class="line">auth [username] password</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/06/ca3f547b33538895.png" alt></p><blockquote><p>缓存服务测试</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/575fadaac0763dc6.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/54f7c259eaf6172c.png" alt></p><p><strong>测试egg接口</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/dc8e99cf5574f3fd.png" alt></p><p><strong>访问前端项目测试接口</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/64b59c23ed0cc0d7.png" alt></p><h1 id="五、部署到云托管"><a href="#五、部署到云托管" class="headerlink" title="五、部署到云托管"></a>五、部署到云托管</h1><blockquote><p>云托管流水线部署更方便</p></blockquote><h2 id="5-1-redis服务"><a href="#5-1-redis服务" class="headerlink" title="5.1 redis服务"></a>5.1 redis服务</h2><p>这里我们上面部署使用的自建服务器上docker搭建的redis服务作为演示</p><p><img src="https://s.poetries.work/uploads/2022/06/c74e6e89043a20d6.png" alt></p><h2 id="5-2-mysql服务"><a href="#5-2-mysql服务" class="headerlink" title="5.2 mysql服务"></a>5.2 mysql服务</h2><p>这里我们上面部署使用的自建服务器上docker搭建的mysql服务作为演示</p><p><img src="https://s.poetries.work/uploads/2022/06/1e17df55d9c3634f.png" alt></p><h2 id="5-3-egg部署"><a href="#5-3-egg部署" class="headerlink" title="5.3 egg部署"></a>5.3 egg部署</h2><h3 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h3><p><img src="https://s.poetries.work/uploads/2022/06/144606d89bc20359.png" alt></p><p>然后上传代码到github，通过云托管流水线构建</p><h3 id="新建服务"><a href="#新建服务" class="headerlink" title="新建服务"></a>新建服务</h3><p><img src="https://s.poetries.work/uploads/2022/06/c09974e946ab3075.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/71c1f38043c67c1b.png" alt></p><p>点击发布后，云托管会执行Dockerfile构建流水线，到日志可以查看构建进度</p><p><img src="https://s.poetries.work/uploads/2022/06/2c6ce688f421ef04.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/0f3919c9924b6071.png" alt></p><p><strong>微信云托管部署成功后，可以在实例列表，点击进入容器看到代码</strong>，这里里面的内容不能修改，在容器启动后会覆盖</p><p><img src="https://s.poetries.work/uploads/2022/06/3e1b91db0e2b0718.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/d0dd17b85fd1e305.png" alt></p><h3 id="调试接口"><a href="#调试接口" class="headerlink" title="调试接口"></a>调试接口</h3><p><img src="https://s.poetries.work/uploads/2022/06/e3a9c648993208d2.png" alt></p><p><strong>postman测试</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/713c1e6256b93b9a.png" alt></p><p><strong>测试redis服务</strong></p><p><img src="https://s.poetries.work/uploads/2022/06/c3b97b3e633cb928.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/91202ab620ae6b65.png" alt></p><p>至此部署到微信云托管完成，后续修改代码提交到github会自动触发云托管部署</p><h1 id="六、egg部署到腾讯serverless"><a href="#六、egg部署到腾讯serverless" class="headerlink" title="六、egg部署到腾讯serverless"></a>六、egg部署到腾讯serverless</h1><p>需要注意，云函数的代码包不能超过500M</p><p><img src="https://s.poetries.work/uploads/2022/06/41b9fcbf9242921f.png" alt></p><h2 id="6-1-修改egg配置"><a href="#6-1-修改egg配置" class="headerlink" title="6.1 修改egg配置"></a>6.1 修改egg配置</h2><blockquote><p>由于云函数在执行时，只有 <code>/tmp</code> 可读写的，所以我们需要将 egg.js 框架运行尝试的日志写到该目录下，为此需要修改 <code>config/config.default.js</code> 中的配置如下：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = (exports = &#123;</span><br><span class="line">  env: <span class="string">"prod"</span>, <span class="comment">// 推荐云函数的 egg 运行环境变量修改为 prod</span></span><br><span class="line">  rundir: <span class="string">'/tmp'</span>,</span><br><span class="line">  logger: &#123;</span><br><span class="line">    dir: <span class="string">'/tmp'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="6-2-命令行部署"><a href="#6-2-命令行部署" class="headerlink" title="6.2 命令行部署"></a>6.2 命令行部署</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装Serverless 框架</span></span><br><span class="line">npm i -g serverless</span><br></pre></td></tr></table></figure><h3 id="配置-YAML"><a href="#配置-YAML" class="headerlink" title="配置 YAML"></a>配置 YAML</h3><p><strong>在 egg 项目根目录,新建 Serverless 配置文件 serverless.yml</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app: appDemo</span><br><span class="line">stage: dev</span><br><span class="line">component: egg</span><br><span class="line">name: eggDemo</span><br><span class="line"></span><br><span class="line">inputs:</span><br><span class="line">  src: ./src</span><br><span class="line">  region: ap-guangzhou</span><br><span class="line">  functionName: eggDemo</span><br><span class="line">  runtime: Nodejs10.15</span><br><span class="line">  apigatewayConf:</span><br><span class="line">    protocols:</span><br><span class="line">      - http</span><br><span class="line">      - https</span><br><span class="line">    environment: release</span><br></pre></td></tr></table></figure><h3 id="部署到腾讯云"><a href="#部署到腾讯云" class="headerlink" title="部署到腾讯云"></a>部署到腾讯云</h3><ul><li>部署命令： <code>sls deploy</code>(意: <code>sls</code> 是 <code>serverless</code> 命令的简写。)</li><li>更多配置参考 <a href="https://github.com/serverless-components/tencent-egg/tree/v2" target="_blank" rel="noopener">https://github.com/serverless-components/tencent-egg/tree/v2</a></li></ul><p><img src="https://s.poetries.work/uploads/2022/06/bdea8f2beb76abc4.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/471ac2511396e898.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/51a5bdc6a3e2ee10.png" alt></p><h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><p>通过以下命令移除部署的 Egg 服务资源，包括云函数和 API 网关。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sls remove</span><br></pre></td></tr></table></figure><h3 id="账号配置（可选）"><a href="#账号配置（可选）" class="headerlink" title="账号配置（可选）"></a>账号配置（可选）</h3><blockquote><p>当前默认支持 CLI 扫描二维码登录，如您希望配置持久的环境变量/秘钥信息，也可以在项目根目录 <code>serverless-egg</code> 中创建 <code>.env</code> 文件：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># .env</span><br><span class="line">TENCENT_SECRET_ID=XXX</span><br><span class="line">TENCENT_SECRET_KEY=XXX</span><br></pre></td></tr></table></figure><blockquote><p>如果已有腾讯云账号，可以在 API <a href="https://console.cloud.tencent.com/cam/capi" target="_blank" rel="noopener">密钥管理</a> 中获取 SecretId 和SecretKey.</p></blockquote><h3 id="注意！！！"><a href="#注意！！！" class="headerlink" title="注意！！！"></a>注意！！！</h3><blockquote><p>通常初始化的 egg 项目，会自动创建 <code>app/public</code> 目录。但是在打包压缩时，如果该目录为空，则部署后，该目录不会存在。所以 egg 项目启动时会自动创建，但是云函数是没有操作权限的，建议可以在 <code>app/public</code> 目录下创建一个空文件 <code>.gitkeep</code>，来解决此问题。</p></blockquote><h2 id="6-3-控制台创建部署-模板部署"><a href="#6-3-控制台创建部署-模板部署" class="headerlink" title="6.3 控制台创建部署-模板部署"></a>6.3 控制台创建部署-模板部署</h2><ol><li>登录控制台 <a href="https://console.cloud.tencent.com/sls" target="_blank" rel="noopener">https://console.cloud.tencent.com/sls</a></li><li>单击新建应用，选择Web 应用&gt;Egg 框架，如下图所示：</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/fbf0b03c839cd73e.png" alt></p><ol start="3"><li>单击“下一步”，完成基础配置选择。</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/58b123659a00b194.png" alt></p><ol start="4"><li>上传方式，选择示例代码直接部署，单击完成，即可开始应用的部署。</li><li>部署完成后，您可在应用详情页面，查看示例应用的基本信息，并通过 API 网关生成的访问路径 URL 进行访问，查看您部署的 Egg 项目。</li></ol><p><img src="https://s.poetries.work/uploads/2022/06/c4c3e330b1a6af68.png" alt></p><h2 id="6-4-控制台创建部署-自定义部署"><a href="#6-4-控制台创建部署-自定义部署" class="headerlink" title="6.4 控制台创建部署-自定义部署"></a>6.4 控制台创建部署-自定义部署</h2><blockquote><p>如果除了代码部署外，您还需要更多能力或资源创建，如自动创建层托管依赖、一键实现静态资源分离、支持代码仓库直接拉取等，可以通过应用控制台，完成 Web 应用的创建工作</p></blockquote><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir egg-example &amp;&amp; cd egg-example</span><br><span class="line">npm init egg --type=simple</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><h3 id="部署上云"><a href="#部署上云" class="headerlink" title="部署上云"></a>部署上云</h3><blockquote><p>接下来执行以下步骤，对本地已创建完成的项目进行简单修改，使其可以通过 Web Function 快速部署，对于 Egg 框架，具体改造说明如下：</p></blockquote><ul><li>修改监听地址与端口为 <code>0.0.0.0:9000</code>。</li><li>修改写入路径，serverless 环境下只有 <code>/tmp</code> 目录可读写。</li><li>新增 <code>scf_bootstrap</code> 启动文件。</li></ul><p><strong>1. (可选)配置 scf_bootstrap 启动文件</strong></p><p>您也可以在控制台完成该模块配置。</p><p><img src="https://s.poetries.work/uploads/2022/06/85b3d73ea922f0ea.png" alt></p><blockquote><p>在项目根目录下新建 <code>scf_bootstrap</code> 启动文件，在该文件添加如下内容（用于配置环境变量和启动服务，此处仅为示例，具体操作请以您实际业务场景来调整）：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/var/lang/node12/bin/node</span></span><br><span class="line"></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * docker 中 node 路径：/var/lang/node12/bin/node</span></span><br><span class="line"><span class="comment"> * 由于 serverless 函数只有 /tmp 读写权限，所以在启动时需要修改两个环境变量</span></span><br><span class="line"><span class="comment"> * NODE_LOG_DIR 是为了改写 egg-scripts 默认 node 写入路径（~/logs）-&gt; /tmp</span></span><br><span class="line"><span class="comment"> * EGG_APP_CONFIG 是为了修改 egg 应有的默认当前目录 -&gt; /tmp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">process.env.EGG_SERVER_ENV = <span class="string">'prod'</span>;</span><br><span class="line">process.env.NODE_ENV = <span class="string">'production'</span>;</span><br><span class="line">process.env.NODE_LOG_DIR = <span class="string">'/tmp'</span>;</span><br><span class="line">process.env.EGG_APP_CONFIG = <span class="string">'&#123;"rundir":"/tmp","logger":&#123;"dir":"/tmp"&#125;&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Application &#125; = <span class="built_in">require</span>(<span class="string">'egg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果通过层部署 node_modules 就需要修改 eggPath</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Application.prototype, <span class="built_in">Symbol</span>.for(<span class="string">'egg#eggPath'</span>), &#123;</span><br><span class="line">  value: <span class="string">'/opt'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Application(&#123;</span><br><span class="line">  mode: <span class="string">'single'</span>,</span><br><span class="line">  env: <span class="string">'prod'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9000</span>, <span class="string">'0.0.0.0'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server start on http://0.0.0.0:9000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>新建完成后，还需执行以下命令修改文件可执行权限，默认需要 777 或 755 权限才可正常启动。示例如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 scf_bootstrap</span><br></pre></td></tr></table></figure><p><strong>2. 控制台上传</strong></p><blockquote><p>您可以在控制台完成启动文件 scf_bootstrap 内容配置，配置完成后，控制台将为您自动生成 启动文件，和项目代码一起打包部署</p></blockquote><p>启动文件以项目内文件为准，如果您的项目里已经包含 <code>scf_bootstrap</code> 文件，将不会覆盖该内容。</p><p><img src="https://s.poetries.work/uploads/2022/06/a96ce1c3799f5951.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/ce48d9dd73af824f.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/9a0e3dfa25a6ed3d.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/06/e9dd1225bf0d37cd.png" alt></p><p>查看函数，修改代码查看日志等</p><p><img src="https://s.poetries.work/uploads/2022/06/ca238c35541dd8df.png" alt></p><p><strong>高级配置管理</strong></p><blockquote><p>您可在“高级配置”里进行更多应用管理操作，如创建层、绑定自定义域名、配置环境变量等。</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/06/4ab13bbb74bcdf89.png" alt></p><h2 id="6-5-测试接口"><a href="#6-5-测试接口" class="headerlink" title="6.5 测试接口"></a>6.5 测试接口</h2><p><img src="https://s.poetries.work/uploads/2022/06/5a4f88d78a4740fb.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/692ad2fc22a7721d.png" alt><br><img src="https://s.poetries.work/uploads/2022/06/38120fb475238537.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、本地docker环境搭建&quot;&gt;&lt;a href=&quot;#一、本地docker环境搭建&quot; class=&quot;headerlink&quot; title=&quot;一、本地docker环境搭建&quot;&gt;&lt;/a&gt;一、本地docker环境搭建&lt;/h1&gt;&lt;p&gt;mac下安装docker: &lt;code&gt;br
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="部署" scheme="http://blog.poetries.top/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="Egg" scheme="http://blog.poetries.top/tags/Egg/"/>
    
  </entry>
  
  <entry>
    <title>Nestjs学习总结</title>
    <link href="http://blog.poetries.top/2022/05/25/nest-summary/"/>
    <id>http://blog.poetries.top/2022/05/25/nest-summary/</id>
    <published>2022-05-25T12:35:24.000Z</published>
    <updated>2025-03-30T13:54:29.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Nest (NestJS) 是一个用于构建高效、可扩展的 Node.js 服务器端应用程序的开发框架。它利用 JavaScript 的渐进增强的能力，使用并完全支持 TypeScript （仍然允许开发者使用纯 JavaScript 进行开发），并结合了 OOP （面向对象编程）、FP （函数式编程）和 FRP （函数响应式编程）。</p></blockquote><ul><li>在底层，Nest 构建在强大的 HTTP 服务器框架上，例如 Express （默认），并且还可以通过配置从而使用 Fastify ！</li><li>Nest 在这些常见的 Node.js 框架 (Express/Fastify) 之上提高了一个抽象级别，但仍然向开发者直接暴露了底层框架的 API。这使得开发者可以自由地使用适用于底层平台的无数的第三方模块。</li></ul><p>本文基于nest8演示</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i -g @nestjs/cli</span><br></pre></td></tr></table></figure><p><code>nest new project-name</code> 创建一个项目</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── nest-cli.json</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── app.controller.spec.ts</span><br><span class="line">│   ├── app.controller.ts</span><br><span class="line">│   ├── app.module.ts</span><br><span class="line">│   ├── app.service.ts</span><br><span class="line">│   └── main.ts</span><br><span class="line">├── test</span><br><span class="line">│   ├── app.e2e-spec.ts</span><br><span class="line">│   └── jest-e2e.json</span><br><span class="line">├── tsconfig.build.json</span><br><span class="line">└── tsconfig.json</span><br><span class="line"></span><br><span class="line">2 directories, 12 files</span><br></pre></td></tr></table></figure><p><strong>以下是这些核心文件的简要概述</strong>：</p><ul><li><code>app.controller.ts</code>   带有单个路由的基本控制器示例。</li><li><code>app.module.ts</code>   应用程序的根模块。</li><li><code>main.ts</code> 应用程序入口文件。它使用 NestFactory 用来创建 Nest 应用实例。</li></ul><blockquote><p><code>main.ts</code> 包含一个异步函数，它负责引导我们的应用程序：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ApplicationModule &#125; <span class="keyword">from</span> <span class="string">'./app.module'</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(ApplicationModule);</span><br><span class="line">  <span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><ul><li><code>NestFactory</code> 暴露了一些静态方法用于创建应用实例</li><li><code>create()</code> 方法返回一个实现 <code>INestApplication</code> 接口的对象, 并提供一组可用的方法</li></ul><blockquote><p><code>nest</code>有两个支持开箱即用的 HTTP 平台：<code>express</code> 和 <code>fastify</code>。 您可以选择最适合您需求的产品</p></blockquote><ul><li><code>platform-express</code> Express 是一个众所周知的 node.js 简约 Web 框架。 这是一个经过实战考验，适用于生产的库，拥有大量社区资源。 默认情况下使用 <code>@nestjs/platform-express</code> 包。 许多用户都可以使用 <code>Express</code> ，并且无需采取任何操作即可启用它。</li><li><code>platform-fastify</code> <code>Fastify</code> 是一个高性能，低开销的框架，专注于提供最高的效率和速度。 </li></ul><h2 id="Nest控制器"><a href="#Nest控制器" class="headerlink" title="Nest控制器"></a>Nest控制器</h2><p>Nest中的控制器层负责处理传入的请求, 并返回对客户端的响应。</p><p><img src="https://s.poetries.work/uploads/2022/05/8b2fcd207249cb37.png" alt></p><blockquote><p>控制器的目的是接收应用的特定请求。路由机制控制哪个控制器接收哪些请求。通常，每个控制器有多个路由，不同的路由可以执行不同的操作</p></blockquote><p><strong>通过NestCLi创建控制器：</strong></p><p><code>nest -h</code> 可以看到<code>nest</code>支持的命令</p><p><strong>常用命令：</strong></p><ul><li>创建控制器：<code>nest g co user module</code></li><li>创建服务：<code>nest g s user module</code></li><li>创建模块：<code>nest g mo user module</code></li><li>默认以src为根路径生成</li></ul><p><img src="https://s.poetries.work/uploads/2022/05/1c412ef436a4a04d.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nest g controller posts</span><br></pre></td></tr></table></figure><p>表示创建posts的控制器,这个时候会在src目录下面生成一个posts的文件夹，这个里面就是posts的控制器，代码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'posts'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建好控制器后，<code>nestjs</code>会自动的在 <code>app.module.ts</code> 中引入<code>PostsController</code>，代码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/app.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppController &#125; <span class="keyword">from</span> <span class="string">'./app.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppService &#125; <span class="keyword">from</span> <span class="string">'./app.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PostsController &#125; <span class="keyword">from</span> <span class="string">'./posts/posts.controller'</span></span><br><span class="line">    </span><br><span class="line">@Module(&#123;</span><br><span class="line">    imports: [],</span><br><span class="line">    controllers: [AppController, PostsController],</span><br><span class="line">    providers: [AppService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="nest配置路由请求数据"><a href="#nest配置路由请求数据" class="headerlink" title="nest配置路由请求数据"></a>nest配置路由请求数据</h2><blockquote><p>Nestjs提供了其他HTTP请求方法的装饰器 <code>@Get()</code> <code>@Post()</code> <code>@Put()</code> 、 <code>@Delete()</code>、 <code>@Patch()</code>、 <code>@Options()</code>、 <code>@Head()</code>和 <code>@All()</code></p></blockquote><p>在Nestjs中获取<code>Get</code>传值或者<code>Post提</code>交的数据的话我们可以使用Nestjs中的装饰器来获取。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Request()  req</span><br><span class="line">@Response() res</span><br><span class="line">@Next() next</span><br><span class="line">@Session()  req.session</span><br><span class="line">@Param(key?: string)    req.params / req.params[key]</span><br><span class="line">@Body(key?: string) req.body / req.body[key]</span><br><span class="line">@Query(key?: string)    req.query / req.query[key]</span><br><span class="line">@Headers(name?: string) req.headers / req.headers[name]</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Controller(<span class="string">'posts'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly postsService: PostsService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @Post(<span class="string">'create'</span>)</span><br><span class="line">  create(@Body() createPostDto: CreatePostDto) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.postsService.create(createPostDto);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">'list'</span>)</span><br><span class="line">  findAll(@Query() query) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.postsService.findAll(query);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">':id'</span>)</span><br><span class="line">  findById(@Param(<span class="string">'id'</span>) id: string) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.postsService.findById(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Put(<span class="string">':id'</span>)</span><br><span class="line">  update(</span><br><span class="line">    @Param(<span class="string">'id'</span>) id: string,</span><br><span class="line">    @Body() updatePostDto: UpdatePostDto,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.postsService.update(id, updatePostDto);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Delete(<span class="string">':id'</span>)</span><br><span class="line">  remove(@Param(<span class="string">'id'</span>) id: string) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.postsService.remove(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><code>关于nest的return</code>： 当请求处理程序返回 JavaScript 对象或数组时，它将自动序列化为 JSON。但是，当它返回一个字符串时，Nest 将只发送一个字符串而不是序列化它</li></ul><h2 id="Nest服务"><a href="#Nest服务" class="headerlink" title="Nest服务"></a>Nest服务</h2><blockquote><p>Nestjs中的服务可以是<code>service</code> 也可以是<code>provider</code>。他们都可以<code>通过 constructor 注入依赖关系</code>。服务本质上就是通过<code>@Injectable()</code> 装饰器注解的类。在Nestjs中服务相当于<code>MVC</code>的<code>Model</code></p></blockquote><p><img src="https://s.poetries.work/uploads/2022/05/1c607b98268d7707.png" alt></p><p><strong>创建服务</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nest g service posts</span><br></pre></td></tr></table></figure><p>创建好服务后就可以在服务中定义对应的方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; HttpException, HttpStatus, Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository, Not, Between, Equal, Like, In &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> dayjs <span class="keyword">from</span> <span class="string">'dayjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreatePostDto &#125; <span class="keyword">from</span> <span class="string">'./dto/create-post.dto'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UpdatePostDto &#125; <span class="keyword">from</span> <span class="string">'./dto/update-post.dto'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PostsEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/post.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PostsRo &#125; <span class="keyword">from</span> <span class="string">'./interfaces/posts.interface'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(PostsEntity)</span><br><span class="line">    private readonly postsRepository: Repository&lt;PostsEntity&gt;,</span><br><span class="line">  ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> create(post: CreatePostDto) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; title &#125; = post;</span><br><span class="line">    <span class="keyword">const</span> doc = <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.findOne(&#123; <span class="attr">where</span>: &#123; title &#125; &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doc'</span>, doc);</span><br><span class="line">    <span class="keyword">if</span> (doc) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">'文章标题已存在'</span>, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data: <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.save(post),</span><br><span class="line">      message: <span class="string">'创建成功'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分页查询列表</span></span><br><span class="line">  <span class="keyword">async</span> findAll(query = &#123;&#125; <span class="keyword">as</span> any) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; pageSize, pageNum, orderBy, sort, ...params &#125; = query;</span><br><span class="line">    orderBy = query.orderBy || <span class="string">'create_time'</span>;</span><br><span class="line">    sort = query.sort || <span class="string">'DESC'</span>;</span><br><span class="line">    pageSize = <span class="built_in">Number</span>(query.pageSize || <span class="number">10</span>);</span><br><span class="line">    pageNum = <span class="built_in">Number</span>(query.pageNum || <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'query'</span>, query);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> queryParams = &#123;&#125; <span class="keyword">as</span> any;</span><br><span class="line">    <span class="built_in">Object</span>.keys(params).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (params[key]) &#123;</span><br><span class="line">        queryParams[key] = Like(<span class="string">`%<span class="subst">$&#123;params[key]&#125;</span>%`</span>); <span class="comment">// 所有字段支持模糊查询、%%之间不能有空格</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> qb = <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.createQueryBuilder(<span class="string">'post'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// qb.where(&#123; status: In([2, 3]) &#125;);</span></span><br><span class="line">    qb.where(queryParams);</span><br><span class="line">    <span class="comment">// qb.select(['post.title', 'post.content']); // 查询部分字段返回</span></span><br><span class="line">    qb.orderBy(<span class="string">`post.<span class="subst">$&#123;orderBy&#125;</span>`</span>, sort);</span><br><span class="line">    qb.skip(pageSize * (pageNum - <span class="number">1</span>));</span><br><span class="line">    qb.take(pageSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      list: <span class="keyword">await</span> qb.getMany(),</span><br><span class="line">      totalNum: <span class="keyword">await</span> qb.getCount(), <span class="comment">// 按条件查询的数量</span></span><br><span class="line">      total: <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.count(), <span class="comment">// 总的数量</span></span><br><span class="line">      pageSize,</span><br><span class="line">      pageNum,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据ID查询详情</span></span><br><span class="line">  <span class="keyword">async</span> findById(id: string): <span class="built_in">Promise</span>&lt;PostsEntity&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.findOne(&#123; <span class="attr">where</span>: &#123; id &#125; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  <span class="keyword">async</span> update(id: string, <span class="attr">updatePostDto</span>: UpdatePostDto) &#123;</span><br><span class="line">    <span class="keyword">const</span> existRecord = <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.findOne(&#123; <span class="attr">where</span>: &#123; id &#125; &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!existRecord) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">`id为<span class="subst">$&#123;id&#125;</span>的文章不存在`</span>, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updatePostDto覆盖existRecord 合并，可以更新单个字段</span></span><br><span class="line">    <span class="keyword">const</span> updatePost = <span class="keyword">this</span>.postsRepository.merge(existRecord, &#123;</span><br><span class="line">      ...updatePostDto,</span><br><span class="line">      update_time: dayjs().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data: <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.save(updatePost),</span><br><span class="line">      message: <span class="string">'更新成功'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="keyword">async</span> remove(id: string) &#123;</span><br><span class="line">    <span class="keyword">const</span> existPost = <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.findOne(&#123; <span class="attr">where</span>: &#123; id &#125; &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!existPost) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">`文章ID <span class="subst">$&#123;id&#125;</span> 不存在`</span>, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.remove(existPost);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data: &#123; id &#125;,</span><br><span class="line">      message: <span class="string">'删除成功'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nest模块"><a href="#Nest模块" class="headerlink" title="Nest模块"></a>Nest模块</h2><blockquote><p>模块是具有 <code>@Module()</code> 装饰器的类。 <code>@Module()</code> 装饰器提供了元数据，Nest 用它来组织应用程序结构</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/05/fcc23bae4de7fa32.png" alt></p><blockquote><p>每个 Nest 应用程序至少有一个模块，即根模块。根模块是 Nest 开始安排应用程序树的地方。事实上，根模块可能是应用程序中唯一的模块，特别是当应用程序很小时，但是对于大型程序来说这是没有意义的。在大多数情况下，您将拥有多个模块，每个模块都有一组紧密相关的功能。</p></blockquote><p><strong>@module() 装饰器接受一个描述模块属性的对象：</strong></p><ul><li><code>providers</code> 由 Nest 注入器实例化的提供者，并且可以至少在整个模块中共享</li><li><code>controllers</code> 必须创建的一组控制器</li><li><code>imports</code> 导入模块的列表，这些模块导出了此模块中所需提供者</li><li><code>exports</code> 由本模块提供并应在其他模块中可用的提供者的子集</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建模块 posts</span></span><br><span class="line">nest g <span class="built_in">module</span> posts</span><br></pre></td></tr></table></figure><p><strong>Nestjs中的共享模块</strong></p><p>每个模块都是一个共享模块。一旦创建就能被任意模块重复使用。假设我们将在几个模块之间共享 PostsService 实例。 我们需要把 PostsService 放到 exports 数组中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// posts.modules.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PostsController &#125; <span class="keyword">from</span> <span class="string">'./posts.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PostsService &#125; <span class="keyword">from</span> <span class="string">'./posts.service'</span>;</span><br><span class="line">@Module(&#123;</span><br><span class="line">  controllers: [PostsController],</span><br><span class="line">  providers: [PostsService],</span><br><span class="line">  exports: [PostsService] <span class="comment">// 共享模块导出</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以使用 <code>nest g res posts</code> 一键创建以上需要的各个模块</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/05/f63b444ed1c1d481.png" alt></p><h2 id="配置静态资源"><a href="#配置静态资源" class="headerlink" title="配置静态资源"></a>配置静态资源</h2><p>NestJS中配置静态资源目录完整代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i @nestjs/platform-express -S</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NestExpressApplication &#125; <span class="keyword">from</span> <span class="string">'@nestjs/platform-express'</span>;</span><br><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建实例</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create&lt;NestExpressApplication&gt;(AppModule);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//使用方式一</span></span><br><span class="line">  app.useStaticAssets(<span class="string">'public'</span>)  <span class="comment">//配置静态资源目录</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用方式二：配置前缀目录 设置静态资源目录</span></span><br><span class="line">  app.useStaticAssets(join(__dirname, <span class="string">'../public'</span>), &#123;</span><br><span class="line">    <span class="comment">// 配置虚拟目录，比如我们想通过 http://localhost:3000/static/1.jpg 来访问public目录里面的文件</span></span><br><span class="line">    prefix: <span class="string">'/static/'</span>, <span class="comment">// 设置虚拟路径</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 启动端口</span></span><br><span class="line">  <span class="keyword">const</span> PORT = process.env.PORT || <span class="number">9000</span>;</span><br><span class="line">  <span class="keyword">await</span> app.listen(PORT, () =&gt;</span><br><span class="line">    Logger.log(<span class="string">`服务已经启动 http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><h2 id="配置模板引擎"><a href="#配置模板引擎" class="headerlink" title="配置模板引擎"></a>配置模板引擎</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i ejs --save</span><br></pre></td></tr></table></figure><p>配置模板引擎</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;join&#125; <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line"></span><br><span class="line">  app.setBaseViewsDir(join(__dirname, <span class="string">'..'</span>, <span class="string">'views'</span>)) <span class="comment">// 放视图的文件</span></span><br><span class="line">  app.setViewEngine(<span class="string">'ejs'</span>); <span class="comment">//模板渲染引擎</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> app.listen(<span class="number">9000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><p>项目根目录新建<code>views</code>目录然后新建<code>根目录 -&gt; views -&gt; default -&gt; index.ejs</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h3</span>&gt;</span>模板引擎<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=message%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>渲染页面</strong></p><p>Nestjs中 <code>Render</code>装饰器可以渲染模板，<strong>使用路由匹配渲染引擎</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mport &#123; Controller, Get, Render &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppService &#125; <span class="keyword">from</span> <span class="string">'./app.service'</span>;</span><br><span class="line"></span><br><span class="line">@Controller()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppController</span> </span>&#123;</span><br><span class="line">  @Get()</span><br><span class="line">  @Render(<span class="string">'default/index'</span>)  <span class="comment">//使用render渲染模板引擎，参数就是文件路径：default文件夹下的index.ejs</span></span><br><span class="line">  getUser(): any &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">message</span>: <span class="string">"hello word"</span>&#125;   <span class="comment">//只有返回参数在模板才能获取，如果不传递参数，必须返回一个空对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cookie的使用"><a href="#Cookie的使用" class="headerlink" title="Cookie的使用"></a>Cookie的使用</h2><blockquote><p>cookie和session的使用<strong>依赖</strong>于当前使用的平台，如：express和fastify<br>两种的使用方式不同，这里主要记录基于<strong>express</strong>平台的用法</p></blockquote><p>cookie可以用来存储用户信息，存储购物车等信息，在实际项目中用的非常多</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm instlal cookie-parser --save </span><br><span class="line">npm i -D @types/cookie-parser --save</span><br></pre></td></tr></table></figure><p>引入注册</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NestExpressApplication &#125; <span class="keyword">from</span> <span class="string">'@nestjs/platform-express'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> cookieParser <span class="keyword">from</span> <span class="string">'cookie-parser'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create&lt;NestExpressApplication&gt;(AppModule);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//注册cookie</span></span><br><span class="line">  app.use(cookieParser(<span class="string">'dafgafa'</span>));  <span class="comment">//加密密码</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><p><strong>接口中设置cookie 使用response</strong></p><p>请求该接口，响应一个cookie</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get()</span><br><span class="line">index(@Response() res)&#123;</span><br><span class="line">    <span class="comment">//设置cookie, signed:true加密</span></span><br><span class="line">    <span class="comment">//参数：1：key, 2:value, 3:配置</span></span><br><span class="line">    res.cookie(<span class="string">'username'</span>, <span class="string">'poetry'</span>, &#123;<span class="attr">maxAge</span>: <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>, <span class="attr">httpOnly</span>: <span class="literal">true</span>, <span class="attr">signed</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//使用res后，返回数据必须使用res</span></span><br><span class="line">    <span class="comment">//如果是用了render模板渲染，还是使用return</span></span><br><span class="line">    res.send(&#123;xxx&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cookie相关配置参数</strong></p><ul><li><code>domain</code>    String    指定域名下有效</li><li><code>expires</code>      Date        过期时间(秒),设置在某个时间点后会在该<code>cookoe</code>后失效</li><li><code>httpOnly</code>  Boolean    默认为<code>false</code> 如果为<code>true</code>表示不允许客户端(通过<code>js</code>来获取<code>cookie</code>)</li><li><code>maxAge</code>  String    最大失效时间(毫秒),设置在多少时间后失效</li><li><code>path</code>        String    表示<code>cookie</code>影响到的路径,如:<code>path=/</code>如果路径不能匹配的时候,浏览器则不发送这个<code>cookie</code></li><li><code>secure</code>     Boolean    当 <code>secure</code> 值为 <code>true</code> 时,<code>cookie</code> 在 HTTP 中是无效,在 <code>HTTPS</code> 中才有效</li><li><code>signed</code>     Boolean    表示是否签名<code>cookie</code>,如果设置为<code>true</code>的时候表示对这个<code>cookie</code>签名了,这样就需要用<code>res.signedCookies()</code>获取值<code>cookie</code>不是使用<code>res.cookies()</code>了</li></ul><p><strong>获取cookie</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get()</span><br><span class="line">index(@Request() req)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(req.cookies.username)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//加密的cookie获取方式</span></span><br><span class="line">      <span class="built_in">console</span>.log(req.signedCookies.username)  </span><br><span class="line">      <span class="keyword">return</span> req.cookies.username</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Cookie加密</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置中间件的时候需要传参</span></span><br><span class="line">app.use(cookieParser(<span class="string">'123456'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置cookie的时候配置signed属性</span></span><br><span class="line">res.cookie(<span class="string">'userinfo'</span>,<span class="string">'hahaha'</span>,&#123;<span class="attr">domain</span>:<span class="string">'.ccc.com'</span>,<span class="attr">maxAge</span>:<span class="number">900000</span>,<span class="attr">httpOnly</span>:<span class="literal">true</span>,<span class="attr">signed</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// signedCookies调用设置的cookie</span></span><br><span class="line"><span class="built_in">console</span>.log(req.signedCookies);</span><br></pre></td></tr></table></figure><h2 id="Session的使用"><a href="#Session的使用" class="headerlink" title="Session的使用"></a>Session的使用</h2><ul><li><code>session</code>是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而<code>session</code>保存在服务器上</li><li>当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session对象，生成一个类似于key,value的键值对， 然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带key(cookie)，找到对应的session(value)。 客户的信息都保存在session中</li></ul><p><strong>安装 express-session</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i express-session --save</span><br><span class="line">npm i -D @types/express-session --save</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NestExpressApplication &#125; <span class="keyword">from</span> <span class="string">'@nestjs/platform-express'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> session <span class="keyword">from</span> <span class="string">'express-seesion'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create&lt;NestExpressApplication&gt;(AppModule);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//配置session</span></span><br><span class="line">  app.use(session(&#123;</span><br><span class="line">      secret: <span class="string">'dmyxs'</span>,</span><br><span class="line">      cookie: &#123; <span class="attr">maxAge</span>: <span class="number">10000</span>, <span class="attr">httpOnly</span>: <span class="literal">true</span> &#125;,  <span class="comment">//以cookie存储到客户端</span></span><br><span class="line">      rolling: <span class="literal">true</span> <span class="comment">//每次重新请求时，重新设置cookie</span></span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><p><strong>session相关配置参数</strong></p><ul><li><code>secret</code>               String   生成<code>session</code>签名的密钥</li><li><code>name</code>               String   客户端的<code>cookie</code>的名称，默认为<code>connect.sid</code>, 可自己设置</li><li><code>resave</code>               Boolean    强制保存 <code>session</code> 即使它并没有变化, 默认为<code>true</code>, 建议设置成<code>false</code></li><li><code>saveUninitalized</code>   Boolean    强制将未初始化的 <code>session</code> 存储。当新建了一个 <code>session</code> 且未设定属性或值时，它就处于 未初始化状态。在设定一个 <code>cookie</code> 前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。默认:<code>true</code>, 建议手动添加</li><li><code>cookie</code>               Object   设置返回到前端<code>cookie</code>属性，默认值为<code>{ path: ‘/’, httpOnly: true, secure: false, maxAge: null }</code>。</li><li><code>rolling</code>               Boolean    在每次请求时强行设置 <code>cookie</code>，这将重置 <code>cookie</code> 过期时间, 默认为<code>false</code></li></ul><p><strong>接口中设置session</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get()</span><br><span class="line">  index(@Request() req)&#123;</span><br><span class="line">    <span class="comment">//设置session</span></span><br><span class="line">    req.session.username = <span class="string">'poetry'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取session</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get(<span class="string">'/session'</span>)</span><br><span class="line">  session(@Request() req, @Session() session )&#123;</span><br><span class="line">    <span class="comment">//获取session：两种方式</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.session.username)</span><br><span class="line">    <span class="built_in">console</span>.log(session.username)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello session'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨域，前缀路径、网站安全、请求限速"><a href="#跨域，前缀路径、网站安全、请求限速" class="headerlink" title="跨域，前缀路径、网站安全、请求限速"></a>跨域，前缀路径、网站安全、请求限速</h2><p><strong>跨域，路径前缀，网络安全</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add helmet csurf</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Logger, ValidationPipe &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> helmet <span class="keyword">from</span> <span class="string">'helmet'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> csurf <span class="keyword">from</span> <span class="string">'csurf'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 路径前缀：如：http://www.test.com/api/v1/user</span></span><br><span class="line">  app.setGlobalPrefix(<span class="string">'api/v1'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cors：跨域资源共享，方式一：允许跨站访问</span></span><br><span class="line">  app.enableCors();</span><br><span class="line">  <span class="comment">// 方式二：const app = await NestFactory.create(AppModule, &#123; cors: true &#125;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//防止跨站脚本攻击</span></span><br><span class="line">  app.use(helmet());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//CSRF保护：跨站点请求伪造</span></span><br><span class="line">  app.use(csurf());</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">await</span> app.listen(PORT, () =&gt; &#123;</span><br><span class="line">    Logger.log(</span><br><span class="line">      <span class="string">`服务已经启动,接口请访问:localhost:<span class="subst">$&#123;PORT&#125;</span><span class="subst">$&#123;PREFIX&#125;</span>`</span>,</span><br><span class="line">    )</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><p><strong>限速：限制客户端在一定时间内的请求次数</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add @nestjs/throttler</span><br></pre></td></tr></table></figure><blockquote><p>在需要使用的模块引入使用，这里是<strong>全局</strong>使用，在<code>app.module.ts</code>中引入。这里设置的是：<strong>1分钟内只能请求10次，超过则报status为429的错误</strong></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.module.ts</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; APP_GUARD &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserModule &#125; <span class="keyword">from</span> <span class="string">'./modules/user/user.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; ThrottlerModule, ThrottlerGuard &#125; <span class="keyword">from</span> <span class="string">'@nestjs/throttler'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">  UserModule,</span><br><span class="line">    ThrottlerModule.forRoot(&#123;</span><br><span class="line">      ttl: <span class="number">60</span>,  <span class="comment">//1分钟</span></span><br><span class="line">      limit: <span class="number">10</span>, <span class="comment">//请求10次</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  providers: [ <span class="comment">//全局使用</span></span><br><span class="line">    &#123;</span><br><span class="line">      provide: APP_GUARD,</span><br><span class="line">      useClass: ThrottlerGuard,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="管道、守卫、拦截器、过滤器、中间件"><a href="#管道、守卫、拦截器、过滤器、中间件" class="headerlink" title="管道、守卫、拦截器、过滤器、中间件"></a>管道、守卫、拦截器、过滤器、中间件</h2><ul><li><strong>管道</strong>：数据处理与转换，数据验证</li><li><strong>守卫</strong>：验证用户登陆，保护路由</li><li><strong>拦截器</strong>：对请求响应进行拦截，统一响应内容</li><li><strong>过滤器</strong>：异常捕获</li><li><strong>中间件</strong>：日志打印</li></ul><blockquote><p>执行顺序（时机）</p></blockquote><p>从客户端发送一个post请求，路径为：<code>/user/login</code>，请求参数为：<code>{userinfo: ‘xx’,password: ‘xx’}</code>，到服务器接收请求内容，触发绑定的函数并且执行相关逻辑完毕，然后返回内容给客户端的整个过程大体上要经过如下几个步骤：</p><p><img src="https://s.poetries.work/uploads/2022/05/1670837aa99d6cb8.png" alt></p><blockquote><p>全局使用: 管道 - 守卫 - 拦截器 - 过滤器 - 中间件。统一在main.ts文件中使用，全局生效</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ParseIntPipe &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; HttpExceptionFilter &#125; <span class="keyword">from</span> <span class="string">'./common/filters/http-exception.filter'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">'./common/middleware/logger.middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AuthGuard &#125; <span class="keyword">from</span> <span class="string">'./common/guard/auth.guard'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AuthInterceptor &#125; <span class="keyword">from</span> <span class="string">'./common/interceptors/auth.interceptor'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//全局使用管道：这里使用的是内置，也可以使用自定义管道，在下文</span></span><br><span class="line">  app.useGlobalPipes(<span class="keyword">new</span> ParseIntPipe());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//全局使用中间件</span></span><br><span class="line">  app.use(LoggerMiddleware)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//全局使用过滤器</span></span><br><span class="line">  <span class="comment">//这里使用的是自定义过滤器，先别管，先学会怎么在全局使用</span></span><br><span class="line">  app.useGlobalFilters(<span class="keyword">new</span> HttpExceptionFilter());  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//全局使用守卫</span></span><br><span class="line">  app.useGlobalGuards(<span class="keyword">new</span> AuthGuard());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//全局使用拦截器</span></span><br><span class="line">  app.useGlobalInterceptors(<span class="keyword">new</span> AuthInterceptor());</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>常用内置管道，从<code>@nestjs/common</code>导出</p><ul><li><code>ParseIntPipe</code>：将字符串数字转数字</li><li><code>ValidationPipe</code>：验证管道</li></ul><blockquote><p>局部使用管道</p></blockquote><ul><li><p>匹配整个路径，使用UsePipes</p></li><li><p>只匹配某个接口，使用UsePipes</p></li><li><p>在获取参数时匹配，一般使用内置管道</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Get,</span><br><span class="line">  Put,</span><br><span class="line">  Body,</span><br><span class="line">  Param,</span><br><span class="line">  UsePipes,</span><br><span class="line">  ParseIntPipe</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myPipe &#125; <span class="keyword">from</span> <span class="string">'../../common/pipes/user.pipe'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'user'</span>)</span><br><span class="line">@UsePipes(<span class="keyword">new</span> myPipe())  <span class="comment">//局部方式1：匹配整个/user， get请求和put请求都会命中</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  @Get(<span class="string">':id'</span>)</span><br><span class="line">  getUserById(@Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id) &#123; <span class="comment">//局部方式3：只匹配/user的get请求，使用的是内置管道</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'user'</span>, <span class="keyword">typeof</span> id);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Put(<span class="string">':id'</span>)</span><br><span class="line">  @UsePipes(<span class="keyword">new</span> myPipe())  <span class="comment">//局部方式2：只匹配/user的put请求</span></span><br><span class="line">  updateUser(@Body() user, @Param(<span class="string">'id'</span>) id) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user,</span><br><span class="line">      id,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自定义管道</p></blockquote><p>使用快捷命令生成：<code>nest g pi myPipe common/pipes</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ArgumentMetadata,</span><br><span class="line">  Injectable,</span><br><span class="line">  PipeTransform,</span><br><span class="line">  BadRequestException,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义管道必须实现自PipeTransform，固定写法，该接口有一个transform方法</span></span><br><span class="line"><span class="comment">//transform参数：</span></span><br><span class="line"><span class="comment">//value：使用myPipe时所传递的值，可以是param传递的的查询路径参数，可以是body的请求体</span></span><br><span class="line"><span class="comment">//metadata：元数据，可以用它判断是来自param或body或query</span></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">myPipe</span> <span class="title">implements</span> <span class="title">PipeTransform</span>&lt;<span class="title">string</span>&gt; </span>&#123;</span><br><span class="line">  transform(value: string, <span class="attr">metadata</span>: ArgumentMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (metadata.type === <span class="string">'body'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'来自请求体'</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (metadata.type === <span class="string">'param'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'来自查询路径'</span>, value);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> val = <span class="built_in">parseInt</span>(value, <span class="number">10</span>);</span><br><span class="line">      <span class="comment">//如果不是传递一个数字，抛出错误</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isNaN</span>(val)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">'Validation failed'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="守卫"><a href="#守卫" class="headerlink" title="守卫"></a>守卫</h3><blockquote><p>自定义守卫</p></blockquote><p>使用快捷命令生成：<code>nest g gu myGuard common/guards</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CanActivate, ExecutionContext, Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Reflector &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>; <span class="comment">//反射器，作用与自定义装饰器桥接，获取数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义守卫必须CanActivate，固定写法，该接口只有一个canActivate方法</span></span><br><span class="line"><span class="comment">//canActivate参数：</span></span><br><span class="line"><span class="comment">//context：请求的(Response/Request)的引用</span></span><br><span class="line"><span class="comment">//通过守卫返回true，否则返回false，返回403状态码</span></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthGuard</span> <span class="title">implements</span> <span class="title">CanActivate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly reflector: Reflector) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 白名单数组</span></span><br><span class="line">  private whiteUrlList: string[] = [<span class="string">'/user'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证该次请求是否为白名单内的路由</span></span><br><span class="line">  private isWhiteUrl(urlList: string[], <span class="attr">url</span>: string): boolean &#123;</span><br><span class="line">    <span class="keyword">if</span> (urlList.includes(url)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  canActivate(context: ExecutionContext): boolean &#123;</span><br><span class="line">    <span class="comment">// 获取请求对象</span></span><br><span class="line">    <span class="keyword">const</span> request = context.switchToHttp().getRequest();</span><br><span class="line">    <span class="comment">//console.log('request', request.headers);</span></span><br><span class="line">    <span class="comment">//console.log('request', request.params);</span></span><br><span class="line">    <span class="comment">//console.log('request', request.query);</span></span><br><span class="line">    <span class="comment">//console.log('request', request.url);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用法一：验证是否是白名单内的路由</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isWhiteUrl(<span class="keyword">this</span>.whiteUrlList, request.url)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用法二：使用反射器，配合装饰器使用，获取装饰器传递过来的数据</span></span><br><span class="line">    <span class="keyword">const</span> roles = <span class="keyword">this</span>.reflector.get&lt;string[]&gt;(<span class="string">'roles'</span>, context.getHandler());</span><br><span class="line">    <span class="comment">//console.log(roles); // [ 'admin' ]</span></span><br><span class="line">    <span class="comment">//http://localhost:3000/user/9?user=admin，如果与装饰器传递过来的值匹配则通过，否则不通过</span></span><br><span class="line">    <span class="comment">//真实开发中可能从cookie或token中获取值</span></span><br><span class="line">    <span class="keyword">const</span> &#123; user &#125; = request.query;</span><br><span class="line">    <span class="keyword">if</span> (roles.includes(user)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他用法</span></span><br><span class="line">    <span class="comment">// 获取请求头中的token字段</span></span><br><span class="line">    <span class="keyword">const</span> token = context.switchToRpc().getData().headers.token;</span><br><span class="line">    <span class="comment">// console.log('token', token);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取session</span></span><br><span class="line">    <span class="keyword">const</span> userinfo = context.switchToHttp().getRequest().session;</span><br><span class="line">    <span class="comment">// console.log('session', userinfo);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>局部使用守卫</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Get,</span><br><span class="line">  Delete,</span><br><span class="line">  Param,</span><br><span class="line">  UsePipes,</span><br><span class="line">  UseGuards,</span><br><span class="line">  ParseIntPipe,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AuthGuard &#125; <span class="keyword">from</span> <span class="string">'../../common/guard/auth.guard'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Role &#125; <span class="keyword">from</span> <span class="string">'../../common/decorator/role.decorator'</span>; <span class="comment">//自定义装饰器</span></span><br><span class="line"></span><br><span class="line">@UseGuards(AuthGuard) <span class="comment">//局部使用守卫，守卫整个user路径</span></span><br><span class="line">@Controller(<span class="string">'user'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  @Get(<span class="string">':id'</span>)</span><br><span class="line">  getUserById(@Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'user'</span>, <span class="keyword">typeof</span> id);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Delete(<span class="string">':id'</span>)</span><br><span class="line">  @Role(<span class="string">'admin'</span>)  <span class="comment">//使用自定义装饰器，传入角色，必须是admin才能删除</span></span><br><span class="line">  removeUser(@Param(<span class="string">'id'</span>) id) &#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>自定义守卫中使用到了自定义装饰器</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nest g d role common/decorator</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是快捷生成的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; SetMetadata &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SetMetadata作用：将获取到的值，设置到元数据中，然后守卫通过反射器才能获取到值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Roles = <span class="function">(<span class="params">...roles: string[]</span>) =&gt;</span> SetMetadata(<span class="string">'roles'</span>, roles);</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>使用快捷命令生成：<code>nest g in auth common/intercepters</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  CallHandler,</span><br><span class="line">  ExecutionContext,</span><br><span class="line">  Injectable,</span><br><span class="line">  NestInterceptor,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; map &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义拦截器必须实现自NestInterceptor，固定写法，该接口只有一个intercept方法</span></span><br><span class="line"><span class="comment">//intercept参数：</span></span><br><span class="line"><span class="comment">//context：请求上下文，可以拿到的Response和Request</span></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthInterceptor</span> <span class="title">implements</span> <span class="title">NestInterceptor</span> </span>&#123;</span><br><span class="line">  intercept(context: ExecutionContext, <span class="attr">next</span>: CallHandler): Observable&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> request = context.switchToHttp().getRequest();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'拦截器'</span>, request.url);</span><br><span class="line">    <span class="keyword">return</span> next.handle().pipe(</span><br><span class="line">      map(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'全局响应拦截器方法返回内容后...'</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          status: <span class="number">200</span>,</span><br><span class="line">          timestamp: <span class="keyword">new</span> <span class="built_in">Date</span>().toISOString(),</span><br><span class="line">          path: request.url,</span><br><span class="line">          message: <span class="string">'请求成功'</span>,</span><br><span class="line">          data: data,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><blockquote><p>局部使用过滤器</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Get,</span><br><span class="line">  UseFilters,</span><br><span class="line">  HttpException,</span><br><span class="line">  HttpStatus,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpExceptionFilter &#125; <span class="keyword">from</span> <span class="string">'../../common/filters/http-exception.filter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部使用过滤器</span></span><br><span class="line">@UseFilters(<span class="keyword">new</span> HttpExceptionFilter())</span><br><span class="line">@Controller(<span class="string">'/user'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line">  @Get()</span><br><span class="line">  getUserById(@Query() &#123; id &#125;): string &#123;</span><br><span class="line">    <span class="keyword">if</span> (!id) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">        &#123;</span><br><span class="line">          status: HttpStatus.BAD_REQUEST,</span><br><span class="line">          message: <span class="string">'请求参数id 必传'</span>,</span><br><span class="line">          error: <span class="string">'id is required'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        HttpStatus.BAD_REQUEST,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello error'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义过滤器</strong></p><p>使用快捷命令生成：<code>nest g f myFilter common/filters</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ArgumentsHost,</span><br><span class="line">  Catch,</span><br><span class="line">  ExceptionFilter,</span><br><span class="line">  HttpException,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须实现至ExceptionFilter，固定写法，该接口只有一个catch方法</span></span><br><span class="line"><span class="comment">//catch方法参数：</span></span><br><span class="line"><span class="comment">//exception：当前正在处理的异常对象</span></span><br><span class="line"><span class="comment">//host：传递给原始处理程序的参数的一个包装(Response/Request)的引用</span></span><br><span class="line">@Catch(HttpException)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpExceptionFilter</span> <span class="title">implements</span> <span class="title">ExceptionFilter</span>&lt;<span class="title">HttpException</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">catch</span>(exception: HttpException, <span class="attr">host</span>: ArgumentsHost) &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = host.switchToHttp();</span><br><span class="line">    <span class="keyword">const</span> response = ctx.getResponse();</span><br><span class="line">    <span class="keyword">const</span> request = ctx.getRequest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> status = exception.getStatus(); <span class="comment">//获取状态码</span></span><br><span class="line">    <span class="keyword">const</span> exceptionRes: any = exception.getResponse(); <span class="comment">//获取响应对象</span></span><br><span class="line">    <span class="keyword">const</span> &#123; error, message &#125; = exceptionRes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的异常响应内容</span></span><br><span class="line">    <span class="keyword">const</span> msgLog = &#123;</span><br><span class="line">      status,</span><br><span class="line">      timestamp: <span class="keyword">new</span> <span class="built_in">Date</span>().toISOString(),</span><br><span class="line">      path: request.url,</span><br><span class="line">      error,</span><br><span class="line">      message,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    response.status(status).json(msgLog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><blockquote><p>局部使用中间件</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, MiddlewareConsumer, RequestMethod &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">'./common/middleware/logger.middlerware'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserModule &#125; <span class="keyword">from</span> <span class="string">'./modules/user/user.module'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">imports:[ UserModule ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;</span><br><span class="line">  configure(consumer: MiddlewareConsumer) &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware) <span class="comment">//应用中间件</span></span><br><span class="line">      .exclude(&#123; <span class="attr">path</span>: <span class="string">'user'</span>, <span class="attr">method</span>: RequestMethod.POST &#125;)  <span class="comment">//排除user的post方法</span></span><br><span class="line">      .forRoutes(<span class="string">'user'</span>); <span class="comment">//监听路径  参数：路径名或*，*是匹配所以的路由</span></span><br><span class="line">      <span class="comment">// .forRoutes(&#123; path: 'user', method: RequestMethod.POST &#125;, &#123; path: 'album', method: RequestMethod.ALL &#125;); //多个</span></span><br><span class="line">     <span class="comment">// .apply(UserMiddleware) //支持多个中间件</span></span><br><span class="line">     <span class="comment">// .forRoutes('user')</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义中间件</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nest g mi logger common/middleware</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, NestMiddleware &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Request, Response &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerMiddleware</span> <span class="title">implements</span> <span class="title">NestMiddleware</span> </span>&#123;</span><br><span class="line">  <span class="comment">//req：请求参数</span></span><br><span class="line">  <span class="comment">//res：响应参数</span></span><br><span class="line">  <span class="comment">//next：执行下一个中件间</span></span><br><span class="line">  use(req: Request, <span class="attr">res</span>: Response, <span class="attr">next</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; method, path &#125; = req;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;method&#125;</span> <span class="subst">$&#123;path&#125;</span>`</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数式中间件</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数式中间件-应用于全局</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建实例</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create&lt;NestExpressApplication&gt;(AppModule);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置全局日志函数中间件</span></span><br><span class="line">  app.use(logger);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><h2 id="一例看懂中间件、守卫、管道、异常过滤器、拦截器"><a href="#一例看懂中间件、守卫、管道、异常过滤器、拦截器" class="headerlink" title="一例看懂中间件、守卫、管道、异常过滤器、拦截器"></a>一例看懂中间件、守卫、管道、异常过滤器、拦截器</h2><blockquote><p>从客户端发送一个post请求，路径为：<code>/user/login</code>，请求参数为：<code>{userinfo: ‘xx’,password: ‘xx’}</code>，到服务器接收请求内容，触发绑定的函数并且执行相关逻辑完毕，然后返回内容给客户端的整个过程大体上要经过如下几个步骤：`</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/05/8bb8d3e0e2bdaebe.png" alt></p><p>项目需要包支持：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save rxjs xml2js class-validator class-transformer</span><br></pre></td></tr></table></figure><ul><li><p><code>rxjs</code> 针对JavaScript的反应式扩展,支持更多的转换运算</p></li><li><p><code>xml2js</code> 转换xml内容变成json格式</p></li><li><code>class-validator</code>、<code>class-transformer</code> 管道验证包和转换器</li></ul><p>建立user模块：模块内容结构：</p><p><code>nest g res user</code></p><p><img src="https://s.poetries.work/uploads/2022/05/6b74e9b59b24a0fd.png" alt></p><p>user.controller.ts文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Post,</span><br><span class="line">  Body</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserLoginDTO &#125; <span class="keyword">from</span> <span class="string">'./dto/user.login.dto'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'user'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly userService: UserService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @Post(<span class="string">'test'</span>)</span><br><span class="line">  loginIn(@Body() userlogindto: UserLoginDTO) &#123;</span><br><span class="line">    <span class="keyword">return</span> userlogindto;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>user.module.ts文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserController &#125; <span class="keyword">from</span> <span class="string">'./user.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  controllers: [UserController],</span><br><span class="line">  providers: [UserService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>user.service.ts文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>user.login.dto.ts文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user / dto / user.login.dto.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; IsNotIn, MinLength &#125; <span class="keyword">from</span> <span class="string">'class-validator'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginDTO</span></span>&#123;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  * 账号</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  @IsNotIn([<span class="string">''</span>,<span class="literal">undefined</span>,<span class="literal">null</span>],&#123;<span class="attr">message</span>: <span class="string">'账号不能为空'</span>&#125;)</span><br><span class="line">  username: string;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  * 密码</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  @MinLength(<span class="number">6</span>,&#123;</span><br><span class="line">    message: <span class="string">'密码长度不能小于6位数'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  password: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app.module.ts文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子模块加载</span></span><br><span class="line"><span class="keyword">import</span> &#123; UserModule &#125; <span class="keyword">from</span> <span class="string">'./user/user.module'</span></span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    UserModule</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>新建common文件夹里面分别建立对应的文件夹以及文件：<br>中间件(middleware) — xml.middleware.ts<br>守卫(guard) — auth.guard.ts<br>管道(pipe) — validation.pipe.ts<br>异常过滤器(filters) — http-exception.filter.ts<br>拦截器(interceptor) — response.interceptor.ts</p></blockquote><p><img src="https://s.poetries.work/uploads/2022/05/b0bafbf19bde075f.png" alt></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ValidationPipe &#125; <span class="keyword">from</span> <span class="string">'./common/pipe/validation.pipe'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpExceptionFilter &#125; <span class="keyword">from</span> <span class="string">'./common/filters/http-exception.filter'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; XMLMiddleware &#125; <span class="keyword">from</span> <span class="string">'./common/middleware/xml.middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AuthGuard &#125; <span class="keyword">from</span> <span class="string">'./common/guard/auth.guard'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ResponseInterceptor &#125; <span class="keyword">from</span> <span class="string">'./common/interceptor/response.interceptor'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册通用验证管道ValidationPipe</span></span><br><span class="line">  app.useGlobalPipes(<span class="keyword">new</span> ValidationPipe());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册通用异常过滤器HttpExceptionFilter</span></span><br><span class="line">  app.useGlobalFilters(<span class="keyword">new</span> HttpExceptionFilter());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册xml支持中间件(这里必须调用.use才能够注册)</span></span><br><span class="line">  app.use(<span class="keyword">new</span> XMLMiddleware().use);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册权限验证守卫</span></span><br><span class="line">  app.useGlobalGuards(<span class="keyword">new</span> AuthGuard());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册响应拦截器</span></span><br><span class="line">  app.useGlobalInterceptors(<span class="keyword">new</span> ResponseInterceptor());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> app.listen(<span class="number">3001</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><h3 id="中间件是请求的第一道关卡"><a href="#中间件是请求的第一道关卡" class="headerlink" title="中间件是请求的第一道关卡"></a>中间件是请求的第一道关卡</h3><ol><li>执行任何代码。</li><li>对请求和响应对象进行更改。</li><li>结束请求-响应周期。</li><li>调用堆栈中的下一个中间件函数。</li><li>如果当前的中间件函数没有结束请求-响应周期, 它必须调用 next() 将控制传递给下一个中间件函数。否则, 请求将被挂起</li></ol><p>本例中：使用中间件让express支持xml请求并且将xml内容转换为json数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// common/middleware/xml.middleware.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable, NestMiddleware &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Request, Response &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">const</span> xml2js = <span class="built_in">require</span>(<span class="string">'xml2js'</span>);</span><br><span class="line"><span class="keyword">const</span> parser = <span class="keyword">new</span> xml2js.Parser();</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLMiddleware</span> <span class="title">implements</span> <span class="title">NestMiddleware</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 参数是固定的Request/Response/next,</span></span><br><span class="line">  <span class="comment">// Request/Response/next对应请求体和响应体和下一步函数</span></span><br><span class="line">  use(req: Request, <span class="attr">res</span>: Response, <span class="attr">next</span>: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入全局xml中间件...'</span>);</span><br><span class="line">    <span class="comment">// 获取express原生请求对象req,找到其请求头内容，如果包含application/xml，则执行转换</span></span><br><span class="line">    <span class="keyword">if</span>(req.headers[<span class="string">'content-type'</span>] &amp;&amp; req.headers[<span class="string">'content-type'</span>].includes(<span class="string">'application/xml'</span>))&#123;</span><br><span class="line">      <span class="comment">// 监听data方法获取到对应的参数数据(这里的方法是express的原生方法)</span></span><br><span class="line">      req.on(<span class="string">'data'</span>, mreq =&gt; &#123;</span><br><span class="line">        <span class="comment">// 使用xml2js对xml数据进行转换</span></span><br><span class="line">        parser.parseString(mreq,<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</span><br><span class="line">          <span class="comment">// 将转换后的数据放入到请求对象的req中</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'parseString转换后的数据'</span>,result);</span><br><span class="line">          <span class="comment">// 这里之后可以根据需要对result做一些补充完善</span></span><br><span class="line">          req[<span class="string">'body'</span>]= result;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用next方法进入到下一个中间件或者路由</span></span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册方式</strong></p><ul><li><p>全局注册：在<code>main.ts</code>中导入需要的中间件模块如：XMLMiddleware然后使用 <code>app.use(new XMLMiddleware().use)</code>即可</p></li><li><p>模块注册：在对应的模块中注册如：<code>user.module.ts</code></p></li></ul><p><img src="https://s.poetries.work/uploads/2022/05/7985e11265cdecc2.png" alt></p><blockquote><p>同一路由注册多个中间件的执行顺序为，先是全局中间件执行，然后是模块中间件执行，模块中的中间件顺序按照<code>.apply</code>中注册的顺序执行</p></blockquote><h3 id="守卫是第二道关卡"><a href="#守卫是第二道关卡" class="headerlink" title="守卫是第二道关卡"></a>守卫是第二道关卡</h3><blockquote><p>守卫控制一些权限内容，如：一些接口需要带上token标记，才能够调用，守卫则是对这个标记进行验证操作的。<br>本例中代码如下：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// common/guard/auth.guard.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;Injectable,CanActivate,HttpException,HttpStatus,ExecutionContext,&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthGuard</span> <span class="title">implements</span> <span class="title">CanActivate</span> </span>&#123;</span><br><span class="line">  <span class="comment">// context 请求的(Response/Request)的引用</span></span><br><span class="line">  <span class="keyword">async</span> canActivate(context: ExecutionContext): <span class="built_in">Promise</span>&lt;boolean&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入全局权限守卫...'</span>);</span><br><span class="line">    <span class="comment">// 获取请求对象</span></span><br><span class="line">    <span class="keyword">const</span> request = context.switchToHttp().getRequest();</span><br><span class="line">    <span class="comment">// 获取请求头中的token字段</span></span><br><span class="line">    <span class="keyword">const</span> token = context.switchToRpc().getData().headers.token;</span><br><span class="line">    <span class="comment">// 如果白名单内的路由就不拦截直接通过</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hasUrl(<span class="keyword">this</span>.urlList, request.url)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证token的合理性以及根据token做出相应的操作</span></span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以添加验证逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">          <span class="string">'没有授权访问,请先登录'</span>,</span><br><span class="line">          HttpStatus.UNAUTHORIZED,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">        <span class="string">'没有授权访问,请先登录'</span>,</span><br><span class="line">        HttpStatus.UNAUTHORIZED,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 白名单数组</span></span><br><span class="line">  private urlList: string[] = [</span><br><span class="line">    <span class="string">'/user/login'</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证该次请求是否为白名单内的路由</span></span><br><span class="line">  private hasUrl(urlList: string[], <span class="attr">url</span>: string): boolean &#123;</span><br><span class="line">    <span class="keyword">let</span> flag: boolean = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (urlList.indexOf(url) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注册方式</strong></p><ul><li>全局注册：在<code>main.ts</code>中导入需要的守卫模块如：<code>AuthGuard</code>。然后使用 <code>app.useGlobalGuards(new AuthGuard())</code> 即可</li><li>模块注册：在需要注册的<code>controller</code>控制器中导入<code>AuthGuard</code>。然后从<code>@nestjs/common</code>中导<code>UseGuards</code>装饰器。最后直接放置在对应的<code>@Controller()</code>或者<code>@Post/@Get…</code>等装饰器之下即可</li></ul><p><img src="https://s.poetries.work/uploads/2022/05/976e8bcbe31b38ce.png" alt></p><blockquote><p>同一路由注册多个守卫的执行顺序为，先是全局守卫执行，然后是模块中守卫执行</p></blockquote><h3 id="拦截器是第三道关卡"><a href="#拦截器是第三道关卡" class="headerlink" title="拦截器是第三道关卡"></a>拦截器是第三道关卡</h3><p>想到自定义返回内容如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;statusCode&quot;: 400,</span><br><span class="line">    &quot;timestamp&quot;: &quot;2022-05-14T08:06:45.265Z&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/user/login&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;请求失败&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;isNotIn&quot;: &quot;账号不能为空&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候就可以使用拦截器来做一下处理了。<br><strong>拦截器作用：</strong></p><ol><li>在函数执行之前/之后绑定额外的逻辑</li><li>转换从函数返回的结果</li><li>转换从函数抛出的异常</li><li>扩展基本函数行为</li><li>根据所选条件完全重写函数 (例如, 缓存目的)</li></ol><p><strong>拦截器的执行顺序分为两个部分：</strong></p><ul><li>第一个部分在管道和自定义逻辑(next.handle()方法)之前。</li><li>第二个部分在管道和自定义逻辑(next.handle()方法)之后。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// common/interceptor/response.interceptor.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 全局响应拦截器，统一返回体内容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Injectable,</span><br><span class="line">  NestInterceptor,</span><br><span class="line">  CallHandler,</span><br><span class="line">  ExecutionContext,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; map &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="comment">// 返回体结构</span></span><br><span class="line">interface Response&lt;T&gt; &#123;</span><br><span class="line">  data: T;</span><br><span class="line">&#125;</span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseInterceptor</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">NestInterceptor</span>&lt;<span class="title">T</span>, <span class="title">Response</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  intercept(</span><br><span class="line">    context: ExecutionContext,</span><br><span class="line">    next: CallHandler&lt;T&gt;,</span><br><span class="line">  ): Observable&lt;Response&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 解析ExecutionContext的数据内容获取到请求体</span></span><br><span class="line">    <span class="keyword">const</span> ctx = context.switchToHttp();</span><br><span class="line">    <span class="keyword">const</span> request = ctx.getRequest();</span><br><span class="line">    <span class="comment">// 实现数据的遍历与转变</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入全局响应拦截器...'</span>);</span><br><span class="line">    <span class="keyword">return</span> next.handle().pipe(</span><br><span class="line">      map(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'全局响应拦截器方法返回内容后...'</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          statusCode: <span class="number">0</span>,</span><br><span class="line">          timestamp: <span class="keyword">new</span> <span class="built_in">Date</span>().toISOString(),</span><br><span class="line">          path: request.url,</span><br><span class="line">          message: <span class="string">'请求成功'</span>,</span><br><span class="line">          data:data</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/05/8d262c4c5dcad632.png" alt></p><blockquote><p>中间多了个全局管道以及自定义逻辑，即只有路由绑定的函数有正确的返回值之后才会有<code>next.handle()</code>之后的内容</p></blockquote><p><strong>注册方式</strong></p><ul><li>全局注册：在<code>main.ts</code>中导入需要的模块如：<code>ResponseInterceptor</code>。然后使用 <code>app.useGlobalInterceptors(new ResponseInterceptor())</code>即可</li><li>模块注册：在需要注册的<code>controller</code>控制器中导入<code>ResponseInterceptor</code>。然后从<code>@nestjs/common</code>中导入<code>UseInterceptors</code>装饰器。最后直接放置在对应的<code>@Controller()</code>或者<code>@Post/@Get</code>…等装饰器之下即可</li></ul><p><img src="https://s.poetries.work/uploads/2022/05/099d67812f591bc5.png" alt></p><blockquote><p>同一路由注册多个拦截器时候，优先执行模块中绑定的拦截器，然后其拦截器转换的内容将作为全局拦截器的内容，即包裹两次返回内容如：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; // 全局拦截器效果</span><br><span class="line">    &quot;statusCode&quot;: 0,</span><br><span class="line">    &quot;timestamp&quot;: &quot;2022-05-14T08:20:06.159Z&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/user/login&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;请求成功&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">    &quot;pagenum&quot;: 1, // 模块中拦截器包裹效果</span><br><span class="line">    “pageSize&quot;: 10</span><br><span class="line">        &quot;list&quot;: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道是第四道关卡"><a href="#管道是第四道关卡" class="headerlink" title="管道是第四道关卡"></a>管道是第四道关卡</h3><ul><li><p>管道是请求过程中的第四个内容，主要用于对请求参数的验证和转换操作。</p></li><li><p>项目中使用<code>class-validator</code> <code>class-transformer</code>进行配合验证相关的输入操作内容</p></li></ul><p><strong>认识官方的三个内置管道</strong></p><ol><li><code>ValidationPipe</code>：基于<code>class-validator</code>和<code>class-transformer</code>这两个npm包编写的一个常规的验证管道，可以从<code>class-validator</code>导入配置规则，然后直接使用验证(当前不需要了解<code>ValidationPipe</code>的原理，只需要知道从<code>class-validator</code>引规则，设定到对应字段，然后使用<code>ValidationPipe</code>即可)</li><li><code>ParseIntPipe</code>：转换传入的参数为数字</li></ol><p><img src="https://s.poetries.work/uploads/2022/05/9b73303097ddcf73.png" alt></p><p>如：传递过来的是/test?id=‘123’”这里会将字符串‘123’转换成数字123</p><ol start="3"><li><strong>ParseUUIDPipe</strong>：验证字符串是否是 UUID(通用唯一识别码)</li></ol><p><img src="https://s.poetries.work/uploads/2022/05/ea2ed3388b228548.png" alt></p><p>如：传递过来的是/test?id=‘xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx’”这里会验证格式是否正确，不正确则抛出错误，否则调用findOne方法</p><p>本例中管道使用如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// common/pipe/validation.pipe.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 全局dto验证管道</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; validate &#125; <span class="keyword">from</span> <span class="string">'class-validator'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; plainToClass &#125; <span class="keyword">from</span> <span class="string">'class-transformer'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PipeTransform, Injectable, ArgumentMetadata, BadRequestException &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationPipe</span> <span class="title">implements</span> <span class="title">PipeTransform</span>&lt;<span class="title">any</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// value 是当前处理的参数，而 metatype 是属性的元类型</span></span><br><span class="line">  <span class="keyword">async</span> transform(value: any, &#123; metatype &#125;: ArgumentMetadata) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入全局管道...'</span>);</span><br><span class="line">    <span class="keyword">if</span> (!metatype || !<span class="keyword">this</span>.toValidate(metatype)) &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// plainToClass方法将普通的javascript对象转换为特定类的实例</span></span><br><span class="line">    <span class="keyword">const</span> object = plainToClass(metatype, value);</span><br><span class="line">    <span class="comment">// 验证该对象返回出错的数组</span></span><br><span class="line">    <span class="keyword">const</span> errors = <span class="keyword">await</span> validate(object);</span><br><span class="line">    <span class="keyword">if</span> (errors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 将错误信息数组中的第一个内容返回给异常过滤器</span></span><br><span class="line">      <span class="keyword">let</span> errormsg = errors.shift().constraints;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(errormsg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 验证属性值的元类型是否是String, Boolean, Number, Array, Object中的一种</span></span><br><span class="line">  private toValidate(metatype: any): boolean &#123;</span><br><span class="line">    <span class="keyword">const</span> types: <span class="built_in">Function</span>[] = [<span class="built_in">String</span>, <span class="built_in">Boolean</span>, <span class="built_in">Number</span>, <span class="built_in">Array</span>, <span class="built_in">Object</span>];</span><br><span class="line">    <span class="keyword">return</span> !types.includes(metatype);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册方式</strong></p><ul><li>全局注册：在<code>main.ts</code>中导入需要的模块如：<code>ValidationPipe</code>；然后使用 <code>app.useGlobalPipes(new ValidationPipe())</code> 即可</li><li>模块注册：在需要注册的<code>controller</code>控制器中导入<code>ValidationPipe</code>；然后从<code>@nestjs/common</code>中导入<code>UsePipes</code>装饰器；最后直接放置在对应的<code>@Controller()</code>或者<code>@Post/@Get…</code>等装饰器之下即可，管道还允许注册在相关的参数上如：<code>@Body/@Query…</code>等</li></ul><p><img src="https://s.poetries.work/uploads/2022/05/d9c2b21c632c9baa.png" alt></p><blockquote><p><strong>注意：</strong>同一路由注册多个管道的时候，优先执行全局管道，然后再执行模块管道：</p></blockquote><ul><li>异常过滤器是所有抛出的异常的统一处理方案</li><li>简单来讲就是捕获系统抛出的所有异常，然后自定义修改异常内容，抛出友好的提示。</li></ul><p><strong>内置异常类</strong></p><blockquote><p>系统提供了不少内置的系统异常类，需要的时候直接使用throw new XXX(描述,状态)这样的方式即可抛出对应的异常,一旦抛出异常，当前请求将会终止。</p></blockquote><p><strong>注意每个异常抛出的状态码有所不同</strong>。如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">BadRequestException — <span class="number">400</span></span><br><span class="line">UnauthorizedException — <span class="number">401</span></span><br><span class="line">ForbiddenException — <span class="number">403</span></span><br><span class="line">NotFoundException — <span class="number">404</span></span><br><span class="line">NotAcceptableException — <span class="number">406</span></span><br><span class="line">RequestTimeoutException — <span class="number">408</span></span><br><span class="line">ConflictException — <span class="number">409</span></span><br><span class="line">GoneException — <span class="number">410</span></span><br><span class="line">PayloadTooLargeException — <span class="number">413</span></span><br><span class="line">UnsupportedMediaTypeException — <span class="number">415</span></span><br><span class="line">UnprocessableEntityException — <span class="number">422</span></span><br><span class="line">InternalServerErrorException — <span class="number">500</span></span><br><span class="line">NotImplementedException — <span class="number">501</span></span><br><span class="line">BadGatewayException — <span class="number">502</span></span><br><span class="line">ServiceUnavailableException — <span class="number">503</span></span><br><span class="line">GatewayTimeoutException — <span class="number">504</span></span><br></pre></td></tr></table></figure><p>本例中使用的是自定义的异常类，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// common/filters/http-exception.filter.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; ExceptionFilter, Catch, ArgumentsHost, HttpException,Logger,HttpStatus &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Request, Response &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"></span><br><span class="line">@Catch()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpExceptionFilter</span> <span class="title">implements</span> <span class="title">ExceptionFilter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// exception 当前正在处理的异常对象</span></span><br><span class="line">  <span class="comment">// host 是传递给原始处理程序的参数的一个包装(Response/Request)的引用</span></span><br><span class="line">  <span class="keyword">catch</span>(exception: HttpException, <span class="attr">host</span>: ArgumentsHost) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入全局异常过滤器...'</span>);</span><br><span class="line">    <span class="keyword">const</span> ctx = host.switchToHttp();</span><br><span class="line">    <span class="keyword">const</span> response = ctx.getResponse&lt;Response&gt;();</span><br><span class="line">    <span class="keyword">const</span> request = ctx.getRequest&lt;Request&gt;();</span><br><span class="line">    <span class="comment">// HttpException 属于基础异常类，可自定义内容</span></span><br><span class="line">    <span class="comment">// 如果是自定义的异常类则抛出自定义的status </span></span><br><span class="line">    <span class="comment">// 否则就是内置HTTP异常类，然后抛出其对应的内置Status内容</span></span><br><span class="line">    <span class="keyword">const</span> status =</span><br><span class="line">      exception <span class="keyword">instanceof</span> HttpException</span><br><span class="line">        ? exception.getStatus()</span><br><span class="line">        : HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">    <span class="comment">// 抛出错误信息</span></span><br><span class="line">    <span class="keyword">const</span> message =</span><br><span class="line">      exception.message ||</span><br><span class="line">      exception.message.message ||</span><br><span class="line">      exception.message.error ||</span><br><span class="line">      <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> msgLog = &#123;</span><br><span class="line">      statusCode: status, <span class="comment">// 系统错误状态</span></span><br><span class="line">      timestamp: <span class="keyword">new</span> <span class="built_in">Date</span>().toISOString(), <span class="comment">// 错误日期</span></span><br><span class="line">      path: request.url, <span class="comment">// 错误路由</span></span><br><span class="line">      message: <span class="string">'请求失败'</span>, </span><br><span class="line">      data: message <span class="comment">// 错误消息内容体(争取和拦截器中定义的响应体一样)</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 打印错误综合日志</span></span><br><span class="line">     Logger.error(</span><br><span class="line">      <span class="string">'错误信息'</span>,</span><br><span class="line">      <span class="built_in">JSON</span>.stringify(msgLog),</span><br><span class="line">      <span class="string">'HttpExceptionFilter'</span>,</span><br><span class="line">    );</span><br><span class="line">    response</span><br><span class="line">      .status(status)</span><br><span class="line">      .json(msgLog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册方式</strong></p><ul><li>全局注册：在<code>main.ts</code>中导入需要的模块如：<code>HttpExceptionFilter</code> 然后使用 <code>app.useGlobalFilters(new HttpExceptionFilter())</code> 即可</li><li>模块注册：在需要注册的<code>controller</code>控制器中导入<code>HttpExceptionFilter</code>然后从<code>@nestjs/common</code>中导入<code>UseFilters</code>装饰器；最后直接放置在对应的<code>@Controller()</code>或者<code>@Post/@Get…</code>等装饰器之下即可</li></ul><p><img src="https://s.poetries.work/uploads/2022/05/0263be3b963d942b.png" alt></p><blockquote><p><strong>注意：</strong> 同一路由注册多个管道的时候，只会执行一个异常过滤器，优先执行模块中绑定的异常过滤器，如果模块中无绑定异常过滤则执行全局异常过滤器</p></blockquote><h2 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h2><p>如何 限制 和 验证 前端传递过来的数据？</p><p>常用：<code>dto</code>（data transfer object数据传输对象） + <code>class-validator</code>，自定义提示内容，还能集成swagger</p><p><strong>class-validator的验证项装饰器</strong></p><p><a href="https://github.com/typestack/class-validator#usage" target="_blank" rel="noopener">https://github.com/typestack/class-validator#usage</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@IsOptional() //可选的</span><br><span class="line">@IsNotEmpty(&#123; message: ‘不能为空’ &#125;)</span><br><span class="line">@MinLength(6, &#123;message: ‘密码长度不能小于6位’&#125;)</span><br><span class="line">@MaxLength(20, &#123;message: ‘密码长度不能超过20位’&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@IsEmail(&#123;&#125;, &#123; message: ‘邮箱格式错误’ &#125;) //邮箱</span><br><span class="line">@IsMobilePhone(‘zh-CN’, &#123;&#125;, &#123; message: ‘手机号码格式错误’ &#125;) //手机号码</span><br><span class="line">@IsEnum([0, 1], &#123;message: ‘只能传入数字0或1’&#125;) //枚举</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ValidateIf(o =&gt; o.username === ‘admin’) //条件判断，条件满足才验证，如：这里是传入的username是admin才验证</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add class-validator class-transformer</span><br></pre></td></tr></table></figure><p>全局使用内置管道<code>ValidationPipe</code> ，不然会报错，无法起作用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Logger, ValidationPipe &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line">  app.useGlobalPipes(<span class="keyword">new</span> ValidationPipe()); <span class="comment">//全局内置管道</span></span><br><span class="line">  <span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><p>编写<code>dto</code>，使用<code>class-validator</code>的校验项验证</p><p>创建DTO：只需要用户名，密码即可，两种都不能为空</p><blockquote><p>可以使用<code>nest g res user</code>一键创建带有dto的接口模块</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; IsNotEmpty, MinLength, MaxLength &#125; <span class="keyword">from</span> <span class="string">'class-validator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateUserDto</span> </span>&#123;</span><br><span class="line">  @IsNotEmpty(&#123; <span class="attr">message</span>: <span class="string">'用户名不能为空'</span> &#125;)</span><br><span class="line">  username: string;</span><br><span class="line"></span><br><span class="line">  @IsNotEmpty(&#123; <span class="attr">message</span>: <span class="string">'密码不能为空'</span> &#125;)</span><br><span class="line">  @MinLength(<span class="number">6</span>, &#123;</span><br><span class="line">    message: <span class="string">'密码长度不能小于6位'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  @MaxLength(<span class="number">20</span>, &#123;</span><br><span class="line">    message: <span class="string">'密码长度不能超过20位'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  password: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改DTO：用户名，密码，手机号码，邮箱，性别，状态，都是<strong>可选的</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  IsEnum,</span><br><span class="line">  MinLength,</span><br><span class="line">  MaxLength,</span><br><span class="line">  IsOptional,</span><br><span class="line">  IsEmail,</span><br><span class="line">  IsMobilePhone,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'class-validator'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Type &#125; <span class="keyword">from</span> <span class="string">'class-transformer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateUserDto</span> </span>&#123;</span><br><span class="line">  @IsOptional()</span><br><span class="line">  username: string;</span><br><span class="line"></span><br><span class="line">  @IsOptional()</span><br><span class="line">  @MinLength(<span class="number">6</span>, &#123;</span><br><span class="line">    message: <span class="string">'密码长度不能小于6位'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  @MaxLength(<span class="number">20</span>, &#123;</span><br><span class="line">    message: <span class="string">'密码长度不能超过20位'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  password: string;</span><br><span class="line"></span><br><span class="line">  @IsOptional()</span><br><span class="line">  @IsEmail(&#123;&#125;, &#123; <span class="attr">message</span>: <span class="string">'邮箱格式错误'</span> &#125;)</span><br><span class="line">  email: string;</span><br><span class="line"></span><br><span class="line">  @IsOptional()</span><br><span class="line">  @IsMobilePhone(<span class="string">'zh-CN'</span>, &#123;&#125;, &#123; <span class="attr">message</span>: <span class="string">'手机号码格式错误'</span> &#125;)</span><br><span class="line">  mobile: string;</span><br><span class="line"></span><br><span class="line">  @IsOptional()</span><br><span class="line">  @IsEnum([<span class="string">'male'</span>, <span class="string">'female'</span>], &#123;</span><br><span class="line">    message: <span class="string">'gender只能传入字符串male或female'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  gender: string;</span><br><span class="line"></span><br><span class="line">  @IsOptional()</span><br><span class="line">  @IsEnum(&#123; 禁用: <span class="number">0</span>, 可用: <span class="number">1</span> &#125;,&#123;</span><br><span class="line">    message: <span class="string">'status只能传入数字0或1'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  @Type(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Number</span>) <span class="comment">//如果传递的是string类型，不报错，自动转成number类型</span></span><br><span class="line">  status: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>controller</code>和<code>service</code>一起使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user.controller.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Post,</span><br><span class="line">  Body,</span><br><span class="line">  HttpCode,</span><br><span class="line">  HttpStatus,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateUserDto &#125; <span class="keyword">from</span> <span class="string">'./dto/create-user.dto'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'user'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly userService: UserService) &#123; &#125;</span><br><span class="line">  </span><br><span class="line">  @Post()</span><br><span class="line">  @HttpCode(HttpStatus.OK)</span><br><span class="line">  <span class="keyword">async</span> create(@Body() user: CreateUserDto) &#123; <span class="comment">//使用创建dto</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.create(user);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Patch(<span class="string">':id'</span>)</span><br><span class="line">    <span class="keyword">async</span> update(@Param(<span class="string">'id'</span>) id: string, @Body() user: UpdateUserDto) &#123;  <span class="comment">//使用更新dto</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.update(id, user);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user.service.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ToolsService &#125; <span class="keyword">from</span> <span class="string">'../../utils/tools.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateUserDto &#125; <span class="keyword">from</span> <span class="string">'./dto/create-user.dto'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> create(user: CreateUserDto) &#123; <span class="comment">//使用dto</span></span><br><span class="line">    <span class="keyword">do</span> some thing....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/05/21f5a8f9dbfad1f0.png" alt><br><img src="https://s.poetries.work/uploads/2022/05/38a1ae106ec9638c.png" alt></p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="配置抽离"><a href="#配置抽离" class="headerlink" title="配置抽离"></a>配置抽离</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add nestjs-config</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.module.ts</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据库</span></span><br><span class="line"><span class="keyword">import</span> &#123; TypeOrmModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局配置</span></span><br><span class="line"><span class="keyword">import</span> &#123; ConfigModule, ConfigService &#125; <span class="keyword">from</span> <span class="string">'nestjs-config'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    <span class="comment">//1.配置config目录</span></span><br><span class="line">    ConfigModule.load(path.resolve(__dirname, <span class="string">'config'</span>, <span class="string">'**/!(*.d).&#123;ts,js&#125;'</span>)),  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.读取配置，这里读取的是数据库配置</span></span><br><span class="line">TypeOrmModule.forRootAsync(&#123;</span><br><span class="line">      useFactory: <span class="function">(<span class="params">config: ConfigService</span>) =&gt;</span> config.get(<span class="string">'database'</span>), </span><br><span class="line">      inject: [ConfigService],  <span class="comment">// 获取服务注入</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  controllers: [AppController],</span><br><span class="line">  providers: [AppService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>配置数据库</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">src -&gt; config -&gt; database</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; join &#125; <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  type: <span class="string">'mysql'</span>,</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  port: <span class="number">3306</span>,</span><br><span class="line">  username: <span class="string">'root'</span>,</span><br><span class="line">  password: <span class="string">'your password'</span>,</span><br><span class="line">  database: <span class="string">'test'</span>,</span><br><span class="line">  entities: [join(__dirname, <span class="string">'../'</span>, <span class="string">'**/**.entity&#123;.ts,.js&#125;'</span>)],</span><br><span class="line">  synchronize: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add cross-env</span><br></pre></td></tr></table></figure><p>cross-env的作用是兼容window系统和mac系统来设置环境变量</p><p><strong>在package.json中配置</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start:dev&quot;: &quot;cross-env NODE_ENV=development nest start --watch&quot;,</span><br><span class="line">    &quot;start:debug&quot;: &quot;nest start --debug --watch&quot;,</span><br><span class="line">    &quot;start:prod&quot;: &quot;cross-env NODE_ENV=production node dist/main&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p><strong>dotenv的使用</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add dotenv</span><br></pre></td></tr></table></figure><p><strong>根目录创建 env.parse.ts</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> dotenv <span class="keyword">from</span> <span class="string">'dotenv'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isProd = process.env.NODE_ENV === <span class="string">'production'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localEnv = path.resolve(<span class="string">'.env.local'</span>);</span><br><span class="line"><span class="keyword">const</span> prodEnv = path.resolve(<span class="string">'.env.prod'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filePath = isProd &amp;&amp; fs.existsSync(prodEnv) ? prodEnv : localEnv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 通过process.env.xx读取变量</span></span><br><span class="line">dotenv.config(&#123; <span class="attr">path</span>: filePath &#125;);</span><br></pre></td></tr></table></figure><p>导入环境</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// main.ts</span><br><span class="line">import &apos;../env.parse&apos;; // 导入环境变量</span><br></pre></td></tr></table></figure><p><code>.env.local</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PORT=9000</span><br><span class="line">MYSQL_HOST=127.0.0.1</span><br><span class="line">MYSQL_PORT=3306</span><br><span class="line">MYSQL_USER=root</span><br><span class="line">MYSQL_PASSWORD=123</span><br><span class="line">MYSQL_DATABASE=test</span><br></pre></td></tr></table></figure><p><code>.env.prod</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PORT=9000</span><br><span class="line">MYSQL_HOST=127.0.0.1</span><br><span class="line">MYSQL_PORT=3306</span><br><span class="line">MYSQL_USER=root</span><br><span class="line">MYSQL_PASSWORD=1234</span><br><span class="line">MYSQL_DATABASE=test</span><br></pre></td></tr></table></figure><p>读取环境变量 <code>process.env.MYSQL_HOST</code>形式</p><h2 id="文件上传与下载"><a href="#文件上传与下载" class="headerlink" title="文件上传与下载"></a>文件上传与下载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add @nestjs/platform-express compressing</span><br><span class="line"></span><br><span class="line">compressing 文件下载依赖，提供流的方式</span><br></pre></td></tr></table></figure><p>配置文件的目录地址，以及文件的名字格式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// src/config/file.ts 上传文件配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; join &#125; <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; diskStorage &#125; <span class="keyword">from</span> <span class="string">'multer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传文件配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  root: join(__dirname, <span class="string">'../../assets/uploads'</span>),</span><br><span class="line">  storage: diskStorage(&#123;</span><br><span class="line">    destination: join(</span><br><span class="line">      __dirname,</span><br><span class="line">      <span class="string">`../../assets/uploads/<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleDateString()&#125;</span>`</span>,</span><br><span class="line">    ),</span><br><span class="line">    filename: <span class="function">(<span class="params">req, file, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> filename = <span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()&#125;</span>.<span class="subst">$&#123;file.mimetype.split(<span class="string">'/'</span>)[<span class="number">1</span>]&#125;</span>`</span>;</span><br><span class="line">      <span class="keyword">return</span> cb(<span class="literal">null</span>, filename);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; ConfigModule, ConfigService &#125; <span class="keyword">from</span> <span class="string">'nestjs-config'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    <span class="comment">// 加载配置文件目录 src/config</span></span><br><span class="line">    ConfigModule.load(resolve(__dirname, <span class="string">'config'</span>, <span class="string">'**/!(*.d).&#123;ts,js&#125;'</span>)),</span><br><span class="line">  ],</span><br><span class="line">  controllers: [],</span><br><span class="line">  providers: [],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> <span class="title">implements</span> <span class="title">NestModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// upload.controller.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Get,</span><br><span class="line">  Post,</span><br><span class="line">  UseInterceptors,</span><br><span class="line">  UploadedFile,</span><br><span class="line">  UploadedFiles,</span><br><span class="line">  Body,</span><br><span class="line">  Res,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FileInterceptor, FilesInterceptor &#125; <span class="keyword">from</span> <span class="string">'@nestjs/platform-express'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FileUploadDto &#125; <span class="keyword">from</span> <span class="string">'./dto/upload-file.dto'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UploadService &#125; <span class="keyword">from</span> <span class="string">'./upload.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Response &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'common'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly uploadService: UploadService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @Post(<span class="string">'upload'</span>)</span><br><span class="line">  @UseInterceptors(FileInterceptor(<span class="string">'file'</span>))</span><br><span class="line">  uploadFile(@UploadedFile() file) &#123;</span><br><span class="line">    <span class="keyword">this</span>.uploadService.uploadSingleFile(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 多文件上传</span></span><br><span class="line">  @Post(<span class="string">'uploads'</span>)</span><br><span class="line">  @UseInterceptors(FilesInterceptor(<span class="string">'file'</span>))</span><br><span class="line">  uploadMuliFile(@UploadedFiles() files, @Body() body) &#123;</span><br><span class="line">    <span class="keyword">this</span>.uploadService.UploadMuliFile(files, body);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">'export'</span>)</span><br><span class="line">  <span class="keyword">async</span> downloadAll(@Res() res: Response) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; filename, tarStream &#125; = <span class="keyword">await</span> <span class="keyword">this</span>.uploadService.downloadAll();</span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/octet-stream'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Content-Disposition'</span>, <span class="string">`attachment; filename=<span class="subst">$&#123;filename&#125;</span>`</span>);</span><br><span class="line">    tarStream.pipe(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// upload.service.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable, HttpException, HttpStatus &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; join &#125; <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createWriteStream &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; tar &#125; <span class="keyword">from</span> <span class="string">'compressing'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConfigService &#125; <span class="keyword">from</span> <span class="string">'nestjs-config'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly configService: ConfigService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  uploadSingleFile(file: any) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'file'</span>, file);</span><br><span class="line">  &#125;</span><br><span class="line">  UploadMuliFile(files: any, <span class="attr">body</span>: any) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'files'</span>, files);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> downloadAll() &#123;</span><br><span class="line">    <span class="keyword">const</span> uploadDir = <span class="keyword">this</span>.configService.get(<span class="string">'file'</span>).root;</span><br><span class="line">    <span class="keyword">const</span> tarStream = <span class="keyword">new</span> tar.Stream();</span><br><span class="line">    <span class="keyword">await</span> tarStream.addEntry(uploadDir);</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">filename</span>: <span class="string">'download.tar'</span>, tarStream &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// upload.module.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MulterModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/platform-express'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConfigService &#125; <span class="keyword">from</span> <span class="string">'nestjs-config'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UploadService &#125; <span class="keyword">from</span> <span class="string">'./upload.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UploadController &#125; <span class="keyword">from</span> <span class="string">'./upload.controller'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    MulterModule.registerAsync(&#123;</span><br><span class="line">      useFactory: <span class="function">(<span class="params">config: ConfigService</span>) =&gt;</span> config.get(<span class="string">'file'</span>),</span><br><span class="line">      inject: [ConfigService],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  controllers: [UploadController],</span><br><span class="line">  providers: [UploadService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="实现图片随机验证码"><a href="#实现图片随机验证码" class="headerlink" title="实现图片随机验证码"></a>实现图片随机验证码</h2><p>nest如何实现图片随机验证码？</p><p><img src="https://s.poetries.work/uploads/2022/05/58d3d8e7ca89835f.png" alt></p><p>这里使用的是<strong>svg-captcha</strong>这个库，你也可以使用其他的库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add svg-captcha</span><br></pre></td></tr></table></figure><p><strong>封装，以便多次调用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">src -&gt; utils -&gt; tools.service.ts</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> svgCaptcha <span class="keyword">from</span> <span class="string">'svg-captcha'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolsService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> captche(size = <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> captcha = svgCaptcha.create(&#123;  <span class="comment">//可配置返回的图片信息</span></span><br><span class="line">      size, <span class="comment">//生成几个验证码</span></span><br><span class="line">      fontSize: <span class="number">50</span>, <span class="comment">//文字大小</span></span><br><span class="line">      width: <span class="number">100</span>,  <span class="comment">//宽度</span></span><br><span class="line">      height: <span class="number">34</span>,  <span class="comment">//高度</span></span><br><span class="line">      background: <span class="string">'#cc9966'</span>,  <span class="comment">//背景颜色</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> captcha;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在使用的module中引入</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserController &#125; <span class="keyword">from</span> <span class="string">'./user.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ToolsService &#125; <span class="keyword">from</span> <span class="string">'../../utils/tools.service'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  controllers: [UserController],</span><br><span class="line">  providers: [UserService, ToolsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Post，Body &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; EmailService &#125; <span class="keyword">from</span> <span class="string">'./email.service'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'user'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly toolsService: ToolsService,) &#123;&#125;  <span class="comment">//注入服务</span></span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">'authcode'</span>)  <span class="comment">//当请求该接口时，返回一张随机图片验证码</span></span><br><span class="line">  <span class="keyword">async</span> getCode(@Req() req, @Res() res) &#123;</span><br><span class="line">    <span class="keyword">const</span> svgCaptcha = <span class="keyword">await</span> <span class="keyword">this</span>.toolsService.captche(); <span class="comment">//创建验证码</span></span><br><span class="line">    req.session.code = svgCaptcha.text; <span class="comment">//使用session保存验证，用于登陆时验证</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.session.code);</span><br><span class="line">    res.type(<span class="string">'image/svg+xml'</span>); <span class="comment">//指定返回的类型</span></span><br><span class="line">    res.send(svgCaptcha.data); <span class="comment">//给页面返回一张图片</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Post(<span class="string">'/login'</span>)</span><br><span class="line">  login(@Body() body, @Session() session) &#123;</span><br><span class="line">  <span class="comment">//验证验证码，由前端传递过来</span></span><br><span class="line">  <span class="keyword">const</span> &#123; code &#125; = body;</span><br><span class="line">  <span class="keyword">if</span>(code?.toUpperCase() === session.code?.toUpperCase())&#123;</span><br><span class="line"><span class="built_in">console</span>.log(‘验证码通过’)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello authcode'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前端简单代码</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        form &#123;</span><br><span class="line">            display: flex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.input</span> &#123;</span></span><br><span class="line">            width: 80px;</span><br><span class="line">            height: 32px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.verify_img</span> &#123;</span></span><br><span class="line">            margin: 0px 5px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>随机验证码<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/user/login"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">'code'</span> <span class="attr">class</span>=<span class="string">"input"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"verify_img"</span> <span class="attr">src</span>=<span class="string">"/user/code"</span> <span class="attr">title</span>=<span class="string">"看不清？点击刷新"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">onclick</span>=<span class="string">"javascript:this.src='/user/code?t='+Math.random()"</span>&gt;</span> //点击再次生成新的验证码</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h2><blockquote><p>邮件服务使用文档 <a href="https://nest-modules.github.io/mailer/docs/mailer" target="_blank" rel="noopener">https://nest-modules.github.io/mailer/docs/mailer</a></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邮件服务配置</span></span><br><span class="line"><span class="comment">// app.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; MailerModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs-modules/mailer'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; resolve, join &#125; <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConfigModule, ConfigService &#125; <span class="keyword">from</span> <span class="string">'nestjs-config'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    <span class="comment">// 加载配置文件目录 src/config</span></span><br><span class="line">    ConfigModule.load(resolve(__dirname, <span class="string">'config'</span>, <span class="string">'**/!(*.d).&#123;ts,js&#125;'</span>)),</span><br><span class="line">    <span class="comment">// 邮件服务配置</span></span><br><span class="line">    MailerModule.forRootAsync(&#123;</span><br><span class="line">      useFactory: <span class="function">(<span class="params">config: ConfigService</span>) =&gt;</span> config.get(<span class="string">'email'</span>),</span><br><span class="line">      inject: [ConfigService],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  controllers: [],</span><br><span class="line">  providers: [],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> <span class="title">implements</span> <span class="title">NestModule</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// src/config/email.ts 邮件服务配置</span></span><br><span class="line"><span class="keyword">import</span> &#123; join &#125; <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="comment">// npm i ejs -S</span></span><br><span class="line"><span class="keyword">import</span> &#123; EjsAdapter &#125; <span class="keyword">from</span> <span class="string">'@nestjs-modules/mailer/dist/adapters/ejs.adapter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  transport: &#123;</span><br><span class="line">    host: <span class="string">'smtp.qq.com'</span>,</span><br><span class="line">    secureConnection: <span class="literal">true</span>, <span class="comment">// use SSL</span></span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">465</span>,</span><br><span class="line">    ignoreTLS: <span class="literal">false</span>,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      user: <span class="string">'123@test.com'</span>,</span><br><span class="line">      pass: <span class="string">'dfafew1'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  defaults: &#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="string">'"nestjs" &lt;123@test.com&gt;'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// preview: true, // 发送邮件前预览</span></span><br><span class="line">  template: &#123;</span><br><span class="line">    dir: join(__dirname, <span class="string">'../templates/email'</span>), <span class="comment">// 邮件模板</span></span><br><span class="line">    adapter: <span class="keyword">new</span> EjsAdapter(),</span><br><span class="line">    options: &#123;</span><br><span class="line">      strict: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>邮件服务使用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// email.services.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MailerService &#125; <span class="keyword">from</span> <span class="string">'@nestjs-modules/mailer'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 邮件服务注入</span></span><br><span class="line">  <span class="keyword">constructor</span>(private mailerService: MailerService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> sendEmail() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'发送邮件'</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.mailerService.sendMail(&#123;</span><br><span class="line">      to: <span class="string">'test@qq.com'</span>, <span class="comment">// 收件人</span></span><br><span class="line">      <span class="keyword">from</span>: <span class="string">'123@test.com'</span>, <span class="comment">// 发件人</span></span><br><span class="line">      <span class="comment">// subject: '副标题',</span></span><br><span class="line">      text: <span class="string">'welcome'</span>, <span class="comment">// plaintext body</span></span><br><span class="line">      html: <span class="string">'&lt;h1&gt;hello&lt;/h1&gt;'</span>, <span class="comment">// HTML body content</span></span><br><span class="line">      <span class="comment">// template: 'email', // 邮件模板</span></span><br><span class="line">      <span class="comment">// context: &#123; // 传入邮件模板的data</span></span><br><span class="line">      <span class="comment">//   email: 'test@qq.com',</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'发送成功'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nest基于possport-jwt做登陆验证"><a href="#nest基于possport-jwt做登陆验证" class="headerlink" title="nest基于possport + jwt做登陆验证"></a>nest基于possport + jwt做登陆验证</h2><p><strong>方式与逻辑</strong></p><ul><li>基于possport的本地策略和jwt策略</li><li><strong>本地策略</strong>主要是验证账号和密码是否存在，如果存在就登陆，返回<strong>token</strong></li><li><strong>jwt策略</strong>则是验证用户<strong>登陆时附带的token</strong>是否匹配和有效，如果不匹配和无效则返回<strong>401状态码</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add @nestjs/jwt @nestjs/passport passport-jwt passport-local passport</span><br><span class="line">yarn add -D @types/passport @types/passport-jwt @types/passport-local</span><br></pre></td></tr></table></figure><p><strong>jwt策略 jwt.strategy.ts</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/modules/auth/jwt.strategy.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Strategy, ExtractJwt, StrategyOptions &#125; <span class="keyword">from</span> <span class="string">'passport-jwt'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PassportStrategy &#125; <span class="keyword">from</span> <span class="string">'@nestjs/passport'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; jwtConstants &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtStrategy</span> <span class="keyword">extends</span> <span class="title">PassportStrategy</span>(<span class="title">Strategy</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(&#123;</span><br><span class="line">      jwtFromRequest: ExtractJwt.fromHeader(<span class="string">'token'</span>),</span><br><span class="line">      ignoreExpiration: <span class="literal">false</span>,</span><br><span class="line">      secretOrKey: jwtConstants.secret, <span class="comment">// 使用密钥解析</span></span><br><span class="line">    &#125; <span class="keyword">as</span> StrategyOptions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//token验证, payload是super中已经解析好的token信息</span></span><br><span class="line">  <span class="keyword">async</span> validate(payload: any) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">userId</span>: payload.userId, <span class="attr">username</span>: payload.username &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本地策略 local.strategy.ts</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/modules/auth/local.strategy.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Strategy, IStrategyOptions &#125; <span class="keyword">from</span> <span class="string">'passport-local'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Injectable, HttpException, HttpStatus &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PassportStrategy &#125; <span class="keyword">from</span> <span class="string">'@nestjs/passport'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AuthService &#125; <span class="keyword">from</span> <span class="string">'./auth.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本地策略</span></span><br><span class="line"><span class="comment">//PassportStrategy接受两个参数：</span></span><br><span class="line"><span class="comment">//第一个：Strategy，你要用的策略，这里是passport-local，本地策略</span></span><br><span class="line"><span class="comment">//第二个：别名，可选，默认是passport-local的local，用于接口时传递的字符串</span></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalStrategy</span> <span class="keyword">extends</span> <span class="title">PassportStrategy</span>(<span class="title">Strategy</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private authService: AuthService) &#123;</span><br><span class="line">    <span class="keyword">super</span>(&#123;</span><br><span class="line">      usernameField: <span class="string">'username'</span>,</span><br><span class="line">      passwordField: <span class="string">'password'</span>,</span><br><span class="line">    &#125; <span class="keyword">as</span> IStrategyOptions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// validate是LocalStrategy的内置方法</span></span><br><span class="line">  <span class="keyword">async</span> validate(username: string, <span class="attr">password</span>: string): <span class="built_in">Promise</span>&lt;any&gt; &#123;</span><br><span class="line">    <span class="comment">//查询数据库，验证账号密码，并最终返回用户</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.authService.validateUser(&#123; username, password &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>constants.ts</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/modules/auth/constants.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> jwtConstants = &#123;</span><br><span class="line">  secret: <span class="string">'secretKey'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用守卫 auth.controller.ts</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/modules/auth/auth.controller.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Post, Request, UseGuards &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AuthGuard &#125; <span class="keyword">from</span> <span class="string">'@nestjs/passport'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AuthService &#125; <span class="keyword">from</span> <span class="string">'./auth.service'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'auth'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly authService: AuthService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登录测试 无需token</span></span><br><span class="line">  @UseGuards(AuthGuard(<span class="string">'local'</span>)) <span class="comment">//本地策略，传递local，执行local里面的validate方法</span></span><br><span class="line">  @Post(<span class="string">'login'</span>)</span><br><span class="line">  <span class="keyword">async</span> login(@Request() req) &#123; <span class="comment">//通过req可以获取到validate方法返回的user，传递给login，登陆</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.authService.login(req.user);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在需要的地方使用守卫，需要带token才可访问</span></span><br><span class="line">  @UseGuards(AuthGuard(<span class="string">'jwt'</span>))<span class="comment">//jwt策略，身份鉴权</span></span><br><span class="line">  @Get(<span class="string">'userInfo'</span>)</span><br><span class="line">  getUserInfo(@Request() req) &#123;<span class="comment">//通过req获取到被验证后的user，也可以使用装饰器</span></span><br><span class="line">    <span class="keyword">return</span> req.user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在module引入jwt配置和数据库查询的实体 auth.module.ts</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/modules/auth/auth.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; LocalStrategy &#125; <span class="keyword">from</span> <span class="string">'./local.strategy'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; jwtConstants &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PassportModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/passport'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; JwtModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/jwt'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AuthService &#125; <span class="keyword">from</span> <span class="string">'./auth.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AuthController &#125; <span class="keyword">from</span> <span class="string">'./auth.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; JwtStrategy &#125; <span class="keyword">from</span> <span class="string">'./jwt.strategy'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'../user/entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; TypeOrmModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    TypeOrmModule.forFeature([UsersEntity]),</span><br><span class="line">    PassportModule,</span><br><span class="line">    JwtModule.register(&#123;</span><br><span class="line">      secret: jwtConstants.secret,</span><br><span class="line">      signOptions: &#123; <span class="attr">expiresIn</span>: <span class="string">'10d'</span> &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  controllers: [AuthController],</span><br><span class="line">  providers: [AuthService, LocalStrategy, JwtStrategy],</span><br><span class="line">  exports: [AuthService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>auth.service.ts</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/modules/auth/auth.service.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; JwtService &#125; <span class="keyword">from</span> <span class="string">'@nestjs/jwt'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; compareSync &#125; <span class="keyword">from</span> <span class="string">'bcryptjs'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">  @InjectRepository(UsersEntity),</span><br><span class="line">       private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">  private jwtService: JwtService</span><br><span class="line">    ) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  validateUser(username: string, <span class="attr">password</span>: string) &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(&#123;</span><br><span class="line">      where: &#123; username &#125;,</span><br><span class="line">      select: [<span class="string">'username'</span>, <span class="string">'password'</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户名或密码不正确'</span>);</span><br><span class="line">    <span class="comment">//使用bcryptjs验证密码</span></span><br><span class="line">    <span class="keyword">if</span> (!compareSync(password, user.password)) &#123;</span><br><span class="line">      ToolsService.fail(<span class="string">'用户名或密码不正确'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">  login(user: any) &#123;</span><br><span class="line">    <span class="keyword">const</span> payload = &#123; <span class="attr">username</span>: user.username &#125;;  <span class="comment">// 把信息存在token</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      token: <span class="keyword">this</span>.jwtService.sign(payload),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在app.module.ts中导入即可测试</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.modules.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; AuthModule &#125; <span class="keyword">from</span> <span class="string">'./modules/auth/auth.module'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    ...</span><br><span class="line">    AuthModule, <span class="comment">// 导入模块</span></span><br><span class="line">  ],</span><br><span class="line">  controllers: [AppController],</span><br><span class="line">  providers: [],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> <span class="title">implements</span> <span class="title">NestModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>使用postman测试</strong></p><p><img src="https://s.poetries.work/uploads/2022/05/154d26405e7a471a.png" alt></p><h2 id="对数据库的密码加密：md5和bcryptjs"><a href="#对数据库的密码加密：md5和bcryptjs" class="headerlink" title="对数据库的密码加密：md5和bcryptjs"></a>对数据库的密码加密：md5和bcryptjs</h2><p><strong>密码加密</strong></p><blockquote><p>一般开发中，是不会有人直接将密码明文直接放到数据库当中的。因为这种做法是非常不安全的，需要对密码进行加密处理。<br>好处：</p><ul><li>预防内部网站运营人员知道用户的密码</li><li>预防外部的攻击，尽可能保护用户的隐私</li></ul></blockquote><p><strong>加密方式</strong></p><ul><li>使用<code>md5</code>：每次生成的值是一样的，一些网站可以破解，因为每次存储的都是一样的值</li><li>使用<code>bcryptjs</code>：每次生成的值是不一样的</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add md5</span><br></pre></td></tr></table></figure><p>加密</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> md5 <span class="keyword">from</span> <span class="string">'md5'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> passwrod = <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">const</span> transP = md5(passwrod);  <span class="comment">// 固定值：e10adc3949ba59abbe56e057f20f883e</span></span><br></pre></td></tr></table></figure><p>给密码加点”盐”：目的是混淆密码，其实还是得到固定的值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> passwrod = <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">const</span> salt = <span class="string">'dmxys'</span></span><br><span class="line"><span class="keyword">const</span> transP = md5(passwrod + salt);  <span class="comment">// 固定值：4e6a2881e83262a72f6c70f48f3e8022</span></span><br></pre></td></tr></table></figure><p>验证密码：先加密，再验证</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> passwrod = <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">const</span> databasePassword = <span class="string">'e10adc3949ba59abbe56e057f20f883e'</span></span><br><span class="line"><span class="keyword">if</span> (md5(passwrod) === databasePassword ) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'密码通过'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用bcryptjs</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add bcryptjs</span><br><span class="line">yarn add -D @types/bcryptjs</span><br></pre></td></tr></table></figure><p>同一密码，每次生成不一样的值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; compareSync, hashSync &#125; <span class="keyword">from</span> <span class="string">'bcryptjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> passwrod = <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">const</span> transformPass = hashSync(passwrod);  $<span class="number">2</span>a$<span class="number">10</span>$HgTA1GX8uxbocSQlbQ42/.Y2XnIL7FyfKzn6IC69IXveD6F9LiULS</span><br><span class="line"><span class="keyword">const</span> transformPass2 = hashSync(passwrod); $<span class="number">2</span>a$<span class="number">10</span>$mynd130vI1vkz4OQ3C<span class="number">.6</span>FeYXGEq24KLUt1CsKN2WZqVsv0tPrtOcW</span><br><span class="line"><span class="keyword">const</span> transformPass3 = hashSync(passwrod); $<span class="number">2</span>a$<span class="number">10</span>$bOHdFQ4TKBrtcNgmduzD8esds04BoXc0JcrLme68rTeik7U96KBvu</span><br></pre></td></tr></table></figure><p>验证密码：使用不同的值 匹配 密码123456，都能通过</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> password = <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">const</span> databasePassword1 = <span class="string">'$2a$10$HgTA1GX8uxbocSQlbQ42/.Y2XnIL7FyfKzn6IC69IXveD6F9LiULS'</span></span><br><span class="line"><span class="keyword">const</span> databasePassword2 = <span class="string">'$2a$10$mynd130vI1vkz4OQ3C.6FeYXGEq24KLUt1CsKN2WZqVsv0tPrtOcW'</span></span><br><span class="line"><span class="keyword">const</span> databasePassword3 = <span class="string">'$2a$10$bOHdFQ4TKBrtcNgmduzD8esds04BoXc0JcrLme68rTeik7U96KBvu'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (compareSync(password, databasePassword3)) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'密码通过'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐使用<code>bcryptjs</code>，算法要比<code>md5</code>高级</p><h2 id="角色权限"><a href="#角色权限" class="headerlink" title="角色权限"></a>角色权限</h2><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><ul><li><blockquote><ul><li><p>RBAC是基于角色的权限访问控制（Role-Based Access Control）一种数据库设计思想，根据设计数据库设计方案，完成项目的权限管理</p></li><li><p>在RBAC中，有3个基础组成部分，分别是：<code>用户</code>、<code>角色</code>和<code>权限</code>，权限与角色相关联，用户通过成为适当角色而得到这些角色的权限</p></li></ul></blockquote></li><li><p>权限：具备操作某个事务的能力</p></li><li>角色：一系列权限的集合</li></ul><blockquote><p>如：一般的管理系统中：<br>销售人员：仅仅可以查看商品信息<br>运营人员：可以查看，修改商品信息<br>管理人员：可以查看，修改，删除，以及修改员工权限等等<br>管理人员只要为每个员工账号分配对应的角色，登陆操作时就只能执行对应的权限或看到对应的页面</p></blockquote><p><strong>权限类型</strong></p><ul><li>展示（菜单），如：显示用户列表，显示删除按钮等等…</li><li>操作（功能），如：增删改查，上传下载，发布公告，发起活动等等…</li></ul><p><strong>数据库设计</strong></p><blockquote><p>数据库设计：可简单，可复杂，几个人使用的系统和几千人使用的系统是不一样的<br>小型项目：用户表，权限表<br>中型项目：用户表，角色表，权限表<br>大型项目：用户表，用户分组表，角色表，权限表，菜单表…</p></blockquote><p><strong>没有角色的设计</strong></p><p>只有用户表，菜单表，两者是多对多关系，有一个关联表</p><p><strong>缺点：</strong></p><ul><li>新建一个用户时，在用户表中添加一条数据</li><li>新建一个用户时，在关联表中添加N条数据</li><li>每次新建一个用户需要添加1+N(关联几个)条数据</li><li>如果有100个用户，每个用户100个权限，那需要添加10000条数据</li></ul><h3 id="基于RBAC的设计"><a href="#基于RBAC的设计" class="headerlink" title="基于RBAC的设计"></a>基于RBAC的设计</h3><p>用户表和角色表的关系设计：</p><blockquote><p>如果你希望一个用户可以有多个角色，如：一个人即是销售总监，也是人事管理，就设计多对多关系<br>如果你希望一个用户只能有一个角色，就设计一对多，多对一关系</p></blockquote><p>角色表和权限表的关系设计：</p><blockquote><p>一个角色可以拥有多个权限，一个权限被多个角色使用，设计多对多关系</p></blockquote><p><strong>多对多关系设计</strong></p><p>用户表与角色表是多对多关系，角色表与菜单表是多对多关系</p><p><img src="https://s.poetries.work/uploads/2022/05/df5b0726d1260958.png" alt></p><p><strong>更加复杂的设计</strong></p><p><img src="https://s.poetries.work/uploads/2022/05/58f62ca515da28df.png" alt></p><p><strong>实现流程</strong></p><ol><li>数据表设计</li><li>实现角色的增删改查</li><li>实现用户的增删改查，增加和修改用户的时候需要选择角色</li><li>实现权限的增删改查</li><li>实现角色与授权的关联</li><li>判断当前登录的用户是否有访问菜单的权限</li><li>根据当前登录账户的角色信息动态显示左侧菜单（前端）</li></ol><p><strong>代码实现</strong></p><blockquote><p>这里将实现一个用户，部门，角色，权限的例子：<br>用户通过成为部门的一员，则拥有部门普通角色的权限，还可以单独给用户设置角色，通过角色，获取权限。<br>权限模块包括，模块，菜单，操作，通过type区分类型，这里就不再拆分。</p></blockquote><p><strong>关系总览：</strong></p><ul><li>用户 - 部门：一对多关系，这里设计用户只能加入一个部门，如果设计可以加入多个部门，设计为多对多关系</li><li>用户 - 角色：多对多关系，可以给用户设置多个角色</li><li>角色 - 部门：多对多关系，一个部门多个角色</li><li>角色 - 权限：多对多关系，一个角色拥有多个权限，一个权限被多个角色使用</li></ul><h3 id="数据库实体设计"><a href="#数据库实体设计" class="headerlink" title="数据库实体设计"></a>数据库实体设计</h3><p><strong>用户</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Column,</span><br><span class="line">  Entity,</span><br><span class="line">  ManyToMany,</span><br><span class="line">  ManyToOne,</span><br><span class="line">  JoinColumn,</span><br><span class="line">  JoinTable,</span><br><span class="line">  PrimaryGeneratedColumn,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RoleEntity &#125; <span class="keyword">from</span> <span class="string">'../../role/entities/role.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DepartmentEntity &#125; <span class="keyword">from</span> <span class="string">'../../department/entities/department.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'user'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'varchar'</span>,</span><br><span class="line">    length: <span class="number">30</span>,</span><br><span class="line">    nullable: <span class="literal">false</span>,</span><br><span class="line">    unique: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  username: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'varchar'</span>,</span><br><span class="line">    name: <span class="string">'password'</span>,</span><br><span class="line">    length: <span class="number">100</span>,</span><br><span class="line">    nullable: <span class="literal">false</span>,</span><br><span class="line">    select: <span class="literal">false</span>,</span><br><span class="line">    comment: <span class="string">'密码'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  password: string;</span><br><span class="line"></span><br><span class="line">  @ManyToMany(<span class="function"><span class="params">()</span> =&gt;</span> RoleEntity, (role) =&gt; role.users)</span><br><span class="line">  @JoinTable(&#123; <span class="attr">name</span>: <span class="string">'user_role'</span> &#125;)</span><br><span class="line">  roles: RoleEntity[];</span><br><span class="line"></span><br><span class="line">  @ManyToOne(<span class="function"><span class="params">()</span> =&gt;</span> DepartmentEntity, (department) =&gt; department.users)</span><br><span class="line">  @JoinColumn(&#123; <span class="attr">name</span>: <span class="string">'department_id'</span> &#125;)</span><br><span class="line">  department: DepartmentEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>角色</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Entity,</span><br><span class="line">  PrimaryGeneratedColumn,</span><br><span class="line">  Column,</span><br><span class="line">  ManyToMany,</span><br><span class="line">  JoinTable,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'../../user/entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DepartmentEntity &#125; <span class="keyword">from</span> <span class="string">'../../department/entities/department.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AccessEntity &#125; <span class="keyword">from</span> <span class="string">'../../access/entities/access.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'role'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">type</span>: <span class="string">'varchar'</span>, <span class="attr">length</span>: <span class="number">30</span> &#125;)</span><br><span class="line">  rolename: string;</span><br><span class="line"></span><br><span class="line">  @ManyToMany(<span class="function"><span class="params">()</span> =&gt;</span> UsersEntity, (user) =&gt; user.roles)</span><br><span class="line">  users: UsersEntity[];</span><br><span class="line"></span><br><span class="line">  @ManyToMany(<span class="function"><span class="params">()</span> =&gt;</span> DepartmentEntity, (department) =&gt; department.roles)</span><br><span class="line">  department: DepartmentEntity[];</span><br><span class="line"></span><br><span class="line">  @ManyToMany(<span class="function"><span class="params">()</span> =&gt;</span> AccessEntity, (access) =&gt; access.roles)</span><br><span class="line">  @JoinTable(&#123; <span class="attr">name</span>: <span class="string">'role_access'</span> &#125;)</span><br><span class="line">  access: AccessEntity[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>部门</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Entity,</span><br><span class="line">  PrimaryGeneratedColumn,</span><br><span class="line">  Column,</span><br><span class="line">  ManyToMany,</span><br><span class="line">  OneToMany,</span><br><span class="line">  JoinTable,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'../../user/entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RoleEntity &#125; <span class="keyword">from</span> <span class="string">'../../role/entities/role.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'department'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">type</span>: <span class="string">'varchar'</span>, <span class="attr">length</span>: <span class="number">30</span> &#125;)</span><br><span class="line">  departmentname: string;</span><br><span class="line"></span><br><span class="line">  @OneToMany(<span class="function"><span class="params">()</span> =&gt;</span> UsersEntity, (user) =&gt; user.department)</span><br><span class="line">  users: UsersEntity[];</span><br><span class="line"></span><br><span class="line">  @ManyToMany(<span class="function"><span class="params">()</span> =&gt;</span> RoleEntity, (role) =&gt; role.department)</span><br><span class="line">  @JoinTable(&#123; <span class="attr">name</span>: <span class="string">'department_role'</span> &#125;)</span><br><span class="line">  roles: RoleEntity[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>权限</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Entity,</span><br><span class="line">  PrimaryGeneratedColumn,</span><br><span class="line">  Column,</span><br><span class="line">  Tree,</span><br><span class="line">  TreeChildren,</span><br><span class="line">  TreeParent,</span><br><span class="line">  ManyToMany,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RoleEntity &#125; <span class="keyword">from</span> <span class="string">'../../role/entities/role.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'access'</span> &#125;)</span><br><span class="line">@Tree(<span class="string">'closure-table'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">type</span>: <span class="string">'varchar'</span>, <span class="attr">length</span>: <span class="number">30</span>, <span class="attr">comment</span>: <span class="string">'模块'</span> &#125;)</span><br><span class="line">  module_name: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">type</span>: <span class="string">'varchar'</span>, <span class="attr">length</span>: <span class="number">30</span>, <span class="attr">nullable</span>: <span class="literal">true</span>, <span class="attr">comment</span>: <span class="string">'操作'</span> &#125;)</span><br><span class="line">  action_name: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">type</span>: <span class="string">'tinyint'</span>, <span class="attr">comment</span>: <span class="string">'类型：1:模块，2：菜单，3：操作'</span> &#125;)</span><br><span class="line">  type: number;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">type</span>: <span class="string">'text'</span>, <span class="attr">nullable</span>: <span class="literal">true</span>, <span class="attr">comment</span>: <span class="string">'操作地址'</span> &#125;)</span><br><span class="line">  url: string;</span><br><span class="line"></span><br><span class="line">  @TreeParent()</span><br><span class="line">  parentCategory: AccessEntity;</span><br><span class="line"></span><br><span class="line">  @TreeChildren()</span><br><span class="line">  childCategorys: AccessEntity[];</span><br><span class="line"></span><br><span class="line">  @ManyToMany(<span class="function"><span class="params">()</span> =&gt;</span> RoleEntity, (role) =&gt; role.access)</span><br><span class="line">  roles: RoleEntity[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><p>由于要实现很多接口，这里只说明一部分，其实都是数据库的操作，所有接口如下：</p><p><img src="https://s.poetries.work/uploads/2022/05/ea6301b6c0da9373.png" alt></p><p><strong>根据用户的id获取信息</strong>：id，用户名，部门名，角色，这些信息在做用户登陆时传递到token中。</p><blockquote><p>这里设计的是：创建用户时，添加部门，就会成为部门的普通角色，也可单独设置角色，但不是每个用户都有单独的角色。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> getUserinfoByUid(uid: number) &#123;</span><br><span class="line">获取用户</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(</span><br><span class="line">      &#123; <span class="attr">id</span>: uid &#125;,</span><br><span class="line">      &#123; <span class="attr">relations</span>: [<span class="string">'roles'</span>] &#125;,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户ID不存在'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sql = <span class="string">`</span></span><br><span class="line"><span class="string">    select </span></span><br><span class="line"><span class="string">    user.id as user_id, user.username, user.department_id, department.departmentname, role.id as role_id, rolename</span></span><br><span class="line"><span class="string">    from</span></span><br><span class="line"><span class="string">    user, department, role, department_role as dr</span></span><br><span class="line"><span class="string">    where </span></span><br><span class="line"><span class="string">    user.department_id = department.id</span></span><br><span class="line"><span class="string">    and department.id = dr.departmentId</span></span><br><span class="line"><span class="string">    and role.id = dr.roleId</span></span><br><span class="line"><span class="string">    and user.id = <span class="subst">$&#123;uid&#125;</span>`</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.query(sql);</span><br><span class="line">    <span class="keyword">const</span> userinfo = result[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> userObj = &#123;</span><br><span class="line">      user_id: userinfo.user_id,</span><br><span class="line">      username: userinfo.username,</span><br><span class="line">      department_id: userinfo.department_id,</span><br><span class="line">      departmentname: userinfo.departmentname,</span><br><span class="line">      roles: [&#123; <span class="attr">id</span>: userinfo.role_id, <span class="attr">rolename</span>: userinfo.rolename &#125;],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用户的角色roles有值，证明单独设置了角色，所以需要拼接起来</span></span><br><span class="line">    <span class="keyword">if</span> (user.roles.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> _user = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(user));</span><br><span class="line">      userObj.roles = [...userObj.roles, ..._user.roles];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口请求结果：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"status"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"请求成功"</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"user_id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"username"</span>: <span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">"department_id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"departmentname"</span>: <span class="string">"销售部"</span>,</span><br><span class="line">        <span class="string">"roles"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">"rolename"</span>: <span class="string">"销售部员工"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"id"</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="string">"rolename"</span>: <span class="string">"admin"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结合possport + jwt 做用户登陆授权验证</strong></p><blockquote><p>在验证账户密码通过后，possport 返回用户，然后根据用户id获取用户信息，存储token，用于路由守卫，还可以使用redis存储，以作他用。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> login(user: any): <span class="built_in">Promise</span>&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id &#125; = user;</span><br><span class="line">    <span class="keyword">const</span> userResult = <span class="keyword">await</span> <span class="keyword">this</span>.userService.getUserinfoByUid(id);</span><br><span class="line">    <span class="keyword">const</span> access_token = <span class="keyword">this</span>.jwtService.sign(userResult);</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.redisService.set(<span class="string">`user-token-<span class="subst">$&#123;id&#125;</span>`</span>, access_token, <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; access_token &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"status"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"请求成功"</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"access_token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImFkbWluIiwiZGVwYXJ0bWVudF9pZCI6MSwiZGVwYXJ0bWVudG5hbWUiOiLplIDllK7pg6giLCJyb2xlcyI6W3siaWQiOjEsInJvbGVuYW1lIjoi6ZSA5ZSu6YOo5ZGY5belIn0seyJpZCI6NSwicm9sZW5hbWUiOiJhZG1pbiJ9XSwiaWF0IjoxNjIxNjA1Nzg5LCJleHAiOjE2MjE2OTIxODl9.VIp0MdzSPM13eq1Bn8bB9Iu_SLKy4yoMU2N4uwgWDls"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后端的权限访问"><a href="#后端的权限访问" class="headerlink" title="后端的权限访问"></a><strong>后端的权限访问</strong></h3><blockquote><p>使用守卫，装饰器，结合token，验证访问权限</p></blockquote><p><strong>逻辑：</strong></p><ul><li>第一步：在<code>controller</code>使用自定义守卫装饰接口路径，在请求该接口路径时，全部进入守卫逻辑</li><li>第二步：使用自定义装饰器装饰特定接口，传递角色，自定义守卫会使用反射器获取该值，以判断该用户是否有权限</li></ul><p>如下：<code>findOne</code>接口使用了自定义装饰器装饰接口，意思是只能<code>admin</code>来访问</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Get,</span><br><span class="line">  Body,</span><br><span class="line">  Patch,</span><br><span class="line">  Post,</span><br><span class="line">  Param,</span><br><span class="line">  Delete,</span><br><span class="line">  UseGuards,</span><br><span class="line">  ParseIntPipe,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateUserDto &#125; <span class="keyword">from</span> <span class="string">'./dto/create-user.dto'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UpdateUserDto &#125; <span class="keyword">from</span> <span class="string">'./dto/update-user.dto'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AuthGuard &#125; <span class="keyword">from</span> <span class="string">'../../common/guard/auth.guard'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Roles &#125; <span class="keyword">from</span> <span class="string">'../../common/decorator/role.decorator'</span>;</span><br><span class="line"></span><br><span class="line">@UseGuards(AuthGuard)   <span class="comment">// 自定义守卫</span></span><br><span class="line">@Controller(<span class="string">'user'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly userService: UserService) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  <span class="keyword">async</span> findAll() &#123;</span><br><span class="line">    <span class="keyword">const</span> [data, count] = <span class="keyword">await</span> <span class="keyword">this</span>.userService.findAll();</span><br><span class="line">    <span class="keyword">return</span> &#123; count, data &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">':id'</span>)</span><br><span class="line">  @Roles(<span class="string">'admin'</span>)  <span class="comment">// 自定义装饰器</span></span><br><span class="line">  <span class="keyword">async</span> findOne(@Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.findOne(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>装饰器</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; SetMetadata &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetMetadata作用：将获取到的值，设置到元数据中，然后守卫通过反射器才能获取到值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Roles = <span class="function">(<span class="params">...args: string[]</span>) =&gt;</span> SetMetadata(<span class="string">'roles'</span>, args);</span><br></pre></td></tr></table></figure><p><strong>自定义守卫</strong></p><blockquote><p>返回<code>true</code>则有访问权限，返回<code>false</code>则直接报<code>403</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CanActivate, ExecutionContext, Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; JwtService &#125; <span class="keyword">from</span> <span class="string">'@nestjs/jwt'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Reflector &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>; <span class="comment">// 反射器，作用与自定义装饰器桥接</span></span><br><span class="line"><span class="keyword">import</span> &#123; ToolsService &#125; <span class="keyword">from</span> <span class="string">'../../utils/tools.service'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthGuard</span> <span class="title">implements</span> <span class="title">CanActivate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    private readonly reflector: Reflector,</span><br><span class="line">    private readonly jwtService: JwtService,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 白名单数组</span></span><br><span class="line">  private whiteUrlList: string[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证该次请求是否为白名单内的路由</span></span><br><span class="line">  private isWhiteUrl(urlList: string[], <span class="attr">url</span>: string): boolean &#123;</span><br><span class="line">    <span class="keyword">if</span> (urlList.includes(url)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  canActivate(context: ExecutionContext): boolean &#123;</span><br><span class="line">    <span class="comment">// 获取请求对象</span></span><br><span class="line">    <span class="keyword">const</span> request = context.switchToHttp().getRequest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证是否是白名单内的路由</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isWhiteUrl(<span class="keyword">this</span>.whiteUrlList, request.url)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取请求头中的token字段，解析获取存储在token的用户信息</span></span><br><span class="line">    <span class="keyword">const</span> token = context.switchToRpc().getData().headers.token;</span><br><span class="line">    <span class="keyword">const</span> user: any = <span class="keyword">this</span>.jwtService.decode(token);</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'token获取失败，请传递token或书写正确'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用反射器，配合装饰器使用，获取装饰器传递过来的数据</span></span><br><span class="line">    <span class="keyword">const</span> authRoles = <span class="keyword">this</span>.reflector.get&lt;string[]&gt;(</span><br><span class="line">      <span class="string">'roles'</span>,</span><br><span class="line">      context.getHandler(),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有使用roles装饰，就获取不到值，就不鉴权，等于白名单</span></span><br><span class="line">    <span class="keyword">if</span> (!authRoles) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果用户的所属角色与装饰器传递过来的值匹配则通过，否则不通过</span></span><br><span class="line">    <span class="keyword">const</span> userRoles = user.roles;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; userRoles.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (authRoles.includes(userRoles[i].rolename)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单测试</strong></p><blockquote><p>两个用户，分别对应不同的角色，分别请求user的findOne接口<br>用户1：销售部员工和admin<br>用户2：人事部员工</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户1：销售部员工和admin</span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: 200,</span><br><span class="line">    &quot;message&quot;: &quot;请求成功&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;user_id&quot;: 1,</span><br><span class="line">        &quot;username&quot;: &quot;admin&quot;,</span><br><span class="line">        &quot;department_id&quot;: 1,</span><br><span class="line">        &quot;departmentname&quot;: &quot;销售部&quot;,</span><br><span class="line">        &quot;roles&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 1,</span><br><span class="line">                &quot;rolename&quot;: &quot;销售部员工&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 5,</span><br><span class="line">                &quot;rolename&quot;: &quot;admin&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用户2：人事部员工</span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: 200,</span><br><span class="line">    &quot;message&quot;: &quot;请求成功&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;user_id&quot;: 2,</span><br><span class="line">        &quot;username&quot;: &quot;admin2&quot;,</span><br><span class="line">        &quot;department_id&quot;: 2,</span><br><span class="line">        &quot;departmentname&quot;: &quot;人事部&quot;,</span><br><span class="line">        &quot;roles&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 3,</span><br><span class="line">                &quot;rolename&quot;: &quot;人事部员工&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">不出意外的话：2号用户的请求结果</span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: 403,</span><br><span class="line">    &quot;message&quot;: &quot;Forbidden resource&quot;,</span><br><span class="line">    &quot;error&quot;: &quot;Forbidden&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/user/1&quot;,</span><br><span class="line">    &quot;timestamp&quot;: &quot;2021-05-21T14:44:04.954Z&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前端的权限访问则是通过权限表url和type来处理</p></blockquote><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>nest如何开启定时任务？</p><p><strong>定时任务场景</strong></p><blockquote><p>每天定时更新，定时发送邮件</p></blockquote><p>没有controller，因为定时任务是自动完成的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add @nestjs/schedule</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/tasks/task.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; TasksService &#125; <span class="keyword">from</span> <span class="string">'./tasks.service'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  providers: [TasksService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在这里编写你的定时任务</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/tasks/task.service.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable, Logger &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Cron, Interval, Timeout &#125; <span class="keyword">from</span> <span class="string">'@nestjs/schedule'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksService</span> </span>&#123;</span><br><span class="line">  private readonly logger = <span class="keyword">new</span> Logger(TasksService.name);</span><br><span class="line"></span><br><span class="line">  @Cron(<span class="string">'45 * * * * *'</span>)  每隔<span class="number">45</span>秒执行一次</span><br><span class="line">  handleCron() &#123;</span><br><span class="line">    <span class="keyword">this</span>.logger.debug(<span class="string">'Called when the second is 45'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Interval(<span class="number">10000</span>)  每隔<span class="number">10</span>秒执行一次</span><br><span class="line">  handleInterval() &#123;</span><br><span class="line">    <span class="keyword">this</span>.logger.debug(<span class="string">'Called every 10 seconds'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Timeout(<span class="number">5000</span>)  <span class="number">5</span>秒只执行一次</span><br><span class="line">  handleTimeout() &#123;</span><br><span class="line">    <span class="keyword">this</span>.logger.debug(<span class="string">'Called once after 5 seconds'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义定时时间</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">* * * * * * 分别对应的意思：</span><br><span class="line">第<span class="number">1</span>个星：秒</span><br><span class="line">第<span class="number">2</span>个星：分钟</span><br><span class="line">第<span class="number">3</span>个星：小时</span><br><span class="line">第<span class="number">4</span>个星：一个月中的第几天</span><br><span class="line">第<span class="number">5</span>个星：月</span><br><span class="line">第<span class="number">6</span>个星：一个星期中的第几天</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"><span class="number">45</span> * * * * *：每隔<span class="number">45</span>秒执行一次</span><br></pre></td></tr></table></figure><p><strong>挂载-使用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.module.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; TasksModule &#125; <span class="keyword">from</span> <span class="string">'./tasks/task.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ScheduleModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/schedule'</span>;</span><br><span class="line"></span><br><span class="line">imports: [</span><br><span class="line">    ConfigModule.load(path.resolve(__dirname, <span class="string">'config'</span>, <span class="string">'**/!(*.d).&#123;ts,js&#125;'</span>)),</span><br><span class="line">    ScheduleModule.forRoot(),</span><br><span class="line">    TasksModule,</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><h2 id="接入Swagger接口文档"><a href="#接入Swagger接口文档" class="headerlink" title="接入Swagger接口文档"></a>接入Swagger接口文档</h2><ul><li>优点：不用写接口文档，在线生成，自动生成，可操作数据库，完美配合<code>dto</code></li><li>缺点：多一些代码，显得有点乱，习惯就好</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add @nestjs/swagger swagger-ui-express -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; SwaggerModule, DocumentBuilder &#125; <span class="keyword">from</span> <span class="string">'@nestjs/swagger'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建实例</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create&lt;NestExpressApplication&gt;(AppModule);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建接口文档服务</span></span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">new</span> DocumentBuilder()</span><br><span class="line">    .addBearerAuth() <span class="comment">// token认证，输入token才可以访问文档</span></span><br><span class="line">    .setTitle(<span class="string">'接口文档'</span>)</span><br><span class="line">    .setDescription(<span class="string">'接口文档介绍'</span>) <span class="comment">// 文档介绍</span></span><br><span class="line">    .addServer(<span class="string">'http://localhost:9000'</span>, <span class="string">'开发环境'</span>)</span><br><span class="line">    .addServer(<span class="string">'https://test.com/release'</span>, <span class="string">'正式环境'</span>)</span><br><span class="line">    .setVersion(<span class="string">'1.0.0'</span>) <span class="comment">// 文档版本</span></span><br><span class="line">    .setContact(<span class="string">'poetry'</span>, <span class="string">''</span>, <span class="string">'test@qq.com'</span>)</span><br><span class="line">    .build();</span><br><span class="line">  <span class="comment">// 为了创建完整的文档（具有定义的HTTP路由），我们使用类的createDocument()方法SwaggerModule。此方法带有两个参数，分别是应用程序实例和基本Swagger选项。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">document</span> = SwaggerModule.createDocument(app, options, &#123;</span><br><span class="line">    extraModels: [], <span class="comment">// 这里导入模型</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 启动swagger</span></span><br><span class="line">  SwaggerModule.setup(<span class="string">'api-docs'</span>, app, <span class="built_in">document</span>); <span class="comment">// 访问路径 http://localhost:9000/api-docs</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 启动端口</span></span><br><span class="line">  <span class="keyword">const</span> PORT = process.env.PORT || <span class="number">9000</span>;</span><br><span class="line">  <span class="keyword">await</span> app.listen(PORT, () =&gt;</span><br><span class="line">    Logger.log(<span class="string">`服务已经启动 http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><p><strong>swagger装饰器</strong></p><p><a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@ApiTags(<span class="string">'user'</span>)   <span class="comment">// 设置模块接口的分类，不设置默认分配到default</span></span><br><span class="line">@ApiOperation(&#123; <span class="attr">summary</span>: <span class="string">'标题'</span>, <span class="attr">description</span>: <span class="string">'详细描述'</span>&#125;)  <span class="comment">// 单个接口描述</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参</span></span><br><span class="line">@ApiQuery(&#123; <span class="attr">name</span>: <span class="string">'limit'</span>, <span class="attr">required</span>: <span class="literal">true</span>&#125;)    <span class="comment">// query参数</span></span><br><span class="line">@ApiQuery(&#123; <span class="attr">name</span>: <span class="string">'role'</span>, <span class="attr">enum</span>: UserRole &#125;)    <span class="comment">// query参数</span></span><br><span class="line">@ApiParam(&#123; <span class="attr">name</span>: <span class="string">'id'</span> &#125;)      <span class="comment">// parma参数</span></span><br><span class="line">@ApiBody(&#123; <span class="attr">type</span>: UserCreateDTO, <span class="attr">description</span>: <span class="string">'输入用户名和密码'</span> &#125;)   <span class="comment">// 请求体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应</span></span><br><span class="line">@ApiResponse(&#123;</span><br><span class="line">    status: <span class="number">200</span>,</span><br><span class="line">    description: <span class="string">'成功返回200，失败返回400'</span>,</span><br><span class="line">    type: UserCreateDTO,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line">@ApiProperty(&#123; <span class="attr">example</span>: <span class="string">'Kitty'</span>, <span class="attr">description</span>: <span class="string">'The name of the Cat'</span> &#125;)</span><br><span class="line">name: string;</span><br></pre></td></tr></table></figure><p>在<code>controller</code>引入<code>@nestjs/swagger</code>， 并配置<code>@ApiBody()</code>和 <code>@ApiParam()</code>不写也是可以的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">user.controller.ts</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Get,</span><br><span class="line">  Post,</span><br><span class="line">  Body,</span><br><span class="line">  Patch,</span><br><span class="line">  Query,</span><br><span class="line">  Param,</span><br><span class="line">  Delete,</span><br><span class="line">  HttpCode,</span><br><span class="line">  HttpStatus,</span><br><span class="line">  ParseIntPipe,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ApiOperation,</span><br><span class="line">  ApiTags,</span><br><span class="line">  ApiQuery,</span><br><span class="line">  ApiBody,</span><br><span class="line">  ApiResponse,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/swagger'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateUserDto &#125; <span class="keyword">from</span> <span class="string">'./dto/create-user.dto'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UpdateUserDto &#125; <span class="keyword">from</span> <span class="string">'./dto/update-user.dto'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'user'</span>)</span><br><span class="line">@ApiTags(<span class="string">'user'</span>)  <span class="comment">// 设置分类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly userService: UserService) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  @Post()</span><br><span class="line">  @ApiOperation(&#123; <span class="attr">summary</span>: <span class="string">'创建用户'</span>, <span class="attr">description</span>: <span class="string">'创建用户'</span> &#125;)  <span class="comment">// 该接口</span></span><br><span class="line">  @HttpCode(HttpStatus.OK)</span><br><span class="line">  <span class="keyword">async</span> create(@Body() user: CreateUserDto) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.create(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  @ApiOperation(&#123; <span class="attr">summary</span>: <span class="string">'查找全部用户'</span>, <span class="attr">description</span>: <span class="string">'创建用户'</span> &#125;)</span><br><span class="line">  @ApiQuery(&#123; <span class="attr">name</span>: <span class="string">'limit'</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;)  请求参数</span><br><span class="line">  @ApiQuery(&#123; <span class="attr">name</span>: <span class="string">'offset'</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;) 请求参数</span><br><span class="line">  <span class="keyword">async</span> findAll(@Query() query) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(query);</span><br><span class="line">    <span class="keyword">const</span> [data, count] = <span class="keyword">await</span> <span class="keyword">this</span>.userService.findAll(query);</span><br><span class="line">    <span class="keyword">return</span> &#123; count, data &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">':id'</span>)</span><br><span class="line">  @ApiOperation(&#123; <span class="attr">summary</span>: <span class="string">'根据ID查找用户'</span> &#125;)</span><br><span class="line">  <span class="keyword">async</span> findOne(@Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.findOne(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Patch(<span class="string">':id'</span>)</span><br><span class="line">  @ApiOperation(&#123; <span class="attr">summary</span>: <span class="string">'更新用户'</span> &#125;)</span><br><span class="line">  @ApiBody(&#123; <span class="attr">type</span>: UpdateUserDto, <span class="attr">description</span>: <span class="string">'参数可选'</span> &#125;)  请求体</span><br><span class="line">  @ApiResponse(&#123;   响应示例</span><br><span class="line">    status: <span class="number">200</span>,</span><br><span class="line">    description: <span class="string">'成功返回200，失败返回400'</span>,</span><br><span class="line">    type: UpdateUserDto,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">async</span> update(</span><br><span class="line">    @Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number,</span><br><span class="line">    @Body() user: UpdateUserDto,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.update(id, user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Delete(<span class="string">':id'</span>)</span><br><span class="line">  @ApiOperation(&#123; <span class="attr">summary</span>: <span class="string">'删除用户'</span> &#125;)</span><br><span class="line">  <span class="keyword">async</span> remove(@Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.remove(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编写dto，引入@nestjs/swagger</strong></p><p>创建</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; IsNotEmpty, MinLength, MaxLength &#125; <span class="keyword">from</span> <span class="string">'class-validator'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ApiProperty &#125; <span class="keyword">from</span> <span class="string">'@nestjs/swagger'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateUserDto</span> </span>&#123;</span><br><span class="line">  @ApiProperty(&#123; <span class="attr">example</span>: <span class="string">'kitty'</span>, <span class="attr">description</span>: <span class="string">'用户名'</span> &#125;)  添加这里即可</span><br><span class="line">  @IsNotEmpty(&#123; <span class="attr">message</span>: <span class="string">'用户名不能为空'</span> &#125;)</span><br><span class="line">  username: string;</span><br><span class="line"></span><br><span class="line">  @ApiProperty(&#123; <span class="attr">example</span>: <span class="string">'12345678'</span>, <span class="attr">description</span>: <span class="string">'密码'</span> &#125;)</span><br><span class="line">  @IsNotEmpty(&#123; <span class="attr">message</span>: <span class="string">'密码不能为空'</span> &#125;)</span><br><span class="line">  @MinLength(<span class="number">6</span>, &#123;</span><br><span class="line">    message: <span class="string">'密码长度不能小于6位'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  @MaxLength(<span class="number">20</span>, &#123;</span><br><span class="line">    message: <span class="string">'密码长度不能超过20位'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  password: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  IsEnum,</span><br><span class="line">  MinLength,</span><br><span class="line">  MaxLength,</span><br><span class="line">  IsOptional,</span><br><span class="line">  ValidateIf,</span><br><span class="line">  IsEmail,</span><br><span class="line">  IsMobilePhone,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'class-validator'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ApiProperty &#125; <span class="keyword">from</span> <span class="string">'@nestjs/swagger'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Type &#125; <span class="keyword">from</span> <span class="string">'class-transformer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateUserDto</span> </span>&#123;</span><br><span class="line">  @ApiProperty(&#123; <span class="attr">description</span>: <span class="string">'用户名'</span>, <span class="attr">example</span>: <span class="string">'kitty'</span>, <span class="attr">required</span>: <span class="literal">false</span> &#125;)  不是必选的</span><br><span class="line">  @IsOptional()</span><br><span class="line">  username: string;</span><br><span class="line"></span><br><span class="line">  @ApiProperty(&#123; <span class="attr">description</span>: <span class="string">'密码'</span>, <span class="attr">example</span>: <span class="string">'12345678'</span>, <span class="attr">required</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">  @IsOptional()</span><br><span class="line">  @MinLength(<span class="number">6</span>, &#123;</span><br><span class="line">    message: <span class="string">'密码长度不能小于6位'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  @MaxLength(<span class="number">20</span>, &#123;</span><br><span class="line">    message: <span class="string">'密码长度不能超过20位'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  password: string;</span><br><span class="line"></span><br><span class="line">  @ApiProperty(&#123;</span><br><span class="line">    description: <span class="string">'邮箱'</span>,</span><br><span class="line">    example: <span class="string">'llovenest@163.com'</span>,</span><br><span class="line">    required: <span class="literal">false</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  @IsOptional()</span><br><span class="line">  @IsEmail(&#123;&#125;, &#123; <span class="attr">message</span>: <span class="string">'邮箱格式错误'</span> &#125;)</span><br><span class="line">  @ValidateIf(<span class="function">(<span class="params">o</span>) =&gt;</span> o.username === <span class="string">'admin'</span>)</span><br><span class="line">  email: string;</span><br><span class="line"></span><br><span class="line">  @ApiProperty(&#123;</span><br><span class="line">    description: <span class="string">'手机号码'</span>,</span><br><span class="line">    example: <span class="string">'13866668888'</span>,</span><br><span class="line">    required: <span class="literal">false</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  @IsOptional()</span><br><span class="line">  @IsMobilePhone(<span class="string">'zh-CN'</span>, &#123;&#125;, &#123; <span class="attr">message</span>: <span class="string">'手机号码格式错误'</span> &#125;)</span><br><span class="line">  mobile: string;</span><br><span class="line"></span><br><span class="line">  @ApiProperty(&#123;</span><br><span class="line">    description: <span class="string">'性别'</span>,</span><br><span class="line">    example: <span class="string">'female'</span>,</span><br><span class="line">    required: <span class="literal">false</span>,</span><br><span class="line">    enum: [<span class="string">'male'</span>, <span class="string">'female'</span>],</span><br><span class="line">  &#125;)</span><br><span class="line">  @IsOptional()</span><br><span class="line">  @IsEnum([<span class="string">'male'</span>, <span class="string">'female'</span>], &#123;</span><br><span class="line">    message: <span class="string">'gender只能传入字符串male或female'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  gender: string;</span><br><span class="line"></span><br><span class="line">  @ApiProperty(&#123;</span><br><span class="line">    description: <span class="string">'状态'</span>,</span><br><span class="line">    example: <span class="number">1</span>,</span><br><span class="line">    required: <span class="literal">false</span>,</span><br><span class="line">    enum: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  &#125;)</span><br><span class="line">  @IsOptional()</span><br><span class="line">  @IsEnum(</span><br><span class="line">    &#123; 禁用: <span class="number">0</span>, 可用: <span class="number">1</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      message: <span class="string">'status只能传入数字0或1'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  )</span><br><span class="line">  @Type(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Number</span>)</span><br><span class="line">  status: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开：localhost:3000/api-docs，开始测试接口</p><p><img src="https://s.poetries.work/uploads/2022/05/dd04126877af210f.png" alt></p><p><img src="https://s.poetries.work/uploads/2022/05/98f40271e2f2ed11.png" alt></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="nest连接Mongodb"><a href="#nest连接Mongodb" class="headerlink" title="nest连接Mongodb"></a>nest连接Mongodb</h2><p>mac中，直接使用<code>brew install mongodb-community</code>安装MongoDB，然后启动服务<code>brew services start mongodb-community</code> 查看服务已经启动<code>ps aux | grep mongo</code></p><blockquote><p>Nestjs中操作Mongodb数据库可以使用Nodejs封装的DB库，也可以使用Mongoose。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://docs.nestjs.com/techniques/mongodb</span></span><br><span class="line"></span><br><span class="line">npm install --save @nestjs/mongoose mongoose</span><br><span class="line">npm install --save-dev @types/mongoose</span><br></pre></td></tr></table></figure><p><strong>在app.module.ts中配置数据库连接</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; ConfigModule, ConfigService &#125; <span class="keyword">from</span> <span class="string">'nestjs-config'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MongooseModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/mongoose'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MongodbModule &#125; <span class="keyword">from</span> <span class="string">'../examples/mongodb/mongodb.module'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    <span class="comment">// 加载配置文件目录</span></span><br><span class="line">    ConfigModule.load(resolve(__dirname, <span class="string">'config'</span>, <span class="string">'**/!(*.d).&#123;ts,js&#125;'</span>)),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// mongodb</span></span><br><span class="line">    MongooseModule.forRootAsync(&#123;</span><br><span class="line">      useFactory: <span class="keyword">async</span> (configService: ConfigService) =&gt;</span><br><span class="line">        configService.get(<span class="string">'mongodb'</span>),</span><br><span class="line">      inject: [ConfigService],</span><br><span class="line">    &#125;),</span><br><span class="line">    MongodbModule,</span><br><span class="line">  ],</span><br><span class="line">  controllers: [],</span><br><span class="line">  providers: [],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> <span class="title">implements</span> <span class="title">NestModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mongodb配置</span></span><br><span class="line"><span class="comment">// src/config/mongodb.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  uri: <span class="string">'mongodb://localhost:27017/nest'</span>, <span class="comment">// 指定nest数据库</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>配置Schema</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// article.schema</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> mongoose <span class="keyword">from</span> <span class="string">'mongoose'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ArticleSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  content:<span class="built_in">String</span>,</span><br><span class="line">  author: <span class="built_in">String</span>,</span><br><span class="line">  status: <span class="built_in">Number</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>在控制器对应的Module中配置Model</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mongodb.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MongodbService &#125; <span class="keyword">from</span> <span class="string">'./mongodb.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MongodbController &#125; <span class="keyword">from</span> <span class="string">'./mongodb.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ArticleSchema &#125; <span class="keyword">from</span> <span class="string">'./schemas/article.schema'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MongooseModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/mongoose'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    MongooseModule.forFeature([</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'Article'</span>, <span class="comment">// schema名称对应</span></span><br><span class="line">        schema: ArticleSchema, <span class="comment">// 引入的schema</span></span><br><span class="line">        collection: <span class="string">'article'</span>, <span class="comment">// 数据库名称</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]),</span><br><span class="line">  ],</span><br><span class="line">  controllers: [MongodbController],</span><br><span class="line">  providers: [MongodbService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MongodbModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>在服务里面使用@InjectModel 获取数据库Model实现操作数据库</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mongodb.service.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectModel &#125; <span class="keyword">from</span> <span class="string">'@nestjs/mongoose'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MongodbService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注入模型</span></span><br><span class="line">  <span class="keyword">constructor</span>(@InjectModel('Article') private readonly articleModel) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> findAll() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.articleModel.find().exec();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> findById(id) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.articleModel.findById(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> create(body) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.articleModel.create(body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> update(body) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id, ...params &#125; = body;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.articleModel.findByIdAndUpdate(id, params);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">delete</span>(id) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.articleModel.findByIdAndDelete(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器测试 <a href="http://localhost:9000/api/mongodb/list" target="_blank" rel="noopener">http://localhost:9000/api/mongodb/list</a></p><p><img src="https://s.poetries.work/uploads/2022/05/e14c1f5173139807.png" alt></p><h2 id="typeORM操作Mysql数据库"><a href="#typeORM操作Mysql数据库" class="headerlink" title="typeORM操作Mysql数据库"></a>typeORM操作Mysql数据库</h2><p>mac中，直接使用<code>brew install mysql</code>安装mysql，然后启动服务<code>brew services start mysql</code> 查看服务已经启动<code>ps aux | grep mysql</code></p><p>Nest 操作Mysql官方文档：<a href="https://docs.nestjs.com/techniques/database" target="_blank" rel="noopener">https://docs.nestjs.com/techniques/database</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save @nestjs/typeorm typeorm mysql</span><br></pre></td></tr></table></figure><p><strong>配置数据库连接地址</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/config/typeorm.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; MYSQL_HOST, MYSQL_PORT, MYSQL_USER, MYSQL_PASSWORD, MYSQL_DATABASE &#125; =</span><br><span class="line">  process.env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  type: <span class="string">'mysql'</span>,</span><br><span class="line">  host: MYSQL_HOST,</span><br><span class="line">  port: MYSQL_PORT,</span><br><span class="line">  username: MYSQL_USER,</span><br><span class="line">  password: MYSQL_PASSWORD,</span><br><span class="line">  database: MYSQL_DATABASE,</span><br><span class="line">  synchronize: process.env.NODE_ENV !== <span class="string">'production'</span>, <span class="comment">// 生产环境不要开启</span></span><br><span class="line">  autoLoadEntities: <span class="literal">true</span>, <span class="comment">// 如果为true,将自动加载实体(默认：false)</span></span><br><span class="line">  keepConnectionAlive: <span class="literal">true</span>, <span class="comment">// 如果为true，在应用程序关闭后连接不会关闭（默认：false)</span></span><br><span class="line">  retryDelay: <span class="number">3000</span>, <span class="comment">// 两次重试连接的间隔(ms)（默认：3000）</span></span><br><span class="line">  retryAttempts: <span class="number">10</span>, <span class="comment">// 重试连接数据库的次数（默认：10）</span></span><br><span class="line">  dateStrings: <span class="string">'DATETIME'</span>, <span class="comment">// 转化为时间</span></span><br><span class="line">  timezone: <span class="string">'+0800'</span>, <span class="comment">// +HHMM -HHMM</span></span><br><span class="line">  <span class="comment">// 自动需要导入模型</span></span><br><span class="line">  entities: [<span class="string">'dist/**/*.entity&#123;.ts,.js&#125;'</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> config;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.module.ts中配置</span></span><br><span class="line"><span class="keyword">import</span> &#123; resolve, join &#125; <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConfigModule, ConfigService &#125; <span class="keyword">from</span> <span class="string">'nestjs-config'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; TypeOrmModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    <span class="comment">// 加载配置文件目录</span></span><br><span class="line">    ConfigModule.load(resolve(__dirname, <span class="string">'config'</span>, <span class="string">'**/!(*.d).&#123;ts,js&#125;'</span>)),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接mysql数据库</span></span><br><span class="line">    TypeOrmModule.forRootAsync(&#123;</span><br><span class="line">      useFactory: <span class="function">(<span class="params">config: ConfigService</span>) =&gt;</span> config.get(<span class="string">'typeorm'</span>),</span><br><span class="line">      inject: [ConfigService],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  controllers: [],</span><br><span class="line">  providers: [],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> <span class="title">implements</span> <span class="title">NestModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>配置实体entity</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// photo.entity.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Column,</span><br><span class="line">  Entity,</span><br><span class="line">  ManyToMany,</span><br><span class="line">  OneToMany,</span><br><span class="line">  PrimaryGeneratedColumn,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PostsEntity &#125; <span class="keyword">from</span> <span class="string">'./post.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(<span class="string">'photo'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoEntity</span> </span>&#123;</span><br><span class="line">  <span class="comment">// @PrimaryGeneratedColumn()</span></span><br><span class="line">  <span class="comment">// id: number; // 标记为主列，值自动生成</span></span><br><span class="line">  @PrimaryGeneratedColumn(<span class="string">'uuid'</span>)</span><br><span class="line">  id: string; <span class="comment">// 该值将使用uuid自动生成</span></span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">length</span>: <span class="number">50</span> &#125;)</span><br><span class="line">  url: string;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 多对一关系，多个图片对应一篇文章</span></span><br><span class="line">  @ManyToMany(<span class="function"><span class="params">()</span> =&gt;</span> PostsEntity, (post) =&gt; post.photos)</span><br><span class="line">  posts: PostsEntity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> &#123; Column, Entity, OneToMany, PrimaryGeneratedColumn &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PhotoEntity &#125; <span class="keyword">from</span> <span class="string">'./photo.entity'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type UserRoleType = <span class="string">'admin'</span> | <span class="string">'editor'</span> | <span class="string">'ghost'</span>;</span><br><span class="line"><span class="keyword">export</span> type postStatus = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mysql的列类型: type</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * int, tinyint, smallint, mediumint, bigint, float, double, dec, decimal,</span></span><br><span class="line"><span class="comment"> * numeric, date, datetime, timestamp, time, year, char, varchar, nvarchar,</span></span><br><span class="line"><span class="comment"> * text, tinytext, mediumtext, blob, longtext, tinyblob, mediumblob, longblob, enum,</span></span><br><span class="line"><span class="comment"> * json, binary, geometry, point, linestring, polygon, multipoint, multilinestring,</span></span><br><span class="line"><span class="comment"> * multipolygon, geometrycollection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ColumnOptions中可用选项列表：</span></span><br><span class="line"><span class="comment"> * length: number - 列类型的长度。 例如，如果要创建varchar（150）类型，请指定列类型和长度选项。</span></span><br><span class="line"><span class="comment">  width: number - 列类型的显示范围。 仅用于MySQL integer types(opens new window)</span></span><br><span class="line"><span class="comment">  onUpdate: string - ON UPDATE触发器。 仅用于 MySQL (opens new window).</span></span><br><span class="line"><span class="comment">  nullable: boolean - 在数据库中使列NULL或NOT NULL。 默认情况下，列是nullable：false。</span></span><br><span class="line"><span class="comment">  update: boolean - 指示"save"操作是否更新列值。如果为false，则只能在第一次插入对象时编写该值。 默认值为"true"。</span></span><br><span class="line"><span class="comment">  select: boolean - 定义在进行查询时是否默认隐藏此列。 设置为false时，列数据不会显示标准查询。 默认情况下，列是select：true</span></span><br><span class="line"><span class="comment">  default: string - 添加数据库级列的DEFAULT值。</span></span><br><span class="line"><span class="comment">  primary: boolean - 将列标记为主要列。 使用方式和@ PrimaryColumn相同。</span></span><br><span class="line"><span class="comment">  unique: boolean - 将列标记为唯一列（创建唯一约束）。</span></span><br><span class="line"><span class="comment">  comment: string - 数据库列备注，并非所有数据库类型都支持。</span></span><br><span class="line"><span class="comment">  precision: number - 十进制（精确数字）列的精度（仅适用于十进制列），这是为值存储的最大位数。仅用于某些列类型。</span></span><br><span class="line"><span class="comment">  scale: number - 十进制（精确数字）列的比例（仅适用于十进制列），表示小数点右侧的位数，且不得大于精度。 仅用于某些列类型。</span></span><br><span class="line"><span class="comment">  zerofill: boolean - 将ZEROFILL属性设置为数字列。 仅在 MySQL 中使用。 如果是true，MySQL 会自动将UNSIGNED属性添加到此列。</span></span><br><span class="line"><span class="comment">  unsigned: boolean - 将UNSIGNED属性设置为数字列。 仅在 MySQL 中使用。</span></span><br><span class="line"><span class="comment">  charset: string - 定义列字符集。 并非所有数据库类型都支持。</span></span><br><span class="line"><span class="comment">  collation: string - 定义列排序规则。</span></span><br><span class="line"><span class="comment">  enum: string[]|AnyEnum - 在enum列类型中使用，以指定允许的枚举值列表。 你也可以指定数组或指定枚举类。</span></span><br><span class="line"><span class="comment">  asExpression: string - 生成的列表达式。 仅在MySQL (opens new window)中使用。</span></span><br><span class="line"><span class="comment">  generatedType: "VIRTUAL"|"STORED" - 生成的列类型。 仅在MySQL (opens new window)中使用。</span></span><br><span class="line"><span class="comment">  hstoreType: "object"|"string" -返回HSTORE列类型。 以字符串或对象的形式返回值。 仅在Postgres中使用。</span></span><br><span class="line"><span class="comment">  array: boolean - 用于可以是数组的 postgres 列类型（例如 int []）</span></span><br><span class="line"><span class="comment">  transformer: &#123; from(value: DatabaseType): EntityType, to(value: EntityType): DatabaseType &#125; - 用于将任意类型EntityType的属性编组为数据库支持的类型DatabaseType。</span></span><br><span class="line"><span class="comment">  注意：大多数列选项都是特定于 RDBMS 的，并且在MongoDB中不可用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">@Entity(<span class="string">'posts'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsEntity</span> </span>&#123;</span><br><span class="line">  <span class="comment">// @PrimaryGeneratedColumn()</span></span><br><span class="line">  <span class="comment">// id: number; // 标记为主列，值自动生成</span></span><br><span class="line">  @PrimaryGeneratedColumn(<span class="string">'uuid'</span>)</span><br><span class="line">  id: string; <span class="comment">// 该值将使用uuid自动生成</span></span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">length</span>: <span class="number">50</span> &#125;)</span><br><span class="line">  title: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">length</span>: <span class="number">18</span> &#125;)</span><br><span class="line">  author: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">type</span>: <span class="string">'longtext'</span>, <span class="attr">default</span>: <span class="literal">null</span> &#125;)</span><br><span class="line">  content: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">default</span>: <span class="literal">null</span> &#125;)</span><br><span class="line">  cover_url: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">default</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  type: number;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">type</span>: <span class="string">'text'</span>, <span class="attr">default</span>: <span class="literal">null</span> &#125;)</span><br><span class="line">  remark: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'enum'</span>,</span><br><span class="line">    enum: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  status: postStatus;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">type</span>: <span class="string">'timestamp'</span>, <span class="attr">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'CURRENT_TIMESTAMP'</span> &#125;)</span><br><span class="line">  create_time: <span class="built_in">Date</span>;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'timestamp'</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'CURRENT_TIMESTAMP'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  update_time: <span class="built_in">Date</span>;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'enum'</span>,</span><br><span class="line">    enum: [<span class="string">'admin'</span>, <span class="string">'editor'</span>, <span class="string">'ghost'</span>],</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'ghost'</span>,</span><br><span class="line">    select: <span class="literal">false</span>, <span class="comment">// 定义在进行查询时是否默认隐藏此列</span></span><br><span class="line">  &#125;)</span><br><span class="line">  role: UserRoleType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一对多关系，一篇文章对应多个图片</span></span><br><span class="line">  <span class="comment">// 在service中查询使用 .find(&#123;relations: ['photos]&#125;) 查询文章对应的图片</span></span><br><span class="line">  @OneToMany(<span class="function"><span class="params">()</span> =&gt;</span> PhotoEntity, (photo) =&gt; photo.posts)</span><br><span class="line">  photos: [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数校验</strong></p><p>Nest 与 <a href="https://github.com/pleerock/class-validator" target="_blank" rel="noopener">class-validator</a> 配合得很好。这个优秀的库允许您使用基于装饰器的验证。装饰器的功能非常强大，尤其是与 Nest 的 Pipe 功能相结合使用时，因为我们可以通过访问 <code>metatype</code> 信息做很多事情，在开始之前需要安装一些依赖。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --save class-validator class-transformer</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// posts.dto.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; ApiProperty, ApiPropertyOptional &#125; <span class="keyword">from</span> <span class="string">'@nestjs/swagger'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IsNotEmpty, IsNumber, IsString &#125; <span class="keyword">from</span> <span class="string">'class-validator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatePostDto</span> </span>&#123;</span><br><span class="line">  @IsNotEmpty(&#123; <span class="attr">message</span>: <span class="string">'文章标题必填'</span> &#125;)</span><br><span class="line">  readonly title: string;</span><br><span class="line"></span><br><span class="line">  @IsNotEmpty(&#123; <span class="attr">message</span>: <span class="string">'缺少作者信息'</span> &#125;)</span><br><span class="line">  readonly author: string;</span><br><span class="line"></span><br><span class="line">  readonly content: string;</span><br><span class="line"></span><br><span class="line">  readonly cover_url: string;</span><br><span class="line"></span><br><span class="line">  @IsNotEmpty(&#123; <span class="attr">message</span>: <span class="string">'缺少文章类型'</span> &#125;)</span><br><span class="line">  readonly type: number;</span><br><span class="line"></span><br><span class="line">  readonly remark: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在控制器对应的Module中配置Model</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; TypeOrmModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PostsService &#125; <span class="keyword">from</span> <span class="string">'./posts.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PostsController &#125; <span class="keyword">from</span> <span class="string">'./posts.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PostsEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/post.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [TypeOrmModule.forFeature([PostsEntity])],</span><br><span class="line">  controllers: [PostsController],</span><br><span class="line">  providers: [PostsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>在服务里面使用@InjectRepository获取数据库Model实现操作数据库</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// posts.services.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; HttpException, HttpStatus, Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository, Not, Between, Equal, Like, In &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> dayjs <span class="keyword">from</span> <span class="string">'dayjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreatePostDto &#125; <span class="keyword">from</span> <span class="string">'./dto/create-post.dto'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UpdatePostDto &#125; <span class="keyword">from</span> <span class="string">'./dto/update-post.dto'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PostsEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/post.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PostsRo &#125; <span class="keyword">from</span> <span class="string">'./interfaces/posts.interface'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PostsService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(PostsEntity)</span><br><span class="line">    private readonly postsRepository: Repository&lt;PostsEntity&gt;,</span><br><span class="line">  ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> create(post: CreatePostDto) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; title &#125; = post;</span><br><span class="line">    <span class="keyword">const</span> doc = <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.findOne(&#123; <span class="attr">where</span>: &#123; title &#125; &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doc'</span>, doc);</span><br><span class="line">    <span class="keyword">if</span> (doc) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">'文章标题已存在'</span>, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data: <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.save(post),</span><br><span class="line">      message: <span class="string">'创建成功'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分页查询列表</span></span><br><span class="line">  <span class="keyword">async</span> findAll(query = &#123;&#125; <span class="keyword">as</span> any) &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line prefer-const</span></span><br><span class="line">    <span class="keyword">let</span> &#123; pageSize, pageNum, orderBy, sort, ...params &#125; = query;</span><br><span class="line">    orderBy = query.orderBy || <span class="string">'create_time'</span>;</span><br><span class="line">    sort = query.sort || <span class="string">'DESC'</span>;</span><br><span class="line">    pageSize = <span class="built_in">Number</span>(query.pageSize || <span class="number">10</span>);</span><br><span class="line">    pageNum = <span class="built_in">Number</span>(query.pageNum || <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'query'</span>, query);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queryParams = &#123;&#125; <span class="keyword">as</span> any;</span><br><span class="line">    <span class="built_in">Object</span>.keys(params).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (params[key]) &#123;</span><br><span class="line">        queryParams[key] = Like(<span class="string">`%<span class="subst">$&#123;params[key]&#125;</span>%`</span>); <span class="comment">// 所有字段支持模糊查询、%%之间不能有空格</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> qb = <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.createQueryBuilder(<span class="string">'post'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// qb.where(&#123; status: In([2, 3]) &#125;);</span></span><br><span class="line">    qb.where(queryParams);</span><br><span class="line">    <span class="comment">// qb.select(['post.title', 'post.content']); // 查询部分字段返回</span></span><br><span class="line">    qb.orderBy(<span class="string">`post.<span class="subst">$&#123;orderBy&#125;</span>`</span>, sort);</span><br><span class="line">    qb.skip(pageSize * (pageNum - <span class="number">1</span>));</span><br><span class="line">    qb.take(pageSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      list: <span class="keyword">await</span> qb.getMany(),</span><br><span class="line">      totalNum: <span class="keyword">await</span> qb.getCount(), <span class="comment">// 按条件查询的数量</span></span><br><span class="line">      total: <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.count(), <span class="comment">// 总的数量</span></span><br><span class="line">      pageSize,</span><br><span class="line">      pageNum,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据ID查询详情</span></span><br><span class="line">  <span class="keyword">async</span> findById(id: string): <span class="built_in">Promise</span>&lt;PostsEntity&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.findOne(&#123; <span class="attr">where</span>: &#123; id &#125; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  <span class="keyword">async</span> update(id: string, <span class="attr">updatePostDto</span>: UpdatePostDto) &#123;</span><br><span class="line">    <span class="keyword">const</span> existRecord = <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.findOne(&#123; <span class="attr">where</span>: &#123; id &#125; &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!existRecord) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">`id为<span class="subst">$&#123;id&#125;</span>的文章不存在`</span>, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updatePostDto覆盖existRecord 合并，可以更新单个字段</span></span><br><span class="line">    <span class="keyword">const</span> updatePost = <span class="keyword">this</span>.postsRepository.merge(existRecord, &#123;</span><br><span class="line">      ...updatePostDto,</span><br><span class="line">      update_time: dayjs().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data: <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.save(updatePost),</span><br><span class="line">      message: <span class="string">'更新成功'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="keyword">async</span> remove(id: string) &#123;</span><br><span class="line">    <span class="keyword">const</span> existPost = <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.findOne(&#123; <span class="attr">where</span>: &#123; id &#125; &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!existPost) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">`文章ID <span class="subst">$&#123;id&#125;</span> 不存在`</span>, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.postsRepository.remove(existPost);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data: &#123; id &#125;,</span><br><span class="line">      message: <span class="string">'删除成功'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nest统一处理数据库操作的查询结果"><a href="#nest统一处理数据库操作的查询结果" class="headerlink" title="nest统一处理数据库操作的查询结果"></a>nest统一处理数据库操作的查询结果</h2><blockquote><p>操作数据库时，如何做异常处异常？ 比如id不存在，用户名已经存在？如何统一处理请求失败和请求成功？</p></blockquote><p><strong>处理方式</strong>：</p><ul><li>在nest中，一般是在<strong>service</strong>中处理异常，如果有异常，直接抛出错误，由<strong>过滤器</strong>捕获，统一格式返回，如果成功，service把结果返回，controller直接return结果即可，由<strong>拦截器</strong>捕获，统一格式返回</li><li>失败：过滤器统一处理</li><li>成功：拦截器统一处理</li><li>当然你也可以在<code>controller</code>处理</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user.controller.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Get,</span><br><span class="line">  Post,</span><br><span class="line">  Body,</span><br><span class="line">  HttpCode,</span><br><span class="line">  HttpStatus,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'user'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly userService: UserService) &#123; &#125;</span><br><span class="line">  @Post()</span><br><span class="line">  @HttpCode(HttpStatus.OK) <span class="comment">//创建成功返回的是201状态码，这里重置为200，需要用到的可以使用HttpCode设置</span></span><br><span class="line">  <span class="keyword">async</span> create(@Body() user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.create(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">':id'</span>)</span><br><span class="line">  <span class="keyword">async</span> findOne(@Param(<span class="string">'id'</span>) id: string) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.findOne(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user.service.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable, HttpException, HttpStatus &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> create(user) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username &#125; = user;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(&#123; username &#125;);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;  <span class="comment">//如果用户名已经存在，抛出错误</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">        &#123; <span class="attr">message</span>: <span class="string">'请求失败'</span>, <span class="attr">error</span>: <span class="string">'用户名已存在'</span> &#125;,</span><br><span class="line">        HttpStatus.BAD_REQUEST,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.save(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> findOne(id: string) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(id);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123; <span class="comment">//如果用户id不存在，抛出错误</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">        &#123; <span class="attr">message</span>: <span class="string">'请求失败'</span>, <span class="attr">error</span>: <span class="string">'用户id不存在'</span> &#125;,</span><br><span class="line">        HttpStatus.BAD_REQUEST,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以将<code>HttpException</code>再简单封装一下，或者使用继承，这样代码更简洁一些</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, HttpException, HttpStatus &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolsService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> fail(error, status = HttpStatus.BAD_REQUEST) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">      &#123;</span><br><span class="line">        message: <span class="string">'请求失败'</span>,</span><br><span class="line">        error: error,</span><br><span class="line">      &#125;,</span><br><span class="line">      status,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简洁代码</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user.service.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable, HttpException, HttpStatus &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ToolsService &#125; <span class="keyword">from</span> <span class="string">'../../utils/tools.service'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> create(user) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username &#125; = user;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(&#123; username &#125;);</span><br><span class="line">    <span class="keyword">if</span> (result) ToolsService.fail(<span class="string">'用户名已存在'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.save(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> findOne(id: string) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(id);</span><br><span class="line">    <span class="keyword">if</span> (!result) ToolsService.fail(<span class="string">'用户id不存在'</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局使用filter过滤器</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/common/filters/http-execption.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ArgumentsHost,</span><br><span class="line">  Catch,</span><br><span class="line">  ExceptionFilter,</span><br><span class="line">  HttpException,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line">@Catch()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpExceptionFilter</span> <span class="title">implements</span> <span class="title">ExceptionFilter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">catch</span>(exception: HttpException, <span class="attr">host</span>: ArgumentsHost) &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = host.switchToHttp();</span><br><span class="line">    <span class="keyword">const</span> response = ctx.getResponse();</span><br><span class="line">    <span class="keyword">const</span> request = ctx.getRequest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> status = exception.getStatus();</span><br><span class="line">    <span class="keyword">const</span> exceptionRes: any = exception.getResponse();</span><br><span class="line">    <span class="keyword">const</span> &#123; error, message &#125; = exceptionRes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> msgLog = &#123;</span><br><span class="line">      status,</span><br><span class="line">      message,</span><br><span class="line">      error,</span><br><span class="line">      path: request.url,</span><br><span class="line">      timestamp: <span class="keyword">new</span> <span class="built_in">Date</span>().toISOString(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    response.status(status).json(msgLog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局使用interceptor拦截器</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/common/inteptors/transform.interceptor.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  CallHandler,</span><br><span class="line">  ExecutionContext,</span><br><span class="line">  Injectable,</span><br><span class="line">  NestInterceptor,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; map &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthInterceptor</span> <span class="title">implements</span> <span class="title">NestInterceptor</span> </span>&#123;</span><br><span class="line">  intercept(context: ExecutionContext, <span class="attr">next</span>: CallHandler): Observable&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> next.handle().pipe(</span><br><span class="line">      map(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          status: <span class="number">200</span>,</span><br><span class="line">          message: <span class="string">'请求成功'</span>,</span><br><span class="line">          data: data,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; HttpExceptionFilter &#125; <span class="keyword">from</span> <span class="string">'./common/filters/http-exception.filter'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; TransformInterceptor &#125; <span class="keyword">from</span> <span class="string">'./common/interceptors/transform.interceptor'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建实例</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create&lt;NestExpressApplication&gt;(AppModule);</span><br><span class="line">  <span class="comment">// 全局过滤器</span></span><br><span class="line">  app.useGlobalFilters(<span class="keyword">new</span> HttpExceptionFilter());</span><br><span class="line">  <span class="comment">// 全局拦截器</span></span><br><span class="line">  app.useGlobalInterceptors(<span class="keyword">new</span> TransformInterceptor());</span><br><span class="line">  <span class="comment">// 启动端口</span></span><br><span class="line">  <span class="keyword">const</span> PORT = process.env.PORT || <span class="number">9000</span>;</span><br><span class="line">  <span class="keyword">await</span> app.listen(PORT, () =&gt;</span><br><span class="line">    Logger.log(<span class="string">`服务已经启动 http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><p>失败</p><p><img src="https://s.poetries.work/uploads/2022/05/fe6da80fe7b316ce.png" alt></p><p>成功</p><p><img src="https://s.poetries.work/uploads/2022/05/e0c55c5a0e22af66.png" alt></p><h2 id="数据库实体设计与操作"><a href="#数据库实体设计与操作" class="headerlink" title="数据库实体设计与操作"></a>数据库实体设计与操作</h2><blockquote><p>typeorm的数据库实体如何编写？<br>数据库实体的监听装饰器如何使用？</p></blockquote><h3 id="实体设计"><a href="#实体设计" class="headerlink" title="实体设计"></a>实体设计</h3><p>简单例子：下面讲解</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn&#125; <span class="keyword">from</span> <span class="string">"typeorm"</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'users'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    @PrimaryGeneratedColumn()</span><br><span class="line">    id: number;         <span class="comment">// 默认是int(11)类型</span></span><br><span class="line"></span><br><span class="line">    @Column()</span><br><span class="line">    username: string;   <span class="comment">// 默认是varchar(255)类型</span></span><br><span class="line"></span><br><span class="line">    @Column()</span><br><span class="line">    password: string;</span><br><span class="line">   </span><br><span class="line">    @Column()</span><br><span class="line">    status: boolean;</span><br><span class="line">   </span><br><span class="line">    @CreateDateColumn()</span><br><span class="line">    created_at:date;</span><br><span class="line">       </span><br><span class="line">    @UpdateDateColumn()</span><br><span class="line">    updated_at:date;</span><br><span class="line"></span><br><span class="line">@DeleteDateColumn()</span><br><span class="line">    deleted_at:date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>装饰器说明</strong></p><ul><li><code>Entity</code>    实体声明，程序运行时，自动创建的数据库表，<code>@Entity({ name: &#39;users&#39; })</code>， <code>name</code>则是给该表命名，否则自动命名</li><li><code>PrimaryColumn</code>   设置主键，没有自增</li><li><code>PrimaryGeneratedColumn</code>    设置主键和自增，一般是<code>id</code></li><li><code>Column</code>   设置数据库列字段，在下面说明</li><li><code>CreateDateColumn</code>          创建时间，自动填写</li><li><code>UpdateDateColumn</code>          更新时间，自动填写</li><li><code>DeleteDateColumn</code>          删除时间，自动填写</li></ul><p><strong>列字段参数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法：</span></span><br><span class="line">@Column(<span class="string">"int"</span>)</span><br><span class="line">@Column(<span class="string">"varchar"</span>, &#123; <span class="attr">length</span>: <span class="number">200</span> &#125;)</span><br><span class="line">@Column(&#123; <span class="attr">type</span>: <span class="string">"int"</span>, <span class="attr">length</span>: <span class="number">200</span> &#125;)  <span class="comment">// 一般采用这种</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用选项参数：</span></span><br><span class="line">@Column(&#123;</span><br><span class="line">    type: <span class="string">'varchar'</span>,   <span class="comment">//  列的数据类型，参考mysql</span></span><br><span class="line">    name: <span class="string">'password'</span>,   <span class="comment">// 数据库表中的列名，string，如果和装饰的字段是一样的可以不指定</span></span><br><span class="line">    length: <span class="number">30</span>,         <span class="comment">// 列类型的长度，number</span></span><br><span class="line">    nullable: <span class="literal">false</span>,    <span class="comment">// 是否允许为空，boolean，默认值是false</span></span><br><span class="line">    select：<span class="literal">false</span>,      <span class="comment">// 查询数据库时是否显示该字段，boolean，默认值是true，密码一般使用false</span></span><br><span class="line">    comment: <span class="string">'密码'</span>     <span class="comment">// 数据库注释，stirng</span></span><br><span class="line">&#125;)</span><br><span class="line">password:string;</span><br><span class="line"></span><br><span class="line">@Column(&#123;</span><br><span class="line">    type:<span class="string">'varchar'</span>,  </span><br><span class="line">    unique: <span class="literal">true</span>,      <span class="comment">// 将列标记为唯一列，唯一约束，比如账号不能有相同的</span></span><br><span class="line">&#125;)</span><br><span class="line">username:string;</span><br><span class="line"></span><br><span class="line">@Column(&#123;</span><br><span class="line">    type:<span class="string">'tinyint'</span>,  </span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>,  <span class="comment">// 默认值，创建时自动填写的值</span></span><br><span class="line">    comment: <span class="string">'0：禁用，1：可用'</span></span><br><span class="line">&#125;)</span><br><span class="line">status:number;</span><br><span class="line"></span><br><span class="line">@Column(&#123;</span><br><span class="line">    type: <span class="string">'enum'</span>,</span><br><span class="line">    enum: [<span class="string">'male'</span>, <span class="string">'female'</span>],   <span class="comment">// 枚举类型，只能是数组中的值</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'male'</span>   默认值          </span><br><span class="line">&#125;)</span><br><span class="line">gender:string;</span><br></pre></td></tr></table></figure><p><strong>完整例子</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Column,</span><br><span class="line">  Entity,</span><br><span class="line">  PrimaryGeneratedColumn,</span><br><span class="line">  CreateDateColumn,</span><br><span class="line">  UpdateDateColumn,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'users'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'varchar'</span>,</span><br><span class="line">    length: <span class="number">30</span>,</span><br><span class="line">    nullable: <span class="literal">false</span>,</span><br><span class="line">    unique: <span class="literal">true</span>, </span><br><span class="line">  &#125;)</span><br><span class="line">  username: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'varchar'</span>,</span><br><span class="line">    name: <span class="string">'password'</span>, </span><br><span class="line">    length: <span class="number">100</span>,</span><br><span class="line">    nullable: <span class="literal">false</span>, </span><br><span class="line">    select: <span class="literal">false</span>,</span><br><span class="line">    comment: <span class="string">'密码'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  password: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'varchar'</span>,</span><br><span class="line">    length: <span class="number">11</span>,</span><br><span class="line">    select: <span class="literal">false</span>,</span><br><span class="line">    nullable: <span class="literal">true</span>,</span><br><span class="line">    comment: <span class="string">'手机号码'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  mobile: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'varchar'</span>,</span><br><span class="line">    length: <span class="number">50</span>,</span><br><span class="line">    select: <span class="literal">false</span>,</span><br><span class="line">    nullable: <span class="literal">true</span>,</span><br><span class="line">    comment: <span class="string">'邮箱'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  email: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'enum'</span>,</span><br><span class="line">    enum: [<span class="string">'male'</span>, <span class="string">'female'</span>], </span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'male'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  gender: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'tinyint'</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>,</span><br><span class="line">    comment: <span class="string">'0：禁用，1：可用'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  status: number;</span><br><span class="line"></span><br><span class="line">  @CreateDateColumn(&#123;</span><br><span class="line">    type: <span class="string">'timestamp'</span>,</span><br><span class="line">    nullable: <span class="literal">false</span>,</span><br><span class="line">    name: <span class="string">'created_at'</span>,</span><br><span class="line">    comment: <span class="string">'创建时间'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  createdAt: <span class="built_in">Date</span>;</span><br><span class="line"></span><br><span class="line">  @UpdateDateColumn(&#123;</span><br><span class="line">    type: <span class="string">'timestamp'</span>,</span><br><span class="line">    nullable: <span class="literal">false</span>,</span><br><span class="line">    name: <span class="string">'updated_at'</span>,</span><br><span class="line">    comment: <span class="string">'更新时间'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  updatedAt: <span class="built_in">Date</span>;</span><br><span class="line"></span><br><span class="line">  @DeleteDateColumn(&#123;</span><br><span class="line">    type: <span class="string">'timestamp'</span>,</span><br><span class="line">    nullable: <span class="literal">true</span>,</span><br><span class="line">    name: <span class="string">'deleted_at'</span>,</span><br><span class="line">    comment: <span class="string">'删除时间'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  deletedAt: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/05/648cf1e9823e51c1.png" alt></p><h3 id="抽离部分重复的字段：使用继承"><a href="#抽离部分重复的字段：使用继承" class="headerlink" title="抽离部分重复的字段：使用继承"></a><strong>抽离部分重复的字段：使用继承</strong></h3><blockquote><p><code>baseEntity</code>：将id，创建时间，更新时间，删除时间抽离成<code>BaseEntity</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Entity,</span><br><span class="line">  PrimaryGeneratedColumn,</span><br><span class="line">  CreateDateColumn,</span><br><span class="line">  UpdateDateColumn,</span><br><span class="line">  DeleteDateColumn,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"></span><br><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line"></span><br><span class="line">  @CreateDateColumn(&#123;</span><br><span class="line">    type: <span class="string">'timestamp'</span>,</span><br><span class="line">    nullable: <span class="literal">false</span>,</span><br><span class="line">    name: <span class="string">'created_at'</span>,</span><br><span class="line">    comment: <span class="string">'创建时间'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  createdAt: <span class="built_in">Date</span>;</span><br><span class="line"></span><br><span class="line">  @UpdateDateColumn(&#123;</span><br><span class="line">    type: <span class="string">'timestamp'</span>,</span><br><span class="line">    nullable: <span class="literal">false</span>,</span><br><span class="line">    name: <span class="string">'updated_at'</span>,</span><br><span class="line">    comment: <span class="string">'更新时间'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  updatedAt: <span class="built_in">Date</span>;</span><br><span class="line"></span><br><span class="line">  @DeleteDateColumn(&#123;</span><br><span class="line">    type: <span class="string">'timestamp'</span>,</span><br><span class="line">    nullable: <span class="literal">false</span>,</span><br><span class="line">    name: <span class="string">'deleted_at'</span>,</span><br><span class="line">    comment: <span class="string">'删除时间'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  deletedAt: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>users</code>表继承自<code>baseEntity</code>，就不需要写创建时间，修改时间，自增<code>ID</code>等重复字段了。其他的表也可以继承自<code>baseEntity</code>，减少重复代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Column,Entity &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BaseEntity &#125; <span class="keyword">from</span> <span class="string">'./user.baseEntity'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'users'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersEntity</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;  <span class="comment">// 继承</span></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'varchar'</span>,</span><br><span class="line">    length: <span class="number">30</span>,</span><br><span class="line">    nullable: <span class="literal">false</span>,</span><br><span class="line">    unique: <span class="literal">true</span>, </span><br><span class="line">  &#125;)</span><br><span class="line">  username: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'varchar'</span>,</span><br><span class="line">    name: <span class="string">'password'</span>, </span><br><span class="line">    length: <span class="number">100</span>,</span><br><span class="line">    nullable: <span class="literal">false</span>, </span><br><span class="line">    select: <span class="literal">false</span>,</span><br><span class="line">    comment: <span class="string">'密码'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  password: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'varchar'</span>,</span><br><span class="line">    length: <span class="number">11</span>,</span><br><span class="line">    select: <span class="literal">false</span>,</span><br><span class="line">    nullable: <span class="literal">true</span>,</span><br><span class="line">    comment: <span class="string">'手机号码'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  mobile: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'varchar'</span>,</span><br><span class="line">    length: <span class="number">50</span>,</span><br><span class="line">    select: <span class="literal">false</span>,</span><br><span class="line">    nullable: <span class="literal">true</span>,</span><br><span class="line">    comment: <span class="string">'邮箱'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  email: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'enum'</span>,</span><br><span class="line">    enum: [<span class="string">'male'</span>, <span class="string">'female'</span>], </span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'male'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  gender: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'tinyint'</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>,</span><br><span class="line">    comment: <span class="string">'0：禁用，1：可用'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  status: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实体监听装饰器"><a href="#实体监听装饰器" class="headerlink" title="实体监听装饰器"></a><strong>实体监听装饰器</strong></h3><ul><li>其实是typeorm在操作数据库时的生命周期，可以更方便的操作数据</li><li>查找后：<code>@AfterLoad</code></li><li>插入前：<code>@BeforeInsert</code></li><li>插入后：<code>@AfterInsert</code></li><li>更新前：<code>@BeforeUpdate</code></li><li>更新后：<code>@AfterUpdate</code></li><li>删除前：<code>@BeforeRemove</code></li></ul><blockquote><p><code>AfterLoad</code>例子：其他的装饰器是一样的用法</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Column,</span><br><span class="line">  Entity,</span><br><span class="line">  AfterLoad,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'users'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersEntity</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找后，如果age小于20，让age = 20</span></span><br><span class="line">  @AfterLoad()    <span class="comment">// 装饰器固定写</span></span><br><span class="line">  load() &#123;        <span class="comment">// 函数名字随你定义</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; <span class="number">20</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.age = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Column()</span><br><span class="line">  username: string;</span><br><span class="line"></span><br><span class="line">  @Column()</span><br><span class="line">  password: string;</span><br><span class="line"></span><br><span class="line">  @Column(&#123;</span><br><span class="line">    type: <span class="string">'tinyint'</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">18</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用生命周期前是18，查找后就变成了20</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"status"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"请求成功"</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"username"</span>: <span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">"age"</span>: <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="typeorm增删改查操作"><a href="#typeorm增删改查操作" class="headerlink" title="typeorm增删改查操作"></a>typeorm增删改查操作</h2><blockquote><p>访问数据库的方式有哪些？<br>typeorm增删改查操作的方式有哪些？</p></blockquote><h3 id="多种访问数据库的方式"><a href="#多种访问数据库的方式" class="headerlink" title="多种访问数据库的方式"></a><strong>多种访问数据库的方式</strong></h3><p>第一种：<code>Connection</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Connection &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    private readonly connection: Connection,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> test() &#123;</span><br><span class="line">    <span class="comment">// 使用封装好方法：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.connection</span><br><span class="line">      .getRepository(UsersEntity)</span><br><span class="line">      .findOne(&#123; <span class="attr">where</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用createQueryBuilder：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.connection</span><br><span class="line">      .createQueryBuilder()</span><br><span class="line">      .select(<span class="string">'user'</span>)</span><br><span class="line">      .from(UsersEntity, <span class="string">'user'</span>)</span><br><span class="line">      .where(<span class="string">'user.id = :id'</span>, &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line">      .getOne();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：<code>Repository</code>，需要<code>@nestjs/typeorm</code>的<code>InjectRepository</code>来注入实体</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">  @InjectRepository(UsersEntity)  注入实体</span><br><span class="line">private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> test() &#123;</span><br><span class="line">  <span class="comment">// 使用封装好方法：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.find(&#123; <span class="attr">where</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用createQueryBuilder：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository</span><br><span class="line">      .createQueryBuilder(<span class="string">'user'</span>)</span><br><span class="line">      .where(<span class="string">'id = :id'</span>, &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line">      .getOne();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种：<code>getConnection()</code>：语法糖，是<code>Connection</code>类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getConnection &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> test() &#123;</span><br><span class="line">  <span class="comment">// 使用封装好方法：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> getConnection()</span><br><span class="line">      .getRepository(UsersEntity)</span><br><span class="line">      .find(&#123; <span class="attr">where</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用createQueryBuilder：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> getConnection()</span><br><span class="line">      .createQueryBuilder()</span><br><span class="line">      .select(<span class="string">'user'</span>)</span><br><span class="line">      .from(UsersEntity, <span class="string">'user'</span>)</span><br><span class="line">      .where(<span class="string">'user.id = :id'</span>, &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line">      .getOne();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四种：<code>getRepository</code>：语法糖</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getRepository &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> test() &#123;</span><br><span class="line">  <span class="comment">// 使用封装好方法：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> getRepository(UsersEntity).find(&#123; <span class="attr">where</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用createQueryBuilder：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> getRepository(UsersEntity)</span><br><span class="line">      .createQueryBuilder(<span class="string">'user'</span>)</span><br><span class="line">      .where(<span class="string">'user.id = :id'</span>, &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line">      .getOne();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五种：<code>getManager</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getManager &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> test() &#123;</span><br><span class="line">  <span class="comment">// 使用封装好方法：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> getManager().find(UsersEntity, &#123; <span class="attr">where</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用createQueryBuilder：</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> getManager()</span><br><span class="line">      .createQueryBuilder(UsersEntity, <span class="string">'user'</span>)</span><br><span class="line">      .where(<span class="string">'user.id = :id'</span>, &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line">      .getOne();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单总结</strong></p><p>使用的方式太多，建议使用：<code>2，4</code>，比较方便</p><p><strong>Connection核心类：</strong></p><ul><li><code>connection</code>                           等于<code>getConnection</code></li><li><code>connection.manager</code>                   等于<code>getManager</code>， 等于<code>getConnection.manager</code></li><li><code>connection.getRepository</code>             等于<code>getRepository</code>， 等于<code>getManager.getRepository</code></li><li><code>connection.createQueryBuilder</code>        使用<code>QueryBuilder</code></li><li><code>connection.createQueryRunner</code>         开启事务</li></ul><ol><li><code>EntityManager</code> 和 <code>Repository</code>都封装了操作数据的方法，注意：两者的使用方式是不一样的，（实在不明白搞这么多方法做什么，学得头大）<br><code>getManager</code>是<code>EntityManager</code>的类型，<code>getRepository</code>是<code>Repository</code>的类型</li><li>都可以使用<code>createQueryBuilder</code>，但使用的方式略有不同</li></ol><h3 id="增删改查的三种方式"><a href="#增删改查的三种方式" class="headerlink" title="增删改查的三种方式"></a><strong>增删改查的三种方式</strong></h3><ul><li>第一种：使用sql语句，适用于sql语句熟练的同学</li><li>第二种：<code>typeorm</code>封装好的方法，增删改 + 简单查询</li><li>第三种：<code>QueryBuilder</code>查询生成器，适用于关系查询，多表查询，复杂查询</li><li>其实底层最终都会生成<code>sql</code>语句，只是封装了几种方式而已，方便人们使用。</li></ul><p><strong>第一种：sql语句</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> findAll() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.query(<span class="string">'select * from users'</span>);  <span class="comment">// 在query中填写sql语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种：typeorm封装好的api方法</strong></p><p>这里使用第二种访问数据库的方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> findAll() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findAndCount();  <span class="comment">// 封装好的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>api方法</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">增</span><br><span class="line">save(user)            创建：返回该数据的所有字段</span><br><span class="line">insert(user)          快速插入一条数据，插入成功：返回插入实体，与save方法不同的是，它不执行级联、关系和其他操作。</span><br><span class="line">删</span><br><span class="line">remove(user)          删除：返回该数据的可见字段</span><br><span class="line">softRemove(user);     拉黑：返回该数据的可见字段，该删除实体必须拥有@DeleteDateColumn()字段，被拉黑的用户还存在数据库中，但无法被find查找到，会在@DeleteDateColumn()字段中添加删除时间，可使用recover恢复</span><br><span class="line">改</span><br><span class="line">update(id, user)      更新：返回更新实体，不是该数据的字段</span><br><span class="line">恢复</span><br><span class="line">recover(&#123; id &#125;)       恢复：返回id，将被softRemove删除（拉黑）的用户恢复，恢复成功后可以被find查找到</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查找全部</span><br><span class="line">find()</span><br><span class="line">find(&#123;<span class="attr">id</span>:<span class="number">9</span>&#125;)                   条件查找，写法一，找不到返回空对象</span><br><span class="line">find(&#123;<span class="attr">where</span>:&#123;<span class="attr">id</span>:<span class="number">10</span>&#125;&#125;)          条件查找，写法二，找不到返回空对象</span><br><span class="line">findAndCount()                 返回数据和总的条数</span><br><span class="line"></span><br><span class="line">查找一个</span><br><span class="line">findOne(id);                       根据ID查找，找不到返回<span class="literal">undefined</span></span><br><span class="line">findOne(&#123; <span class="attr">where</span>: &#123; username &#125; &#125;);  条件查找，找不到返回<span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">根据ID查找一个或多个</span><br><span class="line">findByIds([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);            查找n个，全部查找不到返回空数组，找到就返回找到的</span><br><span class="line"></span><br><span class="line">其他</span><br><span class="line">hasId(<span class="keyword">new</span> UsersEntity())       检测实体是否有合成ID，返回布尔值</span><br><span class="line">getId(<span class="keyword">new</span> UsersEntity())       获取实体的合成ID，获取不到返回<span class="literal">undefined</span></span><br><span class="line">create(&#123;<span class="attr">username</span>: <span class="string">'admin12345'</span>, <span class="attr">password</span>: <span class="string">'123456'</span>,&#125;)  创建一个实体，需要调用save保存</span><br><span class="line">count(&#123; <span class="attr">status</span>: <span class="number">1</span> &#125;)           计数，返回数量，无返回<span class="number">0</span></span><br><span class="line">increment(&#123; id &#125;, <span class="string">'age'</span>, <span class="number">2</span>);   增加，给条件为id的数据的age字段增加<span class="number">2</span>，成功返回改变实体</span><br><span class="line">decrement(&#123; id &#125;, <span class="string">'age'</span>, <span class="number">2</span>)    减少，给条件为id的数据的age字段增加<span class="number">2</span>，成功返回改变实体</span><br><span class="line"></span><br><span class="line">谨用</span><br><span class="line">findOneOrFail(id)              找不到直接报<span class="number">500</span>错误，无法使用过滤器拦截错误，不要使用</span><br><span class="line">clear()                        清空该数据表，谨用！！！</span><br></pre></td></tr></table></figure><p><strong>find更多参数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.userRepository.find(&#123;</span><br><span class="line">    select: [<span class="string">"firstName"</span>, <span class="string">"lastName"</span>],             要的字段</span><br><span class="line">    relations: [<span class="string">"photos"</span>, <span class="string">"videos"</span>],               关系查询</span><br><span class="line">    where: &#123;                                       条件查询</span><br><span class="line">        firstName: <span class="string">"Timber"</span>,</span><br><span class="line">        lastName: <span class="string">"Saw"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    where: [&#123; <span class="attr">username</span>: <span class="string">"li"</span> &#125;, &#123; <span class="attr">username</span>: <span class="string">"joy"</span> &#125;],   多个条件or, 等于：where username = <span class="string">'li'</span> or username = <span class="string">'joy'</span></span><br><span class="line">    order: &#123;                                       排序</span><br><span class="line">        name: <span class="string">"ASC"</span>,</span><br><span class="line">        id: <span class="string">"DESC"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    skip: <span class="number">5</span>,                                       偏移量</span><br><span class="line">    take: <span class="number">10</span>,                                      每页条数</span><br><span class="line">    cache: <span class="number">60000</span>                                   启用缓存：<span class="number">1</span>分钟</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>find进阶选项</strong></p><p>TypeORM 提供了许多内置运算符，可用于创建更复杂的查询</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Not, Between, In &#125; <span class="keyword">from</span> <span class="string">"typeorm"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.find(&#123;</span><br><span class="line">    username: Not(<span class="string">'admin'</span>),</span><br><span class="line">&#125;);</span><br><span class="line">将执行以下查询：</span><br><span class="line">SELECT * FROM <span class="string">"users"</span> WHERE <span class="string">"username"</span> != <span class="string">'admin'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.find(&#123;</span><br><span class="line">    likes: Between(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">&#125;);</span><br><span class="line">SELECT * FROM <span class="string">"users"</span> WHERE <span class="string">"likes"</span> BETWEEN <span class="number">1</span> AND <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.find(&#123;</span><br><span class="line">    username: In([<span class="string">'admin'</span>, <span class="string">'admin2'</span>]),</span><br><span class="line">&#125;);</span><br><span class="line">SELECT * FROM <span class="string">"users"</span> WHERE <span class="string">"title"</span> IN (<span class="string">'admin'</span>, <span class="string">'admin2'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://typeorm.biunav.com/zh/find-options.html#%E8%BF%9B%E9%98%B6%E9%80%89%E9%A1%B9" target="_blank" rel="noopener">更多查看官网</a></p><p><strong>第三种</strong>：<code>QueryBuilder</code>查询生成器</p><p>使用链式操作</p><p><strong>QueryBuilder增，删，改</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository</span><br><span class="line">  .createQueryBuilder()</span><br><span class="line">  .insert()                       声明插入操作</span><br><span class="line">  .into(UsersEntity)              插入的实体</span><br><span class="line">  .values([                       插入的值，可插入多个</span><br><span class="line">    &#123; <span class="attr">username</span>: <span class="string">'Timber'</span>, <span class="attr">password</span>: <span class="string">'123456'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">username</span>: <span class="string">'Timber2'</span>, <span class="attr">password</span>: <span class="string">'123456'</span> &#125;,</span><br><span class="line">  ])</span><br><span class="line">  .execute();                     执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.usersRepository</span><br><span class="line">  .createQueryBuilder()</span><br><span class="line">  .update(UsersEntity)</span><br><span class="line">  .set(&#123; <span class="attr">username</span>: <span class="string">'admin22'</span> &#125;)</span><br><span class="line">  .where(<span class="string">'id = :id'</span>, &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;)</span><br><span class="line">  .execute();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.usersRepository</span><br><span class="line">  .createQueryBuilder()</span><br><span class="line">  .delete()</span><br><span class="line">  .from(UsersEntity)</span><br><span class="line">  .where(<span class="string">'id = :id'</span>, &#123; <span class="attr">id</span>: <span class="number">8</span> &#125;)</span><br><span class="line">  .execute();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理异常：请求成功会返回一个对象， 如果raw.affectedRows != 0 就是成功</span></span><br><span class="line"><span class="string">"raw"</span>: &#123;</span><br><span class="line">      <span class="string">"fieldCount"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"affectedRows"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">"insertId"</span>: <span class="number">13</span>,</span><br><span class="line">      <span class="string">"serverStatus"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">"warningCount"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"message"</span>: <span class="string">"&amp;Records: 2  Duplicates: 0  Warnings: 0"</span>,</span><br><span class="line">      <span class="string">"protocol41"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"changedRows"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询</strong></p><p>简单例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> findAll() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository</span><br><span class="line">    .createQueryBuilder(<span class="string">'user'</span>)                      创建生成器，参数：别名</span><br><span class="line">    .where(<span class="string">'user.id = :id'</span>, &#123; <span class="attr">id</span>: id &#125;)              条件</span><br><span class="line">    .innerJoinAndSelect(<span class="string">'user.avatar'</span>, <span class="string">'avatar'</span>)     关系查询</span><br><span class="line">    .addSelect(<span class="string">'user.password'</span>)                      添加显示字段</span><br><span class="line">    .getOne();                                       获取一条数据</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>QueryBuilder查询生成器说明</strong></p><p>查询单表</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">访问数据库的方式不同：</span><br><span class="line"></span><br><span class="line">方式一：没有指定实体，需要使用<span class="keyword">from</span>指定实体</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> getConnection()</span><br><span class="line">      .createQueryBuilder()</span><br><span class="line">      .select(<span class="string">'user.username'</span>)             ‘user’：全部字段，‘user.username’：只获取username</span><br><span class="line">      .from(UsersEntity, <span class="string">'user'</span>)           参<span class="number">1</span>：连接的实体， 参<span class="number">2</span>：别名</span><br><span class="line">      .where(<span class="string">'user.id = :id'</span>, &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line">      .getOne();</span><br><span class="line"></span><br><span class="line">方式二：指定实体：默认获取全部字段</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> getConnection()</span><br><span class="line">      .createQueryBuilder(UsersEntity, <span class="string">'user'</span>)   指定实体</span><br><span class="line">      .where(<span class="string">'user.id = :id'</span>, &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line">      .getOne();</span><br><span class="line"></span><br><span class="line">方式三： 已经在访问时指定了实体：默认获取全部字段</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository</span><br><span class="line">      .createQueryBuilder(<span class="string">'user'</span>)          别名</span><br><span class="line">      .where(<span class="string">'user.id = :id'</span>, &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line">      .getOne();</span><br></pre></td></tr></table></figure><p>获取结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.getSql();          获取实际执行的sql语句，用于开发时检查问题</span><br><span class="line">.getOne();          获取一条数据（经过typeorm的字段处理）</span><br><span class="line">.getMany();         获取多条数据</span><br><span class="line">.getRawOne();       获取一条原数据（没有经过typeorm的字段处理）</span><br><span class="line">.getRawMany();      获取多条原数据</span><br><span class="line">.stream();          返回流数据</span><br><span class="line"></span><br><span class="line">如：经过typeorm的字段处理，获取到的就是实体设计时的字段</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"status"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"请求成功"</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"username"</span>: <span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">"gender"</span>: <span class="string">"male"</span>,</span><br><span class="line">        <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="string">"status"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"createdAt"</span>: <span class="string">"2021-04-26T09:58:54.469Z"</span>,</span><br><span class="line">        <span class="string">"updatedAt"</span>: <span class="string">"2021-04-28T14:47:36.000Z"</span>,</span><br><span class="line">        <span class="string">"deletedAt"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如：没有经过typeorm的字段处理，将数据库的字段原生不动的显示出来</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"status"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"请求成功"</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"user_id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"user_username"</span>: <span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">"user_gender"</span>: <span class="string">"male"</span>,</span><br><span class="line">        <span class="string">"user_age"</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="string">"user_status"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"user_created_at"</span>: <span class="string">"2021-04-26T09:58:54.469Z"</span>,</span><br><span class="line">        <span class="string">"user_updated_at"</span>: <span class="string">"2021-04-28T14:47:36.000Z"</span>,</span><br><span class="line">        <span class="string">"user_deleted_at"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询部分字段</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.select([<span class="string">"user.id"</span>, <span class="string">"user.name"</span>])</span><br><span class="line">实际执行的sql语句：SELECT user.id, user.name FROM users user；</span><br><span class="line"></span><br><span class="line">添加隐藏字段：实体中设置select为<span class="literal">false</span>时，是不显示字段，使用addSelect会将字段显示出来</span><br><span class="line">.addSelect(<span class="string">'user.password'</span>)</span><br></pre></td></tr></table></figure><p><code>where</code>条件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.where(<span class="string">"user.name = :name"</span>, &#123; <span class="attr">name</span>: <span class="string">"joy"</span> &#125;)</span><br><span class="line">等于</span><br><span class="line">.where(<span class="string">"user.name = :name"</span>)</span><br><span class="line">.setParameter(<span class="string">"name"</span>, <span class="string">"Timber"</span>)</span><br><span class="line">实际执行的sql语句：SELECT * FROM users user WHERE user.name = <span class="string">'joy'</span></span><br><span class="line"></span><br><span class="line">多个条件</span><br><span class="line">.where(<span class="string">"user.firstName = :firstName"</span>, &#123; <span class="attr">firstName</span>: <span class="string">"Timber"</span> &#125;)</span><br><span class="line">.andWhere(<span class="string">"user.lastName = :lastName"</span>, &#123; <span class="attr">lastName</span>: <span class="string">"Saw"</span> &#125;);</span><br><span class="line">实际执行的sql语句：SELECT * FROM users user WHERE user.firstName = <span class="string">'Timber'</span> AND user.lastName = <span class="string">'Saw'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">.where(<span class="string">"user.name IN (:...names)"</span>, &#123; <span class="attr">names</span>: [ <span class="string">"Timber"</span>, <span class="string">"Cristal"</span>, <span class="string">"Lina"</span> ] &#125;)</span><br><span class="line">实际执行的sql语句：SELECT * FROM users user WHERE user.name IN (<span class="string">'Timber'</span>, <span class="string">'Cristal'</span>, <span class="string">'Lina'</span>)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line">.where(<span class="string">"user.firstName = :firstName"</span>, &#123; <span class="attr">firstName</span>: <span class="string">"Timber"</span> &#125;)</span><br><span class="line">.orWhere(<span class="string">"user.lastName = :lastName"</span>, &#123; <span class="attr">lastName</span>: <span class="string">"Saw"</span> &#125;);</span><br><span class="line">实际执行的sql语句：SELECT * FROM users user WHERE user.firstName = <span class="string">'Timber'</span> OR user.lastName = <span class="string">'Saw'</span></span><br><span class="line"></span><br><span class="line">子句</span><br><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> connection</span><br><span class="line">  .getRepository(Post)</span><br><span class="line">  .createQueryBuilder(<span class="string">"post"</span>)</span><br><span class="line">  .where(<span class="function"><span class="params">qb</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> subQuery = qb</span><br><span class="line">      .subQuery()</span><br><span class="line">      .select(<span class="string">"user.name"</span>)</span><br><span class="line">      .from(User, <span class="string">"user"</span>)</span><br><span class="line">      .where(<span class="string">"user.registered = :registered"</span>)</span><br><span class="line">      .getQuery();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"post.title IN "</span> + subQuery;</span><br><span class="line">  &#125;)</span><br><span class="line">  .setParameter(<span class="string">"registered"</span>, <span class="literal">true</span>)</span><br><span class="line">  .getMany();</span><br><span class="line">实际执行的sql语句：select * <span class="keyword">from</span> post where post.title <span class="keyword">in</span> (select name <span class="keyword">from</span> user where registered = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><code>having</code>筛选</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.having(<span class="string">"user.firstName = :firstName"</span>, &#123; <span class="attr">firstName</span>: <span class="string">"Timber"</span> &#125;)</span><br><span class="line">.andHaving(<span class="string">"user.lastName = :lastName"</span>, &#123; <span class="attr">lastName</span>: <span class="string">"Saw"</span> &#125;);</span><br><span class="line">实际执行的sql语句：SELECT ... FROM users user HAVING user.firstName = <span class="string">'Timber'</span> AND user.lastName = <span class="string">'Saw'</span></span><br></pre></td></tr></table></figure><p><code>orderBy</code>排序</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.orderBy(<span class="string">"user.name"</span>, <span class="string">"DESC"</span>)</span><br><span class="line">.addOrderBy(<span class="string">"user.id"</span>, <span class="string">"asc"</span>);</span><br><span class="line">等于</span><br><span class="line">.orderBy(&#123;</span><br><span class="line">  <span class="string">"user.name"</span>: <span class="string">"ASC"</span>,</span><br><span class="line">  <span class="string">"user.id"</span>: <span class="string">"DESC"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">实际执行的sql语句：SELECT * FROM users user order by user.name asc, user.id desc;</span><br></pre></td></tr></table></figure><p><code>group</code>分组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.groupBy(<span class="string">"user.name"</span>)</span><br><span class="line">.addGroupBy(<span class="string">"user.id"</span>);</span><br></pre></td></tr></table></figure><p>关系查询（多表）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>参：你要加载的关系，<span class="number">2</span>参：可选，你为此表分配的别名，<span class="number">3</span>参：可选，查询条件</span><br><span class="line"></span><br><span class="line">左关联查询</span><br><span class="line">.leftJoinAndSelect(<span class="string">"user.profile"</span>, <span class="string">"profile"</span>)     </span><br><span class="line"></span><br><span class="line">右关联查询</span><br><span class="line">.rightJoinAndSelect(<span class="string">"user.profile"</span>, <span class="string">"profile"</span>)    </span><br><span class="line"></span><br><span class="line">内联查询</span><br><span class="line">.innerJoinAndSelect(<span class="string">"user.photos"</span>, <span class="string">"photo"</span>, <span class="string">"photo.isRemoved = :isRemoved"</span>, &#123; <span class="attr">isRemoved</span>: <span class="literal">false</span> &#125;)         </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository</span><br><span class="line">.createQueryBuilder(<span class="string">'user'</span>)</span><br><span class="line">    .leftJoinAndSelect(<span class="string">"user.photos"</span>, <span class="string">"photo"</span>)</span><br><span class="line">    .where(<span class="string">"user.name = :name"</span>, &#123; <span class="attr">name</span>: <span class="string">"joy"</span> &#125;)</span><br><span class="line">  .andWhere(<span class="string">"photo.isRemoved = :isRemoved"</span>, &#123; <span class="attr">isRemoved</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">  .getOne();</span><br><span class="line"></span><br><span class="line">实际执行的sql语句：</span><br><span class="line">SELECT user.*, photo.* </span><br><span class="line">FROM users user</span><br><span class="line">LEFT JOIN photos photo ON photo.user = user.id</span><br><span class="line">WHERE user.name = <span class="string">'joy'</span> AND photo.isRemoved = FALSE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository</span><br><span class="line">.innerJoinAndSelect(<span class="string">"user.photos"</span>, <span class="string">"photo"</span>, <span class="string">"photo.isRemoved = :isRemoved"</span>, &#123; <span class="attr">isRemoved</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">    .where(<span class="string">"user.name = :name"</span>, &#123; <span class="attr">name</span>: <span class="string">"Timber"</span> &#125;)</span><br><span class="line">    .getOne();</span><br><span class="line"></span><br><span class="line">实际执行的sql语句：</span><br><span class="line">SELECT user.*, photo.* FROM users user</span><br><span class="line">INNER JOIN photos photo ON photo.user = user.id AND photo.isRemoved = FALSE</span><br><span class="line">WHERE user.name = <span class="string">'Timber'</span>；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">多个关联</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository</span><br><span class="line">  .createQueryBuilder(<span class="string">"user"</span>)</span><br><span class="line">  .leftJoinAndSelect(<span class="string">"user.profile"</span>, <span class="string">"profile"</span>)</span><br><span class="line">  .leftJoinAndSelect(<span class="string">"user.photos"</span>, <span class="string">"photo"</span>)</span><br><span class="line">  .leftJoinAndSelect(<span class="string">"user.videos"</span>, <span class="string">"video"</span>)</span><br><span class="line">  .getOne();</span><br></pre></td></tr></table></figure><h2 id="typeorm使用事务的3种方式"><a href="#typeorm使用事务的3种方式" class="headerlink" title="typeorm使用事务的3种方式"></a>typeorm使用事务的3种方式</h2><p><code>typeorm</code>使用事务的方式有哪些？如何使用？</p><p><strong>事务</strong></p><blockquote><ul><li>在操作多个表时，或者多个操作时，如果有一个操作失败，所有的操作都失败，要么全部成功，要么全部失</li><li><strong>解决问题</strong>：在多表操作时，因为各种异常导致一个成功，一个失败的数据错误。</li></ul></blockquote><blockquote><p>例子：银行转账<br>如果用户1向用户2转了100元，但因为各种原因，用户2没有收到，如果没有事务处理，用户1扣除的100元就凭空消失了<br>如果有事务处理，只有用户2收到100元，用户1才会扣除100元，如果没有收到，则不会扣除。</p></blockquote><p><strong>应用场景</strong></p><blockquote><p>多表的增，删，改操作</p></blockquote><p><strong>nest-typrorm事务的使用方式</strong></p><ol><li>使用装饰器，在<code>controller</code>中编写，传递给<code>service</code>使用</li><li>使用<code>getManager</code> 或 <code>getConnection</code>，在<code>service</code>中编写与使用</li><li>使用<code>connection</code> 或 <code>getConnection</code>，开启<code>queryRunner</code>，在<code>service</code>中编写与使用</li></ol><p><strong>方式一：使用装饰器</strong></p><p>controller</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Post,</span><br><span class="line">  Body,</span><br><span class="line">  Param,</span><br><span class="line">  ParseIntPipe,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Transaction, TransactionManager, EntityManager &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;  开启事务第一步：引入</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service-oto'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'user'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly userService: UserService) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  @Post(<span class="string">':id'</span>)</span><br><span class="line">  @Transaction() 开启事务第二步：装饰接口</span><br><span class="line">  <span class="keyword">async</span> create(</span><br><span class="line">    @Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number,</span><br><span class="line">    @TransactionManager() maneger: EntityManager,  开启事务第三步：获取事务管理器</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.create(id, maneger);  开启事务第四步：传递给service，使用数据库时调用</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service</p><ul><li>这里处理的是1对1关系：保存头像地址到<code>avatar</code>表，同时关联保存用户的<code>id</code></li><li>如果你不会1对1关系，请先去学习对应的知识</li></ul><p><img src="https://s.poetries.work/uploads/2022/05/24be5e00069ab400.png" alt></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository, EntityManager &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AvatarEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/avatar.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ToolsService &#125; <span class="keyword">from</span> <span class="string">'../../utils/tools.service'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">    @InjectRepository(AvatarEntity)</span><br><span class="line">    private readonly avatarRepository: Repository&lt;AvatarEntity&gt;,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> create(id: number, <span class="attr">manager</span>: EntityManager) &#123;</span><br><span class="line">    <span class="keyword">const</span> urlObj = &#123;</span><br><span class="line">      url: <span class="string">`http://www.dmyxs.com/images/<span class="subst">$&#123;id&#125;</span>.png`</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(&#123; id &#125;);                 先查找用户，因为要保存用户的id</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户id不存在'</span>);                              找不到用户抛出异常</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> avatarEntity = <span class="keyword">this</span>.avatarRepository.create(&#123; <span class="attr">url</span>: urlObj.url &#125;);  创建头像地址的实体</span><br><span class="line">    <span class="keyword">const</span> avatarUrl = <span class="keyword">await</span> manager.save(avatarEntity);                      使用事务保存副表</span><br><span class="line">    user.avatar = avatarUrl;                                                 主表和副表建立关系</span><br><span class="line">    <span class="keyword">await</span> manager.save(user);                                                使用事务保存主表</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'新增成功'</span>;                                                        如果过程出错，不会保存</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式二：使用getManager 或 getConnection</strong></p><p>service</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Connection, Repository, getManager &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AvatarEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/avatar.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ToolsService &#125; <span class="keyword">from</span> <span class="string">'../../utils/tools.service'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">    private readonly connection: Connection,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> test(id: string) &#123;</span><br><span class="line">    <span class="keyword">const</span> urlObj = &#123;</span><br><span class="line">      url: <span class="string">`http://www.dmyxs.com/images/<span class="subst">$&#123;id&#125;</span>.png`</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(id);                        先查找用户</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户id不存在'</span>);                                 找不到用户抛出异常</span><br><span class="line"></span><br><span class="line"><span class="comment">//getConnection的方式：await getConnection().transaction(manager=&gt; &#123;&#125;);</span></span><br><span class="line"><span class="comment">//getManager的方式：</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> getManager().transaction(<span class="keyword">async</span> (manager) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> avatarEntity = manager.create(AvatarEntity, &#123; <span class="attr">url</span>: urlObj.url &#125;);   创建头像地址的实体</span><br><span class="line">      <span class="keyword">const</span> avatarUrl = <span class="keyword">await</span> manager.save(AvatarEntity, avatarEntity);         使用事务保存副表</span><br><span class="line">      user.avatar = avatarUrl;                                                  创建关联</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> manager.save(UsersEntity, user);                             使用事务保存主表，并返回结果</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"status"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"请求成功"</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"createdAt"</span>: <span class="string">"2021-04-26T09:58:54.469Z"</span>,</span><br><span class="line">        <span class="string">"updatedAt"</span>: <span class="string">"2021-04-28T14:47:36.000Z"</span>,</span><br><span class="line">        <span class="string">"deletedAt"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="string">"username"</span>: <span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">"gender"</span>: <span class="string">"male"</span>,</span><br><span class="line">        <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="string">"status"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"avatar"</span>: &#123;</span><br><span class="line">            <span class="string">"url"</span>: <span class="string">"http://www.dmyxs.com/images/1.png"</span>,</span><br><span class="line">            <span class="string">"id"</span>: <span class="number">52</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式三：使用 connection 或 getConnection</strong></p><p>service</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Connection, Repository, getManager &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AvatarEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/avatar.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">    private readonly connection: Connection,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> test(id: string) &#123;</span><br><span class="line">    <span class="keyword">const</span> urlObj = &#123;</span><br><span class="line">      url: <span class="string">`http://www.test.com/images/<span class="subst">$&#123;id&#125;</span>.png`</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(id);         先查找用户</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户id不存在'</span>);                 找不到用户抛出异常</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queryRunner = <span class="keyword">this</span>.connection.createQueryRunner();     获取连接并创建新的queryRunner</span><br><span class="line">    <span class="keyword">await</span> queryRunner.connect();                                 使用我们的新queryRunner建立真正的数据库连</span><br><span class="line">    <span class="keyword">await</span> queryRunner.startTransaction();                        开始事务</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> avatarEntity = <span class="keyword">new</span> AvatarEntity();                     创建实体：要保存的数据</span><br><span class="line">    avatarEntity.url = urlObj.url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> queryRunner.manager                  使用事务保存到副表</span><br><span class="line">        .getRepository(AvatarEntity)</span><br><span class="line">        .save(avatarEntity);</span><br><span class="line"></span><br><span class="line">      user.avatar = result;                                     主表和副表建立连接</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">const</span> userResult = <span class="keyword">await</span> queryRunner.manager              使用事务保存到副表</span><br><span class="line">        .getRepository(UsersEntity)</span><br><span class="line">        .save(user);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">await</span> queryRunner.commitTransaction();                   提交事务</span><br><span class="line">      <span class="keyword">return</span> userResult;                                       返回结果</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'创建失败，取消事务'</span>);</span><br><span class="line">      <span class="keyword">await</span> queryRunner.rollbackTransaction();                 出错回滚</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> queryRunner.release();                             释放</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="typeorm-一对一关系设计与增删改查"><a href="#typeorm-一对一关系设计与增删改查" class="headerlink" title="typeorm 一对一关系设计与增删改查"></a>typeorm 一对一关系设计与增删改查</h2><p>实体如何设计一对一关系？如何增删改查？</p><p><strong>一对一关系</strong></p><blockquote><ul><li>定义：一对一是一种 A 只包含一个 B ，而 B 只包含一个 A 的关系</li><li>其实就是要设计两个表：一张是主表，一张是副表，查找主表时，关联查找副表</li><li>有外键的表称之为副表，不带外键的表称之为主表</li><li>如：一个账户对应一个用户信息，主表是账户，副表是用户信息</li><li>如：一个用户对应一张用户头像图片，主表是用户信息，副表是头像地址</li></ul></blockquote><p><strong>一对一实体设计</strong></p><p>主表：</p><blockquote><ul><li>使用<code>@OneToOne()</code> 来建立关系</li><li>第一个参数：<code>() =&gt; AvatarEntity</code>， 和谁建立关系？ 和<code>AvatarEntity</code>建立关系</li><li>第二个参数：<code>(avatar) =&gt; avatar.user)</code>，和哪个字段联立关系？ <code>avatar</code>就是<code>AvatarEntity</code>的别名，可随便写，和<code>AvatarEntity</code>的<code>userinfo</code>字段建立关系</li><li>第三个参数：<code>RelationOptions</code>关系选项</li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Column,</span><br><span class="line">  Entity,</span><br><span class="line">  PrimaryGeneratedColumn,</span><br><span class="line">  OneToOne,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AvatarEntity &#125; <span class="keyword">from</span> <span class="string">'./avatar.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'users'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line"></span><br><span class="line">  @Column()</span><br><span class="line">  username: string;</span><br><span class="line"></span><br><span class="line">  @Column()</span><br><span class="line">  password: string;</span><br><span class="line"></span><br><span class="line">  @OneToOne(<span class="function"><span class="params">()</span> =&gt;</span> AvatarEntity, (avatar) =&gt; avatar.userinfo)</span><br><span class="line">  avatar: AvatarEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>副表</p><blockquote><p>参数：同主表一样<br>主要：根据<code>@JoinColumn({ name: ‘user_id’ })</code>来分辨副表，<code>name</code>是设置数据库的外键名字，如果不设置是<code>userId</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Entity,</span><br><span class="line">  PrimaryGeneratedColumn,</span><br><span class="line">  Column,</span><br><span class="line">  OneToOne,</span><br><span class="line">  JoinColumn,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./user.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'avatar'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatarEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">type</span>: <span class="string">'varchar'</span> &#125;)</span><br><span class="line">  url: string;</span><br><span class="line"></span><br><span class="line">  @OneToOne(<span class="function"><span class="params">()</span> =&gt;</span> UsersEntity, (user) =&gt; user.avatar)</span><br><span class="line">  @JoinColumn(&#123; <span class="attr">name</span>: <span class="string">'userinfo_id'</span> &#125;)</span><br><span class="line">  userinfo: UsersEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一对一增删改查</strong></p><blockquote><ul><li><strong>注意</strong>：只要涉及两种表操作的，就需要开启事务：同时失败或同时成功，避免数据不统一</li><li><strong>在这里</strong>：创建，修改，删除都开启了事务</li><li><strong>注意</strong>：所有数据应该是由前端传递过来的，这里为了方便，直接硬编码了（写死）</li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user.controller.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Get,</span><br><span class="line">  Post,</span><br><span class="line">  Body,</span><br><span class="line">  Patch,</span><br><span class="line">  Query,</span><br><span class="line">  Param,</span><br><span class="line">  Delete,</span><br><span class="line">  HttpCode,</span><br><span class="line">  HttpStatus,</span><br><span class="line">  ParseIntPipe,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Transaction, TransactionManager, EntityManager &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;  开启事务第一步：引入</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service-oto'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'user'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly userService: UserService) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  <span class="keyword">async</span> findAll() &#123;</span><br><span class="line">    <span class="keyword">const</span> [data, count] = <span class="keyword">await</span> <span class="keyword">this</span>.userService.findAll();</span><br><span class="line">    <span class="keyword">return</span> &#123; count, data &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">':id'</span>)</span><br><span class="line">  <span class="keyword">async</span> findOne(@Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.findOne(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Post(<span class="string">':id'</span>)</span><br><span class="line">  @HttpCode(HttpStatus.OK)</span><br><span class="line">  @Transaction() 开启事务第二步：装饰接口</span><br><span class="line">  <span class="keyword">async</span> create(</span><br><span class="line">    @Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number,</span><br><span class="line">    @TransactionManager() maneger: EntityManager,  开启事务第三步：获取事务管理器</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.create(id, maneger);  开启事务第四步：传递给service，使用数据库时调用</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Patch(<span class="string">':id'</span>)</span><br><span class="line">  @Transaction()</span><br><span class="line">  <span class="keyword">async</span> update(</span><br><span class="line">    @Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number,</span><br><span class="line">    @TransactionManager() maneger: EntityManager,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.update(id, maneger);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Delete(<span class="string">':id'</span>)</span><br><span class="line">  @Transaction()</span><br><span class="line">  <span class="keyword">async</span> remove(</span><br><span class="line">    @Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number,</span><br><span class="line">    @TransactionManager() maneger: EntityManager,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.remove(id, maneger);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user.service.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository, Connection, UpdateResult, EntityManager &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AvatarEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/avatar.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ToolsService &#125; <span class="keyword">from</span> <span class="string">'../../utils/tools.service'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">    @InjectRepository(AvatarEntity)</span><br><span class="line">    private readonly avatarRepository: Repository&lt;AvatarEntity&gt;,</span><br><span class="line">    private connection: Connection,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  一对一增删改查</span><br><span class="line">  查找全部</span><br><span class="line">  <span class="keyword">async</span> findAll() &#123;</span><br><span class="line">    使用封装好的方式</span><br><span class="line">    <span class="comment">// return await this.usersRepository.findAndCount(&#123; relations: ['avatar'] &#125;);</span></span><br><span class="line"></span><br><span class="line">使用QueryBuilder的方式</span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository</span><br><span class="line">      .createQueryBuilder(<span class="string">'UsersEntity'</span>)</span><br><span class="line">      .leftJoinAndSelect(<span class="string">'UsersEntity.avatar'</span>, <span class="string">'AvatarEntity.userinfo'</span>)</span><br><span class="line">      .getManyAndCount();</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  根据主表id查找一对一</span><br><span class="line">  <span class="keyword">async</span> findOne(id: number) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(id, &#123;</span><br><span class="line">      relations: [<span class="string">'avatar'</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!result) ToolsService.fail(<span class="string">'用户id不存在'</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  根据主表id创建一对一</span><br><span class="line">  <span class="keyword">async</span> create(id: number, <span class="attr">manager</span>: EntityManager) &#123;</span><br><span class="line">    <span class="keyword">const</span> urlObj = &#123;</span><br><span class="line">      url: <span class="string">`http://www.dmyxs.com/images/<span class="subst">$&#123;id&#125;</span>.png`</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(&#123; id &#125;);      先查找用户</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户id不存在'</span>);                  如果没找到，抛出错误，由过滤器捕获错误</span><br><span class="line">    </span><br><span class="line">    创建实体的两种方式：<span class="keyword">new</span> 和 create，<span class="keyword">new</span>的方式方便条件判断</span><br><span class="line">    创建实体方式一：</span><br><span class="line">    <span class="keyword">const</span> avatarEntity = <span class="keyword">this</span>.avatarRepository.create(&#123; <span class="attr">url</span>: urlObj.url &#125;);  创建实体</span><br><span class="line"></span><br><span class="line">创建实体方式二：</span><br><span class="line"><span class="comment">//const avatarEntity = new AvatarEntity();</span></span><br><span class="line"><span class="comment">//avatarEntity.url = urlObj.url;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> avatarUrl = <span class="keyword">await</span> manager.save(avatarEntity);          使用事务保存副表</span><br><span class="line">    user.avatar = avatarUrl;                                     主表和副表建立关系</span><br><span class="line">    <span class="keyword">await</span> manager.save(user);                                    使用事务保存主表</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'新增成功'</span>;                                            如果过程出错，不会保存</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  根据主表id更改一对一</span><br><span class="line">  要更改的副表id，会从前端传递过来</span><br><span class="line">  <span class="keyword">async</span> update(id: number, <span class="attr">manager</span>: EntityManager) &#123;</span><br><span class="line">    <span class="keyword">const</span> urlObj = &#123;</span><br><span class="line">      id: <span class="number">18</span>,</span><br><span class="line">      url: <span class="string">`http://www.dmyxs.com/images/<span class="subst">$&#123;id&#125;</span>-update.jpg`</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne( &#123; id &#125; );       先查找用户</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户id不存在'</span>);                      如果没找到id抛出错误，由过滤器捕获错误</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> avatarEntity = <span class="keyword">this</span>.avatarRepository.create(&#123; <span class="attr">url</span>: urlObj.url &#125;);    创建要修改的实体</span><br><span class="line"></span><br><span class="line">使用事务更新方法：<span class="number">1</span>参：要修改的表，<span class="number">2</span>参：要修改的id， <span class="number">3</span>参：要更新的数据</span><br><span class="line">    <span class="keyword">await</span> manager.update(AvatarEntity, urlObj.id, avatarEntity);   </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'更新成功'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  根据主表id删除一对一</span><br><span class="line">  <span class="keyword">async</span> remove(id: number, <span class="attr">manager</span>: EntityManager): <span class="built_in">Promise</span>&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(id);</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户id不存在'</span>);</span><br><span class="line"></span><br><span class="line">    只删副表的关联数据</span><br><span class="line">    <span class="keyword">await</span> manager.delete(AvatarEntity, &#123; <span class="attr">user</span>: id &#125;);</span><br><span class="line">    </span><br><span class="line">    如果连主表用户一起删，加下面这行代码</span><br><span class="line">    <span class="comment">//await manager.delete(UsersEntity, id);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'删除成功'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="typeorm-一对多和多对一关系设计与增删改查"><a href="#typeorm-一对多和多对一关系设计与增删改查" class="headerlink" title="typeorm 一对多和多对一关系设计与增删改查"></a>typeorm 一对多和多对一关系设计与增删改查</h2><p>实体如何设计一对多与多对一关系，如何关联查询</p><p><strong>一对多关系，多对一关系</strong></p><blockquote><p>定义：一对多是一种一个 A 包含多个 B ，而多个B只属于一个 A 的关系<br>其实就是要设计两个表：一张是主表（一对多），一张是副表（多对一），查找主表时，关联查找副表<br>有外键的表称之为副表，不带外键的表称之为主表<br>如：一个用户拥有多个宠物，多个宠物只属于一个用户的（每个宠物只能有一个主人）<br>如：一个用户拥有多张照片，多张照片只属于一个用户的<br>如：一个角色拥有多个用户，多个用户只属于一个角色的（每个用户只能有一个角色）</p></blockquote><p><strong>一对多和多对一实体设计</strong></p><p>一对多</p><blockquote><p>使用<code>@OneToMany()</code>来建立一对多关系<br>第一个参数：<code>() =&gt; PhotoEntity</code>， 和谁建立关系？ 和<code>PhotoEntity</code>建立关系<br>第二个参数：<code>(user) =&gt; user.photo</code>，和哪个字段联立关系？ <code>user</code>就是<code>PhotoEntity</code>的别名，可随便写，和<code>PhotoEntity</code>的<code>userinfo</code>字段建立关系<br>第三个参数：<code>RelationOptions</code>关系选项</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Column,</span><br><span class="line">  Entity,</span><br><span class="line">  PrimaryGeneratedColumn,</span><br><span class="line">  OneToOne,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AvatarEntity &#125; <span class="keyword">from</span> <span class="string">'./avatar.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'users'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line"></span><br><span class="line">  @Column()</span><br><span class="line">  username: string;</span><br><span class="line"></span><br><span class="line">  @Column()</span><br><span class="line">  password: string;</span><br><span class="line"></span><br><span class="line">  @OneToMany(<span class="function"><span class="params">()</span> =&gt;</span> PhotoEntity, (avatar) =&gt; avatar.userinfo)</span><br><span class="line">  photos: PhotoEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多对一</p><blockquote><p>使用<code>@ManyToOne()</code>来建立多对一关系，参数如同上</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Entity, PrimaryGeneratedColumn, Column, ManyToOne &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./user.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'photo'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">type</span>: <span class="string">'varchar'</span> &#125;)</span><br><span class="line">  url: string;</span><br><span class="line"></span><br><span class="line">  @ManyToOne(<span class="function"><span class="params">()</span> =&gt;</span> UsersEntity, (user) =&gt; user.photos)</span><br><span class="line">  @JoinColumn(&#123; <span class="attr">name</span>: <span class="string">'userinfo_id'</span> &#125;)</span><br><span class="line">  userinfo: UsersEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一对多和多对一增删改查</strong></p><blockquote><p>只要涉及两种表操作的，就需要开启事务：同时失败或同时成功，避免数据不统一<br>注意：所有数据应该是由前端传递过来的，这里为了方便，直接硬编码了（写死）<br>比较复杂的是更新操作</p></blockquote><p>user.controller.ts</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Get,</span><br><span class="line">  Post,</span><br><span class="line">  Body,</span><br><span class="line">  Patch,</span><br><span class="line">  Query,</span><br><span class="line">  Param,</span><br><span class="line">  Delete,</span><br><span class="line">  HttpCode,</span><br><span class="line">  HttpStatus,</span><br><span class="line">  ParseIntPipe,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Transaction, TransactionManager, EntityManager &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;  开启事务第一步：引入</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service-oto'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'user'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly userService: UserService) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  <span class="keyword">async</span> findAll() &#123;</span><br><span class="line">    <span class="keyword">const</span> [data, count] = <span class="keyword">await</span> <span class="keyword">this</span>.userService.findAll();</span><br><span class="line">    <span class="keyword">return</span> &#123; count, data &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">':id'</span>)</span><br><span class="line">  <span class="keyword">async</span> findOne(@Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.findOne(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Post(<span class="string">':id'</span>)</span><br><span class="line">  @HttpCode(HttpStatus.OK)</span><br><span class="line">  @Transaction() 开启事务第二步：装饰接口</span><br><span class="line">  <span class="keyword">async</span> create(</span><br><span class="line">    @Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number,</span><br><span class="line">    @TransactionManager() maneger: EntityManager,  开启事务第三步：获取事务管理器</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.create(id, maneger);  开启事务第四步：传递给service，使用数据库时调用</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Patch(<span class="string">':id'</span>)</span><br><span class="line">  @Transaction()</span><br><span class="line">  <span class="keyword">async</span> update(</span><br><span class="line">    @Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number,</span><br><span class="line">    @TransactionManager() maneger: EntityManager,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.update(id, maneger);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Delete(<span class="string">':id'</span>)</span><br><span class="line">  @Transaction()</span><br><span class="line">  <span class="keyword">async</span> remove(</span><br><span class="line">    @Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number,</span><br><span class="line">    @TransactionManager() maneger: EntityManager,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.remove(id, maneger);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>user.service.ts</p><p><strong>令人头大的地方</strong>：建立关系和查找使用实体，删除使用实体的id，感觉设计得不是很合理，违背人的常识</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository, EntityManager &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PhotoEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/photo.entity'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ToolsService &#125; <span class="keyword">from</span> <span class="string">'../../utils/tools.service'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">    @InjectRepository(PhotoEntity)</span><br><span class="line">    private readonly photoRepository: Repository&lt;PhotoEntity&gt;,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  一对多增删改查</span><br><span class="line">  <span class="keyword">async</span> findAll() &#123;</span><br><span class="line">    <span class="comment">// return await this.usersRepository.findAndCount(&#123; relations: ['photos'] &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository</span><br><span class="line">      .createQueryBuilder(<span class="string">'UsersEntity'</span>)</span><br><span class="line">      .leftJoinAndSelect(<span class="string">'UsersEntity.photos'</span>, <span class="string">'PhotoEntity.userinfo'</span>)</span><br><span class="line">      .getManyAndCount();</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  根据主表id查找一对多</span><br><span class="line">  <span class="keyword">async</span> findOne(id: number) &#123;</span><br><span class="line">    查询一个用户有多少张照片（一对多）</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(id, &#123;</span><br><span class="line">      relations: [<span class="string">'photos'</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!result) ToolsService.fail(<span class="string">'用户id不存在'</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    查询这张照片属于谁（多对一）</span><br><span class="line">    <span class="comment">// const result = await this.photoRepository.findOne(id, &#123;</span></span><br><span class="line">    <span class="comment">//   relations: ['userinfo'],</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    <span class="comment">// if (!result) ToolsService.fail('图片id不存在');</span></span><br><span class="line">    <span class="comment">// return result;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  根据主表id创建一对多</span><br><span class="line">  <span class="keyword">async</span> create(id: number, <span class="attr">manager</span>: EntityManager) &#123;</span><br><span class="line">    <span class="keyword">const</span> urlList = [</span><br><span class="line">      &#123;</span><br><span class="line">        url: <span class="string">`http://www.dmyxs.com/images/<span class="subst">$&#123;id&#125;</span>.png`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        url: <span class="string">`http://www.dmyxs.com/images/<span class="subst">$&#123;id&#125;</span>.jpg`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(&#123; id &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户id不存在'</span>);</span><br><span class="line"></span><br><span class="line">遍历传递过来的数据</span><br><span class="line">    <span class="keyword">if</span> (urlList.length !== <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; urlList.length; i++) &#123;</span><br><span class="line">       创建实体的两种方式：<span class="keyword">new</span> 和 create，<span class="keyword">new</span>的方式方便条件判断</span><br><span class="line">       <span class="comment">// const photo = new PhotoEntity();</span></span><br><span class="line">       <span class="comment">// photo.url = urlList[i].url;</span></span><br><span class="line">       <span class="comment">// photo.user = user;</span></span><br><span class="line">       <span class="comment">// await manager.save(PhotoEntity, photo);</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">const</span> photoEntity = <span class="keyword">this</span>.photoRepository.create(&#123;</span><br><span class="line">         url: urlList[i].url,</span><br><span class="line">         userinfo: user,  注意：这里是使用实体建立关系，而不是实体id</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">await</span> manager.save(photoEntity);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'新增成功'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  根据主表id更改一对多</span><br><span class="line">  示例：删除一张，修改一张(修改的有id)，新增一张</span><br><span class="line">  先使用创建，创建两张photo</span><br><span class="line">  <span class="keyword">async</span> update(id: number, <span class="attr">manager</span>: EntityManager) &#123;</span><br><span class="line">    <span class="keyword">const</span> urlList = [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">22</span>,</span><br><span class="line">        url: <span class="string">`http://www.dmyxs.com/images/<span class="subst">$&#123;id&#125;</span>-update.png`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        url: <span class="string">`http://www.dmyxs.com/images/<span class="subst">$&#123;id&#125;</span>-create.jpeg`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(&#123; id &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户id不存在'</span>);</span><br><span class="line">    </span><br><span class="line">    如果要修改主表，先修改主表用户信息，后修改副表图片信息</span><br><span class="line">    修改主表</span><br><span class="line">    <span class="keyword">const</span> userEntity = <span class="keyword">this</span>.usersRepository.create(&#123;</span><br><span class="line">      id,</span><br><span class="line">      username: <span class="string">'admin7'</span>,</span><br><span class="line">      password: <span class="string">'123456'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> manager.save(userEntity);</span><br><span class="line"></span><br><span class="line">    修改副表</span><br><span class="line">    如果前端附带了图片list</span><br><span class="line">    <span class="keyword">if</span> (urlList.length !== <span class="number">0</span>) &#123;</span><br><span class="line">      查询数据库已经有的图片</span><br><span class="line">      <span class="keyword">const</span> databasePhotos = <span class="keyword">await</span> manager.find(PhotoEntity, &#123; <span class="attr">userinfo</span>: user &#125;);</span><br><span class="line">      </span><br><span class="line">      如果有数据，则进行循环判断，先删除多余的数据</span><br><span class="line">      <span class="keyword">if</span> (databasePhotos.length &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; databasePhotos.length; i++) &#123;</span><br><span class="line">        </span><br><span class="line">          以用户传递的图片为基准，数据库的图片id是否在用户传递过来的表里，如果不在，就是要删除的数据</span><br><span class="line">          <span class="keyword">const</span> exist = urlList.find(<span class="function">(<span class="params">item</span>) =&gt;</span> item.id === databasePhotos[i].id);</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">            <span class="keyword">await</span> manager.delete(PhotoEntity, &#123; <span class="attr">id</span>: databasePhotos[i].id &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      否则就是新增和更改的数据</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; urlList.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> photoEntity = <span class="keyword">new</span> PhotoEntity();</span><br><span class="line">        photoEntity.url = urlList[i].url;</span><br><span class="line">        </span><br><span class="line">        如果有id则是修改操作，因为前端传递的数据是从服务端获取的，会附带id，新增的没有</span><br><span class="line">        <span class="keyword">if</span> (!!urlList[i].id) &#123;</span><br><span class="line">        </span><br><span class="line">          修改则让id关联即可</span><br><span class="line">          photoEntity.id = urlList[i].id;</span><br><span class="line">          <span class="keyword">await</span> manager.save(PhotoEntity, photoEntity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">          否则是新增操作,关联用户实体</span><br><span class="line">          photoEntity.userinfo = user;</span><br><span class="line">          <span class="keyword">await</span> manager.save(PhotoEntity, photoEntity);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      如果前端把图片全部删除，删除所有关联的图片</span><br><span class="line">      <span class="keyword">await</span> manager.delete(PhotoEntity, &#123; <span class="attr">userinfo</span>: id &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'更新成功'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  根据主表id删除一对多</span><br><span class="line">  <span class="keyword">async</span> remove(id: number, <span class="attr">manager</span>: EntityManager): <span class="built_in">Promise</span>&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(id);</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户id不存在'</span>);</span><br><span class="line"></span><br><span class="line">    只删副表的关联数据</span><br><span class="line">    <span class="keyword">await</span> manager.delete(PhotoEntity, &#123; <span class="attr">userinfo</span>: id &#125;);</span><br><span class="line">    如果连主表用户一起删，加下面这行代码</span><br><span class="line">    <span class="comment">//await manager.delete(UsersEntity, id);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'删除成功'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="typeorm-多对多关系设计与增删改查"><a href="#typeorm-多对多关系设计与增删改查" class="headerlink" title="typeorm 多对多关系设计与增删改查"></a>typeorm 多对多关系设计与增删改查</h2><blockquote><p>实体如何设计多对多关系？如何增删改查？</p></blockquote><p><strong>多对多关系</strong></p><blockquote><p>定义：多对多是一种 A 包含多个 B，而 B 包含多个 A 的关系<br>如：一个粉丝可以关注多个主播，一个主播可以有多个粉丝<br>如：一篇文章属于多个分类，一个分类下有多篇文章<br>比如这篇文章，可以放在nest目录，也可以放在typeorm目录或者mysql目录</p></blockquote><p><strong>实现方式</strong></p><blockquote><p>第一种：建立两张表，使用装饰器<code>@ManyToMany</code>建立关系，<code>typeorm</code>会自动生成三张表<br>第二种：手动建立3张表</p></blockquote><p>这里使用第一种</p><h3 id="实体设计-1"><a href="#实体设计-1" class="headerlink" title="实体设计"></a><strong>实体设计</strong></h3><p>这里将设计一个用户（粉丝） 与 明星的 多对多关系</p><p>用户（粉丝）可以主动关注明星，让<code>users</code>变为主表，加入<code>@JoinTable()</code></p><blockquote><p>使用<code>@ManyToMany()</code> 来建立多对多关系<br>第一个参数：<code>() =&gt; StarEntity</code>， 和谁建立关系？ 和<code>StarEntity</code>建立关系<br>第二个参数：<code>(star) =&gt; star.photo</code>，和哪个字段联立关系？ <code>star</code>就是<code>StarEntity</code>的别名，可随便写，和<code>PhotoEntity</code>的<code>followers</code>字段建立关系</p></blockquote><p>用户（粉丝）表：follows关注/跟随</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Column,</span><br><span class="line">  Entity,</span><br><span class="line">  PrimaryGeneratedColumn,</span><br><span class="line">  ManyToMany,</span><br><span class="line">  JoinTable,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AvatarEntity &#125; <span class="keyword">from</span> <span class="string">'./avatar.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'users'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line"></span><br><span class="line">  @Column()</span><br><span class="line">  username: string;</span><br><span class="line"></span><br><span class="line">  @Column()</span><br><span class="line">  password: string;</span><br><span class="line"></span><br><span class="line">  @ManyToMany(<span class="function"><span class="params">()</span> =&gt;</span> StarEntity, (star) =&gt; star.followers)</span><br><span class="line">  @JoinTable()</span><br><span class="line">  follows: StarEntity[]; 注意这里是数组类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明星表：followers跟随者</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Entity, PrimaryGeneratedColumn, Column, ManyToMany &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./user.entity'</span>;</span><br><span class="line"></span><br><span class="line">@Entity(&#123; <span class="attr">name</span>: <span class="string">'star'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">StarEntity</span> </span>&#123;</span><br><span class="line">  @PrimaryGeneratedColumn()</span><br><span class="line">  id: number;</span><br><span class="line"></span><br><span class="line">  @Column(&#123; <span class="attr">type</span>: <span class="string">'varchar'</span> &#125;)</span><br><span class="line">  name: string;</span><br><span class="line"></span><br><span class="line">  @ManyToMany(<span class="function"><span class="params">()</span> =&gt;</span> UsersEntity, (user) =&gt; user.follows)</span><br><span class="line">  followers: UsersEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p>程序运行后，将会默认在数据库中生成三张表，users，star，users_follows_star，users_follows_star是中间表，用于记录users和star之间的多对多关系，它是自动生成的。</p></blockquote><p>为了测试方便，你可以在users表和star表创建一些数据：这些属于单表操作<br><img src="https://s.poetries.work/uploads/2022/05/f9afb65f660699e8.png" alt></p><h3 id="多对多增删改查"><a href="#多对多增删改查" class="headerlink" title="多对多增删改查"></a><strong>多对多增删改查</strong></h3><blockquote><p>只要涉及两种表操作的，就需要开启事务：同时失败或同时成功，避免数据不统一<br>注意：所有数据应该是由前端传递过来的，这里为了方便，直接硬编码了（写死）</p></blockquote><p>user.controller.ts</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Controller,</span><br><span class="line">  Get,</span><br><span class="line">  Post,</span><br><span class="line">  Body,</span><br><span class="line">  Patch,</span><br><span class="line">  Query,</span><br><span class="line">  Param,</span><br><span class="line">  Delete,</span><br><span class="line">  HttpCode,</span><br><span class="line">  HttpStatus,</span><br><span class="line">  ParseIntPipe,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Transaction, TransactionManager, EntityManager &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;  开启事务第一步：引入</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service-oto'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'user'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private readonly userService: UserService) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  <span class="keyword">async</span> findAll() &#123;</span><br><span class="line">    <span class="keyword">const</span> [data, count] = <span class="keyword">await</span> <span class="keyword">this</span>.userService.findAll();</span><br><span class="line">    <span class="keyword">return</span> &#123; count, data &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">':id'</span>)</span><br><span class="line">  <span class="keyword">async</span> findOne(@Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.findOne(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Post(<span class="string">':id'</span>)</span><br><span class="line">  @HttpCode(HttpStatus.OK)</span><br><span class="line">  @Transaction() 开启事务第二步：装饰接口</span><br><span class="line">  <span class="keyword">async</span> create(</span><br><span class="line">    @Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number,</span><br><span class="line">    @TransactionManager() maneger: EntityManager,  开启事务第三步：获取事务管理器</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.create(id, maneger);  开启事务第四步：传递给service，使用数据库时调用</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Patch(<span class="string">':id'</span>)</span><br><span class="line">  @Transaction()</span><br><span class="line">  <span class="keyword">async</span> update(</span><br><span class="line">    @Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number,</span><br><span class="line">    @TransactionManager() maneger: EntityManager,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.update(id, maneger);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Delete(<span class="string">':id'</span>)</span><br><span class="line">  @Transaction()</span><br><span class="line">  <span class="keyword">async</span> remove(</span><br><span class="line">    @Param(<span class="string">'id'</span>, <span class="keyword">new</span> ParseIntPipe()) id: number,</span><br><span class="line">    @TransactionManager() maneger: EntityManager,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.userService.remove(id, maneger);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>user.service.ts</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository, EntityManager &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; StarEntity &#125; <span class="keyword">from</span> <span class="string">'./entities/star.entity'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ToolsService &#125; <span class="keyword">from</span> <span class="string">'../../utils/tools.service'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">    @InjectRepository(StarEntity)</span><br><span class="line">    private readonly starRepository: Repository&lt;StarEntity&gt;,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  一对多增删改查</span><br><span class="line">  <span class="keyword">async</span> findAll() &#123;</span><br><span class="line">    <span class="comment">// return await this.usersRepository.findAndCount(&#123; relations: ['follows'] &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository</span><br><span class="line">      .createQueryBuilder(<span class="string">'UsersEntity'</span>)</span><br><span class="line">      .leftJoinAndSelect(<span class="string">'UsersEntity.follows'</span>, <span class="string">'StarEntity.followers'</span>)</span><br><span class="line">      .getManyAndCount();</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  根据主表id查找多对多</span><br><span class="line">  <span class="keyword">async</span> findOne(id: number) &#123;</span><br><span class="line">    查询一个用户关注了哪些明星</span><br><span class="line">    <span class="comment">// const result = await this.usersRepository.findOne(id, &#123;</span></span><br><span class="line">    <span class="comment">//   relations: ['follows'],</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    <span class="comment">// if (!result) ToolsService.fail('用户id不存在');</span></span><br><span class="line">    <span class="comment">// return result;</span></span><br><span class="line"></span><br><span class="line">    查询一个明星有多少粉丝</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.starRepository.findOne(id, &#123;</span><br><span class="line">      relations: [<span class="string">'followers'</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!result) ToolsService.fail(<span class="string">'明星id不存在'</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  根据主表id创建多对多</span><br><span class="line">  粉丝关注明星</span><br><span class="line">  <span class="keyword">async</span> create(id: number, <span class="attr">manager</span>: EntityManager) &#123;</span><br><span class="line">  要关注的明星id数组</span><br><span class="line">    <span class="keyword">const</span> willFollow = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(&#123; id &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户id不存在'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (willFollow.length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> followList = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; willFollow.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> star = <span class="keyword">await</span> manager.findOne(StarEntity, &#123;</span><br><span class="line">          id: willFollow[i],</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (!star) ToolsService.fail(<span class="string">'主播id不存在'</span>);</span><br><span class="line">        followList.push(star);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> userEntity = <span class="keyword">new</span> UsersEntity();</span><br><span class="line">      重点：</span><br><span class="line">      不指定id是创建新的用户，还需要填写username和password等必填的字段</span><br><span class="line">      指定id就是更新某些字段：只关注明星，不创建新的用户，同样可用于修改</span><br><span class="line">      userEntity.id = id; </span><br><span class="line">      userEntity.follows = followList; 建立关联，数据表会自动更新</span><br><span class="line">      <span class="keyword">await</span> manager.save(userEntity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'新增成功'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  根据主表id更改多对多</span><br><span class="line">  假设：某用户关注了id为[<span class="number">3</span>, <span class="number">4</span>]的明星, 现在修改为只关注[<span class="number">2</span>]</span><br><span class="line">  逻辑和创建一样</span><br><span class="line">  <span class="keyword">async</span> update(id: number, <span class="attr">manager</span>: EntityManager) &#123;</span><br><span class="line">    <span class="keyword">const</span> willFollow = [<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(&#123; id &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户id不存在'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (willFollow.length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> followList = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; willFollow.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> listOne = <span class="keyword">await</span> manager.findOne(StarEntity, &#123;</span><br><span class="line">          id: willFollow[i],</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (!listOne) ToolsService.fail(<span class="string">'主播id不存在'</span>);</span><br><span class="line">        followList.push(listOne);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> userEntity = <span class="keyword">new</span> UsersEntity();</span><br><span class="line">      userEntity.id = id;</span><br><span class="line">      userEntity.follows = followList;</span><br><span class="line">      <span class="keyword">await</span> manager.save(userEntity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'更新成功'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  根据主表id删除多对多</span><br><span class="line">  多种删除</span><br><span class="line">  <span class="keyword">async</span> remove(id: number, <span class="attr">manager</span>: EntityManager): <span class="built_in">Promise</span>&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(id, &#123;</span><br><span class="line">      relations: [<span class="string">'follows'</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户id不存在'</span>);</span><br><span class="line"></span><br><span class="line">    根据id删除一个：取消关注某个明星，明星id应由前端传递过来，这里写死</span><br><span class="line">    需要获取当前用户的的follows，使用关系查询</span><br><span class="line">    <span class="keyword">const</span> willDeleteId = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (user.follows.length !== <span class="number">0</span>) &#123;</span><br><span class="line">      过滤掉要删除的数据，再重新赋值</span><br><span class="line">      <span class="keyword">const</span> followList = user.follows.filter(<span class="function">(<span class="params">star</span>) =&gt;</span> star.id != willDeleteId);</span><br><span class="line">      <span class="keyword">const</span> userEntity = <span class="keyword">new</span> UsersEntity();</span><br><span class="line">      userEntity.id = id;</span><br><span class="line">      userEntity.follows = followList;</span><br><span class="line">      <span class="keyword">await</span> manager.save(userEntity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    全部删除关联数据，不删用户</span><br><span class="line">    <span class="comment">// const userEntity = new UsersEntity();</span></span><br><span class="line">    <span class="comment">// userEntity.id = id;</span></span><br><span class="line">    <span class="comment">// userEntity.follows = [];</span></span><br><span class="line">    <span class="comment">// await manager.save(userEntity);</span></span><br><span class="line"></span><br><span class="line">    如果连用户一起删，会将关联数据一起删除</span><br><span class="line">    <span class="comment">// await manager.delete(UsersEntity, id);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'删除成功'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nest连接Redis"><a href="#nest连接Redis" class="headerlink" title="nest连接Redis"></a>nest连接Redis</h2><blockquote><p>Redis 字符串数据类型的相关命令用于管理 redis 字符串值</p></blockquote><ul><li>查看所有的key:  <code>keys *</code></li><li>普通设置： <code>set key value</code></li><li>设置并加过期时间：<code>set key value EX 30</code> 表示30秒后过期</li><li>获取数据： <code>get key</code></li><li>删除指定数据：<code>del key</code></li><li>删除全部数据: <code>flushall</code></li><li>查看类型：<code>type key</code></li><li>设置过期时间: <code>expire key  20</code> 表示指定的<code>key5</code>秒后过期</li></ul><blockquote><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p></blockquote><ul><li>列表右侧增加值：<code>rpush key value</code></li><li>列表左侧增加值：<code>lpush key value</code></li><li>右侧删除值：<code>rpop key</code></li><li>左侧删除值： <code>lpop key</code></li><li>获取数据： <code>lrange key</code></li><li>删除指定数据：<code>del key</code></li><li>删除全部数据: <code>flushall</code></li><li>查看类型： <code>type key</code></li></ul><blockquote><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。它和列表的最主要区别就是没法增加重复值</p></blockquote><ul><li>给集合增数据：<code>sadd key value</code></li><li>删除集合中的一个值：<code>srem key value</code></li><li>获取数据：<code>smembers key</code></li><li>删除指定数据： <code>del key</code></li><li>删除全部数据:  <code>flushall</code></li></ul><blockquote><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p></blockquote><ul><li>设置值hmset ：<code>hmset zhangsan name &quot;张三&quot; age 20  sex “男”</code></li><li>设置值hset ： <code>hset zhangsan name &quot;张三&quot;</code></li><li>获取数据：<code>hgetall key</code></li><li>删除指定数据：<code>del key</code></li><li>删除全部数据:  <code>flushall</code></li></ul><blockquote><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布</span></span><br><span class="line">client.publish(<span class="string">'publish'</span>, <span class="string">'message from publish.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">client.subscribe(<span class="string">'publish'</span>);</span><br><span class="line">client.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">channel, msg</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'client.on message, channel:'</span>, channel, <span class="string">' message:'</span>, msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Nestjs中使用redis</strong></p><blockquote><p>Nestjs Redis 官方文档：<a href="https://github.com/kyknow/nestjs-redis" target="_blank" rel="noopener">https://github.com/kyknow/nestjs-redis</a></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install nestjs-redis --save</span><br></pre></td></tr></table></figure><p>如果是nest8需要注意该问题：<a href="https://github.com/skunight/nestjs-redis/issues/82" target="_blank" rel="noopener">https://github.com/skunight/nestjs-redis/issues/82</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.modules.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; RedisModule &#125; <span class="keyword">from</span> <span class="string">'nestjs-redis'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RedisTestModule &#125; <span class="keyword">from</span> <span class="string">'../examples/redis-test/redis-test.module'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    <span class="comment">// 加载配置文件目录</span></span><br><span class="line">    ConfigModule.load(resolve(__dirname, <span class="string">'config'</span>, <span class="string">'**/!(*.d).&#123;ts,js&#125;'</span>)),</span><br><span class="line">    <span class="comment">// redis连接</span></span><br><span class="line">    RedisModule.forRootAsync(&#123;</span><br><span class="line">      useFactory: <span class="function">(<span class="params">configService: ConfigService</span>) =&gt;</span> configService.get(<span class="string">'redis'</span>),</span><br><span class="line">      inject: [ConfigService],</span><br><span class="line">    &#125;),</span><br><span class="line">    RedisTestModule,</span><br><span class="line">  ],</span><br><span class="line">  controllers: [],</span><br><span class="line">  providers: [ ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> <span class="title">implements</span> <span class="title">NestModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/config/redis.ts 配置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  port: <span class="number">6379</span>,</span><br><span class="line">  db: <span class="number">0</span>,</span><br><span class="line">  password: <span class="string">''</span>,</span><br><span class="line">  keyPrefix: <span class="string">''</span>,</span><br><span class="line">  onClientReady: <span class="function">(<span class="params">client</span>) =&gt;</span> &#123;</span><br><span class="line">    client.on(<span class="string">'error'</span>, (err) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'-----redis error-----'</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>创建一个cache.service.ts 服务 封装操作redis的方法</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/common/cache.service.ts </span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RedisService &#125; <span class="keyword">from</span> <span class="string">'nestjs-redis'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line">  public client;</span><br><span class="line">  <span class="keyword">constructor</span>(private redisService: RedisService) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getClient();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> getClient() &#123;</span><br><span class="line">    <span class="keyword">this</span>.client = <span class="keyword">await</span> <span class="keyword">this</span>.redisService.getClient();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置值的方法</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">set</span>(key: string, value: any, seconds?: number) &#123;</span><br><span class="line">    value = <span class="built_in">JSON</span>.stringify(value);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.client) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.getClient();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!seconds) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.client.set(key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.client.set(key, value, <span class="string">'EX'</span>, seconds);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取值的方法</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">get</span>(key: string) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.client) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.getClient();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="keyword">this</span>.client.get(key);</span><br><span class="line">    <span class="keyword">if</span> (!data) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key删除redis缓存数据</span></span><br><span class="line">  <span class="keyword">async</span> del(key: string): <span class="built_in">Promise</span>&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.client) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.getClient();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.client.del(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空redis的缓存</span></span><br><span class="line">  <span class="keyword">async</span> flushall(): <span class="built_in">Promise</span>&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.client) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.getClient();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.client.flushall();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用redis服务</p></blockquote><p><strong>redis-test.controller</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Body, Controller, Get, Post, Query &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CacheService &#125; <span class="keyword">from</span> <span class="string">'src/common/cache/redis.service'</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">'redis-test'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestController</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注入redis服务</span></span><br><span class="line">  <span class="keyword">constructor</span>(private readonly cacheService: CacheService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">'get'</span>)</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">get</span>(@Query() query) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.cacheService.get(query.key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Post(<span class="string">'set'</span>)</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">set</span>(@Body() body) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; key, ...params &#125; = body <span class="keyword">as</span> any;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.cacheService.set(key, params);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">'del'</span>)</span><br><span class="line">  <span class="keyword">async</span> del(@Query() query) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.cacheService.del(query.key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">'delAll'</span>)</span><br><span class="line">  <span class="keyword">async</span> delAll() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.cacheService.flushall();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>redis-test.module.ts</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RedisTestService &#125; <span class="keyword">from</span> <span class="string">'./redis-test.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RedisTestController &#125; <span class="keyword">from</span> <span class="string">'./redis-test.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CacheService &#125; <span class="keyword">from</span> <span class="string">'src/common/cache/redis.service'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  controllers: [RedisTestController],</span><br><span class="line">  providers: [RedisTestService, CacheService], <span class="comment">// 注入redis服务</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>redis-test.service.ts</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="集成redis实现单点登录"><a href="#集成redis实现单点登录" class="headerlink" title="集成redis实现单点登录"></a>集成redis实现单点登录</h2><p><strong>在要使用的controller或service中使用redis</strong></p><ul><li><p>这里以实现<code>token</code>存储在<code>redis</code>为例子，实现<strong>单点登陆</strong></p></li><li><p>需要在<code>passport</code>的<code>login</code>中，存储<code>token</code>，如果不会<code>passport</code>验证</p></li></ul><p><strong>单点登陆原理</strong></p><blockquote><ul><li><p>一个账户在第一个地方登陆，登陆时，JWT生成token，保存token到redis，同时返回token给前端保存到本地</p></li><li><p>同一账户在第二个地方登陆，登陆时，JWT生成新的token，保存新的token到redis。（token已经改变）<br>此时，第一个地方登陆的账户在请求时，使用的本地token就会和redis里面的新token不一致（注意：都是有效的token）</p></li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; JwtService &#125; <span class="keyword">from</span> <span class="string">'@nestjs/jwt'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository &#125; <span class="keyword">from</span> <span class="string">'typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectRepository &#125; <span class="keyword">from</span> <span class="string">'@nestjs/typeorm'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; compareSync, hashSync &#125; <span class="keyword">from</span> <span class="string">'bcryptjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; UsersEntity &#125; <span class="keyword">from</span> <span class="string">'../user/entities/user.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ToolsService &#125; <span class="keyword">from</span> <span class="string">'../../utils/tools.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateUserDto &#125; <span class="keyword">from</span> <span class="string">'../user/dto/create-user.dto'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CacheService &#125; <span class="keyword">from</span> <span class="string">'../../common/db/redis-ceche.service'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    @InjectRepository(UsersEntity)</span><br><span class="line">    private readonly usersRepository: Repository&lt;UsersEntity&gt;,</span><br><span class="line">    private readonly jwtService: JwtService,</span><br><span class="line">    private readonly redisService: CacheService,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> create(user: CreateUserDto) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = user;</span><br><span class="line">    <span class="keyword">const</span> transformPass = hashSync(password);</span><br><span class="line">    user.password = transformPass;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(&#123; username &#125;);</span><br><span class="line">    <span class="keyword">if</span> (result) ToolsService.fail(<span class="string">'用户名已存在'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.insert(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> validateUser(userinfo): <span class="built_in">Promise</span>&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = userinfo;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.usersRepository.findOne(&#123;</span><br><span class="line">      where: &#123; username &#125;,</span><br><span class="line">      select: [<span class="string">'username'</span>, <span class="string">'password'</span>, <span class="string">'id'</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!user) ToolsService.fail(<span class="string">'用户名或密码不正确'</span>);</span><br><span class="line">    <span class="comment">//使用bcryptjs验证密码</span></span><br><span class="line">    <span class="keyword">if</span> (!compareSync(password, user.password)) &#123;</span><br><span class="line">      ToolsService.fail(<span class="string">'用户名或密码不正确'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> login(user: any): <span class="built_in">Promise</span>&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id, username &#125; = user;</span><br><span class="line">    <span class="keyword">const</span> payload = &#123; id, username &#125;;</span><br><span class="line">    <span class="keyword">const</span> access_token = <span class="keyword">this</span>.jwtService.sign(payload);</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.redisService.set(<span class="string">`user-token-<span class="subst">$&#123;id&#125;</span>`</span>, access_token, <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);  在这里使用redis</span><br><span class="line">    <span class="keyword">return</span> access_token;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/uploads/2022/05/f134cb6419f34607.png" alt></p><p><strong>验证token</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Strategy, ExtractJwt, StrategyOptions &#125; <span class="keyword">from</span> <span class="string">'passport-jwt'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PassportStrategy &#125; <span class="keyword">from</span> <span class="string">'@nestjs/passport'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; jwtConstants &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CacheService &#125; <span class="keyword">from</span> <span class="string">'../../common/db/redis-ceche.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Request &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ToolsService &#125; <span class="keyword">from</span> <span class="string">'../../utils/tools.service'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtStrategy</span> <span class="keyword">extends</span> <span class="title">PassportStrategy</span>(<span class="title">Strategy</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private redisService: CacheService) &#123;</span><br><span class="line">    <span class="keyword">super</span>(&#123;</span><br><span class="line">      jwtFromRequest: ExtractJwt.fromHeader(<span class="string">'token'</span>), <span class="comment">//使用ExtractJwt.fromHeader从header获取token</span></span><br><span class="line">      ignoreExpiration: <span class="literal">false</span>, <span class="comment">//如果为true，则不验证令牌的过期时间。</span></span><br><span class="line">      secretOrKey: jwtConstants.secret, <span class="comment">//使用密钥解析，可以使用process.env.xxx</span></span><br><span class="line">      passReqToCallback: <span class="literal">true</span>,</span><br><span class="line">    &#125; <span class="keyword">as</span> StrategyOptions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//token验证, payload是super中已经解析好的token信息</span></span><br><span class="line">  <span class="keyword">async</span> validate(req: Request, <span class="attr">payload</span>: any) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'payload'</span>, payload);</span><br><span class="line">    <span class="keyword">const</span> &#123; id &#125; = payload;</span><br><span class="line">    <span class="keyword">const</span> token = ExtractJwt.fromHeader(<span class="string">'token'</span>)(req);</span><br><span class="line">    <span class="keyword">const</span> cacheToken = <span class="keyword">await</span> <span class="keyword">this</span>.redisService.get(<span class="string">`user-token-<span class="subst">$&#123;id&#125;</span>`</span>);  获取redis的key</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单点登陆验证</span></span><br><span class="line">    <span class="keyword">if</span> (token !== <span class="built_in">JSON</span>.parse(cacheToken)) &#123;</span><br><span class="line">      ToolsService.fail(<span class="string">'您账户已经在另一处登陆，请重新登陆'</span>, <span class="number">401</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">username</span>: payload.username &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><h3 id="Q：nestJS注入其他依赖时为什么还需要导入其module"><a href="#Q：nestJS注入其他依赖时为什么还需要导入其module" class="headerlink" title="Q：nestJS注入其他依赖时为什么还需要导入其module"></a>Q：nestJS注入其他依赖时为什么还需要导入其module</h3><blockquote><p>A模块的Service需要调用B模块的service中一个方法，则需要在A的Service导入B的service<br>场景如下：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.Service</span></span><br><span class="line"><span class="keyword">import</span> &#123; BService &#125; <span class="keyword">from</span> <span class="string">'../B/B.service'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    private readonly _BService: BService,</span><br><span class="line">  ) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的理解</p><ul><li>在此处@Injectable装饰器已经将B的Service类实例化了，</li><li>已经可以使用B的类方法了。</li><li>但为什么还需要在A的module.ts中导入B模块呢？像是这样:</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; BModule &#125; <span class="keyword">from</span> <span class="string">'../B/B.module'</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [BModule],</span><br><span class="line">  controllers: [AController],</span><br><span class="line">  providers: [AService],</span><br><span class="line">  exports: [AService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>A</strong></p><p>为啥”为什么还需要在A的module.ts中导入B模块呢”？</p><p>因为 <code>BService</code>的作用域只在 <code>BModule</code>里，所以你要在 <code>AController</code>里直接用，就会报错拿不到实例。</p><p>再来说，”有什么办法可以让 <code>BService</code>随处直接用么？”，参考如下手段：</p><p>B 的module 声明时，加上<code>@Global</code>，如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, Global &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BService &#125; <span class="keyword">from</span> <span class="string">'./B.service'</span>;</span><br><span class="line"></span><br><span class="line">@Global()</span><br><span class="line">@Module(&#123;</span><br><span class="line">  providers: [BService],</span><br><span class="line">  exports: [BService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">BModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样，你就不用在 <code>AModule</code>的声明里引入 <code>BModule</code>了。</p><p>关于『你的理解』部分，貌似你把<code>@Inject</code> 和 <code>@Injectable</code> 搞混了，建议再读一读这个部分的文档，多做些练习/尝试，自己感受下每个api的特点。</p><p>最后，官网文档里其实有介绍 ，看<code>依赖注入</code>:<a href="https://docs.nestjs.com/modules#dependency-injection" target="_blank" rel="noopener">https://docs.nestjs.com/modules#dependency-injection</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Nest (NestJS) 是一个用于构建高效、可扩展的 Node.js 服务器端应用程序的开发框架。它利用 JavaScript 的渐进增强的能力，使用并完全支持 TypeScript （仍然允许开发者使用纯 JavaScript 进行开发），并
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="Node" scheme="http://blog.poetries.top/tags/Node/"/>
    
      <category term="Nest" scheme="http://blog.poetries.top/tags/Nest/"/>
    
  </entry>
  
  <entry>
    <title>一次node文件操作过多排查过程总结</title>
    <link href="http://blog.poetries.top/2022/02/16/node-fs-youhua/"/>
    <id>http://blog.poetries.top/2022/02/16/node-fs-youhua/</id>
    <published>2022-02-16T07:55:24.000Z</published>
    <updated>2025-03-30T13:54:29.490Z</updated>
    
    <content type="html"><![CDATA[<p>最近在优化公司内部的脚手架，遇到一个问题，<code>Error: EMFILE, too many open files</code>也就是nodejs打开文件过多会导致错误，一次次排查，最后找到了一个有效的方法，总结记录一下</p><p>当我尝试去操作大量文件的时候</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">200000</span>; i++) &#123;</span><br><span class="line">    fq.readFile(<span class="string">'./somefile.txt'</span>, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, somefile</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"data from somefile.txt without crashing!"</span>, somefile);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上导致<code>Error: EMFILE: too many open files</code>错误。我不必关闭文件，因为显然可以<code>fs.readFile</code>对文件进行操作并为我关闭文件。我在<code>Mac OS</code>上，我的<code>ulimit</code>设置为<code>8192</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ulimit -a</span><br><span class="line">-t: cpu time (seconds)              unlimited</span><br><span class="line">-f: file size (blocks)              unlimited</span><br><span class="line">-d: data seg size (kbytes)          unlimited</span><br><span class="line">-s: stack size (kbytes)             8192</span><br><span class="line">-c: core file size (blocks)         0</span><br><span class="line">-v: address space (kbytes)          unlimited</span><br><span class="line">-l: locked-in-memory size (kbytes)  unlimited</span><br><span class="line">-u: processes                       1392</span><br><span class="line">-n: file descriptors                256</span><br></pre></td></tr></table></figure><p><img src="https://blog.poetries.top/img/static/images/202202161407524.png" alt></p><p>可以通过修改系统配置，但是不太推荐</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo kern.maxfiles=65536 | sudo tee -a /etc/sysctl.conf</span><br><span class="line">$ echo kern.maxfilesperproc=65536 | sudo tee -a /etc/sysctl.conf</span><br><span class="line">$ sudo sysctl -w kern.maxfiles=65536</span><br><span class="line">$ sudo sysctl -w kern.maxfilesperproc=65536</span><br><span class="line">$ ulimit -n 65536</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于<code>node.js</code>的异步特性，因此会发生此错误。进程试图打开的文件超出允许的数量，因此会产生错误。</li><li>可以通过创建打开<code>文件队列</code>来解决此问题，<code>以使它们永远不会超过限制</code>，以下是一些可以为您完成此操作的库：</li></ul></blockquote><p>我们可以使用文件队列来限制每次打开的文件数量</p><blockquote><p>Instantiate Filequeue with a maximum number of files to be opened at once (default is 200)</p></blockquote><p><strong>how to use</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> FileQueue = <span class="built_in">require</span>(<span class="string">'filequeue'</span>);</span><br><span class="line"><span class="keyword">var</span> fq = <span class="keyword">new</span> FileQueue(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// additional instances will attempt to use the same instance (and therefore the same maxfiles)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FileQueue2 = <span class="built_in">require</span>(<span class="string">'filequeue'</span>);</span><br><span class="line"><span class="keyword">var</span> fq2 = <span class="keyword">new</span> FileQueue2(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fq === fq2); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// you can force a new instance of filequeue with the `newQueue` parameter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fq3 = <span class="keyword">new</span> FileQueue(<span class="number">100</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fq === fq3); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p><strong>filequeue支持以下方法</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">readFile</span><br><span class="line">writeFile</span><br><span class="line">readdir</span><br><span class="line">rename</span><br><span class="line">symlink</span><br><span class="line">mkdir</span><br><span class="line">stat</span><br><span class="line">exists</span><br><span class="line">createReadStream</span><br><span class="line">createWriteStream</span><br></pre></td></tr></table></figure><p>使用<code>filequeue</code>就可以正常运行了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> FileQueue = <span class="built_in">require</span>(<span class="string">'filequeue'</span>);</span><br><span class="line"><span class="keyword">var</span> fq = <span class="keyword">new</span> FileQueue(<span class="number">100</span>); <span class="comment">// 限制每次打开的文件数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">200000</span>; i++) &#123;</span><br><span class="line">    fq.readFile(<span class="string">'./demo.txt'</span>, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, somefile</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"data from somefile.txt without crashing!"</span>, somefile);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在优化公司内部的脚手架，遇到一个问题，&lt;code&gt;Error: EMFILE, too many open files&lt;/code&gt;也就是nodejs打开文件过多会导致错误，一次次排查，最后找到了一个有效的方法，总结记录一下&lt;/p&gt;
&lt;p&gt;当我尝试去操作大量文件的时候&lt;
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="Node" scheme="http://blog.poetries.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>教你如何使用vercel服务免费部署前端项目和serverless api</title>
    <link href="http://blog.poetries.top/2022/01/04/vercel-deploy-project/"/>
    <id>http://blog.poetries.top/2022/01/04/vercel-deploy-project/</id>
    <published>2022-01-04T10:21:43.000Z</published>
    <updated>2025-03-30T13:54:29.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍一下vercel"><a href="#一、介绍一下vercel" class="headerlink" title="一、介绍一下vercel"></a>一、介绍一下vercel</h2><blockquote><p><code>vercel</code> 是一个站点托管平台，提供CDN加速，同类的平台有<code>Netlify</code> 和 <code>Github Pages</code>，相比之下，<code>vercel</code> 国内的访问速度更快，并且提供<code>Production</code>环境和<code>development</code>环境，对于项目开发非常的有用的，并且支持持续集成，一次<code>push</code>或者一次<code>PR</code>会自动化构建发布，发布在<code>development</code>环境，都会生成不一样的链接可供预览。</p></blockquote><p>但是<code>vercel</code>只是针对个人用户免费，<code>teams</code>是收费的</p><blockquote><p>首先<code>vercel</code>零配置部署，第二访问速度比<code>github-page</code>好很多，并且构建很快，还是免费使用的，对于部署个人前端项目路、接口服务非常方便</p></blockquote><ul><li><code>vercel</code>类似于<code>github page</code>，但远比<code>github page</code>强大，速度也快得多得多，而且<code>将Github授权给vercel</code>后，可以达到最优雅的发布体验，只需将代码轻轻一推，项目就自动更新部署了。</li><li><code>vercel</code>还支持部署<code>serverless接口</code>。那代表着，其不仅仅可以部署静态网站，甚至可以部署动态网站，而这些功能，统统都是免费的</li><li><code>vercel</code>还支持自动配置<code>https</code>，不用自己去<code>FreeSSL</code>申请证书，更是省去了一大堆证书的配置</li><li><code>vercel</code>目前的部署模板有31种之多</li></ul><p><img src="https://blog.poetries.top/img/static/images/20220104154330.png" alt="vercel template"></p><h2 id="二、起步"><a href="#二、起步" class="headerlink" title="二、起步"></a>二、起步</h2><p>打开<code>vercel</code>主页<code>https://vercel.com/signup</code></p><p><img src="https://blog.poetries.top/img/static/images/20220104154552.png" alt="vercel主页"></p><p>使用<code>GitHub</code>账号去关联<code>vercel</code>，后续代码提交到<code>vercel</code>可以自动触发部署</p><p><img src="https://blog.poetries.top/img/static/images/20220104154810.png" alt="GitHub授权给vercel"></p><p>出现授权页面，点击<code>Authorize Vercel</code>。</p><h2 id="三、部署Hexo博客"><a href="#三、部署Hexo博客" class="headerlink" title="三、部署Hexo博客"></a>三、部署Hexo博客</h2><blockquote><p>vercel是最好用的静态站点托管平台，借助vercel平台，我们可以把博客静态文件部署到vercel上，不在使用GitHub pages托管，vercel比GitHub pages快多了。</p></blockquote><p>选择一个vercel提供的模板部署，当然你也可以把代码提交到GitHub上，再去vercel选择即可</p><p><img src="https://blog.poetries.top/img/static/images/20220104160617.png" alt></p><p>创建一个GitHub项目，代码会自动在GitHub账号上创建</p><p><img src="https://blog.poetries.top/img/static/images/20220104160823.png" alt></p><p>创建完成后，等待vercel构建</p><p><img src="https://blog.poetries.top/img/static/images/20220104160941.png" alt></p><p>创建成功后自动跳到主页</p><p><img src="https://blog.poetries.top/img/static/images/20220104161004.png" alt><br><img src="https://blog.poetries.top/img/static/images/20220104161135.png" alt></p><p>点击visit即可访问创建好的服务 <a href="https://hexo-seven-blush.vercel.app" target="_blank" rel="noopener">https://hexo-seven-blush.vercel.app</a> ，vercel会分配给我们一个默认的域名，当然你也可以自定义修改。</p><p><img src="https://blog.poetries.top/img/static/images/20220104161311.png" alt></p><p>我们可以查看打包日志，如果构建过程出现问题，在这里看即可</p><p><img src="https://blog.poetries.top/img/static/images/20220104161400.png" alt></p><blockquote><p>点击<code>view domain</code> 绑定自定义域名</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20220104161653.png" alt></p><p>然后我们去域名解析处理解析<code>CNAME</code>到<code>cname.vercel-dns.com</code></p><p><img src="https://blog.poetries.top/img/static/images/20220104162009.png" alt></p><blockquote><p>最后解析完成，访问<code>hexo.poetries.com</code>自定义域名即可。到此我们把博客hexo项目部署到vercel上，后期当你在GitHub提交代码会自动触发vercel打包构建</p></blockquote><p>你也可以从Github选择代码来创建项目</p><p><img src="https://blog.poetries.top/img/static/images/20220104162313.png" alt></p><p>导入GitHub账号上的项目</p><p><img src="https://blog.poetries.top/img/static/images/20220104162344.png" alt><br><img src="https://blog.poetries.top/img/static/images/20220104162448.png" alt></p><p>部署vue、react等前端项目过程也类似，这里不再演示</p><h2 id="四、部署Serverless-Api"><a href="#四、部署Serverless-Api" class="headerlink" title="四、部署Serverless Api"></a>四、部署Serverless Api</h2><blockquote><p>用<code>vercel</code>部署<code>Serverless Api</code>，不购买云服务器也能拥有自己的动态网站</p></blockquote><p>简单演示部署api接口服务</p><p><img src="https://blog.poetries.top/img/static/images/20220104163025.png" alt></p><p>配置<code>vercel.json</code>，更多配置在vercel官网查 <code>https://vercel.com/docs</code></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"headers"</span>: [&#123;</span><br><span class="line">    <span class="attr">"source"</span>: <span class="string">"/(.*)"</span>,</span><br><span class="line">    <span class="attr">"headers"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"key"</span> : <span class="string">"Access-Control-Allow-Origin"</span>,</span><br><span class="line">        <span class="attr">"value"</span> : <span class="string">"*"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"key"</span> : <span class="string">"Access-Control-Allow-Headers"</span>,</span><br><span class="line">        <span class="attr">"value"</span> : <span class="string">"content-type"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"key"</span> : <span class="string">"Access-Control-Allow-Methods"</span>,</span><br><span class="line">        <span class="attr">"value"</span> : <span class="string">"DELETE,PUT,POST,GET,OPTIONS"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">"rewrites"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      "source": "/", // 重定向配置 访问/根路径重定向到/api/query-all-users</span><br><span class="line">      "destination": "/api/query-all-users"</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建接口，<code>vercel约定在api下创建接口路径</code>，最后我们可以通过<code>域名/api/json</code> <code>域名/api/query-all-users</code>来访问接口服务，我们这里创建了两个接口</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// api/json.js</span></span><br><span class="line"><span class="comment">// req接收所有请求信息，res 是响应信息</span></span><br><span class="line"><span class="comment">// 通过module.exports暴露出去</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们这里使用腾讯云数据库，把一些数据存到云数据库上</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils/db.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作云数据库的包</span></span><br><span class="line"><span class="keyword">const</span> cloudbase = <span class="built_in">require</span>(<span class="string">'@cloudbase/node-sdk'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">  env: <span class="string">"填入环境ID"</span>, <span class="comment">// 在腾讯云后台创建环境ID</span></span><br><span class="line">  <span class="comment">// 访问该链接获取secretId、secretKey填入即可 https://console.cloud.tencent.com/cam/capi</span></span><br><span class="line">  secretId: <span class="string">""</span>,</span><br><span class="line">  secretKey: <span class="string">""</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取数据库引用</span></span><br><span class="line"><span class="built_in">module</span>.exports = app.database();</span><br></pre></td></tr></table></figure><blockquote><p>访问该链接获取secretId、secretKey填入即可 <a href="https://console.cloud.tencent.com/cam/capi" target="_blank" rel="noopener">https://console.cloud.tencent.com/cam/capi</a></p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20220104175640.png" alt></p><blockquote><p>来到腾讯云控制台，创建环境获取环境ID</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20220104175831.png" alt></p><p>选择<code>数据库-创建新的集合users</code></p><p><img src="https://blog.poetries.top/img/static/images/20220104175945.png" alt></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// api/query-all-users.js</span></span><br><span class="line"><span class="comment">// 查询腾讯云数据库用户记录</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'../utils/db'</span>)</span><br><span class="line"><span class="keyword">const</span> _ = db.command</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (req, response) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;name, pwd, size = <span class="number">50</span>&#125; = req.query</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 更多语法查看腾讯云数据库文档即可 https://cloud.tencent.com/document/product/876/46897</span></span><br><span class="line">  <span class="keyword">let</span> &#123; total &#125; = <span class="keyword">await</span> db.collection(<span class="string">"users"</span>).count()</span><br><span class="line">  <span class="keyword">let</span> pickField = &#123;</span><br><span class="line">    <span class="string">'_id'</span>: <span class="literal">false</span>,</span><br><span class="line">    createAt: <span class="literal">true</span>,</span><br><span class="line">    userName: <span class="literal">true</span>,</span><br><span class="line">    address: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> &#123; data &#125; = <span class="keyword">await</span> db.collection(<span class="string">"users"</span>)</span><br><span class="line">  .field(pickField)</span><br><span class="line">  .orderBy(<span class="string">'createAt'</span>, <span class="string">'desc'</span>)</span><br><span class="line">  .limit(<span class="built_in">parseInt</span>(size))</span><br><span class="line">  .get()</span><br><span class="line"></span><br><span class="line">  response.json(&#123;</span><br><span class="line">    total,</span><br><span class="line">    count: data.length,</span><br><span class="line">    list: data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样我们就写好了两个接口服务，提交代码到GitHub上，然后在vercel上创建项目导入GitHub上的代码部署即可，最后部署的服务通过<code>https://域名/api/query-all-users?name=小月&amp;size=100</code>访问即可</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、介绍一下vercel&quot;&gt;&lt;a href=&quot;#一、介绍一下vercel&quot; class=&quot;headerlink&quot; title=&quot;一、介绍一下vercel&quot;&gt;&lt;/a&gt;一、介绍一下vercel&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;vercel&lt;/cod
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="部署" scheme="http://blog.poetries.top/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="vercel" scheme="http://blog.poetries.top/tags/vercel/"/>
    
  </entry>
  
  <entry>
    <title>教你使用shadowsocks+justmysocks5搭建一个高效稳定的翻墙服务</title>
    <link href="http://blog.poetries.top/2022/01/04/shadowsocks+justmysocks5/"/>
    <id>http://blog.poetries.top/2022/01/04/shadowsocks+justmysocks5/</id>
    <published>2022-01-04T05:50:32.000Z</published>
    <updated>2025-03-30T13:54:29.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、名词简介"><a href="#一、名词简介" class="headerlink" title="一、名词简介"></a>一、名词简介</h1><h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><blockquote><p>VPN英文全称：<code>Virtual Private Network</code>（虚拟专用网络）。<code>VPN</code>被定义为通过一个公用互联网络建立一个临时的、安全的连接，是一条穿过混乱的公用网络的安全、稳定隧道，使用这条隧道可以对数据进行几倍加密达到安全使用互联网的目的</p></blockquote><blockquote><p>具体的实现方式包括<code>PPTP</code>,<code>L2TP</code>,<code>IPsec</code>和<code>openvpn</code>。<code>vpn</code>是一种加密通讯技术，目的是保证数据传输完全和网络匿名。</p></blockquote><h2 id="Proxy（代理）"><a href="#Proxy（代理）" class="headerlink" title="Proxy（代理）"></a>Proxy（代理）</h2><ul><li>反向代理：反向代理的主要作用为服务器做缓存和负载均衡。反向代理的负载均衡是指在多个真正的服务器之前架设一个代理服务器，用户所有的数据都发给代理服务器，代理服务器根据每一个真实服务器的状态将数据转发给一个流量比较少的服务器处理，用户也只需要记住一个域名或IP就可以了。</li><li>正向代理：正向代理主要有<code>HTTP</code>、<code>HTTP over TLS(HTTPS)</code>、<code>Socks</code>、<code>Socks over TLS</code>几种。</li></ul><h2 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h2><ul><li>VPS就是<code>Virtual Private Server</code>，又叫虚似专用服务器。它就相当于是一种技术，可以将一部服务器分割成多个虚似专享服务器。这种技术可以为大家提供优质服务，每一个VPS都可以分派独立公网IP地址、独立操作系统、独立超大空间、独立运行内存、独立CPU资源、独立执行程序和独立系统配置等，可以从根本上防止关联</li><li>VPS（虚拟专用服务器）是由VPS提供商维护，不是一台独立的电脑，而是将一台巨型服务器通过虚拟化技术分割成若干个看似独立的服务器。（ISP运营商面向普通网民提供的是动态ip，绑定域名很不方便，再加上宽带上网上下行网速不对等、网络稳定性不高等问题，大部分人还是选择使用vps建站）。</li><li><code>vps可以用来搭建网站</code>，同时也可以成为VPN服务器，代理服务器。</li></ul><h2 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h2><p><code>shadowsocks</code>同样是一种代理协议。相对于VPN有极强的隐匿性，相对于HTTP代理有较为完善的加密方案，相较于HTTPS配置简单。</p><h1 id="二、如何使用Shadowsocks代理"><a href="#二、如何使用Shadowsocks代理" class="headerlink" title="二、如何使用Shadowsocks代理"></a>二、如何使用Shadowsocks代理</h1><blockquote><p><code>Shadowsocks</code>作为一个翻墙利器自然不仅仅局限于Windows电脑端，还可以用于<code>iOS</code>, <code>Android</code>以<code>Mac</code>上</p></blockquote><h2 id="各平台客户端下载地址"><a href="#各平台客户端下载地址" class="headerlink" title="各平台客户端下载地址"></a>各平台客户端下载地址</h2><ul><li>Android客户端(<a href="https://github.com/shadowsocks/shadowsocks-android/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-android/releases</a>) </li><li>iOS客户端(搜索<code>wingy</code>)</li><li>Windows客户端(<a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-windows/releases</a>)   </li><li>MAC客户端(<a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/ShadowsocksX-NG/releases</a>)</li></ul><p><strong>配置描述:</strong></p><p><img src="https://blog.poetries.top/img/static/images/20220104123619.png" alt></p><ul><li><code>自动代理模式</code>：表示连接国内不通过vpn，可加快访问速度</li><li><code>全局模式</code>：所有连接都通过vpn</li><li><code>服务器</code>：vpn的服务器配置<ul><li>打开服务器设置</li><li>加密方式为: <code>aes-256-cfb</code>，地址和密码</li></ul></li><li>选择服务器，打开小飞机。即可翻墙了。</li></ul><h2 id="搭建服务端代理"><a href="#搭建服务端代理" class="headerlink" title="搭建服务端代理"></a>搭建服务端代理</h2><p>服务端一键安装脚本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-go.sh https://raw.githubusercontent.com/poetries/shadowsocks_install/master/shadowsocks-go.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks-go.sh</span><br><span class="line">./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log</span><br></pre></td></tr></table></figure><p>安装完成后，脚本提示如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Congratulations, Shadowsocks-go install completed!</span><br><span class="line">Your Server IP:your_server_ip</span><br><span class="line">Your Server Port:your_server_port</span><br><span class="line">Your Password:your_password</span><br><span class="line">Your Local Port:1080</span><br><span class="line">Your Encryption Method:aes-256-cfb</span><br><span class="line"></span><br><span class="line">Welcome to visit:https://teddysun.com/392.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure><p>卸载方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./shadowsocks-go.sh uninstall</span><br></pre></td></tr></table></figure><blockquote><p>可以查看 <code>Shadowsocks-go</code> 进程是否已经启动。 本脚本安装完成后，已将 <code>shadowsocks-go</code> 加入开机自启动。</p></blockquote><p>使用命令：</p><ul><li>启动：<code>/etc/init.d/shadowsocks start</code></li><li>停止：<code>/etc/init.d/shadowsocks stop</code></li><li>重启：<code>/etc/init.d/shadowsocks restart</code></li><li>状态：<code>/etc/init.d/shadowsocks status</code></li></ul><p>多用户多端口配置文件示例： 配置文件路径：<code>/etc/shadowsocks/config.json</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;port_password&quot;:&#123;</span><br><span class="line">         &quot;8989&quot;:&quot;password0&quot;,</span><br><span class="line">         &quot;9001&quot;:&quot;password1&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;timeout&quot;:600</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用第三方服务"><a href="#使用第三方服务" class="headerlink" title="使用第三方服务"></a>使用第三方服务</h2><blockquote><p>自己搭建的会有被封ip的风险。推荐使用<code>justmysocks5</code>(<a href="https://justmysocks5.net/members/cart.php)去代理，这些一个月一个月续费就好，不要一次性买几个月。因为不知道是不是用一段时间就费封了。不推荐使用蓝灯，蓝灯不稳定，容易被封杀。现在国内的防火墙封杀蓝灯一抓一个准，只要是国内有两会、或者其他敏感政治事件。基本上都会被封杀。" target="_blank" rel="noopener">https://justmysocks5.net/members/cart.php)去代理，这些一个月一个月续费就好，不要一次性买几个月。因为不知道是不是用一段时间就费封了。不推荐使用蓝灯，蓝灯不稳定，容易被封杀。现在国内的防火墙封杀蓝灯一抓一个准，只要是国内有两会、或者其他敏感政治事件。基本上都会被封杀。</a></p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20220104130036.png" alt><br><img src="https://blog.poetries.top/img/static/images/20220104130233.png" alt></p><p>购买后填入地址、端口、密码即可</p><p><img src="https://blog.poetries.top/img/static/images/20220104124637.png" alt><br><img src="https://blog.poetries.top/img/static/images/20220104124612.png" alt></p><blockquote><p>我是程序员小月，专注分享前端领域编程经验和技术干货，更多干货在公 号：前端进阶之旅</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、名词简介&quot;&gt;&lt;a href=&quot;#一、名词简介&quot; class=&quot;headerlink&quot; title=&quot;一、名词简介&quot;&gt;&lt;/a&gt;一、名词简介&lt;/h1&gt;&lt;h2 id=&quot;VPN&quot;&gt;&lt;a href=&quot;#VPN&quot; class=&quot;headerlink&quot; title=&quot;VPN
      
    
    </summary>
    
      <category term="Tools" scheme="http://blog.poetries.top/categories/Tools/"/>
    
    
      <category term="VPN" scheme="http://blog.poetries.top/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>Git开发流程分支管理方案</title>
    <link href="http://blog.poetries.top/2021/11/26/git-flow-summary/"/>
    <id>http://blog.poetries.top/2021/11/26/git-flow-summary/</id>
    <published>2021-11-26T08:16:12.000Z</published>
    <updated>2025-03-30T13:54:29.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、主分支Master"><a href="#一、主分支Master" class="headerlink" title="一、主分支Master"></a>一、主分支Master</h1><p>代码库应该有一个、且仅有一个主分支：<strong>master</strong>。所有提供给用户使用的正式版本，都在这个主分支上发布。</p><p>每次发布 打一个<code>tag</code>，例如<code>tag v1.0.0、tag v2.0.0</code></p><p><img src="https://blog.poetries.top/img/static/images/20211126173718.png" alt></p><h1 id="二、开发分支Develop"><a href="#二、开发分支Develop" class="headerlink" title="二、开发分支Develop"></a>二、开发分支Develop</h1><p><strong>主分支</strong>只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做<strong>develop</strong>。</p><p>这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在<strong>master</strong>分支上，对<strong>develop</strong>分支进行”合并”（<em>merge</em>）。</p><blockquote><p>Git创建Develop分支的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> git checkout -b develop master </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>将Develop分支发布到Master分支的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 切换到Master分支</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　git checkout master</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 对Develop分支进行合并</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　git merge --no-ff develop</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>==这里稍微解释一下，上一条命令的<code>--no-ff</code>参数是什么意思。默认情况下，Git执行”快进式合并”（<code>fast-farward merge</code>），会直接将Master分支指向Develop分支。==</p><p>使用<code>--no-ff</code>参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20211126173805.png" alt></p><h1 id="三、临时性分支"><a href="#三、临时性分支" class="headerlink" title="三、临时性分支"></a>三、临时性分支</h1><p>版本库的两条主要分支：<strong>master</strong>和d<strong>evelop</strong>。前者用于正式发布，后者用于日常开发。</p><p>其实，常设分支只需要这两条就够了，不需要其他了。</p><p>但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：</p><ul><li>`功能（<strong>feature</strong>）分支</li><li>预发布（<strong>release</strong>）分支</li><li>修补bug（<strong>fixbug</strong>）分支</li></ul><p>这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。</p><p>==接下来，一个个来看这三种”临时性分支”。==</p><h2 id="3-1-功能分支-feature"><a href="#3-1-功能分支-feature" class="headerlink" title="3.1 功能分支-feature"></a>3.1 功能分支-feature</h2><p><strong>功能分支</strong>，它是为了开发某种特定功能，从<em>Develop</em>分支上面分出来的。开发完成后，要再并入Develop。</p><blockquote><p>功能分支的名字，可以采用<strong>feature-*</strong>的形式命名。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 创建一个功能分支：</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　git checkout -b feature-开发一个新功能 develop</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 开发完成后，将功能分支合并到develop分支：</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　git checkout develop</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　git merge --no-ff feature-开发一个新功能</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 删除feature分支：</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　git branch -d feature-开发一个新功能</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="3-2-预发布分支-release"><a href="#3-2-预发布分支-release" class="headerlink" title="3.2 预发布分支-release"></a>3.2 预发布分支-release</h2><p><strong>预发布分支</strong>，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。</p><blockquote><p><code>预发布分支是从Develop分支上面分出来的</code>，预发布结束以后，必须==<code>合并进Develop和Master分支</code>==。它的命名，可以采用<strong>release-*</strong>的形式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 创建一个预发布分支：</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git checkout -b release-1.2.0 develop</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 确认没有问题后，合并到master分支：</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git merge --no-ff release-1.2.0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 对合并生成的新节点，做一个标签</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git tag -a 1.2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 再合并到develop分支：</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git checkout develop</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git merge --no-ff release-1.2.0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 最后，删除预发布分支：</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git branch -d release-1.2.0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="3-3-修补bug分支-fixbug"><a href="#3-3-修补bug分支-fixbug" class="headerlink" title="3.3 修补bug分支-fixbug"></a>3.3 修补bug分支-fixbug</h2><p>最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。</p><blockquote><p>修补bug分支是==<code>从Master分支上面分出来的</code>==。修补结束以后，再==<code>合并进Master和Develop分支</code>==。它的命名，可以采用<strong>fixbug-*</strong>的形式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 创建一个修补bug分支：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　　git checkout -b fixbug-0.1 master</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 修补结束后，合并到master分支：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　　git checkout master</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　　git merge --no-ff fixbug-0.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　　git tag -a 0.1.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 再合并到develop分支：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　　git checkout develop</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　　git merge --no-ff fixbug-0.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 最后，删除<span class="string">"修补bug分支"</span>：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 　　git branch -d fixbug-0.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、主分支Master&quot;&gt;&lt;a href=&quot;#一、主分支Master&quot; class=&quot;headerlink&quot; title=&quot;一、主分支Master&quot;&gt;&lt;/a&gt;一、主分支Master&lt;/h1&gt;&lt;p&gt;代码库应该有一个、且仅有一个主分支：&lt;strong&gt;master&lt;/
      
    
    </summary>
    
      <category term="VCS" scheme="http://blog.poetries.top/categories/VCS/"/>
    
    
      <category term="Git" scheme="http://blog.poetries.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins部署微前端方案实践总结</title>
    <link href="http://blog.poetries.top/2021/11/17/micro-fe-deploy-summary/"/>
    <id>http://blog.poetries.top/2021/11/17/micro-fe-deploy-summary/</id>
    <published>2021-11-17T02:35:08.000Z</published>
    <updated>2025-03-30T13:54:29.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h1><p>集成工具 jenkins 的基本介绍和自动化部署微前端项目的几个简单方案</p><h2 id="一、Jenkins-基础介绍"><a href="#一、Jenkins-基础介绍" class="headerlink" title="一、Jenkins 基础介绍"></a>一、Jenkins 基础介绍</h2><p>Jenkins 是国际上流行的免费开源软件项目,是基于 Java 开发持续集成工具,用于监控持续重复的工作,旨在提供一个开放的易用的软件平台,使软件的持续集成自动化,大大节约人力和时效。</p><p>Jenkins 功能包括：</p><ul><li>持续的软件版本发布/测试项目。</li><li>监控外部调用执行的工作。</li></ul><h3 id="1-系统管理"><a href="#1-系统管理" class="headerlink" title="1. 系统管理"></a>1. 系统管理</h3><p>安装好的 jenkins 可以在系统管理进行配置系统信息等</p><ul><li><p>系统设置</p><ul><li>执行者数量：系统可同时并发执行任务的数量，系统默认 2 个，原则上不超过服务器 CPU 核数，否则容易出现 CPU 利用率过载导致服务挂掉。</li><li>Jenkins URL：Jenkins 访问地址，可以修改地址的端口号，和修改服务器配置文件的端口号效果一致</li></ul></li><li><p>凭据配置</p><ul><li>凭据可以用来存储需要密文保护的数据库密码、Gitlab 密码信息、Docker 私有仓库密码等，以便 Jenkins 可以和这些第三方的应用进行交互，需要安装 Credentials Binding 插件，用户才可管理凭据</li></ul></li><li><p>凭据管理</p><ul><li>凭据管理包含凭据的管理和凭据所在域的管理，系统默认会创建全局域，用户可以在两个管理表格的存储下添加域，在用户选择的域下添加凭据或者进入域详情添加凭据。为了最大程度地提高安全性，在 Jenkins 中配置的凭据以加密形式存储在主 Jenkins 实例上（由 Jenkins 实例 ID 加密），用户需要使用配置的唯一标识 ID 进行处理。</li><li>可以添加的凭证有 5 种：<ol><li>用户名和密码</li><li>SSH 密钥（SSH 公私钥对）</li><li>加密文件</li><li>令牌（例如 API 令牌、GitHub 个人访问令牌）</li><li>证书</li></ol></li><li>添加凭据：<ol><li>种类</li><li>范围 （全局、系统）</li><li>凭据</li><li>ID (此字段是可选的。如果未指定其值，Jenkins 将为凭证 ID 分配一个全局唯一 ID（GUID）值。请记住，一旦设置了凭证 ID，就无法再更改它)</li><li>凭证描述。</li></ol></li></ul></li><li><p>插件管理</p><p>Jenkins 提供了两种不同的方法来在主服务器上安装插件：</p><ul><li><p>在管理平台界面中使用插件管理器</p><p>通过“系统管理” &gt;“插件管理”视图，Jenkins 环境的管理员可以使用该视图。在“ 可选插件 ”选项卡下，可以搜索用户需要的插件，搜索到需要的插件后勾选插件列表的选中框，之后点击左下角的下载并且重启后安装，等待插件下载完成后服务自动重启，重新进入系统即安装成功。</p></li><li><p>使用 Jenkins CLI install-plugin 命令</p><p>管理员还可以使用 Jenkins CLI，它提供了安装插件的命令。用于管理 Jenkins 环境的脚本或配置管理代码可能需要安装插件，而无需在 Web UI 中直接进行用户交互。Jenkins CLI 允许命令行用户或自动化工具下载插件及其依赖项</p></li></ul></li><li><p>管理用户</p><p>Jenkins 默认使用自带数据库模式存储用户，jenkins 默认创建 admin 账号，默认密码位于 <code>/var/lib/jenkins/secrets/initialAdminPassword</code>，登录之后可在管理用户修改用户默认密码</p></li></ul><h3 id="2-新建视图"><a href="#2-新建视图" class="headerlink" title="2. 新建视图"></a>2. 新建视图</h3><p>视图功能主要用于管理不同项目之间的任务，每个项目创建一个视图并在视图下管理整个项目的模块。</p><ul><li>列表视图（显示简单列表。新建或编辑视图的时候可以选择将当前已有的任务添加到该视图，也可以在该视图下新建任务）</li><li>我的视图（该视图自动显示当前用户有权限访问的任务）</li></ul><h3 id="3-任务"><a href="#3-任务" class="headerlink" title="3. 任务"></a>3. 任务</h3><ul><li>新建任务<ul><li>任务名称</li><li>任务模板：jenkins 提供的任务模板，一般新安装的 jenkins 只会有一个“构建一个自由风格的软件项目”模板，而如果需要其他的任务模板需要用户下载对应的插件，不同的任务模板会有不同的构建流程</li><li>复制：可选项，用户可以输入已有的任务名称选择其中之一复制一个新的任务，选择了复制的任务后就无法自定义任务模板，以复制的项目的任务模板为主</li></ul></li><li>任务详情<ul><li>状态</li><li>修改记录：每次构建获取的代码变更记录，即记录每次构建的 git 仓库提交记录</li><li>工作空间：任务的工作空间的项目文件目录</li><li>立即构建：执行构建部署任务，使用不同的插件执行构建过程会有差异</li><li>配置：配置整个任务构建和部署过程的需要干什么</li><li>删除工程</li><li>重命名</li></ul></li></ul><h2 id="二、任务配置"><a href="#二、任务配置" class="headerlink" title="二、任务配置"></a>二、任务配置</h2><p>任务配置主要将自动化构建部署从项目的获取到部署成功的一个过程需要做的工作做分解配置。</p><h3 id="1-General"><a href="#1-General" class="headerlink" title="1. General"></a>1. General</h3><p>这一步主要是在执行构建前对 jenkins 配置进行了简单的设置</p><ul><li><p>描述</p></li><li><p>丢弃旧的构建</p><ul><li>策略：默认 Log Rotation<ul><li>保持构建的天数：将保存此天数的构建记录，为空保存所有</li><li>保持构建的最大个数：保存最近该个数的构建，为空保存所有</li></ul></li></ul></li><li><p>参数化构建过程</p><p>Extended Choice Parameter 插件，该插件可以使用多选框，利用该插件可以指定需要打包的应用，而不需要打包所有项目，减少打包时间</p><ul><li>Name：构建过程使用的参数名</li><li>Description：参数描述</li><li>Basic Parameter Types<ul><li>Parameter Type：<code>Check Boxes</code> （值使用的类型）</li><li>Number of Visible Items：<code>8</code> checkbox 参数值个数（项目子包和主包个数）</li><li>Delimiter：<code>,</code> 各个值的分割符号</li><li>Choose Source for Value：<code>main,subs/appletuser,subs/college,subs/follow,subs/project,subs/questions,subs/statistics,subs/system</code> 参数值（主包和子包相对项目路径</li><li>Choose Source for Default Value：<code>main,subs/appletuser,subs/college,subs/follow,subs/project,subs/questions,subs/statistics,subs/system</code> 参数默认选中的值（主包和子包相对项目路径</li></ul></li></ul><p>布尔值参数，true/false 值的参数，当前应用于构建过程中判断是否需要构建 npm install</p><ul><li>名称：构建过程使用的参数名</li><li>默认值：默认是否勾选</li><li>描述：参数描述</li></ul></li></ul><h3 id="2-源码管理"><a href="#2-源码管理" class="headerlink" title="2. 源码管理"></a>2. 源码管理</h3><ul><li><p>Git plugin</p><p>GIT 仓库管理插件，用于同步 git 库，通过该插件 jenkins 任务可以在构建过程中获取配置好的 git 远程仓库代码，任务执行时代码会被拉取到<code>/var/lib/jenkins/workspace/{任务名称}</code>目录下</p><ul><li>Repository URL 代码仓库地址</li><li>Credentials 服务器连接代码仓库的凭据，可在系统管理添加后选择，也可以在右边的添加按钮新增凭据，新增方式和系统管理的凭据新增一样</li><li>Branches to build 指定任务需要拉取的分支，允许配置多个分支</li><li>源码库浏览器 指定 git 仓库类型，默认自动</li></ul></li></ul><h3 id="3-构建"><a href="#3-构建" class="headerlink" title="3. 构建"></a>3. 构建</h3><ul><li><p>执行 shell</p><p>开始执行构建任务之前源码管理插件已经将代码从远程库中获取，执行 shell 任务主要通过获取参数化构建时设置的参数去对整个项目中的各个应用进行打包并将打包完成的部署文件统一放在根目录的发布文件夹<code>publish</code>，执行详细代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 项目根目录地址（相对于工作空间）</span></span><br><span class="line">project_path=""</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将用户选择需要打包的应用拆分成数组</span></span><br><span class="line">OLD_IFS="$IFS"</span><br><span class="line">IFS=","</span><br><span class="line">arr=($mutiParams)</span><br><span class="line">IFS="$OLD_IFS"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空上次打包的部署文件</span></span><br><span class="line">rm -rf $WORKSPACE$project_path/publish</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in $&#123;arr[@]&#125;</span><br><span class="line">do</span><br><span class="line">    # 进入对应的应用中执行打包过程，$WORKSPACE为系统环境变量，值为工作空间地址</span><br><span class="line">    cd $WORKSPACE$project_path/$i</span><br><span class="line">    rm -rf dist</span><br><span class="line">    # 判断是否需要执行环境安装，当前设置为全局设置，所有需要打包的应用会执行相同的判断</span><br><span class="line">    if [[ $isRunInstall == "true" ]]</span><br><span class="line">    then</span><br><span class="line">      npm install</span><br><span class="line">    fi</span><br><span class="line">    npm run build</span><br><span class="line">    # 将子应用和主应用放在同一级，便于后续部署，因为很多微前端项目子应用都会放置在同一个文件夹下</span><br><span class="line">    [[ $i == "main" ]] &amp;&amp; subdir=$i || subdir=$&#123;i##*/&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mkdir -p $WORKSPACE$project_path/publish/$subdir</span><br><span class="line">    mv dist/* $WORKSPACE$project_path/publish/$subdir</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-构建后操作"><a href="#4-构建后操作" class="headerlink" title="4. 构建后操作"></a>4. 构建后操作</h3><ul><li><p>Send build artifacts over SSH，使用该插件需要在<code>系统管理-&gt;插件管理</code>中安装，该插件主要功能为将构建好的部署包按照一定规则发送到部署服务器，并且在这之后可在部署服务器执行一定的 shell 操作。安装插件后还需要在<code>系统管理-&gt;系统配置-&gt;Publish over SSH</code>添加 SSH Services。</p><ul><li><p>Name：选择部署服务器，所选服务器就是系统配置中所添加，构建时就会连接该服务器</p></li><li><p>Transfers</p><ul><li>Source files：构建服务器中部署文件的相对地址<code>publish/**</code></li><li>Remove prefix：文件发送后在部署服务器的路径和 Source files 一致，可以根据需求删除该地址前面某一段，当前为空</li><li>Remote directory：部署服务器的部署目录<code>/home/jenkinsC</code></li><li>Exec command：文件发送完成之后在这里可以对部署服务器进行操作，这里的 shell 操作作用于部署服务器，由于微前端的部署特殊性，所以这里需要对发送过来的文件进行转移操作，具体如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处的packages后面多了个publish是打包之后的部署文件名，为了防止在部署主应用的时候被删掉</span></span><br><span class="line">packages=<span class="string">"main,subs/appletuser,subs/college,subs/follow,subs/project,subs/questions,subs/statistics,subs/system,publish"</span></span><br><span class="line"><span class="comment"># 部署目录</span></span><br><span class="line">PUBLISH_PATH=/home/jenkinsC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依次循环部署构建好的应用</span></span><br><span class="line"><span class="keyword">for</span> package <span class="keyword">in</span> `ls <span class="variable">$PUBLISH_PATH</span>/publish`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 判断当前是否为主应用，因为主包需要把主应用的所有文件直接部署在部署目录下，所以需要在过滤掉子应用和publish文件夹的情况下删除所有旧的主应用文件再进行部署</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$package</span> == <span class="string">"main"</span> ]]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> `ls <span class="variable">$PUBLISH_PATH</span>`</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          [[ <span class="variable">$packages</span> =~ <span class="variable">$element</span> ]] || rm -rf <span class="variable">$PUBLISH_PATH</span>/<span class="variable">$element</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        mv <span class="variable">$PUBLISH_PATH</span>/publish/<span class="variable">$package</span>/* <span class="variable">$PUBLISH_PATH</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># 子应用部署方式直接先删除原有文件后部署</span></span><br><span class="line">        rm -rf <span class="variable">$PUBLISH_PATH</span>/<span class="variable">$package</span></span><br><span class="line">        mkdir -p <span class="variable">$PUBLISH_PATH</span>/<span class="variable">$package</span></span><br><span class="line">        mv <span class="variable">$PUBLISH_PATH</span>/publish/<span class="variable">$package</span>/* <span class="variable">$PUBLISH_PATH</span>/<span class="variable">$package</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 部署完成后需要删除部署文件，否则下次部署如果没有删掉会再次部署旧的文件</span></span><br><span class="line">rm -rf <span class="variable">$PUBLISH_PATH</span>/publish</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="三、构建"><a href="#三、构建" class="headerlink" title="三、构建"></a>三、构建</h2><p>按照上一步的配置规则执行自动化构建和部署</p><h3 id="1-构建前"><a href="#1-构建前" class="headerlink" title="1. 构建前"></a>1. 构建前</h3><p>路径：工程-&gt;Build With Parameters-&gt;开始构建</p><p>点击开始构建前需要配置构建所需的参数，构建过程中在左下角的构建历史可以查看构建进度条。</p><ul><li>mutiParams：选中对应的应用，构建过程中就会只构建有勾选的应用</li><li>isRunInstall：应用是否需要执行 npm install，当前构建被选中的应用都会按照这个规则执行，为了减少构建过程所消耗的时间</li></ul><h3 id="2-构建后"><a href="#2-构建后" class="headerlink" title="2. 构建后"></a>2. 构建后</h3><p>在左侧的构建历史可以查看构建记录的状态，并且每个构建记录还能通过构建编号左侧的小球颜色判断状态，一般有三个状态分别分为 SUCCESS（蓝色）、UNSTABLE（黄色）、FAILURE（红色），点击对应构建记录可查看详细信息</p><p>状态描述：</p><ul><li>SUCCESS：构建部署成功</li><li>UNSTABLE：构建成功，但是部署过程出错</li><li>FAILURE：构建过程就已经出错</li></ul><p>构建记录：</p><ul><li>状态集：执行构建用户、当前构建记录的 git 分支以及提交记录</li><li>变更记录：当前构建记录 git 提交记录详细信息</li><li>控制台输出：构建部署执行过程命令执行的记录（可以在这里查看构建失败原因以及调试构建过程的问题）</li><li>编辑编译信息：设置当前构建记录的名称和备注</li><li>删除构建</li><li>参数：显示构建部署过程中自定义参数</li></ul><h2 id="四、-Jenkins部署微前端多个包完整配置"><a href="#四、-Jenkins部署微前端多个包完整配置" class="headerlink" title="四、 Jenkins部署微前端多个包完整配置"></a>四、 Jenkins部署微前端多个包完整配置</h2><h3 id="需要安装的插件"><a href="#需要安装的插件" class="headerlink" title="需要安装的插件"></a>需要安装的插件</h3><ul><li><p><code>Extended Choice Parameter</code> 插件，该插件可以使用多选框 <img src="https://blog.poetries.top/img/static/images/20211117095347.png" alt></p></li><li><p>Git plugin </p><ul><li>GIT 仓库管理插件，用于同步 git 库，通过该插件 jenkins 任务可以在构建过程中获取配置好的 git 远程仓库代码，任务执行时代码会被拉取到<code>/var/lib/jenkins/workspace/{任务名称}</code>目录下</li></ul></li><li><p>Send build artifacts over SSH，使用该插件需要在<code>系统管理-&gt;插件管理</code>中安装，该插件主要功能为将构建好的部署包按照一定规则发送到部署服务器，并且在这之后可在部署服务器执行一定的 shell 操作。安装插件后还需要在<code>系统管理-&gt;系统配置-&gt;Publish over SSH</code>添加 SSH Services。</p><p><img src="https://blog.poetries.top/img/static/images/20211117095208.png" alt></p></li></ul><p>  在<code>系统管理-&gt;系统配置-&gt;Publish over SSH</code>添加<img src="https://blog.poetries.top/img/static/images/20211117095542.png" alt></p><h3 id="Jenkins完整配置搭建"><a href="#Jenkins完整配置搭建" class="headerlink" title="Jenkins完整配置搭建"></a>Jenkins完整配置搭建</h3><p>  <strong>效果演示</strong></p><p>  <img src="https://blog.poetries.top/img/static/images/20211117092944.png" alt><br>  <img src="https://blog.poetries.top/img/static/images/20211117093241.png" alt></p><p>  <strong>配置流程</strong></p><p>  <img src="https://blog.poetries.top/img/static/images/20211117085757.png" alt></p><p>  <img src="https://blog.poetries.top/img/static/images/20211117090018.png" alt><br>  <img src="https://blog.poetries.top/img/static/images/20211117091728.png" alt><br>  <img src="https://blog.poetries.top/img/static/images/20211117091930.png" alt><br>  <img src="https://blog.poetries.top/img/static/images/20211117092045.png" alt></p><p>  构建的shell代码</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash -ilex</span></span><br><span class="line"></span><br><span class="line">echo $PATH</span><br><span class="line"></span><br><span class="line">packages="main,subs/system,subs/teaLifeManage,subs/wechatManage"</span><br><span class="line">project_path=""</span><br><span class="line"></span><br><span class="line">OLD_IFS="$IFS"</span><br><span class="line">IFS=","</span><br><span class="line">arr=($mutiParams)</span><br><span class="line">IFS="$OLD_IFS"</span><br><span class="line"></span><br><span class="line">rm -rf $WORKSPACE$project_path/publish</span><br><span class="line"></span><br><span class="line">for i in $&#123;arr[@]&#125;</span><br><span class="line">do</span><br><span class="line">echo '打印i：' + $i </span><br><span class="line">    cd $WORKSPACE$project_path/$i</span><br><span class="line">    rm -rf dist</span><br><span class="line">    if [[ $isRunInstall == "true" ]]</span><br><span class="line">    then</span><br><span class="line">       npm install</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    if [[ $i == "main" ]]</span><br><span class="line">    then</span><br><span class="line">      if [[ $nodeDev == "development" ]]</span><br><span class="line">      theninsta</span><br><span class="line">      npm run test</span><br><span class="line">      else</span><br><span class="line">      npm run build $nodeDev</span><br><span class="line">      fi</span><br><span class="line">    else</span><br><span class="line">      npm run build $nodeDev</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    if [[ $i == "main" ]]</span><br><span class="line">    then</span><br><span class="line">    newsubdir=$i</span><br><span class="line">    else</span><br><span class="line">    subdir=$&#123;i%Manage*&#125;</span><br><span class="line">        newsubdir=$&#123;subdir##*/&#125;</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    mkdir -p $WORKSPACE$project_path/publish/$&#123;newsubdir,,&#125;</span><br><span class="line">    mv dist/* $WORKSPACE$project_path/publish/$&#123;newsubdir,,&#125;</span><br><span class="line">    </span><br><span class="line">    echo '打印WORKSPACE：' + $WORKSPACE</span><br><span class="line">    echo '打印newsubdir：' + $newsubdir</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>  <img src="https://blog.poetries.top/img/static/images/20211117092331.png" alt></p><p>  构建后操作shell代码</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash -ilex</span><br><span class="line">packages=&quot;main,subs/system,subs/teaLifeManage,subs/wechatManage,publish&quot;</span><br><span class="line">PUBLISH_PATH=/home/docker/nginx/html/web-test</span><br><span class="line"></span><br><span class="line">for package in `ls $PUBLISH_PATH/publish`</span><br><span class="line">do</span><br><span class="line">    if [[ $package == &quot;main&quot; ]]</span><br><span class="line">    then</span><br><span class="line">        for element in `ls $PUBLISH_PATH`</span><br><span class="line">        do</span><br><span class="line">        [[ $&#123;packages,,&#125; =~ $element ]] || rm -rf $PUBLISH_PATH/$element</span><br><span class="line">        done</span><br><span class="line">        mv $PUBLISH_PATH/publish/$package/* $PUBLISH_PATH</span><br><span class="line">    else</span><br><span class="line">        rm -rf $PUBLISH_PATH/$package</span><br><span class="line">        mkdir -p $PUBLISH_PATH/$package</span><br><span class="line">        mv $PUBLISH_PATH/publish/$package/* $PUBLISH_PATH/$package</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line">rm -rf $PUBLISH_PATH/publish</span><br></pre></td></tr></table></figure><blockquote><p>最后配置一下Nginx指向<code>/home/docker/nginx/html/web-test</code>部署目录即可访问</p></blockquote><h2 id="五、使用阿里云OSS部署微前端项目"><a href="#五、使用阿里云OSS部署微前端项目" class="headerlink" title="五、使用阿里云OSS部署微前端项目"></a>五、使用阿里云OSS部署微前端项目</h2><p>  介绍阿里云对象存储部署步骤。</p><h3 id="一、创建-Bucket-存储桶"><a href="#一、创建-Bucket-存储桶" class="headerlink" title="一、创建 Bucket 存储桶"></a>一、创建 Bucket 存储桶</h3><h3 id="1-进入对象存储-OSS-服务"><a href="#1-进入对象存储-OSS-服务" class="headerlink" title="1. 进入对象存储 OSS 服务"></a>1. 进入对象存储 OSS 服务</h3><p>  <a href="https://oss.console.aliyun.com/" target="_blank" rel="noopener">https://oss.console.aliyun.com/</a></p><h3 id="2-创建-Bucket-存储桶"><a href="#2-创建-Bucket-存储桶" class="headerlink" title="2. 创建 Bucket 存储桶"></a>2. 创建 Bucket 存储桶</h3><ul><li>Bucket 名称：xxx</li><li>地域：华南 1（深圳）</li><li>版本控制：不开通</li><li>读写权限：公共读</li><li><p>其他保持默认</p><h3 id="二、添加-CDN-域名"><a href="#二、添加-CDN-域名" class="headerlink" title="二、添加 CDN 域名"></a>二、添加 CDN 域名</h3><h3 id="1-进入-CDN-服务"><a href="#1-进入-CDN-服务" class="headerlink" title="1. 进入 CDN 服务"></a>1. 进入 CDN 服务</h3><p><a href="https://cdn.console.aliyun.com/" target="_blank" rel="noopener">https://cdn.console.aliyun.com/</a></p><h3 id="2-添加-CDN-域名"><a href="#2-添加-CDN-域名" class="headerlink" title="2. 添加 CDN 域名"></a>2. 添加 CDN 域名</h3><p>路径：CDN &gt; 域名管理 &gt; 添加域名</p></li><li><p>加速域名：xxx.test.com</p></li><li>资源分组：会员商城</li><li>新增源站信息<ul><li>源站信息：OSS 域名</li><li>域名：xxx.oss-cn-shenzhen.aliyuncs.com</li><li>其他保持默认</li></ul></li><li><p>其他保持默认</p><h3 id="3-HTTPS-配置"><a href="#3-HTTPS-配置" class="headerlink" title="3. HTTPS 配置"></a>3. HTTPS 配置</h3><p>路径：CDN &gt; 域名管理 &gt; 找到域名</p><p>路径：CDN &gt; 域名管理 &gt; 域名名称 &gt; HTTPS 配置 &gt; HTTPS 证书 &gt; 修改配置</p></li><li><p>HTTPS 安全加速：开启</p></li><li>证书来源：云盾（SSL）证书中心</li><li>证书名称：test.com</li><li><p>其他保持默认</p><h3 id="4-得到-CNAME-域名"><a href="#4-得到-CNAME-域名" class="headerlink" title="4. 得到 CNAME 域名"></a>4. 得到 CNAME 域名</h3><p>路径：CDN &gt; 域名管理 &gt; 找到域名</p></li><li><p>CNAME：xxx.test.com.w.kunlunpi.com</p><h3 id="三、添加-CNAME-记录"><a href="#三、添加-CNAME-记录" class="headerlink" title="三、添加 CNAME 记录"></a>三、添加 CNAME 记录</h3><h3 id="1-进入云解析-DNS-服务"><a href="#1-进入云解析-DNS-服务" class="headerlink" title="1. 进入云解析 DNS 服务"></a>1. 进入云解析 DNS 服务</h3><p><a href="https://dns.console.aliyun.com/" target="_blank" rel="noopener">https://dns.console.aliyun.com/</a></p><h3 id="2-添加-CNAME-记录"><a href="#2-添加-CNAME-记录" class="headerlink" title="2. 添加 CNAME 记录"></a>2. 添加 CNAME 记录</h3><p>路径：云解析 DNS &gt; 域名解析 &gt; 找到域名</p><p>路径：云解析 DNS &gt; 域名解析 &gt; 解析设置 &gt; 添加记录</p></li><li><p>记录类型：CNAME</p></li><li>主机记录：xxx.test.com</li><li>记录值：xxx.test.com.w.kunlunpi.com</li><li><p>其他保持默认</p><h3 id="四、设置存储桶"><a href="#四、设置存储桶" class="headerlink" title="四、设置存储桶"></a>四、设置存储桶</h3><h3 id="1-缓存设置"><a href="#1-缓存设置" class="headerlink" title="1. 缓存设置"></a>1. 缓存设置</h3><p>路径：对象存储 &gt; Bucket 列表 &gt; 找到存储桶</p><p>路径：对象存储 &gt; 存储桶名称 &gt; 文件管理 &gt; 找到 index.html 文件 &gt; 更多 &gt; 设置 HTTP 头</p></li><li><p>Cache-Control：no-cache（Object 允许被缓存在客户端或代理服务器的浏览器中，但每次访问时需要向 OSS 验证缓存是否可用。缓存可用时直接访问缓存，缓存不可用时重新向 OSS 请求。）</p></li><li>Cache-Control：no-store（不允许缓存 Object）</li><li>Expires：-1</li><li><p>其他保持默认</p><h3 id="2-设置静态页面"><a href="#2-设置静态页面" class="headerlink" title="2. 设置静态页面"></a>2. 设置静态页面</h3><p>路径：对象存储 &gt; 基础设置 &gt; 静态页面</p></li><li><p>默认首页：index.html</p></li><li>子目录首页：未开通</li><li><p>默认 404 页：index.html</p><h3 id="1-域名管理"><a href="#1-域名管理" class="headerlink" title="1. 域名管理"></a>1. 域名管理</h3><p>路径：对象存储 &gt; 传输管理 &gt; 域名管理 &gt; 绑定域名</p></li><li><p>域名：xxx.test.com</p></li><li><p>其他保持默认</p><h3 id="五、上传代码至存储桶"><a href="#五、上传代码至存储桶" class="headerlink" title="五、上传代码至存储桶"></a>五、上传代码至存储桶</h3><h3 id="1-下载-oss-browser-工具"><a href="#1-下载-oss-browser-工具" class="headerlink" title="1. 下载 oss browser 工具"></a>1. 下载 oss browser 工具</h3><p><a href="https://help.aliyun.com/document_detail/209974.html" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/209974.html</a></p></li></ul><p><img src="https://blog.poetries.top/img/static/images/20211117102935.png" alt></p><hr><p><img src="https://blog.poetries.top/img/static/images/20211117112123.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;持续集成&quot;&gt;&lt;a href=&quot;#持续集成&quot; class=&quot;headerlink&quot; title=&quot;持续集成&quot;&gt;&lt;/a&gt;持续集成&lt;/h1&gt;&lt;p&gt;集成工具 jenkins 的基本介绍和自动化部署微前端项目的几个简单方案&lt;/p&gt;
&lt;h2 id=&quot;一、Jenkins-基础介
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="微前端" scheme="http://blog.poetries.top/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>serverless及小程序云开发实践总结</title>
    <link href="http://blog.poetries.top/2021/09/12/serverless-cloud-weapp/"/>
    <id>http://blog.poetries.top/2021/09/12/serverless-cloud-weapp/</id>
    <published>2021-09-12T10:24:08.000Z</published>
    <updated>2025-03-30T13:54:29.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Serverless-架构详解"><a href="#一、Serverless-架构详解" class="headerlink" title="一、Serverless 架构详解"></a>一、Serverless 架构详解</h1><h2 id="1-1-什么是serverless"><a href="#1-1-什么是serverless" class="headerlink" title="1.1 什么是serverless"></a>1.1 什么是serverless</h2><p><img src="https://blog.poetries.top/img/static/images/20210909143647.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909105911.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909174718.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909174744.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909174732.png" alt></p><p>我们使用函数的时候不用关心后端IP、域名，只需要调用函数，后端的服务是一个函数。serverless并不是没有服务器，只是服务器部署在云上面的，比我们去自己维护更方便多</p><ul><li><code>Serverless</code>又名无服务器,所谓无服务器并非是说不需要依赖和依靠服务器等资源,而是开发者再也不用过多考虑服务器的问题,可以更专注在产品代码上。</li><li><code>Serverless</code>是一种软件系统架构的思想和方法，它不是软件框架、类库或者工具。它与传统架构的不同之处在于，完全由第三方管理，由事件触发，存在于无状态(<code>Stateless</code>)、 暂存(可能只存在于一次调用的过程中)计算容器内。构建无服务器应用程序意味着开发者可以专注在产品代码上，而无须管理和操作云端或本地的服务器或运行时(运行时通俗的讲 就是运行环境，比如 <code>nodejs</code>环境，<code>java</code> 环境，<code>php</code> 环境)。<code>Serverless</code> 真正做到了部署应用 无需涉及基础设施的建设，自动构建、部署和启动服务。</li></ul><blockquote><ul><li>第一种：<code>狭义 Serverless</code>（最常见）= <code>Serverless computing 架构</code> = <code>FaaS 架构</code> = <code>Trigger（事件驱动）+ FaaS（函数即服务）+ BaaS</code>（后端即服务，持久化或第三方服务）= <code>FaaS + BaaS</code></li><li>第二种：广义 <code>Serverless</code> = <code>服务端免运维</code> = <code>具备 Serverless 特性的云服务</code></li></ul></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210909172246.png" alt></p><blockquote><ul><li>FAAS：函数及服务，通俗来说就是我们可以写一个函数，在该函数内执行业务逻辑，函数由fas平台运行</li><li>BAAS：后端及服务，通常指云服务，该云服务常指中间件服务，</li></ul></blockquote><p>FAAS+BAAS 构成了Serverless架构</p><p><img src="https://blog.poetries.top/img/static/images/20210901173327.png" alt></p><p>整体架构十分简单明了, 用 FC 替代了 Web 服务器，但是换来的是免运维，弹性扩容，按需付费等一系列优点</p><blockquote><p>目前，Serverless 的应用场景广泛，大部分传统业务均可以在 Serverless 云函数上完美支持</p></blockquote><h2 id="1-2-Serverless要解决什么？"><a href="#1-2-Serverless要解决什么？" class="headerlink" title="1.2 Serverless要解决什么？"></a>1.2 Serverless要解决什么？</h2><blockquote><p>问题：前端和后端分离后，彼此独立，这样就导致前端需要关注一些后端关注的问题，如下。</p></blockquote><ul><li>完整的后端应用上线流程</li><li>机器管理运维：扩缩容</li><li>降级、熔断、限流</li><li>域名、性能、监控</li></ul><blockquote><p>是不是触及了很多同学的知识盲区。作为一个前端，确实大多数人对于服务端的环境，部署基础设施等等东西并不了解。但是现在前端是独立的部署，前端必然面临这些东西。这就是serverless要解决的问题。</p></blockquote><h2 id="1-3-Serverless做什么事？"><a href="#1-3-Serverless做什么事？" class="headerlink" title="1.3  Serverless做什么事？"></a>1.3  Serverless做什么事？</h2><blockquote><p>问题：是不是可以弄一个工具，我们只需要关心前端代码，服务器的东西工具自动帮我们做好。</p></blockquote><p>这就是serverless做的事情。如下图，我们只需要关心业务代码，不需要关心服务器的基础设施。</p><p><img src="https://blog.poetries.top/img/static/images/20210909175241.png" alt></p><h2 id="1-4-Serverless和函数计算的区别"><a href="#1-4-Serverless和函数计算的区别" class="headerlink" title="1.4 Serverless和函数计算的区别"></a>1.4 Serverless和函数计算的区别</h2><p><img src="https://blog.poetries.top/img/static/images/20210909174858.png" alt></p><h2 id="1-5-Serverless-的技术特点"><a href="#1-5-Serverless-的技术特点" class="headerlink" title="1.5 Serverless 的技术特点"></a>1.5 Serverless 的技术特点</h2><p><strong>事件驱动</strong></p><ul><li>云函数的运行，是由事件驱动起来的，在有事件到来时，云函数会启动运行</li><li>Serverless 应用不会类似于原有的「监听 - 处理」类型的应用一直在线，而是按需启动</li><li>事件的定义可以很丰富，一次 http 请求，一个文件上传，一次数据库条目修改，一条消息发送，都可以定义为事件</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210909215157.png" alt></p><p><strong>单事件处理</strong></p><ul><li>云函数由事件触发，而触发启动的一个云函数实例，一次仅处理一个事件</li><li>无需在代码内考虑高并发高可靠性，代码可以专注于业务，开发更简单</li><li>通过云函数实例的高并发能力，实现业务高并发</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210909215226.png" alt></p><p><strong>自动弹性伸缩</strong></p><ul><li>由于云函数事件驱动及单事件处理的特性，云函数通过自动的伸缩来支持业务的高并发</li><li>针对业务的实际事件或请求数，云函数自动弹性合适的处理实例来承载实际业务量</li><li>在没有事件或请求时，无实例运行，不占用资源</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210909215252.png" alt></p><p><strong>无状态开发</strong></p><ul><li>云函数运行时根据业务弹性，可能伸缩到 0，无法在运行环境中保存状态数据</li><li>分布式应用开发中，均需要保持应用的无状态，以便于水平伸缩</li><li>可以利用外部服务、产品，例如数据库或缓存，实现状态数据的保存</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210909215322.png" alt></p><h2 id="1-6-传统服务器架构-VS-Serverless架构"><a href="#1-6-传统服务器架构-VS-Serverless架构" class="headerlink" title="1.6 传统服务器架构 VS Serverless架构"></a>1.6 传统服务器架构 VS Serverless架构</h2><ol><li>传统的开发模式</li></ol><p><img src="https://blog.poetries.top/img/static/images/20210909180123.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909175657.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210908093108.png" alt></p><ol start="2"><li>新型的<code>serverless</code>开发模式</li></ol><p><img src="https://blog.poetries.top/img/static/images/20210909180137.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210908093115.png" alt></p><p>正常来说，用户开发 Server 端服务，常常面临开发效率，运维成本高，机器资源弹性伸缩等痛点，而使用 Serverless 架构可以很好的解决上述问题。下面是传统架构和 Serverless 架构的对比：</p><p><img src="https://blog.poetries.top/img/static/images/20210901173249.png" alt></p><p>云函数计算是一个事件驱动的全托管计算服务。通过函数计算，您无需管理服务器等基础设施，只需编写代码并上传。函数计算会为您准备好计算资源，以弹性、可靠的方式运行您的代码，并提供日志查询，性能监控，报警等功能。借助于函数计算，您可以快速构建任何类型的应用和服务，无需管理和运维。</p><h2 id="1-7-使用serverless优缺点"><a href="#1-7-使用serverless优缺点" class="headerlink" title="1.7 使用serverless优缺点"></a>1.7 使用serverless优缺点</h2><p><strong>优势</strong></p><ol><li><strong>无运维</strong>：我们不需要购买服务器，直接可进行</li><li><strong>资源分配</strong>: 在 <code>Serverless</code> 架构中，你不用关心应用运行的资源(比如服务配置、磁盘大小)只提供一份代码就行。</li><li><strong>计费方式</strong>: 在<code>Serverless</code> 架构中，计费方式按实际使用量计费(比如函数调用次数、运 行时长)，不按传统的执行代码所需的资源计费(比如固定 <code>CPU</code>)。计费粒度也精确到了毫 秒级，而不是传统的小时级别。个别云厂商推出了每个月的免费额度，比如腾讯云提供了每 个月 40 万 GBs 的资源使用额度和 100 万次调用次数的免费额度。中小企业的网站访问量不 是特别大的话完全可以免费使用。</li></ol><p><img src="https://blog.poetries.top/img/static/images/20210908093139.png" alt></p><ol start="4"><li><strong>弹性伸缩</strong>:<code>Serverless</code> 架构的弹性伸缩更自动化、更精确，可以快速根据业务并发扩容更 多的实例，甚至允许缩容到零实例状态来实现零费用，对用户来说是完全无感知的。而传统 架构对服务器(虚拟机)进行扩容，虚拟机的启动速度也比较慢，需要几分钟甚至更久。</li></ol><p><strong>不足</strong></p><p>当然了 ServerLess 是很诱人，但却不是万能的，有些场景还是不适合的。</p><ul><li>ServerLess 不仅仅是一门技术也是一种理念和微服务一样，很多老系统不能直接上 ServerLess，得相应的进行升级和拆解才能更好的适应 ServerLess，这是一个门槛。</li><li>同时 ServerLess 针对开发语言的可定制性和可开放性，ServerLess 会选择处于稳定版的语言且更新具有一定的滞后性，特别是 Node.JS 这样的版本更新帝，最新稳定版是10，但是提供的却是8。同时如果对语言有底层的修改而无法通过 Plugin 实现同样也无法适应相关场景。</li><li>不适合长时间的进行计算处理的场景，ServerLess 是产生计算后按时间计费的，适合那些触发类短时间计算的，如果有长时间进行计算的场景就不适合。</li></ul><h2 id="1-8-如何理解理解Serverless技术—FaaS和BaaS"><a href="#1-8-如何理解理解Serverless技术—FaaS和BaaS" class="headerlink" title="1.8 如何理解理解Serverless技术—FaaS和BaaS"></a>1.8 如何理解理解Serverless技术—FaaS和BaaS</h2><blockquote><p>Serverless由开发者实现的服务端逻辑运行在无状态的计算容器中，它由事件触发， 完全被第三方管理，其业务层面的状态则被开发者使用的数据库和存储资源所记录。Serverless涵盖了很多技术，分为两类：FaaS和BaaS。</p></blockquote><p><strong>FaaS（Function as a Service，函数即服务）</strong></p><ul><li>FaaS意在无须自行管理服务器系统或自己的服务器应用程序，即可直接运行后端代码。其中所指的服务器应用程序，是该技术与容器和PaaS（平台即服务）等其他现代化架构最大的差异。</li><li>FaaS可以取代一些服务处理服务器（可能是物理计算机，但绝对需要运行某种应用程序），这样不仅不需要自行供应服务器，也不需要全时运行应用程序。</li><li>FaaS产品不要求必须使用特定框架或库进行开发。在语言和环境方面，FaaS函数就是常规的应用程序。例如AWS Lambda的函数可以通过Javascript、Python以及任何JVM语言（Java、Clojure、Scala）等实现。然而Lambda函数也可以执行任何捆绑有所需部署构件的进程，因此可以使用任何语言，只要能编译为Unix进程即可。FaaS函数在架构方面确实存在一定的局限，尤其是在状态和执行时间方面。</li><li>迁往FaaS的过程中，唯一需要修改的代码是“主方法/启动”代码，其中可能需要删除顶级消息处理程序的相关代码（“消息监听器接口”的实现），但这可能只需要更改方法签名即可。在FaaS的世界中，代码的其余所有部分（例如向数据库执行写入的代码）无须任何变化。</li></ul><blockquote><p>相比传统系统，部署方法会有较大变化 – 将代码上传至FaaS供应商，其他事情均可由供应商完成。目前这种方式通常意味着需要上传代码的全新定义（例如上传zip或JAR文件），随后调用一个专有API发起更新过程。</p></blockquote><p>FaaS中的函数可以通过供应商定义的事件类型触发。对于亚马逊AWS，此类触发事件可以包括S3（文件）更新、时间（计划任务），以及加入消息总线的消息（例如Kinesis）。通常你的函数需要通过参数指定自己需要绑定到的事件源。</p><p>大部分供应商还允许函数作为对传入Http请求的响应来触发，通常这类请求来自某种该类型的API网关（例如AWS API网关、Webtask）</p><p><strong>BaaS（Backend as a Service，后端即服务）</strong></p><blockquote><p>BaaS（Backend as a Service，后端即服务）是指我们不再编写或管理所有服务端组件，可以使用领域通用的远程组件（而不是进程内的库）来提供服务</p></blockquote><h2 id="1-9-Serverless计算如何工作？"><a href="#1-9-Serverless计算如何工作？" class="headerlink" title="1.9 Serverless计算如何工作？"></a>1.9 Serverless计算如何工作？</h2><p><img src="https://blog.poetries.top/img/static/images/20210909175448.png" alt></p><blockquote><p>同步调用的特性是，客户端期待服务端立即返回计算结果。请求到达函数计算时，会立即分配执行环境执行函数。</p></blockquote><p>以 API 网关为例，API 网关同步触发函数计算，客户端会一直等待服务端的执行结果，如果执行过程中遇到错误， 函数计算会将错误直接返回，而不会对错误进行重试。这种情况下，需要客户端添加重试机制来做错误处理。</p><p>异步调用的特性是，客户端不急于立即知道函数结果，函数计算将请求丢入队列中即可返回成功，而不会等待到函数调用结束。</p><blockquote><p>函数计算会逐渐消费队列中的请求，分配执行环境，执行函数。如果执行过程中遇到错误，函数计算会对错误的请求进行重试，对函数错误重试三次，系统错误会以指数退避方式无限重试，直至成功。</p></blockquote><p>异步调用适用于数据的处理，比如 OSS 触发器触发函数处理音视频，日志触发器触发函数清洗日志，都是对延时不敏感，又需要尽可能保证任务执行成功的场景。如果用户需要了解失败的请求并对请求做自定义处理，可以使用 Destination 功能。函数计算是 Serverless 的，这不是说无服务器，而是开发者无需关心服务器，函数计算会为开发者分配实例执行函数。</p><h2 id="2-0-FAAS-冷启动"><a href="#2-0-FAAS-冷启动" class="headerlink" title="2.0 FAAS 冷启动"></a>2.0 FAAS 冷启动</h2><p>FaaS 中的冷启动是指从调用函数开始到函数实例准备完成的整个过程。 冷启动我们关注的是启动时间，启动时间越短，我们对资源的利用率就越高。现在的云服务商，基于不同的语言特性，冷启动平均耗时基本在 100～700 毫秒之间。得益于 Google 的 JavaScript 引擎 Just In Time 特性，Node.js 在冷启动方面速度是最快的。</p><p><img src="https://blog.poetries.top/img/static/images/20210909175826.png" alt></p><p>请求第一次访问时，云服务商就可以利用构建好的缓存镜像，直接跳过冷启动的下载函数代码步骤，从镜像启动容器，这个也叫预热冷启动。所以如果我们有些业务场景对响应时间比较敏感，我们就可以通过预热冷启动或预留实例策略，加速或绕过冷启动时间。</p><h2 id="2-1-FAAS-分层"><a href="#2-1-FAAS-分层" class="headerlink" title="2.1 FAAS 分层"></a>2.1 FAAS 分层</h2><ul><li>容器</li><li>运行时runtime</li><li>具体函数代码</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210909175855.png" alt></p><p>云服务商负责的就是容器和 Runtime 的准备阶段了。而开发者自己负责的则是函数执行阶段。一旦容器 &amp;Runtime 启动后，就会维持一段时间，这段时间内的这个函数实例就可以直接处理用户数据请求。当一段时间内没有用户请求事件发生（各个云服务商维持实例的时间和策略不同），则会销毁这个函数实例。</p><p><img src="https://blog.poetries.top/img/static/images/20210909175920.png" alt></p><p>SFF（Serverless For Frontend）指前端数据请求过来，函数触发器触发我们的函数服务；我们的函数启动后，调用后端提供的元数据接口，并将返回的元数据加工成前端需要的数据格式；我们的 FaaS 函数完全就可以休息了。</p><h2 id="2-2-后端应用-BaaS-化"><a href="#2-2-后端应用-BaaS-化" class="headerlink" title="2.2 后端应用 BaaS 化"></a>2.2 后端应用 BaaS 化</h2><p>回到我们的进程模型，用完即毁型是天然的 Stateless，因为它执行完就销毁，你无法单纯用它持久化存储任何值；常驻进程型则是天然的 Stateful，因为它的主进程不退出，主进程可以存储部分值。</p><p>BaaS 化的核心思想就是将后端应用转换成 NoOps 的数据接口，这样 FaaS 在 SFF 层就可以放开手脚，而不用再考虑冷启动时间了。</p><p><img src="https://blog.poetries.top/img/static/images/20210909180012.png" alt></p><h2 id="2-3-Serverless使用场景"><a href="#2-3-Serverless使用场景" class="headerlink" title="2.3 Serverless使用场景"></a>2.3 Serverless使用场景</h2><p><img src="https://blog.poetries.top/img/static/images/20210909175547.png" alt></p><p><strong>发送通知</strong></p><p>诸如 PUSH Notification、邮件通知接口、短信，这一类服务来说，他们都需要基础设施来搭建。并且，他们对实时性的要求相对没有那么高。即使在时间上晚来几秒钟，用户还是能接受的。在我们所见到的短信发送的例子里，一般都会假设用户能在 60 秒内收到短信。因此，在这种时间 1s 的误差，用户也不会恼火的。</p><p><strong>轻量级 API</strong></p><p>Serverless 特别适合于，轻量级快速变化地 API。其实，我一直没有想到一个合适的例子。在我的假想里，一个 AutoSuggest 的 API 可能就是这样的 API，但是这种 API 在有些时候，往往会伴随着相当复杂的业务。于是，便想举一个 Featrue Toggle 的例子，尽管有一些不合适。但是，可能是最有价值的部分。</p><p><strong>物联网</strong></p><p>当我们谈及物联网的时候，我们会讨论事件触发、传输协议、海量数据（数据存储、数据分析）。而有了 Serverless，那么再多的数据，处理起来也是相当容易的一件事。对于一个物联网应用的服务端来说，系统需要收集来自各个地方的数据，并创建一个个 pipeline 来处理、过滤、转换这些数据，并将数据存储到数据库中。对于硬件开发人员来说，对接不同的硬件，本身就是一种挑战。而直接使用诸如 AWS IoT 这样国，可以在某种程度上，帮助我们更好地开发出写服务端连接的应用。</p><p><strong>数据统计分析等</strong></p><p>数据统计本身只需要很少的计算量，但是生成图表，则可以定期生成。在接收数据的时候，我们不需要考虑任何延时带来的问题。50~200 ms 的延时，并不会对我们的系统造成什么影响。</p><h2 id="2-4-serverless的厂家"><a href="#2-4-serverless的厂家" class="headerlink" title="2.4 serverless的厂家"></a>2.4 serverless的厂家</h2><ul><li><p>链接地址</p><ul><li><a href="https://aws.amazon.com/cn/lambda/" target="_blank" rel="noopener">亚马逊 AWS Lambda </a></li><li><a href="https://cloud.google.com/functions" target="_blank" rel="noopener">谷歌 Google Cloud Functions</a></li><li><a href="https://www.azure.cn/" target="_blank" rel="noopener">微软 Microsoft Azure</a></li><li><a href="https://www.aliyun.com/product/fc" target="_blank" rel="noopener">阿里云函数计算</a></li><li><a href="https://cloud.tencent.com/product/scf" target="_blank" rel="noopener">腾讯云 云函数 SCF(Serverless Cloud Function)</a></li><li><a href="https://www.huaweicloud.com/product/functiongraph.html" target="_blank" rel="noopener">华为云 FunctionGraph</a></li></ul></li><li><p>选择腾讯云的缘故</p><ul><li>微信小程序的云开发就是基于腾讯云，选择腾讯云更方便和小程序对接 </li><li>腾讯云在 <code>serverless</code> 方面相比其他厂商支持更好一些 </li><li>腾讯云的技术在线客服非常棒</li><li>腾讯云和<code>serverless</code> 合作在腾讯云中集成了 <code>serverless Framework</code>用我们喜欢的框架开发 <code>serverless</code> 应用。也可以让我们快速部署老项目。</li><li>价格更便宜</li></ul></li></ul><h1 id="二、微信小程序云开发"><a href="#二、微信小程序云开发" class="headerlink" title="二、微信小程序云开发"></a>二、微信小程序云开发</h1><h2 id="2-1-小程序传统开发模式"><a href="#2-1-小程序传统开发模式" class="headerlink" title="2.1 小程序传统开发模式"></a>2.1 小程序传统开发模式</h2><p>前后台联调时间有时候更多，等项目上线需要考虑更多运维的问题，买域名买服务器等</p><p><img src="https://blog.poetries.top/img/static/images/20210909110747.png" alt></p><h2 id="2-2-云开发正在改变小程序的开发模式"><a href="#2-2-云开发正在改变小程序的开发模式" class="headerlink" title="2.2 云开发正在改变小程序的开发模式"></a>2.2 云开发正在改变小程序的开发模式</h2><p><strong>云开发是什么</strong></p><blockquote><p>让开发者更专注于业务的开发，在云开发云函数中，我们可以很方便获取小程序用户openId、unionId一些鉴权信息，减轻后台开发量</p></blockquote><p>简单的说，就是云开发是一套综合类服务的技术产品，通常开发一个完整的应用（小程序也好，Web、移动应用也好）都需要数据库、存储、CDN、后端函数、静态托管、用户登录等等，但是云开发将这些服务都集成到了一起，而且以一种全新的开发方式，让开发一个应用更加快速、方便、便宜且强大，引领未来技术开发的新趋势。</p><p><img src="https://blog.poetries.top/img/static/images/20210909144650.png" alt></p><p>我们不需要区分那部分是前端那部分是后端，我们只需要调用函数一样去哪里这个流程就可以，云函数也可以在本地调式，调式云函数就像调式我们的代码一样的</p><p><strong>云开发优势</strong></p><ul><li>快速上线</li><li>更加专注我们的业务</li><li>独立开发一个完整的小程序，云开发提供非常丰富的接口，我们通过这些接口很方便文件上传等操作</li><li>不需要考虑运维等问题，云开发是弹性扩容的</li><li>数据更安全</li></ul><p><strong>小程序云开发提供哪些基础能力</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210909111446.png" alt></p><h2 id="2-3-小程序云函数计费"><a href="#2-3-小程序云函数计费" class="headerlink" title="2.3 小程序云函数计费"></a>2.3 小程序云函数计费</h2><p><strong>产品定价</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210908110237.png" alt></p><p><strong>支持地域</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210908110111.png" alt></p><p><strong>免费额度</strong></p><p>每个月的免费额度，会在每月开始时刻重置，不会进行累积</p><p><img src="https://blog.poetries.top/img/static/images/20210908110147.png" alt></p><p><strong>配额限制说明</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210908110721.png" alt></p><h2 id="2-4-小程序云开发项目的创建与配置"><a href="#2-4-小程序云开发项目的创建与配置" class="headerlink" title="2.4 小程序云开发项目的创建与配置"></a>2.4 小程序云开发项目的创建与配置</h2><p><img src="https://blog.poetries.top/img/static/images/20210830105322.png" alt></p><h3 id="云开发项目初始化"><a href="#云开发项目初始化" class="headerlink" title="云开发项目初始化"></a>云开发项目初始化</h3><p>找到云开发的环境ID，点击云开发控制台窗口里的设置图标，在环境变量的标签页找到环境名称和环境ID。</p><blockquote><p>用户在开通云开发之后就创建了一个云开发环境，微信小程序可拥有最多两个环境，每个环境都对应一整套独立的云开发资源，包括数据库、云存储、云函数、静态托管等，各个环境是相互独立的。每个环境都有一个唯一的环境ID（环境名称不唯一）。</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210830110227.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210830110241.png" alt></p><p><strong>指定开发者工具的云开发环境</strong></p><blockquote><p>当云开发服务开通后，我们可以在小程序源代码cloudfunctions文件夹名看到你的环境名称。如果在cloudfunctions文件夹名显示的不是环境名称，而是“未指定环境”，可以鼠标右键该文件夹，可以看到弹窗的第一项为“当前环境”，有个小三角，在这里可以选择或切换已经建好的云开发环境。如果环境为空白，重启开发者工具，再来选择。</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210830110613.png" alt></p><p><strong>指定小程序的云开发环境</strong></p><p>在开发者工具中打开源代码文件夹<code>miniprogram</code>里的app.js文件，找到如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.cloud.init(&#123;</span><br><span class="line">  <span class="comment">// env 参数说明：</span></span><br><span class="line">  <span class="comment">//   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源</span></span><br><span class="line">  <span class="comment">//   此处请填入环境 ID, 环境 ID 可打开云控制台查看</span></span><br><span class="line">  <span class="comment">//   如不填则使用默认环境（第一个创建的环境）</span></span><br><span class="line">  <span class="comment">// env: 'my-env-id',</span></span><br><span class="line">  traceUser: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://blog.poetries.top/img/static/images/20210830110805.png" alt></p><blockquote><p>在 env: ‘my-env-id’处改成你的环境ID，注意需要填入的是你的环境ID而不是环境名称哦，结果如下：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为云开发可以创建多个环境，比如微信小程序就可以创建两个免费的云开发环境，一个用于测试，一个用于正式发布。如果你没有在小程序端指定环境，会默认选择为你创建的第一个云开发环境。我们可以通过修改env的参数来切换小程序端用来调用的云开发环境。</span></span><br><span class="line">wx.cloud.init(&#123;</span><br><span class="line">  env: <span class="string">'cloud1-2g12nyjfdh7f4caed9'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 云开发能力全局只需要初始化一次即可，这里的traceUser属性设置为true，会将用户访问记录到用户管理中，在云开发控制台的运营分析—用户访问里可以看到访问记录。</span></span><br><span class="line">  traceUser: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="小程序云开发资源的管理"><a href="#小程序云开发资源的管理" class="headerlink" title="小程序云开发资源的管理"></a>小程序云开发资源的管理</h3><p><strong>小程序云开发控制台</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210830111520.png" alt></p><p><strong>腾讯云云开发网页控制台</strong></p><blockquote><p>我们还可以使用腾讯云云开发网页控制台来管理云开发资源，需要注意两点，一个是登录方式需要选择其他登录方式里的微信公众号，点击然后使用手机微信扫码，在微信上选择你要登录的小程序；二是要进入腾讯云后台之后切换选择云开发Cloudbase。</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210830111557.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210830111607.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210830111625.png" alt></p><h3 id="其他工具与方式"><a href="#其他工具与方式" class="headerlink" title="其他工具与方式"></a>其他工具与方式</h3><p>云开发资源还支持其他方式来调用</p><ul><li>CloudBase CLI：我们可以使用云开发提供的命令行工具 <a href="https://docs.cloudbase.net/cli/intro.html" target="_blank" rel="noopener">CloudBase CLI</a> 对云开发环境里面的资源进行批量管理，比如云函数批量下载更新；云存储里面的文件夹批量下载和上传等等；</li><li><code>Tencent CloudBase Toolkit</code>：Tencent CloudBase Toolkit是一款Visual Studio Code的云开发插件，使用这个插件可以更好地在本地进行云开发项目开发和代码调试，并且轻松将项目部署到云端；</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210830111817.png" alt></p><h3 id="部署并上传云函数"><a href="#部署并上传云函数" class="headerlink" title="部署并上传云函数"></a>部署并上传云函数</h3><p><strong>云函数的根目录与云函数目录</strong></p><blockquote><p>cloudfuntions文件夹图标里有朵小云，表示这就是云函数根目录。展开cloudfunctions，我们可以看到里面有login、openapi、callback、echo等文件夹，这些就是云函数目录。而miniprogram文件夹则放置的是小程序的页面文件</p></blockquote><p>cloudfunctions里放的是云函数，miniprogram放的是小程序的页面，这并不是一成不变的，也就是说你也可以修改这些文件夹的名称，这取决于项目配置文件<code>project.config.json</code>里的如下配置项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;miniprogramRoot&quot;:  &quot;miniprogram/&quot;,</span><br><span class="line">&quot;cloudfunctionRoot&quot;:  &quot;cloudfunctions/&quot;,</span><br></pre></td></tr></table></figure><p>但是你最好是让放小程序页面的文件夹以及放云函数的文件夹处于平级关系且都在项目的根目录下，便于管理。</p><p><strong>云函数部署与上传</strong></p><ul><li>右键云函数目录，选择在终端中打开，输入<code>npm install</code>命令下载依赖文件；</li><li>然后再右键云函数目录，点击“创建并部署：所有文件”</li><li>在云开发控制台–云函数–云函数列表查看云函数是否部署成功。</li></ul><h2 id="2-5-小程序云函数场景"><a href="#2-5-小程序云函数场景" class="headerlink" title="2.5 小程序云函数场景"></a>2.5 小程序云函数场景</h2><h3 id="小程序云开发对比不同方式获取用户信息的应用场景"><a href="#小程序云开发对比不同方式获取用户信息的应用场景" class="headerlink" title="小程序云开发对比不同方式获取用户信息的应用场景"></a>小程序云开发对比不同方式获取用户信息的应用场景</h3><p><img src="https://blog.poetries.top/img/static/images/20210909114318.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909115128.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909115658.png" alt></p><h3 id="小程序码"><a href="#小程序码" class="headerlink" title="小程序码"></a>小程序码</h3><p><img src="https://blog.poetries.top/img/static/images/20210909115740.png" alt></p><h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><p><img src="https://blog.poetries.top/img/static/images/20210905154352.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210905154454.png" alt></p><h3 id="云函数路由优化tcb-router"><a href="#云函数路由优化tcb-router" class="headerlink" title="云函数路由优化tcb-router"></a>云函数路由优化tcb-router</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i tcb-router</span><br></pre></td></tr></table></figure><p><img src="https://blog.poetries.top/img/static/images/20210909112822.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909112915.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909112943.png" alt></p><h3 id="云函数超时时间"><a href="#云函数超时时间" class="headerlink" title="云函数超时时间"></a>云函数超时时间</h3><p><img src="https://blog.poetries.top/img/static/images/20210905143347.png" alt></p><h3 id="订阅消息"><a href="#订阅消息" class="headerlink" title="订阅消息"></a>订阅消息</h3><ul><li>消息推送位置：服务通知</li><li>消息下发条件：用户自主订阅</li><li>消息卡片：查看详情可以跳转到小程序页面</li></ul><p><strong>使用步骤</strong></p><p>1、在微信公众平台上获取消息模板的ID<br>2、获取下发的权限：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.requestSubscribeMessage(&#123;</span><br><span class="line">    tmplIds: [&apos;模板ID&apos;],</span><br><span class="line">    success(res) &#123; </span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>subscribeNew</code>: 获取下发消息的权限，由用户自主选择订阅</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">subscribeNew:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   wx.requestSubscribeMessage(&#123;</span><br><span class="line">     tmplIds: [<span class="string">'模板ID'</span>],</span><br><span class="line">     success(res) &#123; </span><br><span class="line">       <span class="built_in">console</span>.log(res)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog.poetries.top/img/static/images/20210906134316.png" alt></p><p><img src="https://blog.poetries.top/img/static/images/20210905171014.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210905171103.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210905171125.png" alt></p><p><img src="https://blog.poetries.top/img/static/images/20210909113952.png" alt></p><p><img src="https://blog.poetries.top/img/static/images/20210905171621.png" alt></p><p>3、调用接口下发订阅消息：<code>subscribeMessage.send</code></p><p>这里是云调用订阅消息，首先要创建一个云函数</p><p>需要在config.json中配置<code>subscribeMessage.send</code>权限</p><p>config.json:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;permissions&quot;: &#123;</span><br><span class="line">  &quot;openapi&quot;: [</span><br><span class="line">    &quot;openapi.subscribeMessage.send&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>云函数编写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 云函数入口文件</span></span><br><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">'wx-server-sdk'</span>)</span><br><span class="line"></span><br><span class="line">cloud.init()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 云函数入口函数</span></span><br><span class="line">exports.main = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wxContext = cloud.getWXContext()</span><br><span class="line">  <span class="built_in">console</span>.log(event,<span class="string">'sendMessage'</span>)</span><br><span class="line">  <span class="comment">// 订阅消息推送</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> cloud.openapi.subscribeMessage.send(&#123;</span><br><span class="line">    touser: wxContext.OPENID,</span><br><span class="line">    page: <span class="string">`/pages/index/index`</span>,</span><br><span class="line">    lang: <span class="string">'zh_CN'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      name1: &#123;</span><br><span class="line">        value: event.user_name</span><br><span class="line">      &#125;,</span><br><span class="line">      thing7: &#123;</span><br><span class="line">        value: event.name</span><br><span class="line">      &#125;,</span><br><span class="line">      phone_number5: &#123;</span><br><span class="line">        value: event.phone</span><br><span class="line">      &#125;,</span><br><span class="line">      thing6: &#123;</span><br><span class="line">        value: event.xueli</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    templateId: <span class="string">'yXgBDeiRvjIZ98zOA1212CJeCXw8fj09Ir0sNT3ZXI7H0sw'</span>, <span class="comment">// 模板id</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog.poetries.top/img/static/images/20210909114130.png" alt></p><p>当用户订阅消息之后，就可以给用户下发消息了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view bindtap=&quot;sendNew&quot;&gt;发送消息&lt;/view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sendNew:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    wx.cloud.callFunction(&#123;</span><br><span class="line">      <span class="comment">// 要调用的云函数名称</span></span><br><span class="line">      name: <span class="string">'sendNew'</span>,</span><br><span class="line">      <span class="comment">// 传递给云函数的参数</span></span><br><span class="line">      data: &#123;</span><br><span class="line">        openid: <span class="string">''</span>,</span><br><span class="line">        theme:<span class="string">"团建"</span>,</span><br><span class="line">        address:<span class="string">"xx"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="comment">// output: res.result === 3</span></span><br><span class="line">      &#125;,</span><br><span class="line">      fail: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将云函数上传部署，使用手机测试，成功后，在微信的服务通知就会收到了订阅的消息</p><p><img src="https://blog.poetries.top/img/static/images/20210906134517.png" alt></p><h3 id="定时触发器"><a href="#定时触发器" class="headerlink" title="定时触发器"></a>定时触发器</h3><p>每天指定时间执行云函数</p><p><img src="https://blog.poetries.top/img/static/images/20210905143230.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210905143302.png" alt></p><h2 id="2-6-云数据库"><a href="#2-6-云数据库" class="headerlink" title="2.6 云数据库"></a>2.6 云数据库</h2><p><strong>1. 云数据库获取100条数据突破</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210905142630.png" alt></p><p><strong>2. 分页查询数据库</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210905143553.png" alt></p><p><strong>3. 模糊查询</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210909113505.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909113515.png" alt></p><p><strong>4. 数据权限管理</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210909113617.png" alt></p><p><strong>5. 云数据库中1对N关系的三种设计方式</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210905165740.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210905170014.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210905170132.png" alt></p><h2 id="2-7-小程序云函数调试"><a href="#2-7-小程序云函数调试" class="headerlink" title="2.7 小程序云函数调试"></a>2.7 小程序云函数调试</h2><h3 id="控制台调试"><a href="#控制台调试" class="headerlink" title="控制台调试"></a>控制台调试</h3><p><img src="https://blog.poetries.top/img/static/images/20210904213740.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210904214040.png" alt></p><h3 id="vscode本地调试"><a href="#vscode本地调试" class="headerlink" title="vscode本地调试"></a>vscode本地调试</h3><p>选择“云端函数”列表右侧的 ，向云端函数发送触发事件。</p><p><img src="https://blog.poetries.top/img/static/images/20210908143618.png" alt></p><h2 id="2-8-小程序云开发部署管理后台演示-触发云函数的运用"><a href="#2-8-小程序云开发部署管理后台演示-触发云函数的运用" class="headerlink" title="2.8 小程序云开发部署管理后台演示-触发云函数的运用"></a>2.8 小程序云开发部署管理后台演示-触发云函数的运用</h2><p><img src="https://blog.poetries.top/img/static/images/20210909123158.png" alt></p><h3 id="接口调用凭证access-token的缓存与更新"><a href="#接口调用凭证access-token的缓存与更新" class="headerlink" title="接口调用凭证access_token的缓存与更新"></a>接口调用凭证access_token的缓存与更新</h3><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html</a></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> rp = <span class="built_in">require</span>(<span class="string">'request-promise'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;APPID,SECRET&#125; = <span class="built_in">require</span>(<span class="string">'./config'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fileName = path.resolve(__dirname, <span class="string">'./access_token.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个接口调用都需要access_token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> URL = <span class="string">`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=<span class="subst">$&#123;APPID&#125;</span>&amp;secret=<span class="subst">$&#123;SECRET&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ![](https://blog.poetries.top/img/static/images/20210905185325.png)</span></span><br><span class="line"><span class="keyword">const</span> updateAccessToken = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> resStr = <span class="keyword">await</span> rp(URL)</span><br><span class="line">  <span class="keyword">const</span> res = <span class="built_in">JSON</span>.parse(resStr)</span><br><span class="line">  <span class="keyword">if</span>(res.access_token) &#123;</span><br><span class="line">    fs.writeFileSync(fileName,<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      access_token: res.access_token,</span><br><span class="line">      createTime: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> updateAccessToken()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getAccessToken = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = fs.readFileSync(fileName, <span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="built_in">JSON</span>.parse(res)</span><br><span class="line">    <span class="keyword">const</span> createTime = <span class="keyword">new</span> <span class="built_in">Date</span>(obj.createTime).getTime()</span><br><span class="line">    <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="keyword">if</span>((nowTime - createTime) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// token过期</span></span><br><span class="line">      <span class="keyword">await</span> updateAccessToken()</span><br><span class="line">      <span class="keyword">await</span> getAccessToken()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj.access_token</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">await</span> updateAccessToken()</span><br><span class="line">    <span class="keyword">await</span> getAccessToken()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setInterval(async () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   await updateAccessToken()</span></span><br><span class="line">  <span class="comment">// 在2小时上减去5分钟 提前刷新token 平滑过渡</span></span><br><span class="line"><span class="comment">// &#125;, (7200 - 300)*1000);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getAccessToken2 = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> resStr = <span class="keyword">await</span> rp(URL)</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">JSON</span>.parse(resStr)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> res.access_token</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = getAccessToken2</span><br></pre></td></tr></table></figure><h3 id="HTTP-API-触发云函数"><a href="#HTTP-API-触发云函数" class="headerlink" title="HTTP API 触发云函数"></a>HTTP API 触发云函数</h3><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-http-api/functions/invokeCloudFunction.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-http-api/functions/invokeCloudFunction.html</a></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils/callCloudFn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getAccessToken = <span class="built_in">require</span>(<span class="string">'./getAccessToken'</span>)</span><br><span class="line"><span class="keyword">const</span> rp = <span class="built_in">require</span>(<span class="string">'request-promise'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用云函数方法</span></span><br><span class="line"><span class="comment"> * @param &#123;d&#125; ctx </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; fnName </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; params </span></span><br><span class="line"><span class="comment"> * @returns </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> callCloudFn = <span class="keyword">async</span> (ctx, fnName, params) =&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> ACCESS_TOKEN = <span class="keyword">await</span> getAccessToken()</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    uri: <span class="string">`https://api.weixin.qq.com/tcb/invokecloudfunction?access_token=<span class="subst">$&#123;ACCESS_TOKEN&#125;</span>&amp;env=<span class="subst">$&#123;ctx.env&#125;</span>&amp;name=<span class="subst">$&#123;fnName&#125;</span>`</span>,</span><br><span class="line">    body: &#123;</span><br><span class="line">      ...params</span><br><span class="line">    &#125;,</span><br><span class="line">    json: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> rp(options).then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">JSON</span>.parse(res.resp_data).data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = callCloudFn</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils/callCloudStorage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getAccessToken = <span class="built_in">require</span>(<span class="string">'./getAccessToken'</span>)</span><br><span class="line"><span class="keyword">const</span> rp = <span class="built_in">require</span>(<span class="string">'request-promise'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件下载链接 把fileId转化成http地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> callCloudStorage = &#123;</span><br><span class="line">  <span class="keyword">async</span> download(ctx,fileList) &#123;</span><br><span class="line">    <span class="keyword">const</span> ACCESS_TOKEN = <span class="keyword">await</span> getAccessToken()</span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">      method: <span class="string">'POST'</span>,</span><br><span class="line">      uri: <span class="string">`https://api.weixin.qq.com/tcb/batchdownloadfile?access_token=<span class="subst">$&#123;ACCESS_TOKEN&#125;</span>`</span>,</span><br><span class="line">      body: &#123;</span><br><span class="line">        <span class="string">"file_list"</span>: fileList,</span><br><span class="line">        <span class="string">"env"</span>: ctx.env</span><br><span class="line">      &#125;,</span><br><span class="line">      json: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> rp(options).then(<span class="function"><span class="params">res</span>=&gt;</span>res)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 上传图片</span></span><br><span class="line">  <span class="keyword">async</span> upload(ctx) &#123;</span><br><span class="line">    <span class="keyword">const</span> ACCESS_TOKEN = <span class="keyword">await</span> getAccessToken()</span><br><span class="line">    <span class="keyword">const</span> file = ctx.request.files.file</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传到云存储指定文件夹blog</span></span><br><span class="line">    <span class="keyword">const</span> path = <span class="string">`day/<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>-<span class="subst">$&#123;<span class="built_in">Math</span>.random()&#125;</span>-<span class="subst">$&#123;file.name&#125;</span>`</span></span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">      method: <span class="string">'POST'</span>,</span><br><span class="line">      uri: <span class="string">`https://api.weixin.qq.com/tcb/uploadfile?access_token=<span class="subst">$&#123;ACCESS_TOKEN&#125;</span>`</span>,</span><br><span class="line">      body: &#123;</span><br><span class="line">        <span class="string">"path"</span>: path,</span><br><span class="line">        <span class="string">"env"</span>: ctx.env</span><br><span class="line">      &#125;,</span><br><span class="line">      json: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> info = <span class="keyword">await</span> rp(options).then(<span class="function"><span class="params">res</span>=&gt;</span>res)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(info,<span class="string">'----upload info----'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 上传图片</span></span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">      method: <span class="string">"POST"</span>,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">'content-type'</span>: <span class="string">"multipart/form-data"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      uri: info.url,</span><br><span class="line">      formData: &#123;</span><br><span class="line">        key: path,</span><br><span class="line">        Signature: info.authorization,</span><br><span class="line">        <span class="string">'x-cos-security-token'</span>: info.token,</span><br><span class="line">        <span class="string">'x-cos-meta-fileid'</span>: info.cos_file_id,</span><br><span class="line">        file: fs.createReadStream(file.path)</span><br><span class="line">      &#125;,</span><br><span class="line">      json: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> rp(params)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> info.file_id</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 删除云储存图片</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">delete</span>(ctx, fileid_list) &#123;</span><br><span class="line">    <span class="keyword">const</span> ACCESS_TOKEN = <span class="keyword">await</span> getAccessToken()</span><br><span class="line">    <span class="keyword">const</span> file = ctx.query.file </span><br><span class="line">    <span class="comment">// 上传到云存储指定文件夹blog</span></span><br><span class="line">    <span class="keyword">const</span> path = <span class="string">`blog/<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>-<span class="subst">$&#123;<span class="built_in">Math</span>.random()&#125;</span>-<span class="subst">$&#123;file&#125;</span>`</span></span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">      method: <span class="string">'POST'</span>,</span><br><span class="line">      uri: <span class="string">`https://api.weixin.qq.com/tcb/batchdeletefile?access_token=<span class="subst">$&#123;ACCESS_TOKEN&#125;</span>`</span>,</span><br><span class="line">      body: &#123;</span><br><span class="line">        <span class="string">"fileid_list"</span>: fileid_list,</span><br><span class="line">        <span class="string">"env"</span>: ctx.env</span><br><span class="line">      &#125;,</span><br><span class="line">      json: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> rp(options).then(<span class="function"><span class="params">res</span>=&gt;</span>res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = callCloudStorage</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/day/list'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> callCloudFn(ctx, <span class="string">'day'</span>, &#123;</span><br><span class="line">    $url: <span class="string">'list'</span>,</span><br><span class="line">    pageSize: <span class="number">30</span>,</span><br><span class="line">    pageNum: <span class="number">0</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 文件下载链接 cloud=&gt;http格式</span></span><br><span class="line">  <span class="keyword">let</span> fileList = []</span><br><span class="line">  data.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.image.indexOf(<span class="string">'cloud://'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      fileList.push(&#123;</span><br><span class="line">        fileid: v.image,</span><br><span class="line">        max_age: <span class="number">7200</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(fileList.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> downloadRes = <span class="keyword">await</span> callCloudStorage.download(ctx,fileList)</span><br><span class="line">    <span class="keyword">const</span> downloadFileList = downloadRes.file_list || []</span><br><span class="line">    </span><br><span class="line">    downloadFileList.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">      data.forEach(<span class="function"><span class="params">vv</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.fileid === vv.image) &#123;</span><br><span class="line">          <span class="comment">// 获取云存储的http图片路径</span></span><br><span class="line">          vv.image = v.download_url</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    data,</span><br><span class="line">    code: <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="三、不同厂商的serverless部署演示"><a href="#三、不同厂商的serverless部署演示" class="headerlink" title="三、不同厂商的serverless部署演示"></a>三、不同厂商的serverless部署演示</h1><h2 id="3-1-腾讯serverless"><a href="#3-1-腾讯serverless" class="headerlink" title="3.1 腾讯serverless"></a>3.1 腾讯serverless</h2><h3 id="1、Web-函数管理"><a href="#1、Web-函数管理" class="headerlink" title="1、Web 函数管理"></a>1、Web 函数管理</h3><p><strong>Web 函数运行原理如下图所示：</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210908112127.png" alt></p><p>用户发送的 HTTP 请求经过 API 网关后，网关侧将原生请求直接透传的同时，在请求头部添加了网关触发函数时需要的函数名、函数地域等内容，并一起传递到函数环境，触发后端函数执行。</p><p>函数环境内，通过内置的 Proxy 实现 Nginx 转发，并去除头部非产品规范的请求信息，将原生 HTTP 请求通过指定端口发送给用户的 Web Server 服务。</p><p>用户的 Web Server 配置好指定的监听端口9000和服务启动文件后部署到云端，通过该端口获取 HTTP 请求并进行处理。</p><p><strong>Web 函数请求限制</strong></p><ul><li>Web 函数只能通过 API 网关调用，不支持通过函数 API 接口触发。</li><li>在 Response headers 中有以下限制：<ul><li>所有 key 和 value 的大小不超过4KB。</li><li>body 的大小不超过6MB。</li></ul></li><li>部署您的 Web 服务时，<code>必须监听指定的 9000 端口</code>，不可以监听内部回环地址 <code>127.0.0.1</code>。</li><li>目前 HTTP 请求 Header 里的 Connection 字段不支持自定义配置。</li></ul><p><strong>启动文件作用</strong></p><blockquote><p>scf_bootstrap 为 Web Server 的启动文件，保证您的 Web 服务正常启动并监听请求。除此之外，您还可以根据需要在 scf_bootstrap 中自定义实现更多个性化操作：</p></blockquote><ul><li>设定运行时依赖库的路径及环境变量等。</li><li>加载自定义语言及版本依赖的库文件及扩展程序等，如仍有依赖文件需要实时拉取，可下载至 /tmp 目录。</li><li>解析函数文件，并执行函数调用前所需的全局操作或初始化程序（如开发工具包客户端 HTTP CLIENT 等初始化、数据库连接池创建等），便于调用阶段复用。</li><li>启动安全、监控等插件。</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210908113308.png" alt></p><p><strong>使用前提</strong></p><ul><li>需具有可执行权限，请确保您的 <code>scf_bootstrap</code> 文件具备777或755权限，否则会因为权限不足而无法执行。</li><li>能够在 SCF 系统环境（CentOS 7.6）中运行。</li><li>如果启动命令文件是 shell 脚本，第一行需有 <code>#!/bin/bash</code>。</li><li>启动命令必须为绝对路径 <code>/var/lang/${specific_lang}${version}/bin/${specific_lang}</code>，否则无法正常调用，详情请参见 <a href="https://cloud.tencent.com/document/product/583/56126#1" target="_blank" rel="noopener">标准语言环境绝对路径</a>。</li><li>建议使用监听地址为 <code>0.0.0.0</code>，不可以使用内部回环地址 <code>127.0.0.1</code></li></ul><p><strong>标准语言环境绝对路径</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210908113549.png" alt></p><p><strong>常见 Web Server 启动命令模版</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210908113613.png" alt></p><h3 id="2、serverless-fromework及控制台部署"><a href="#2、serverless-fromework及控制台部署" class="headerlink" title="2、serverless fromework及控制台部署"></a>2、serverless fromework及控制台部署</h3><blockquote><p>serverless文档 <a href="https://www.serverless.com/cn/framework/docs/" target="_blank" rel="noopener">https://www.serverless.com/cn/framework/docs/</a></p></blockquote><p><strong>1. 控制台部署</strong></p><p>部署koa2管理端接口</p><p><img src="https://blog.poetries.top/img/static/images/20210907164116.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210907164233.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210907164300.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210907164312.png" alt></p><blockquote><p>官方demo <a href="https://github.com/tencentyun/serverless-demo/blob/master/WebFunc-KoaDemo/src/app.js" target="_blank" rel="noopener">https://github.com/tencentyun/serverless-demo/blob/master/WebFunc-KoaDemo/src/app.js</a></p></blockquote><p>仓库关联GitHub，提交git代码自动更新</p><p><img src="https://blog.poetries.top/img/static/images/20210907171452.png" alt></p><p><strong>2. 命令行部署-Serverless Framework方式</strong></p><p><strong>云函数和serverless的区别</strong></p><ul><li><code>Serverless Framework</code> 是<code>Serverless</code>公司推出的一个开源的<code>Serverless</code> 应用开发框架。</li><li><code>Serverless Framework</code>是由 <code>Serverless Framework Plugin</code> 和 <code>Serverless Framework Components</code> 组成。</li><li><code>Serverless Framework Plugin</code> 实际上是一个函数的管理工具，使用这个工具，可以很轻松的<font color="#f00"><strong>部署函数、删除函数、触发函数、查看函数信息、查看函数日志、回滚函数、查看函数</strong></font> 数据等。简单的概括就是<code>serverless</code>其实就云函数的集合体，使用<code>serverless</code>后我们创建的云函数不需要手动去创建触发器等操作。</li><li>官方地址<ul><li><a href="https://www.serverless.com/" target="_blank" rel="noopener"><code>serverless</code>官网地址</a></li><li><a href="https://www.serverless.com/cn" target="_blank" rel="noopener"><code>serverless</code>中文官网</a></li><li><a href="https://github.com/serverless/serverless" target="_blank" rel="noopener"><code>github</code>地址</a></li></ul></li></ul><p><strong>Serverless Framework应用场景</strong></p><blockquote><p>什么场景下需要使用<code>serverless</code>，而不是使用云函数，其实在实际开发过程中，我们都是使用<code>serverless</code>而不去使用云函数，毕竟云函数的使用场景受限，或者说比较基础。打一个简单的比方，在写<code>js</code>操作<code>dom</code>的时候，你会选择用原生<code>js</code>还是会使用<code>jquery</code>一样的比喻。</p></blockquote><ul><li>基于云函数的命令行开发工具<ul><li>通过 <code>Serverless Framework</code>，开发者可以在命令行完成函数的开发、部署、调试。还可以结合前端服务、 API 网关、数据库等其它云上资源，实现全栈应用的快速部署。</li></ul></li><li>传统应用框架的快速迁移<ul><li><code>Serverless Framework</code> 提供了一套通用的框架迁移方案，通过使用 <code>Serverless Framework</code>提供的框架组件(<code>Egg/Koa/Express</code> 等，<font color="#f00"><a href="https://github.com/serverless" target="_blank" rel="noopener">更多的框架支持可以参考</a></font>)，原有应用仅需几行代码简单改造， 即可快速迁移到函数平台。同时支持命令行与控制台的开发方式。</li></ul></li></ul><blockquote><p>使用<code>serverless</code>命令创建第一个应用</p></blockquote><p>全局安装命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g serverless </span><br><span class="line">serverless -v</span><br></pre></td></tr></table></figure><p>创建项目</p><blockquote><p>在电脑的一个空目录下运行命令</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serverless</span><br></pre></td></tr></table></figure><p>根据提示选择你要创建的模板</p><blockquote><p>控制台输入 <code>serverless</code> </p></blockquote><p>选择对应的模板</p><p><img src="https://blog.poetries.top/img/static/images/20210909134505.png" alt></p><p>部署上线</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serverless deploy</span><br></pre></td></tr></table></figure><p><img src="https://blog.poetries.top/img/static/images/20210909135902.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909134955.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909135104.png" alt></p><p><strong>serverless.yml配置详情</strong></p><blockquote><blockquote><p><a href="https://github.com/serverless-components/tencent-http/blob/master/docs/configure.md" target="_blank" rel="noopener">https://github.com/serverless-components/tencent-http/blob/master/docs/configure.md</a></p></blockquote></blockquote><p>部署上线后可以在这里查看你的项目</p><p><img src="https://blog.poetries.top/img/static/images/20210907222947.png" alt></p><p>测试部署的项目</p><p><img src="https://blog.poetries.top/img/static/images/20210907222956.png" alt></p><p>删除部署的项目</p><p><img src="https://blog.poetries.top/img/static/images/20210909140209.png" alt></p><p><strong>3. 在vscode中配置插件来开发serverless</strong></p><p>在<code>vscode</code>上安装插件</p><p><img src="https://blog.poetries.top/img/static/images/20210908093524.png" alt></p><p>在<code>vscode</code>安装后插件登录并且拉取应用</p><p><img src="https://blog.poetries.top/img/static/images/20210908093544.png" alt></p><p>关于登录账号及密钥<a href="https://console.cloud.tencent.com/cam/capi" target="_blank" rel="noopener">查看地址</a></p><p>远程拉取代码</p><p><img src="https://blog.poetries.top/img/static/images/20210908093655.png" alt></p><p>下载后的代码如果想上传也可以直接上传的</p><p><img src="https://blog.poetries.top/img/static/images/20210908093704.png" alt></p><p><strong>WebIDE创建云函数实践</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210908094739.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210908094748.png" alt></p><h3 id="3、serverless部署前端项目"><a href="#3、serverless部署前端项目" class="headerlink" title="3、serverless部署前端项目"></a>3、serverless部署前端项目</h3><blockquote><p>建议使用 Serverless Framework CLI，可快速部署本地云函数</p></blockquote><ul><li>使用命令生成<code>vue</code>项目文件</li><li>直接将代码推送到云端就可以</li><li>也许你会好奇，我们正常的<code>vue</code>项目部署都要先<code>npm run build</code>,然后将打包后的<code>dist</code>目录传到服务器上的<code>nginx</code>静态目录下，这样才能访问</li><li>注意前端的项目部署都是存储到<code>oss</code>中的</li><li>使用<code>serverless</code>默认生成的项目是<code>vue2</code>版本的，如果你要部署<code>vue3</code>的项目需要手动构建</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># serverless.yml文件</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">website</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">vue-starter</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">vue-demo-70a4c710</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  src:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./src</span></span><br><span class="line">    <span class="comment"># 配置了这个hook每次发布的时候会先build</span></span><br><span class="line"><span class="attr">    hook:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"><span class="attr">    dist:</span> <span class="string">./dist</span></span><br><span class="line"><span class="attr">  bucketName:</span> <span class="string">my-vue-starter</span></span><br><span class="line"><span class="attr">  protocol:</span> <span class="string">https</span></span><br></pre></td></tr></table></figure><p><strong>手动构建一个<code>vue3</code>的项目</strong></p><ul><li><a href="https://github.com/serverless-components/tencent-website/" target="_blank" rel="noopener">参考文档</a></li><li>使用脚手架创建一个<code>vue3</code>项目</li><li>初始化一个<code>serverless.yml</code>文件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serverless init website-starter --name example</span><br></pre></td></tr></table></figure><blockquote><p>将这个<code>serverless.yml</code>文件复制到<code>vue3</code>项目中</p></blockquote><p>简单的修改下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">component:</span> <span class="string">website</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">websiteDemo</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">vue3-demo-6cb9842a</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  src:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./src</span></span><br><span class="line"><span class="attr">    hook:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"><span class="attr">    dist:</span> <span class="string">./dist</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">ap-guangzhou</span></span><br><span class="line"><span class="attr">  bucketName:</span> <span class="string">my-website-starter</span></span><br><span class="line"><span class="attr">  protocol:</span> <span class="string">https</span></span><br></pre></td></tr></table></figure><blockquote><p>部署上线 <code>serverless deploy</code></p></blockquote><p><strong>手动部署<code>react</code>项目</strong></p><blockquote><p>手动创建一个<code>react</code>项目</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx create-react-app react-demo --template typescript</span><br></pre></td></tr></table></figure><blockquote><p>在<code>react</code>根目录下创建一个<code>serverless.yml</code>的文件</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">component:</span> <span class="string">website</span></span><br><span class="line"><span class="comment"># 这里修改下</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">react-starter</span></span><br><span class="line"><span class="comment"># 这里修改下</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">reactDemo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line"><span class="attr">  src:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">./src</span></span><br><span class="line"><span class="attr">    hook:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">    <span class="comment"># 这里要根据你打包后的目录</span></span><br><span class="line"><span class="attr">    dist:</span> <span class="string">./build</span></span><br><span class="line">  <span class="comment"># 这个定义下</span></span><br><span class="line"><span class="attr">  bucketName:</span> <span class="string">my-react-starter</span></span><br><span class="line"><span class="attr">  protocol:</span> <span class="string">https</span></span><br></pre></td></tr></table></figure><blockquote><p>推送到云端 <code>serverless deploy</code></p></blockquote><p><strong>使用静态文件托管来部署前端项目</strong></p><ul><li>先本地根据项目命令打包好</li><li>在云产品中选择静态文件托管</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210908100907.png" alt></p><ul><li>直接将上传你打包后的代码</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210908100915.png" alt></p><h3 id="4、在serverless中连接mysql"><a href="#4、在serverless中连接mysql" class="headerlink" title="4、在serverless中连接mysql"></a>4、在serverless中连接mysql</h3><p><strong>数据库的准备</strong></p><blockquote><p>使用<code>serverless</code>开发与我们自己使用云服务器服务器<code>ECS</code>不一样的，因为我们不能在<code>serverless</code>上安装软件(我们不能安装第三方的<code>mysql</code>、<code>docker</code>、<code>redis</code>)等软件，因此我们在使用<code>serverless</code>开发的时候，如果我们项目中使用到了比如:<code>mysql</code>、<code>redis</code>、<code>rabbitMQ</code>、<code>RocketMQ</code>类的我们就需要自行解决。下面介绍几种方式</p></blockquote><ol><li>自己有一台备用的云服务器<code>ECS</code>，我们在上面安装了需要的软件，对外提供了<code>IP</code>或者域名，在安全组中开放了端口号以供我们在<code>serverless</code>中使用。<font color="#f00">其实如果你自己有云服务器<code>ECS</code>可能就不会考虑使用<code>serverless</code>来开发了</font></li><li>单独使用第三方付费或者按量收费的数据库，比如:<ul><li>阿里云的<a href="https://www.aliyun.com/product/rds/mysql" target="_blank" rel="noopener">云数据库RDS MySQL</a></li><li>腾讯云的数据库<a href="https://buy.cloud.tencent.com/cdb?" target="_blank" rel="noopener">云数据库</a></li></ul></li><li>使用腾讯云官方自带的有免费额度的<code>NoSQL</code>数据库<a href="https://docs.cloudbase.net/database/data-type.html#date" target="_blank" rel="noopener">参考文档</a>，本训练营会介绍如何使用，但是在项目中不会使用。</li><li>我在自己的服务器上使用<code>docker</code>搭建了一个<code>mysql8</code>版本的数据库，以供大家学习使用，自己根据自己的名字来在上面创建自己的数据库。<font color="#f00">大家自行保存地址，如果自己有服务器的，可以自己服务器上搭建，就不需要用我这个</font></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ip地址</span><br><span class="line">8.129.234.99</span><br><span class="line"># 用户名</span><br><span class="line">root</span><br><span class="line"># 密码</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p><strong>在<code>serverless</code>中连接<code>mysql</code></strong></p><p>本案例只是测试官方案例连接数据库，不涉及什么知识点，根据自身条件选择是否跳过</p><blockquote><p>在函数服务中选择<code>mysql</code>数据库模板来创建数据库云函数应用。<font color="#f00">注意选择的语音和区域</font></p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210908101905.png" alt></p><blockquote><p>在自己的数据库中创建数据库及数据表</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建数据表sql</span><br><span class="line">CREATE TABLE `account` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键id&apos;,</span><br><span class="line">  `username` varchar(50) NOT NULL COMMENT &apos;用户名&apos;,</span><br><span class="line">  `password` varchar(100) NOT NULL COMMENT &apos;密码&apos;,</span><br><span class="line">  `created_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) COMMENT &apos;创建时间&apos;,</span><br><span class="line">  `updated_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) COMMENT &apos;更新时间&apos;,</span><br><span class="line">  `deleted_at` timestamp(6) NULL DEFAULT NULL COMMENT &apos;软删除时间&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 插入几条数据sql</span><br><span class="line">insert into account(username, password) values(&apos;admin&apos;, &apos;123456&apos;);</span><br><span class="line">insert into account(username, password) values(&apos;张三&apos;, &apos;123456&apos;);</span><br></pre></td></tr></table></figure><blockquote><p>打开云函数的代码管理修改数据库的连接配置</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210908101915.png" alt></p><blockquote><p>进入代码编辑界面的函数代码编辑代码</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapPromise</span>(<span class="params">connection, sql</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    connection.query(sql, <span class="function"><span class="keyword">function</span>(<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        rej(error)</span><br><span class="line">      &#125;</span><br><span class="line">      res(results)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">exports.main_handler = <span class="keyword">async</span> (event, context, callback) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line">  <span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">    host: <span class="string">'8.129.234.99'</span>, <span class="comment">//  云数据库实例ip地址</span></span><br><span class="line">    user: <span class="string">'root'</span>, <span class="comment">// 云数据库用户名，如root</span></span><br><span class="line">    password: <span class="string">'123456'</span>, <span class="comment">// 云数据库密码</span></span><br><span class="line">    database: <span class="string">'serverless_nest'</span> <span class="comment">//  数据库名称</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  connection.connect();</span><br><span class="line">  <span class="comment">// 你需要查询的sql文件</span></span><br><span class="line">  <span class="keyword">const</span> querySql = <span class="string">`SELECT * from account`</span></span><br><span class="line">  <span class="comment">// 查询结果</span></span><br><span class="line">  <span class="keyword">let</span> queryResult = <span class="keyword">await</span> wrapPromise(connection, querySql)</span><br><span class="line">  </span><br><span class="line">  connection.end();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> queryResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改完成后点击部署和测试</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210908101926.png" alt></p><p>出现下面界面表示你已经在云函数中连接<code>mysql</code>成功了</p><p><img src="https://blog.poetries.top/img/static/images/20210908101935.png" alt></p><blockquote><p>如果你想在浏览器上测试访问，可以点击<strong>触发管理</strong></p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210908101943.png" alt></p><h3 id="5、云开发与serverless的区别"><a href="#5、云开发与serverless的区别" class="headerlink" title="5、云开发与serverless的区别"></a>5、云开发与serverless的区别</h3><ul><li><code>Serverless Framework</code> 是无服务器应用框架，提供将云函数<code>SCF</code>、<code>API</code> 网关、对象存储 <code>COS</code>、云数据库 <code>DB</code> 等资源组合的业务框架，开发者可以直接基于框架编写业务逻辑，而无需关注底层资源的配置和管理。</li><li>云开发（<code>Tencent CloudBase，TCB</code>）是腾讯云提供的云原生一体化开发环境和工具平台，为开发者提供高可用、自动弹性扩缩的后端云服务，包含计算、存储、托管等 <code>serverless</code> 化能力，可用于云端一体化开发多种端应用（小程序、公众号、<code>Web</code> 应用、<code>Flutter</code> 客户端等），帮助开发者统一构建和管理后端服务和云资源，避免了应用开发过程中繁琐的服务器搭建及运维，开发者可以专注于业务逻辑的实现，开发门槛更低，效率更高。</li><li><strong>二者最大的区别是</strong>：给开发者使用的平台支持不一样，云开发支持web端、QQ、微信小程序级静态网站托管等这些平台服务。</li></ul><p><strong>使用云开发创建一个<code>nest</code>项目</strong></p><p>在产品中选择云开发产品</p><p><img src="https://blog.poetries.top/img/static/images/20210908102916.png" alt></p><p>创建一个项目,注意点:这里要选择好区域，下次创建了项目，区域不一样，可能项目就看不到</p><p><img src="https://blog.poetries.top/img/static/images/20210908102926.png" alt></p><p>使用模板创建</p><p><img src="https://blog.poetries.top/img/static/images/20210908102935.png" alt></p><p>查看自己创建应用并且访问</p><p><img src="https://blog.poetries.top/img/static/images/20210908102946.png" alt></p><p><strong>使用脚手架的方式创建</strong></p><p>全局安装脚手架包<a href="https://docs.cloudbase.net/cli/intro.html" target="_blank" rel="noopener">官方地址</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g @cloudbase/cli</span><br></pre></td></tr></table></figure><p>测试安装是否成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloudbase -v</span><br></pre></td></tr></table></figure><p>登录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloudbase login</span><br></pre></td></tr></table></figure><p>本地创建项目</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcb new &lt;appName&gt; [template] </span><br><span class="line"># 比如</span><br><span class="line">tcb new nest-cloundbase nest-starter</span><br></pre></td></tr></table></figure><p>选择自己已经创建的环境,如果没有就 创建新环境,这时候会打开浏览器</p><p><img src="https://blog.poetries.top/img/static/images/20210908102958.png" alt></p><p>本地打开项目并且安装依赖包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>部署到线上</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run deploy</span><br></pre></td></tr></table></figure><p><img src="https://blog.poetries.top/img/static/images/20210908103013.png" alt></p><p><strong>在云开发中使用<code>NoSQL</code></strong></p><p>在面板上创建一个<code>NoSQL</code>的数据库，<a href="https://docs.cloudbase.net/database/introduce.html" target="_blank" rel="noopener">参考地址</a></p><p><img src="https://blog.poetries.top/img/static/images/20210908103028.png" alt></p><p>在项目中安装连接数据库的<code>SDK</code><a href="https://docs.cloudbase.net/api-reference/server/node-sdk/introduction.html" target="_blank" rel="noopener">参考文档</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @cloudbase/node-sdk</span><br></pre></td></tr></table></figure><p>初始化数据库连接<a href="https://docs.cloudbase.net/api-reference/server/node-sdk/initialization.html#init" target="_blank" rel="noopener">参考地址</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cloudbase <span class="keyword">from</span> <span class="string">'@cloudbase/node-sdk'</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注意以下几个参数是必填的,文档上说的是非必填</span></span><br><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">  secretId: <span class="string">'xx'</span>,</span><br><span class="line">  secretKey: <span class="string">'yy'</span>,</span><br><span class="line">  env: <span class="string">'xx'</span>,</span><br><span class="line">  <span class="comment">// 根据你创建的区域来写,目前只有上海(ap-shanghai)、广州(ap-guangzhou)</span></span><br><span class="line">  region: <span class="string">'ap-shanghai'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取数据库引用</span></span><br><span class="line"><span class="keyword">const</span> db = app.database();</span><br></pre></td></tr></table></figure><p>关于获取<code>secretId</code>、<code>secretKey</code>、<code>env</code>的地址</p><ul><li><code>env</code>的获取地址</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210908103040.png" alt></p><ul><li><code>secretId</code> 和<code>secretKey</code>获取</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210908103051.png" alt></p><ul><li>点击<code>test</code>用户进入</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210908103101.png" alt></p><p>根据文档，我们将插入一条数据(<strong>同样先忽视类型检测</strong>)</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> createAccount(data: <span class="built_in">any</span>): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> db.collection(<span class="string">'account'</span>)</span><br><span class="line">    .add(&#123;</span><br><span class="line">      ...data,</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>环境变量的配置</strong></p><p>本地开发环境变量的配置</p><ul><li>安装依赖包</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install dotenv</span><br><span class="line">npm install @types/dotenv -D</span><br></pre></td></tr></table></figure><blockquote><p>在项目根目录下创建一个<code>.env</code>的文件用来存储一些敏感信息</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PORT=7000</span><br><span class="line"></span><br><span class="line">SECRET_ID = AKIDMfCxx2stVYNUx</span><br><span class="line">SECRET_KEY = d3C7pxxxv1VqiMrBHS</span><br><span class="line">ENV = serverlxxim00f1a872</span><br><span class="line">REGION = ap-guangzhou</span><br></pre></td></tr></table></figure><p>在应用中使用使用环境变量的值</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = cloudbase.init(&#123;</span><br><span class="line">  secretId: process.env.SECRET_ID,</span><br><span class="line">  secretKey: process.env.SECRET_KEY,</span><br><span class="line">  env: process.env.ENV,</span><br><span class="line">  <span class="comment">// 根据你创建的区域来写,目前只有上海(ap-shanghai)、广州(ap-guangzhou)</span></span><br><span class="line">  region: process.env.REGION</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-2-阿里云函数部署"><a href="#3-2-阿里云函数部署" class="headerlink" title="3.2 阿里云函数部署"></a>3.2 阿里云函数部署</h2><p><img src="https://blog.poetries.top/img/static/images/20210907200749.png" alt></p><h2 id="3-3-vercel部署"><a href="#3-3-vercel部署" class="headerlink" title="3.3 vercel部署"></a>3.3 vercel部署</h2><blockquote><p>国外挺好用的一个serverless免费平台</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210909140036.png" alt><br><img src="https://blog.poetries.top/img/static/images/20210909140058.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Serverless-架构详解&quot;&gt;&lt;a href=&quot;#一、Serverless-架构详解&quot; class=&quot;headerlink&quot; title=&quot;一、Serverless 架构详解&quot;&gt;&lt;/a&gt;一、Serverless 架构详解&lt;/h1&gt;&lt;h2 id=&quot;1-1-什
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="serverless" scheme="http://blog.poetries.top/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>微前端实战总结篇</title>
    <link href="http://blog.poetries.top/2021/07/31/micro-fe-summary/"/>
    <id>http://blog.poetries.top/2021/07/31/micro-fe-summary/</id>
    <published>2021-07-31T12:35:08.000Z</published>
    <updated>2025-03-30T13:54:29.486Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog.poetries.top/img/static/images/20210710171426.png" alt></p><p>微前端现有的落地方案可以分为三类，自组织模式、基座模式以及模块加载模式。</p><h2 id="一、为什么需要微前端"><a href="#一、为什么需要微前端" class="headerlink" title="一、为什么需要微前端?"></a>一、为什么需要微前端?</h2><p>这里我们通过3W(what,why,how)的方式来讲解什么是微前端：</p><h3 id="1-What-什么是微前端"><a href="#1-What-什么是微前端" class="headerlink" title="1.What?什么是微前端?"></a>1.What?什么是微前端?</h3><p><img src="https://blog.poetries.top/img/static/images/20210731160243.png" alt></p><p>微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。</p><blockquote><p>微前端的核心在于拆, 拆完后再合!</p></blockquote><h3 id="2-Why-为什么去使用他"><a href="#2-Why-为什么去使用他" class="headerlink" title="2.Why?为什么去使用他?"></a>2.Why?为什么去使用他?</h3><ul><li>不同团队间开发同一个应用技术栈不同怎么破？</li><li>希望每个团队都可以独立开发，独立部署怎么破？</li><li>项目中还需要老的应用代码怎么破？</li></ul><blockquote><p>我们是不是可以将一个应用划分成若干个子应用，再将子应用打包成一个个的lib呢？当路径切换时加载不同的子应用，这样每个子应用都是独立的，技术栈也就不用再做限制了！从而解决了前端协同开发的问题。</p></blockquote><h3 id="3-How-怎样落地微前端"><a href="#3-How-怎样落地微前端" class="headerlink" title="3.How?怎样落地微前端?"></a>3.How?怎样落地微前端?</h3><p><img src="https://blog.poetries.top/img/static/images/20210731154621.png" alt></p><ul><li>2018年 <code>Single-SPA</code>诞生了， <code>single-spa</code>是一个用于前端微服务化的JavaScript前端解决方案  (本身没有处理样式隔离、js执行隔离)  实现了路由劫持和应用加载；</li><li>2019年 qiankun基于Single-SPA, 提供了更加开箱即用的 API  (<code>single-spa + sandbox + import-html-entry</code>)，它 做到了技术栈无关，并且接入简单(有多简单呢，像iframe一样简单)</li></ul><blockquote><p>总结：子应用可以独立构建，运行时动态加载，主子应用完全解耦，并且技术栈无关，靠的是协议接入(这里提前强调一下：子应用必须导出 <code>bootstrap、mount、unmount</code>三个方法)。</p></blockquote><p>这里先回答一下大家可能会有的疑问：</p><p><strong>这不是iframe吗？</strong></p><blockquote><p>如果使用的是<code>iframe</code>，当iframe中的子应用切换路由时用户刷新页面就尴尬了。</p></blockquote><p><strong>应用间如何通信？</strong></p><ul><li>基于URL来进行数据传递，但是这种传递消息的方式能力较弱</li><li>基于CustomEvent实现通信；</li><li><ul><li>基于props主子应用间通信；</li></ul></li><li>使用全局变量、Redux进行通信</li></ul><p><strong>如何处理公共依赖？</strong></p><ul><li>CDN - <code>externals</code></li><li>webpack<code>联邦模块</code></li></ul><h2 id="二、SingleSpa实战"><a href="#二、SingleSpa实战" class="headerlink" title="二、SingleSpa实战"></a>二、SingleSpa实战</h2><blockquote><p>官网 <a href="https://zh-hans.single-spa.js.org/docs/configuration" target="_blank" rel="noopener">https://zh-hans.single-spa.js.org/docs/configuration</a></p></blockquote><h3 id="1-构建子应用"><a href="#1-构建子应用" class="headerlink" title="1.构建子应用"></a>1.构建子应用</h3><blockquote><p>首先创建一个vue子应用，并通过<code>single-spa-vue</code>来导出必要的生命周期：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create spa-vue  </span><br><span class="line">npm install single-spa-vue</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> singleSpaVue <span class="keyword">from</span> <span class="string">'single-spa-vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appOptions = &#123;</span><br><span class="line">   el: <span class="string">'#vue'</span>,</span><br><span class="line">   router,</span><br><span class="line">   render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在非子应用中正常挂载应用</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.singleSpaNavigate)&#123;</span><br><span class="line"> <span class="keyword">delete</span> appOptions.el;</span><br><span class="line"> <span class="keyword">new</span> Vue(appOptions).$mount(<span class="string">'#app'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vueLifeCycle = singleSpaVue(&#123;</span><br><span class="line">   Vue,</span><br><span class="line">   appOptions</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子应用必须导出以下生命周期：bootstrap、mount、unmount</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bootstrap = vueLifeCycle.bootstrap;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mount = vueLifeCycle.mount;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> unmount = vueLifeCycle.unmount;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> vueLifeCycle;</span><br></pre></td></tr></table></figure><p><strong>配置子路由基础路径</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  base: <span class="string">'/vue'</span>,   <span class="comment">//改变路径配置</span></span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://blog.poetries.top/img/static/images/20210731155249.png" alt></p><h3 id="2-配置库打包"><a href="#2-配置库打包" class="headerlink" title="2.配置库打包"></a>2.配置库打包</h3><blockquote><p>将子模块打包成类库</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    configureWebpack: &#123;</span><br><span class="line">    <span class="comment">// 把属性挂载到window上方便父应用调用 window.singleVue.bootstrap/mount/unmount</span></span><br><span class="line">        output: &#123;</span><br><span class="line">            library: <span class="string">'singleVue'</span>,</span><br><span class="line">            libraryTarget: <span class="string">'umd'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        devServer:&#123;</span><br><span class="line">            port:<span class="number">10000</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog.poetries.top/img/static/images/20210731114005.png" alt></p><h3 id="3-主应用搭建"><a href="#3-主应用搭建" class="headerlink" title="3.主应用搭建"></a>3.主应用搭建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">    &lt;router-link to=&quot;/vue&quot;&gt;vue项目router-link&gt; </span><br><span class="line">    &lt;div id=&quot;vue&quot;&gt;div&gt;</span><br><span class="line">div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>将子应用挂载到<code>id=&quot;vue&quot;</code>标签中</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> &#123;registerApplication,start&#125; <span class="keyword">from</span> <span class="string">'single-spa'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">    script.src = url </span><br><span class="line">    script.onload = resolve</span><br><span class="line">    script.onerror = reject</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册应用</span></span><br><span class="line">registerApplication(<span class="string">'myVueApp'</span>,</span><br><span class="line">  <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'load'</span>)</span><br><span class="line">    <span class="comment">// singlespa问题 </span></span><br><span class="line">    <span class="comment">// 加载文件需要自己构建script标签 但是不知道应用有多少个文件</span></span><br><span class="line">    <span class="comment">// 样式不隔离</span></span><br><span class="line">    <span class="comment">// 全局对象没有js沙箱的机制 比如加载不同的应用 每个应用都用同一个环境</span></span><br><span class="line">    <span class="comment">// 先加载公共的</span></span><br><span class="line">    <span class="keyword">await</span> loadScript(<span class="string">'http://localhost:10000/js/chunk-vendors.js'</span>)</span><br><span class="line">    <span class="keyword">await</span> loadScript(<span class="string">'http://localhost:10000/js/app.js'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.singleVue <span class="comment">// bootstrap mount unmount</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 用户切换到/vue下 我们需要加载刚才定义的子应用</span></span><br><span class="line">  location=&gt;location.pathname.startsWith(<span class="string">'/vue'</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://blog.poetries.top/img/static/images/20210731155355.png" alt></p><h3 id="4-动态设置子应用publicPath"><a href="#4-动态设置子应用publicPath" class="headerlink" title="4.动态设置子应用publicPath"></a>4.动态设置子应用publicPath</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.singleSpaNavigate)&#123;</span><br><span class="line">  __webpack_public_path__ = <span class="string">'http://localhost:10000/'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、qiankun实战"><a href="#三、qiankun实战" class="headerlink" title="三、qiankun实战"></a>三、qiankun实战</h2><blockquote><p><code>qiankun</code>是目前比较完善的一个微前端解决方案，它已在蚂蚁内部经受过足够大量的项目考验及打磨，十分健壮。这里附上官网。</p></blockquote><blockquote><p><a href="https://qiankun.umijs.org/zh/guide" target="_blank" rel="noopener">https://qiankun.umijs.org/zh/guide</a></p></blockquote><h3 id="1-主应用编写"><a href="#1-主应用编写" class="headerlink" title="1.主应用编写"></a>1.主应用编写</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--注意这里不要写app 否则跟子应用的加载冲突</span></span><br><span class="line"><span class="comment">  &lt;div id="app"&gt;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-menu</span> <span class="attr">:router</span>=<span class="string">"true"</span> <span class="attr">mode</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 基座中可以放自己的路由 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- 引用其他子应用 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">"/vue"</span>&gt;</span>vue应用<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">"/react"</span>&gt;</span>react应用<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 其他子应用的挂载节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"vue"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"react"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注册子应用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; registerMicroApps,start &#125; <span class="keyword">from</span> <span class="string">'qiankun'</span></span><br><span class="line"><span class="comment">// 基座写法</span></span><br><span class="line"><span class="keyword">const</span> apps = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'vueApp'</span>, <span class="comment">// 名字</span></span><br><span class="line">    <span class="comment">// 默认会加载这个HTML，解析里面的js动态执行 （子应用必须支持跨域）</span></span><br><span class="line">    entry: <span class="string">'//localhost:10000'</span>,  </span><br><span class="line">    container: <span class="string">'#vue'</span>, <span class="comment">// 容器</span></span><br><span class="line">    activeRule: <span class="string">'/vue'</span>, <span class="comment">// 激活的路径 访问/vue把应用挂载到#vue上</span></span><br><span class="line">    props: &#123; <span class="comment">// 传递属性给子应用接收</span></span><br><span class="line">      a: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'reactApp'</span>,</span><br><span class="line">    <span class="comment">// 默认会加载这个HTML，解析里面的js动态执行 （子应用必须支持跨域）</span></span><br><span class="line">    entry: <span class="string">'//localhost:20000'</span>,  </span><br><span class="line">    container: <span class="string">'#react'</span>,</span><br><span class="line">    activeRule: <span class="string">'/react'</span> <span class="comment">// 访问/react把应用挂载到#react上</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">registerMicroApps(apps)</span><br><span class="line"><span class="comment">// 开启</span></span><br><span class="line">start(&#123;</span><br><span class="line">  prefetch: <span class="literal">false</span> <span class="comment">// 取消预加载</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-子Vue应用"><a href="#2-子Vue应用" class="headerlink" title="2.子Vue应用"></a>2.子Vue应用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  <span class="comment">// base里主应用里面注册的保持一致</span></span><br><span class="line">  base: <span class="string">'/vue'</span>,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  instance = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;).$mount(<span class="string">'#app'</span>) <span class="comment">// 这里是挂载到自己的HTML中 基座会拿到挂载后的HTML 将其插入进去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 独立运行微应用</span></span><br><span class="line"><span class="comment">// https://qiankun.umijs.org/zh/faq#%E5%A6%82%E4%BD%95%E7%8B%AC%E7%AB%8B%E8%BF%90%E8%A1%8C%E5%BE%AE%E5%BA%94%E7%94%A8%EF%BC%9F</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  render()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果被qiankun使用 会动态注入路径</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  <span class="comment">// qiankun 将会在微应用 bootstrap 之前注入一个运行时的 publicPath 变量，你需要做的是在微应用的 entry js 的顶部添加如下代码：</span></span><br><span class="line">  __webpack_public_path__ = <span class="built_in">window</span>.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子应用的协议 导出供父应用调用 必须导出promise</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params">props</span>) </span>&#123;&#125; <span class="comment">// 启动可以不用写 需要导出方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  render()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  instance.$destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里不要忘记子应用的钩子导出。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        port:<span class="number">10000</span>,</span><br><span class="line">        headers:&#123;</span><br><span class="line">            <span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span> <span class="comment">//允许访问跨域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    configureWebpack:&#123;</span><br><span class="line">        <span class="comment">// 打umd包</span></span><br><span class="line">        output:&#123;</span><br><span class="line">            library:<span class="string">'vueApp'</span>,</span><br><span class="line">            libraryTarget:<span class="string">'umd'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-子React应用"><a href="#3-子React应用" class="headerlink" title="3.子React应用"></a>3.子React应用</h3><blockquote><p>再起一个子应用，为了表明技术栈无关特性，这里使用了一个<code>React</code>项目：</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// app.js</span><br><span class="line"></span><br><span class="line">import logo from './logo.svg';</span><br><span class="line">import './App.css';</span><br><span class="line">import &#123;BrowserRouter,Route,Link&#125; from 'react-router-dom'</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    // /react跟主应用配置保持一致</span><br><span class="line">    <span class="tag">&lt;<span class="name">BrowserRouter</span> <span class="attr">basename</span>=<span class="string">"/react"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/"</span> <span class="attr">exact</span> <span class="attr">render</span>=<span class="string">&#123;()</span>=&gt;</span>(</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"App"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">header</span> <span class="attr">className</span>=<span class="string">"App-header"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;logo&#125;</span> <span class="attr">className</span>=<span class="string">"App-logo"</span> <span class="attr">alt</span>=<span class="string">"logo"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">              Edit <span class="tag">&lt;<span class="name">code</span>&gt;</span>src/App.js<span class="tag">&lt;/<span class="name">code</span>&gt;</span> and save to reload.</span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">              <span class="attr">className</span>=<span class="string">"App-link"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">href</span>=<span class="string">"https://reactjs.org"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">target</span>=<span class="string">"_blank"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">rel</span>=<span class="string">"noopener noreferrer"</span></span></span><br><span class="line"><span class="tag">            &gt;</span></span><br><span class="line">              Learn React</span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      )&#125; /&gt;</span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/about"</span> <span class="attr">exact</span> <span class="attr">render</span>=<span class="string">&#123;()</span>=&gt;</span>(</span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>About Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      )&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> reportWebVitals <span class="keyword">from</span> <span class="string">'./reportWebVitals'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;React.StrictMode&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/React.StrictMode&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ If you want to start measuring performance in your app, pass a function</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ to log results (for example: reportWebVitals(console.log))</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ or send to an analytics endpoint. Learn more: https:/</span><span class="regexp">/bit.ly/</span>CRA-vitals</span><br><span class="line">reportWebVitals();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 独立运行</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.__POWERED_BY_QIANKUN__)&#123;</span><br><span class="line">  render()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子应用协议</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  render()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(<span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重写react中的webpack配置文件 (config-overrides.js)</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add react-app-rewired --save-dev</span><br></pre></td></tr></table></figure><blockquote><p>修改package.json文件</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// react-scripts 改成 react-app-rewired</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"react-app-rewired start"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"react-app-rewired build"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"react-app-rewired test"</span>,</span><br><span class="line">    <span class="string">"eject"</span>: <span class="string">"react-app-rewired eject"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><blockquote><p>在根目录新建配置文件</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置文件重写</span></span><br><span class="line">touch config-overrides.js</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config-overrides.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  webpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 名字和基座配置的一样</span></span><br><span class="line">    config.output.library = <span class="string">'reactApp'</span>;</span><br><span class="line">    config.output.libraryTarget = <span class="string">"umd"</span>;</span><br><span class="line">    config.output.publicPath = <span class="string">'http://localhost:20000/'</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: <span class="function"><span class="keyword">function</span> (<span class="params">configFunction</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">proxy, allowedHost</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> config = configFunction(proxy, allowedHost);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 配置跨域</span></span><br><span class="line">      config.headers = &#123;</span><br><span class="line">        <span class="string">"Access-Control-Allow-Origin"</span>: <span class="string">"*"</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>配置.env文件</strong></p><blockquote><p>根目录新建<code>.env</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PORT=20000</span><br><span class="line"># socket发送端口</span><br><span class="line">WDS_SOCKET_PORT=20000</span><br></pre></td></tr></table></figure><p><strong>React路由配置</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Route, Link &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BASE_NAME = <span class="built_in">window</span>.__POWERED_BY_QIANKUN__ ? <span class="string">"/react"</span> : <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;BrowserRouter basename=&#123;BASE_NAME&#125;&gt;&lt;Link to="/"&gt;首页Link&gt;&lt;Link to="/about"&gt;关于Link&gt;&lt;Route path="/" exact render=&#123;() =&gt; &lt;h1&gt;hello homeh1&gt;&#125;&gt;Route&gt;&lt;Route path="/about" render=&#123;() =&gt; &lt;h1&gt;hello abouth1&gt;&#125;&gt;Route&gt;BrowserRouter&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog.poetries.top/img/static/images/20210731205952.png" alt></p><h2 id="四、飞冰微前端实战"><a href="#四、飞冰微前端实战" class="headerlink" title="四、飞冰微前端实战"></a>四、飞冰微前端实战</h2><blockquote><p>官方接入指南 <a href="https://micro-frontends.ice.work/docs/guide" target="_blank" rel="noopener">https://micro-frontends.ice.work/docs/guide</a></p></blockquote><h3 id="4-1-react主应用编写"><a href="#4-1-react主应用编写" class="headerlink" title="4.1 react主应用编写"></a>4.1 react主应用编写</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm init ice icestark-layout @icedesign/stark-layout-scaffold</span><br><span class="line">$ cd icestark-layout</span><br><span class="line">$ npm install</span><br><span class="line">$ npm start</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/app.jsx中加入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appConfig: IAppConfig = &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  icestark: &#123;</span><br><span class="line">    type: <span class="string">'framework'</span>,</span><br><span class="line">    Layout: FrameworkLayout,</span><br><span class="line">    getApps: <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> apps = [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/vue'</span>,</span><br><span class="line">        title: <span class="string">'vue微应用测试'</span>,</span><br><span class="line">        sandbox: <span class="literal">false</span>,</span><br><span class="line">        url: [</span><br><span class="line">          <span class="comment">// 测试环境</span></span><br><span class="line">          <span class="comment">// 请求子应用端口下的服务，子应用的vue.config.js里面 需要配置headers跨域请求头</span></span><br><span class="line">          <span class="string">"http://localhost:3001/js/chunk-vendors.js"</span>,</span><br><span class="line">          <span class="string">"http://localhost:3001/js/app.js"</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/react'</span>,</span><br><span class="line">        title: <span class="string">'react微应用测试'</span>,</span><br><span class="line">        sandbox: <span class="literal">true</span>,</span><br><span class="line">        url: [</span><br><span class="line">          <span class="comment">// 测试环境</span></span><br><span class="line">          <span class="comment">// 请求子应用端口下的服务，子应用的webpackDevServer.config.js里面 需要配置headers跨域请求头</span></span><br><span class="line">          <span class="string">"http://localhost:3000/static/js/bundle.js"</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;</span><br><span class="line">    ];</span><br><span class="line">      <span class="keyword">return</span> apps;</span><br><span class="line">    &#125;,</span><br><span class="line">    appRouter: &#123;</span><br><span class="line">      LoadingComponent: PageLoading,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 侧边栏菜单</span></span><br><span class="line"><span class="comment">// src/layouts/menuConfig.ts 改造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asideMenuConfig = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'vue微应用测试'</span>,</span><br><span class="line">    icon: <span class="string">'set'</span>,</span><br><span class="line">    path: <span class="string">'/vue'</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'React微应用测试'</span>,</span><br><span class="line">    icon: <span class="string">'set'</span>,</span><br><span class="line">    path: <span class="string">'/react'</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="4-2-vue子应用接入"><a href="#4-2-vue子应用接入" class="headerlink" title="4.2 vue子应用接入"></a>4.2 vue子应用接入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个子应用</span><br><span class="line">vue create vue-child</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改vue.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    open: <span class="literal">true</span>, <span class="comment">// 设置浏览器自动打开项目</span></span><br><span class="line">    port: <span class="number">3001</span>, <span class="comment">// 设置端口</span></span><br><span class="line">    <span class="comment">// 支持跨域 方便主应用请求子应用资源</span></span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Access-Control-Allow-Origin'</span> : <span class="string">'*'</span>,</span><br><span class="line">      <span class="string">'Access-Control-Allow-Methods'</span>: <span class="string">'GET, POST, PUT, DELETE, PATCH, OPTIONS'</span>,</span><br><span class="line">      <span class="string">'Access-Control-Allow-Headers'</span>: <span class="string">'X-Requested-With, content-type, Authorization'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    <span class="comment">// 打包成lib包 umd格式</span></span><br><span class="line">    output: &#123;</span><br><span class="line">      library: <span class="string">'icestark-vue'</span>,</span><br><span class="line">      libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>src/main.js</code>改造</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  isInIcestark,</span><br><span class="line">  getMountNode,</span><br><span class="line">  registerAppEnter,</span><br><span class="line">  registerAppLeave,</span><br><span class="line">  setLibraryName</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@ice/stark-app'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vue = createApp(App)</span><br><span class="line">vue.use(store)</span><br><span class="line">vue.use(router)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：`setLibraryName` 的入参需要与 webpack 工程配置的 output.library 保持一致</span></span><br><span class="line"><span class="comment">//  重要 不加不生效 和 vue.config.js中配置的一样</span></span><br><span class="line">setLibraryName(<span class="string">'icestark-vue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">&#123; container &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ![](https://blog.poetries.top/img/static/images/20210731130030.png)</span></span><br><span class="line">  <span class="built_in">console</span>.log(container,<span class="string">'container'</span>)</span><br><span class="line">  vue.mount(container);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  vue.unmount();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (!isInIcestark()) &#123;</span><br><span class="line">  vue.mount(<span class="string">'#app'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>router改造</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; getBasename &#125; from &apos;@ice/stark-app&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  // 重要 在主应用中的基准路由</span><br><span class="line">  base: getBasename(),</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure><h3 id="4-3-react子应用接入"><a href="#4-3-react子应用接入" class="headerlink" title="4.3 react子应用接入"></a>4.3 react子应用接入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create-react-app react-child</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// src/app.js</span><br><span class="line"></span><br><span class="line">import &#123; isInIcestark, getMountNode, registerAppEnter, registerAppLeave &#125; from &apos;@ice/stark-app&apos;;</span><br><span class="line"></span><br><span class="line">export function mount(props) &#123;</span><br><span class="line">  ReactDOM.render(&lt;App /&gt;, props.container);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function unmount(props) &#123;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(props.container);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!isInIcestark()) &#123;</span><br><span class="line">  ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;root&apos;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (isInIcestark()) &#123;</span><br><span class="line">  registerAppEnter(() =&gt; &#123;</span><br><span class="line">    ReactDOM.render(&lt;App /&gt;, getMountNode());</span><br><span class="line">  &#125;)</span><br><span class="line">  registerAppLeave(() =&gt; &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(getMountNode());</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;root&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>npm run eject</code>后，改造 <code>config/webpackDevServer.config.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hot: <span class="string">''</span>,</span><br><span class="line">port: <span class="string">''</span>,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持跨域</span></span><br><span class="line">headers: &#123;</span><br><span class="line">  <span class="string">'Access-Control-Allow-Origin'</span> : <span class="string">'*'</span>,</span><br><span class="line">  <span class="string">'Access-Control-Allow-Methods'</span>: <span class="string">'GET, POST, PUT, DELETE, PATCH, OPTIONS'</span>,</span><br><span class="line">  <span class="string">'Access-Control-Allow-Headers'</span>: <span class="string">'X-Requested-With, content-type, Authorization'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="五、CSS隔离方案"><a href="#五、CSS隔离方案" class="headerlink" title="五、CSS隔离方案"></a>五、CSS隔离方案</h2><h3 id="子应用之间样式隔离："><a href="#子应用之间样式隔离：" class="headerlink" title="子应用之间样式隔离："></a>子应用之间样式隔离：</h3><blockquote><p><code>Dynamic Stylesheet</code>动态样式表，当应用切换时移除掉老应用样式，再添加新应用样式，保证在一个时间点内只有一个应用的样式表生效</p></blockquote><h3 id="主应用和子应用之间的样式隔离："><a href="#主应用和子应用之间的样式隔离：" class="headerlink" title="主应用和子应用之间的样式隔离："></a>主应用和子应用之间的样式隔离：</h3><ul><li><code>BEM(Block Element Modifier)</code>  约定项目前缀</li><li><code>CSS-Modules</code> 打包时生成不冲突的选择器名</li><li>Shadow DOM 真正意义上的隔离</li><li><code>css-in-js</code></li></ul><p><img src="https://blog.poetries.top/img/static/images/20210731160312.png" alt></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>shadow dom<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"shadow"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> shadowDOM = <span class="built_in">document</span>.getElementById(<span class="string">'shadow'</span>).attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'closed'</span>&#125;) <span class="comment">// 外界无法访问 </span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> pEle = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span></span><br><span class="line"><span class="javascript">      pEle.innerHTML = <span class="string">'hello shadowDOM'</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> styleEle = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>)</span></span><br><span class="line"><span class="javascript">      styleEle.textContent = <span class="string">`p&#123;color:red&#125; `</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// ![](https://blog.poetries.top/img/static/images/20210731135230.png)</span></span></span><br><span class="line">      shadowDOM.appendChild(styleEle)</span><br><span class="line">      shadowDOM.appendChild(pEle)</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// react vue 里面的弹框等因为挂载到body上 所以用shadowDOM不行 </span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 会挂载到全局污染样式</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//document.body.appendChild(pEle)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>shadow DOM</code> 内部的元素始终不会影响到它的外部元素，可以实现真正意义上的隔离</p></blockquote><h2 id="六、JS沙箱机制"><a href="#六、JS沙箱机制" class="headerlink" title="六、JS沙箱机制"></a>六、JS沙箱机制</h2><p><img src="https://blog.poetries.top/img/static/images/20210731155716.png" alt></p><blockquote><p>当运行子应用时应该跑在内部沙箱环境中</p></blockquote><ul><li>快照沙箱，当应用沙箱挂载或卸载时记录快照，在切换时依据快照恢复环境 (无法支持多实例)</li><li><code>Proxy</code> 代理沙箱，不影响全局环境</li></ul><h3 id="1-快照沙箱"><a href="#1-快照沙箱" class="headerlink" title="1.快照沙箱"></a>1.快照沙箱</h3><ol><li>激活时将当前window属性进行快照处理</li><li>失活时用快照中的内容和当前window属性比对</li><li>如果属性发生变化保存到<code>modifyPropsMap</code>中，并用快照还原window属性</li><li>再次激活时，再次进行快照，并用上次修改的结果还原window属性</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotSandbox</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = <span class="built_in">window</span>; </span><br><span class="line">        <span class="keyword">this</span>.modifyPropsMap = &#123;&#125;; <span class="comment">// 修改了哪些属性</span></span><br><span class="line">        <span class="keyword">this</span>.active();</span><br><span class="line">    &#125;</span><br><span class="line">    active() &#123;</span><br><span class="line">        <span class="keyword">this</span>.windowSnapshot = &#123;&#125;; <span class="comment">// window对象的快照</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">window</span>.hasOwnProperty(prop)) &#123;</span><br><span class="line">                <span class="comment">// 将window上的属性进行拍照</span></span><br><span class="line">                <span class="keyword">this</span>.windowSnapshot[prop] = <span class="built_in">window</span>[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.modifyPropsMap).forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>[p] = <span class="keyword">this</span>.modifyPropsMap[p];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    inactive() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> <span class="built_in">window</span>) &#123; <span class="comment">// diff 差异</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">window</span>.hasOwnProperty(prop)) &#123;</span><br><span class="line">                <span class="comment">// 将上次拍照的结果和本次window属性做对比</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">window</span>[prop] !== <span class="keyword">this</span>.windowSnapshot[prop]) &#123;</span><br><span class="line">                    <span class="comment">// 保存修改后的结果</span></span><br><span class="line">                    <span class="keyword">this</span>.modifyPropsMap[prop] = <span class="built_in">window</span>[prop]; </span><br><span class="line">                    <span class="comment">// 还原window</span></span><br><span class="line">                    <span class="built_in">window</span>[prop] = <span class="keyword">this</span>.windowSnapshot[prop]; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sandbox = <span class="keyword">new</span> SnapshotSandbox();</span><br><span class="line">(<span class="function">(<span class="params"><span class="built_in">window</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">window</span>.b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">window</span>.c = <span class="number">3</span></span><br><span class="line">    <span class="built_in">console</span>.log(a,b,c)</span><br><span class="line">    sandbox.inactive();</span><br><span class="line">    <span class="built_in">console</span>.log(a,b,c)</span><br><span class="line">&#125;)(sandbox.proxy);</span><br></pre></td></tr></table></figure><blockquote><p>快照沙箱只能针对单实例应用场景，如果是多个实例同时挂载的情况则无法解决，这时只能通过Proxy代理沙箱来实现</p></blockquote><h3 id="2-Proxy-代理沙箱"><a href="#2-Proxy-代理沙箱" class="headerlink" title="2.Proxy 代理沙箱"></a>2.Proxy 代理沙箱</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxySandbox</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">const</span> rawWindow = <span class="built_in">window</span>;</span><br><span class="line">        <span class="keyword">const</span> fakeWindow = &#123;&#125;</span><br><span class="line">        <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(fakeWindow, &#123;</span><br><span class="line">            <span class="keyword">set</span>(target, p, value) &#123;</span><br><span class="line">                target[p] = value;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">get</span>(target, p) &#123;</span><br><span class="line">                <span class="keyword">return</span> target[p] || rawWindow[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.proxy = proxy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sandbox1 = <span class="keyword">new</span> ProxySandbox();</span><br><span class="line"><span class="keyword">let</span> sandbox2 = <span class="keyword">new</span> ProxySandbox();</span><br><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">(<span class="function">(<span class="params"><span class="built_in">window</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.a = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.a)</span><br><span class="line">&#125;)(sandbox1.proxy);</span><br><span class="line">(<span class="function">(<span class="params"><span class="built_in">window</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.a = <span class="string">'world'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.a)</span><br><span class="line">&#125;)(sandbox2.proxy);</span><br></pre></td></tr></table></figure><blockquote><p>每个应用都创建一个<code>proxy</code>来代理<code>window</code>对象，好处是每个应用都是相对独立的，不需要直接更改全局的<code>window</code>属性</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://blog.poetries.top/img/static/images/20210710171426.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;微前端现有的落地方案可以分为三类，自组织模式、基座模式以及模块加载模式。&lt;/p&gt;
&lt;h2 id=&quot;一、
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="微前端" scheme="http://blog.poetries.top/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端监控系统总结篇</title>
    <link href="http://blog.poetries.top/2021/05/11/fe-monitor-sys/"/>
    <id>http://blog.poetries.top/2021/05/11/fe-monitor-sys/</id>
    <published>2021-05-11T02:50:32.000Z</published>
    <updated>2025-03-30T13:54:29.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、性能优化方法论"><a href="#一、性能优化方法论" class="headerlink" title="一、性能优化方法论"></a>一、性能优化方法论</h2><p><img src="https://blog.poetries.top/img/static/images/20210502210714.png" alt></p><blockquote><p>首屏时间可以拆分为白屏时间、数据接口响应时间、图片加载资源等</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210502214539.png" alt></p><p><img src="https://blog.poetries.top/img/static/images/20210503212926.png" alt></p><h2 id="二、指标采集：首屏时间指标采集具体办法"><a href="#二、指标采集：首屏时间指标采集具体办法" class="headerlink" title="二、指标采集：首屏时间指标采集具体办法"></a>二、指标采集：首屏时间指标采集具体办法</h2><h3 id="手动采集办法及优缺点："><a href="#手动采集办法及优缺点：" class="headerlink" title="手动采集办法及优缺点："></a>手动采集办法及优缺点：</h3><ul><li>所谓手动采集，一般是通过埋点的方式进行， 比如在页面开始位置打上 <code>FMP.Start()</code>，在首屏结束位置打上 <code>FMP.End()</code>，利用 <code>FMP.End()-FMP.Start()</code> 获取到首屏时间。</li><li>手动采集的统计结果并不精确，因为依赖于人，每个人对首屏的理解有偏差，经常打错或者忘记打点。</li></ul><h3 id="自动化采集优势及办法"><a href="#自动化采集优势及办法" class="headerlink" title="自动化采集优势及办法"></a>自动化采集优势及办法</h3><blockquote><p>所谓自动化采集，即引入一段通用的代码来做首屏时间自动化采集，引入过程中，除了必要的配置不需要做其他事情。</p></blockquote><p>自动化采集的好处是独立性更强，接入过程更自动化。具体的自动化采集代码，可以由一个公共团队来开发，试点后，推广到各个业务团队。而且统计结果更标准化，同一段统计代码，标准更统一，业务侧同学也更认可这个统计结果。</p><p>当然，它也有缺点，最明显的是，有些个性化需求无法满足，毕竟在工作中，总会有一些特殊业务场景。所以，采用自动化采集方案必须做一些取舍。</p><h3 id="单页面（SPA）应用业务下的采集办法"><a href="#单页面（SPA）应用业务下的采集办法" class="headerlink" title="单页面（SPA）应用业务下的采集办法"></a>单页面（SPA）应用业务下的采集办法</h3><p>SPA 页面因为无法基于 <code>DOMContentLoaded</code> 做首屏指标采集，可以使用 <code>MutationObserver</code> 采集首屏时间。</p><blockquote><p><code>MutationObserver</code> 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 <code>Mutation Events</code> 功能的替代品，该功能是 DOM3 Events 规范的一部分。</p></blockquote><p>简单来说， 使用 <code>MutationObserver 能监控页面信息的变化</code>，当页面 <code>body</code> 变化最剧烈的时候，我们拿到的时间数据，就是<code>首屏时间</code>。</p><p>首先，在用户进入页面时，我们可以使用 <code>MutationObserver</code> 监控 <code>DOM</code> 元素 （Document Object Model，文档对象模型）。当 DOM 元素发生变化时，程序会标记变化的元素，记录时间点和分数，存储到数组中。数据的格式类似于 <code>[200ms,18.5]</code>。</p><p>为了提升计算的效率，我们认为首屏指标采集到某些条件时，首屏渲染已经结束，我们需要考虑首屏采集终止的条件，即计算时间超过 30 秒还没有结束；计算了 4 轮且 1 秒内分数不再变化；计算了 9 次且分数不再变化。</p><p>接下来，设定元素权重计算分数。</p><p>递归遍历 DOM 元素及其子元素，根据子元素所在层数设定元素权重，比如第一层元素权重是 1，当它被渲染时得 1 分，每增加一层权重增加 0.5，比如第五层元素权重是 3.5，渲染时给出对应分数。</p><p>为什么需要权重呢？</p><p>因为页面中每个 DOM 元素对于首屏的意义是不同的，越往内层越接近真实的首屏内容，如图片和文字，越往外层越接近 body 等框架层。</p><p>最后，根据前面的得分，计算元素的分数变化率，获取变化率最大点对应的分数。然后找到该分数对应的时间，即为首屏时间。</p><p>分数部分核心计算逻辑是递归遍历元素，将一些无用的标签排除，如果元素超过可视范围返回 0 分，每一层增加 0.5 的权重，具体请看下面代码示例。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CScor</span>(<span class="params">el, tiers, parentScore</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> tagName = el.tagName;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"SCRIPT"</span> !== tagName &amp;&amp; <span class="string">"STYLE"</span> !== tagName &amp;&amp; <span class="string">"META"</span> !== tagName &amp;&amp; <span class="string">"HEAD"</span> !== tagName) &#123;</span><br><span class="line">      <span class="keyword">const</span> childrenLen = el.children ? el.children.length : <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (childrenLen &gt; <span class="number">0</span>) <span class="keyword">for</span> (<span class="keyword">let</span> childs = el.children, len = childrenLen - <span class="number">1</span>; len &gt;= <span class="number">0</span>; len--) &#123;</span><br><span class="line">        score += calculateScore(childs[len], tiers + <span class="number">1</span>, score &gt; <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (score &lt;= <span class="number">0</span> &amp;&amp; !parentScore) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(el.getBoundingClientRect &amp;&amp; el.getBoundingClientRect().top &lt; WH)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      score += <span class="number">1</span> + <span class="number">.5</span> * tiers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>变化率部分核心计算逻辑是获取 DOM 变化最大时对应的时间，代码如下所示</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">calFinallScore() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.sendMark) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">const</span> time = <span class="built_in">Date</span>.now() - performance.timing.fetchStart;</span><br><span class="line">      <span class="keyword">var</span> isCheckFmp = time &gt; <span class="number">30000</span> || SCORE_ITEMS &amp;&amp; SCORE_ITEMS.length &gt; <span class="number">4</span> &amp;&amp; time - (SCORE_ITEMS &amp;&amp; SCORE_ITEMS.length &amp;&amp; SCORE_ITEMS[SCORE_ITEMS.length - <span class="number">1</span>].t || <span class="number">0</span>) &gt; <span class="number">2</span> * CHECK_INTERVAL || (SCORE_ITEMS.length &gt; <span class="number">10</span> &amp;&amp; <span class="built_in">window</span>.performance.timing.loadEventEnd !== <span class="number">0</span> &amp;&amp; SCORE_ITEMS[SCORE_ITEMS.length - <span class="number">1</span>].score === SCORE_ITEMS[SCORE_ITEMS.length - <span class="number">9</span>].score);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.observer &amp;&amp; isCheckFmp) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observer.disconnect();</span><br><span class="line">        <span class="built_in">window</span>.SCORE_ITEMS_CHART = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(SCORE_ITEMS));</span><br><span class="line">        <span class="keyword">let</span> fmps = getFmp(SCORE_ITEMS);</span><br><span class="line">        <span class="keyword">let</span> record = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> o = <span class="number">1</span>; o &lt; fmps.length; o++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fmps[o].t &gt;= fmps[o - <span class="number">1</span>].t) &#123;</span><br><span class="line">            <span class="keyword">let</span> l = fmps[o].score - fmps[o - <span class="number">1</span>].score;</span><br><span class="line">            (!record || record.rate &lt;= l) &amp;&amp; (record = &#123;</span><br><span class="line">              t: fmps[o].t,</span><br><span class="line">              rate: l</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.fmp = record &amp;&amp; record.t || <span class="number">30001</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.checkImgs(<span class="built_in">document</span>.body)</span><br><span class="line">          <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...this.imgs.map(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="regexp">/^(\/\/)/</span>.test(element)) element = <span class="string">'https:'</span> + element;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> performance.getEntriesByName(element)[<span class="number">0</span>].responseEnd || <span class="number">0</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;))</span><br><span class="line">          record &amp;&amp; record.t &gt; <span class="number">0</span> &amp;&amp; record.t &lt; <span class="number">36e5</span> ? <span class="keyword">this</span>.setPerformance(&#123;</span><br><span class="line">            fmpImg: <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.max(record.t , max))</span><br><span class="line">          &#125;) : <span class="keyword">this</span>.setPerformance(&#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="keyword">this</span>.setPerformance(&#123;&#125;);</span><br><span class="line">          <span class="comment">// console.error(error)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.calFinallScore();</span><br><span class="line">        &#125;, CHECK_INTERVAL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个就是首屏计算的部分流程。</p><p>看完前面的流程，不知道你有没有这样的疑问：<code>如果页面里包含图片，使用上面的首屏指标采集方案，结果准确吗</code>？</p><blockquote><p>结论是：不准确。上述计算逻辑主要是针对 DOM元素来做的，图片加载过程是异步，图片容器（图片的 DOM 元素）和内容的加载是分开的，当容器加载出来时，内容还没出来，一定要确保内容加载出来，才算首屏。</p></blockquote><p>这就需要增加一些策略了，以下是包含图片页面的首屏计算 demo。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"imgTest"</span> <span class="attr">src</span>=<span class="string">"https://www.baidu.com/img/bd_logo1.png?where=super"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"imgTest"</span> <span class="attr">src</span>=<span class="string">"https://www.baidu.com/img/bd_logo1.png?where=super"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">text/css</span>&gt;</span></span><br><span class="line">    background-image:url('https://www.baidu.com/img/dong_8f1d47bcb77d74a1e029d8cbb3b33854.gif);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> imgs = []</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> getImageDomSrc = &#123;</span></span><br><span class="line"><span class="javascript">    _getImgSrcFromBgImg: <span class="function"><span class="keyword">function</span> (<span class="params">bgImg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> imgSrc;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> matches = bgImg.match(<span class="regexp">/url\(.*?\)/g</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (matches &amp;&amp; matches.length) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> urlStr = matches[matches.length - <span class="number">1</span>];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> innerUrl = urlStr.replace(<span class="regexp">/^url\([\'\"]?/</span>, <span class="string">''</span>).replace(<span class="regexp">/[\'\"]?\)$/</span>, <span class="string">''</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (((<span class="regexp">/^http/</span>.test(innerUrl) || <span class="regexp">/^\/\//</span>.test(innerUrl)))) &#123;</span></span><br><span class="line">          imgSrc = innerUrl;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> imgSrc;</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    getImgSrcFromDom: <span class="function"><span class="keyword">function</span> (<span class="params">dom, imgFilter</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!(dom.getBoundingClientRect &amp;&amp; dom.getBoundingClientRect().top &lt; <span class="built_in">window</span>.innerHeight))</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">      imgFilter = [<span class="regexp">/(\.)(png|jpg|jpeg|gif|webp|ico|bmp|tiff|svg)/i</span>]</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> src;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (dom.nodeName.toUpperCase() == <span class="string">'IMG'</span>) &#123;</span></span><br><span class="line"><span class="javascript">        src = dom.getAttribute(<span class="string">'src'</span>);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> computedStyle = <span class="built_in">window</span>.getComputedStyle(dom);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> bgImg = computedStyle.getPropertyValue(<span class="string">'background-image'</span>) || computedStyle.getPropertyValue(<span class="string">'background'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> tempSrc = <span class="keyword">this</span>._getImgSrcFromBgImg(bgImg, imgFilter);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (tempSrc &amp;&amp; <span class="keyword">this</span>._isImg(tempSrc, imgFilter)) &#123;</span></span><br><span class="line">          src = tempSrc;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> src;</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    _isImg: <span class="function"><span class="keyword">function</span> (<span class="params">src, imgFilter</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = imgFilter.length; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (imgFilter[i].test(src)) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    traverse(e) &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> _this = <span class="keyword">this</span></span></span><br><span class="line">        , tName = e.tagName;</span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="string">"SCRIPT"</span> !== tName &amp;&amp; <span class="string">"STYLE"</span> !== tName &amp;&amp; <span class="string">"META"</span> !== tName &amp;&amp; <span class="string">"HEAD"</span> !== tName) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> el = <span class="keyword">this</span>.getImgSrcFromDom(e)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (el &amp;&amp; !imgs.includes(el))</span></span><br><span class="line">          imgs.push(el)</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> len = e.children ? e.children.length : <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span></span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (<span class="keyword">var</span> child = e.children, _len = len - <span class="number">1</span>; _len &gt;= <span class="number">0</span>; _len--)</span></span><br><span class="line">            _this.traverse(child[_len]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  getImageDomSrc.traverse(<span class="built_in">document</span>.body);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(imgs,<span class="string">'-imgs--'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> max = <span class="built_in">Math</span>.max(...imgs.map(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">     <span class="keyword">if</span> (<span class="regexp">/^(\/\/)/</span>.test(element))</span></span><br><span class="line"><span class="javascript">      element = <span class="string">'https:'</span> + element;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> performance.getEntriesByName(element)[<span class="number">0</span>].responseEnd || <span class="number">0</span></span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">catch</span> (error) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="number">0</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ))</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(max);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">)()</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它的计算逻辑是这样的。</p><p>首先，获取页面所有的图片路径。在这里，图片类型分两种，一种是带 IMG 标签的，一种是带 DIV 标签的。前者可以直接通过 src 值得到图片路径，后者可以使用 <code>window.getComputedStyle(dom)</code> 方式获取它的样式集合。</p><p>接下来，通过正则获取图片的路径即可。</p><p>然后通过 <code>performance.getEntriesByName(element)[0].responseEnd</code> 的方式获取到对应图片路径的下载时间，最后与使用 <code>MutationObserver</code> 获得的 DOM 首屏时间相比较，哪个更长，哪个就是最终的首屏时间。</p><blockquote><p>以上就是首屏采集的完整流程</p></blockquote><blockquote><p>注意：计算首屏时间用到的<code>getBoundingClientRect</code>和<code>getComputedStyle</code>会引起强制回流</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210503151137.png" alt></p><h2 id="三、指标采集：白屏、卡顿、网络环境指标采集方法"><a href="#三、指标采集：白屏、卡顿、网络环境指标采集方法" class="headerlink" title="三、指标采集：白屏、卡顿、网络环境指标采集方法"></a>三、指标采集：白屏、卡顿、网络环境指标采集方法</h2><h3 id="白屏指标采集"><a href="#白屏指标采集" class="headerlink" title="白屏指标采集"></a>白屏指标采集</h3><blockquote><p>白屏时间是指从输入内容回车（包括刷新、跳转等方式）后，到页面开始出现第一个字符的时间。白屏时间的长短会影响用户对 App 或站点的第一印象</p></blockquote><p>白屏指标怎么采集呢？我们先来回顾一下浏览器的页面加载过程：</p><blockquote><p>客户端发起请求 -&gt; 下载 HTML 及 JS/CSS 资源 -&gt; 解析 JS 执行 -&gt; JS 请求数据 -&gt; 客户端解析 DOM 并渲染 -&gt; 下载渲染图片-&gt; 完成渲整体染</p></blockquote><p>在这个过程中，客户端解析 DOM 并渲染之前的时间，都算白屏时间。所以，<strong>白屏时间的采集思路如下</strong>：<code>白屏时间 = 页面开始展示时间点 - 开始请求时间点</code>。如果你是借助浏览器的 <code>Performance API</code> 工具来采集，那么可以使用公式：<code>白屏时间 FP</code> = <code>domLoading - navigationStart</code>。</p><p>这是浏览器页面加载过程，如果放在 App场景下，就不太一样了，App下的页面加载过程：</p><blockquote><p>初始化 WebView -&gt; 客户端发起请求 -&gt; 下载 HTML 及 JS/CSS 资源 -&gt; 解析 JS 执行 -&gt; JS 请求数据 -&gt; 服务端处理并返回数据 -&gt; 客户端解析 DOM 并渲染 -&gt; 下载渲染图片 -&gt; 完成整体渲染。</p></blockquote><p><code>App下的白屏时间，多了启动浏览器内核，也就是 Webview 初始化的时间</code>。这个时间必须通过手动采集的方式来获得，而且因为线上线下时间差别不大，线下采集即可。<strong>具体来说，在 App 测试版本中，程序在 App 创建 WebView 时打一个点，然后在开始建立网络连接打一个点，这两个点的时间差就是 Webview 初始化的时间</strong>。</p><h3 id="卡顿指标采集"><a href="#卡顿指标采集" class="headerlink" title="卡顿指标采集"></a>卡顿指标采集</h3><p><strong>所谓卡顿，简单来说就是页面出现卡住了的不流畅的情况</strong>。 提到它的指标，你是不是会一下就想到 FPS（Frames Per Second，每秒显示帧数）？FPS 多少算卡顿？网上有很多资料，大多提到 FPS 在 60 以上，页面流畅，不卡顿。但事实上并非如此，比如我们看电影或者动画时，素虽然 FPS 是 30 （低于60），但我们觉得很流畅，并不卡顿。</p><p>FPS 低于 60 并不意味着卡顿，那 FPS 高于 60 是否意味着一定不卡顿呢？比如前 60 帧渲染很快（10ms 渲染 1 帧），后面的 3 帧渲染很慢（ 20ms 渲染 1 帧），这样平均起来 FPS 为95，高于 60 的标准。这种情况会不会卡顿呢？实际效果是卡顿的。因为卡顿与否的关键点在于单帧渲染耗时是否过长。</p><blockquote><p>但难点在于，在浏览器上，我们没办法拿到单帧渲染耗时的接口，所以这时候，只能拿 FPS 来计算，只要 FPS 保持稳定，且值比较低，就没问题。<code>它的标准是多少呢？连续 3 帧不低于 20 FPS，且保持恒定</code>。</p></blockquote><p>以 H5 为例，<code>H5 场景下获取 FPS 方案如下</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fps_compatibility= <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">        <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">var</span> fps_config=&#123;</span><br><span class="line">  lastTime:performance.now(),</span><br><span class="line">  lastFameTime : performance.now(),</span><br><span class="line">  frame:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fps_loop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _first =  performance.now(),_diff = (_first - fps_config.lastFameTime);</span><br><span class="line">    fps_config.lastFameTime = _first;</span><br><span class="line">    <span class="keyword">var</span> fps = <span class="built_in">Math</span>.round(<span class="number">1000</span>/_diff);</span><br><span class="line">    fps_config.frame++;</span><br><span class="line">    <span class="keyword">if</span> (_first &gt; <span class="number">1000</span> + fps_config.lastTime) &#123;</span><br><span class="line">        <span class="keyword">var</span> fps = <span class="built_in">Math</span>.round( ( fps_config.frame * <span class="number">1000</span> ) / ( _first - fps_config.lastTime ) );</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`time: <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span> fps is：`</span>, fps);</span><br><span class="line">        fps_config.frame = <span class="number">0</span>;    </span><br><span class="line">        fps_config.lastTime = _first ;    </span><br><span class="line">    &#125;;           </span><br><span class="line">    fps_compatibility(fps_loop);   </span><br><span class="line">&#125;</span><br><span class="line">fps_loop();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBlocking</span>(<span class="params">fpsList, below=<span class="number">20</span>, last=<span class="number">3</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fpsList.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fpsList[i] &amp;&amp; fpsList[i] &lt; below) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= last) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用 <code>requestAnimationFrame</code> 在一秒内执行 <code>60</code> 次（在不卡顿的情况下）这一点，假设页面加载用时 <code>X ms</code>，这期间 <code>requestAnimationFrame</code> 执行了 <code>N</code> 次，则帧率为 <code>1000* N/X</code>，也就是<code>FPS</code></p></blockquote><p>由于用户客户端差异很大，我们要考虑兼容性，在这里我们定义 <code>fps_compatibility</code> 表示兼容性方面的处理，在浏览器不支持 <code>requestAnimationFrame</code> 时，利用 <code>setTimeout</code> 来模拟实现，在 <code>fps_loop</code> 里面完成 FPS 的计算，最终通过遍历 <code>fpsList</code> 来判断是否连续三次 fps 小于20。</p><p>如果连续判断 3次 FPS 都小于20，就认为是卡顿。</p><p><img src="https://blog.poetries.top/img/static/images/20210503152718.png" alt></p><h2 id="四、工具实践：性能-SDK-及上报策略设计"><a href="#四、工具实践：性能-SDK-及上报策略设计" class="headerlink" title="四、工具实践：性能 SDK 及上报策略设计"></a>四、工具实践：性能 SDK 及上报策略设计</h2><p>由于性能 SDK 最终是给各个业务使用的，所以它的设计要满足在接入性能监控平台时，简单易用和运行平稳高效，这两个要求。</p><h3 id="SDK-接入设计"><a href="#SDK-接入设计" class="headerlink" title="SDK 接入设计"></a>SDK 接入设计</h3><p>要保证 <code>SDK</code> 接入简单，容易使用，<code>首先要把之前首屏、白屏和卡顿采集的脚本封装在一起，并让脚本自动初始化和运行</code>。</p><p><img src="https://blog.poetries.top/img/static/images/20210503152937.png" alt></p><ul><li>具体来说，首屏采集的<code>分数计算部分 API（calculateScore）</code>、<code>变化率计算的 API（calFinallScore）</code>和<code>首屏图片时间计算 API（fmpImg）</code>可以一起封装成 FMP API。其中首屏图片计算 API 因为比较独立，可以专门抽离成一个 util，供其他地方调用。白屏和卡顿采集也类似，可以封装成 <code>FP API</code> 和 <code>BLOCK API</code>。</li><li>还有一个 <code>ExtensionAPI</code> 接口，用来封装一些后续需要使用的数据，比如加载瀑布流相关的数据（将首屏时间细分为DNS、TCP连接等时间），这些数据可以通过浏览器提供的 <code>performance</code> 接口获得。</li></ul><blockquote><p>为了进行首屏、白屏、卡顿的指标采集，我们可以封装 <code>Perf API</code>，调用 <code>FMP、FP、BLOCK、ExtensionAPI</code> 四个 API 来完成。因为是调用 <code>window.performance</code> 接口，所以先做环境兼容性的判断，即看看浏览器是否支持 <code>window.performance</code></p></blockquote><p>最终我们接入时只要安装一个 <code>npm</code> 包，然后初始化即可，具体代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install @common/Perf -S;</span><br><span class="line"><span class="keyword">import</span> &#123; perfInit &#125; <span class="keyword">from</span> <span class="string">'@common'</span>;</span><br><span class="line">perfInit ();</span><br></pre></td></tr></table></figure><p>或者以外链的形式接入：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;https:<span class="comment">//s1.static.com/common/perf/static/js/1.0.0/perf.min.js&lt;/script&gt;</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  perfInit ();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了性能 SDK 自身的方案设计之外，提供帮助文档（如示例代码、 QA 列表等），也可以提高性能 SDK 的易用性。</p><p>具体来说，我们可以搭建一个简单的性能 SDK 网站，进入站点后，前端工程师可以看到使用文档，包括各种平台下如何接入，接入的示例代码是怎样的，接入性能 SDK 后去哪个 URL 看数据，遇到异常问题时怎么调试，等等。</p><h3 id="SDK-运行设计"><a href="#SDK-运行设计" class="headerlink" title="SDK 运行设计"></a>SDK 运行设计</h3><p>SDK 如果想运行高效，必须有好的兼容性策略、容错机制和测试方案。</p><p>所谓兼容性策略，就是性能 SDK 可以在各个业务下都可以稳定运行。</p><p><strong>我们知道，前端性能优化会面临的业务场景大致有：</strong></p><ul><li>各类页面，如平台型页面、3C 类页面、中后台页面；</li><li>一些可视化搭建的平台，如用于搭建天猫双十一会场页这种用于交易运行页面的魔方系统；</li><li>各个终端，如 PC 端，移动端，小程序端等。</li></ul><p>这就要求性能 SDK 要能适应这些业务，及时采集性能指标并进行上报。那具体怎么做呢？</p><p>一般不同页面和终端，它们的技术栈也会不同，如 PC端页面使用 React，移动端页面使用 VUE 。这个时候，<code>我们可以尽可能用原生 JavaScript 去做性能指标的采集，从而实现跨不同技术栈的采集</code>。</p><blockquote><p>不同终端方面，我设计了一个适配层来抹平采集方面的差异。<code>具体来说，小程序端可以用有自己的采集 API，如 minaFMP</code>，<code>其他端可以直接用 FMP</code>，这样在性能 SDK 初始化时，<code>根据当前终端类型的不同，去调用各自的性能指标采集 API</code>。</p></blockquote><p>容错方面怎么做呢？</p><blockquote><p>如果是性能 SDK 自身的报错，可以通过 <code>try catch</code> 的方式捕获到，然后上报异常监控平台。注意，不要因为 SDK 的报错而影响引入性能 SDK 页面的正常运行。</p></blockquote><h3 id="日志数据过滤"><a href="#日志数据过滤" class="headerlink" title="日志数据过滤"></a>日志数据过滤</h3><p>我的建议是，在采集性能指标之后，最好先对异常数据进行过滤。</p><p>异常数据分一般有两类，第一类是计算错误导致的异常数据，比如负值或者非数值数据，第二类是合法异常值、极大值、极小值，属于网络断掉或者超时形成的数值，比如 15s 以上的首屏时间。</p><p>负值的性能指标数据影响很大，它会严重拖低首屏时间，也会把计算逻辑导致负值的问题给掩盖掉。</p><h3 id="数据抽样策略"><a href="#数据抽样策略" class="headerlink" title="数据抽样策略"></a>数据抽样策略</h3><p>性能 SDK 上报数据是全量还是抽象，需要根据本身 App 或者网站的日活来确定，如果日活10万以下，那抽样就没必要了。如果是一款日活千万的 App，那就需要进行数据抽样了，因为如果上报全量日志的话，会耗费大量用户的流量和请求带宽。</p><h3 id="上报机制选择"><a href="#上报机制选择" class="headerlink" title="上报机制选择"></a>上报机制选择</h3><p>一般，为了节省流量，性能 SDK 也会根据网络能力，选择合适的上报机制。在强网环境（如 <code>4G/WIFI</code>），直接进行上报；在弱网（<code>2G/3G</code>）下，将日志存储到本地，延时到强网下再上报。</p><p>除了网络能力，我们还可以让 SDK 根据 App 忙碌状态，选择合适的上报策略。如果 App 处于空闲状态，直接上报；如果处于忙碌状态，等到闲时（比如凌晨 2-3 点）再进行上报。</p><p>除此之外，还有一些其他的策略，如批量数据上报，默认消息数量达到 30 条才上报，或者只在 App 启动时上报等策略，等等。你可以根据实际情况进行选择。</p><p><img src="https://blog.poetries.top/img/static/images/20210503153920.png" alt></p><blockquote><p>采集到数据后，先对数据进行校验，如果发现数据异常则直接上报到数据异常平台（通过邮件或者钉钉通知的方式发送给开发者），反之如果数据是正常范围内的，则结合采样率来看是否需要上报。</p></blockquote><h2 id="五、平台实践：如何从-0-到-1-搭建前端性能平台"><a href="#五、平台实践：如何从-0-到-1-搭建前端性能平台" class="headerlink" title="五、平台实践：如何从 0 到 1 搭建前端性能平台"></a>五、平台实践：如何从 0 到 1 搭建前端性能平台</h2><p>前端性能平台是一个 Web 系统，主要包括后台的性能数据处理和前台的可视化展示两部分</p><p>其中，数据处理后台主要是对 SDK 上报后的性能指标进行处理和运算，具体包括数据入库、数据清洗、数据计算，做完这些后，前台会对结果进行可视化展现，我们借助它就可以实时监督前端的性能情况。下图是性能平台大盘页的效果，主要对当前用户关注的性能模块进行展示，内容包括首屏时间、秒开率和采样PV。</p><p><img src="https://blog.poetries.top/img/static/images/20210503154327.png" alt></p><p>那么，我们该如何搭建这样一个性能平台呢？</p><p><img src="https://blog.poetries.top/img/static/images/20210503154342.png" alt></p><p><strong>这是具体的技术架构图，从底层到前台大致情况如下：</strong></p><ul><li>数据接入层，主要是接收 <code>SDK</code> 上报的性能数据，做数据处理后入库，包含的技术有 <code>Node.js、Node-sechdule、Node-mailer</code>；</li><li>数据计算层，会对性能数据做计算处理，需要的技术有 <code>Kafka、Spark、Hive、HDFS</code></li><li>存储层，包括 <code>MySQL + MongoDB</code> ，性能平台需要的数据会来这里</li><li>平台层，也就是展示给用户的部分，需要的技术有 <code>React、Ant design、Antv、Less</code></li></ul><h3 id="性能数据处理后台"><a href="#性能数据处理后台" class="headerlink" title="性能数据处理后台"></a>性能数据处理后台</h3><p>想要搭建性能平台，我们先来看它的性能处理后台情况。<strong>一般性能 SDK 上报数据的处理过程是这样的</strong>：</p><ul><li>客户端借助 <code>SDK</code> 上报性能数据指标，数据接入层（图中绿色部分）接收相应数据，并做协议转换等简单处理后，作为生产者向 Kafka 写入数据；</li><li>数据计算层（图中橙色部分）作为消费者，从 Kafka 读数据存入 Hive（Hadoop平台的存储表），Hadoop 平台借助 Spark 做数据分析计算；</li><li>借助 Hive 提供的接口，数据计算层使用 SQL 语句从 Hive 拉取计算后的数据到数据库平台（MongoDB），平台层取出数据，准备数据可视化展现的数据。</li></ul><p><strong>上述数据流程，对应的性能数据后台的搭建过程如下</strong>：</p><ol><li>第一步是入库，客户端借助 SDK 上报性能数据指标后，需要后端服务层的处理，这里我们选取的是 NodeJS 做后端，利用 Controller 层对数据做处理。</li></ol><p>为了避免数据库出现“脏数据”（如空数据、异常数据），影响后续数据处理，我们将 SDK 上报的数据通过 URL 解析成 key-value 格式的数据，对数据进行空数据删除，异常数据舍弃等操作。然后我们让数据写进消息队列 Kafka。</p><p><strong>为什么不是直接存入 Hive 呢？</strong></p><p>因为客户端上报的性能数据量和用户规模有关。如果直接入库到 Hive，遇到高并发的时候，会因为服务器扛不住而导致数据丢失。与此同时，因为数据下游（数据的使用方，如数据清洗计算平台，性能预警模块）会有多个数据接收端，直接入库的话也会造成数据重复。</p><p>所以最好我们选择 Kafka，先让数据写进消息队列。Kafka 能通过缓存，慢慢接收这些数据，降低流量洪峰压力。同时，消息队列还有接收数据后将其删除的特点，可以避免数据重复的问题。</p><ol start="2"><li>第二步，<code>对 Kafka 中的数据，做数据清洗和数据计算</code></li></ol><p><strong>数据清洗，是指针对性能上报单条数据进行核对校验的过程。所清洗的数据包括：</strong></p><ul><li>对重复数据的处理，即同一个用户网络出错时，多次重试导致上传了好几条首屏时间相关的数据；</li><li>对缺失数据的处理，虽然上报了首屏时间，但白屏时间或者卡顿时间计算时没能给出；</li><li>对错误数据的处理，即数据超出正常范围，出现负值或者超出极大值的情况。</li></ul><p>这几种类型数据问题如果不处理，最终会影响计算结果的准确性。那么该怎么处理呢？</p><ul><li>遇到重复数据，直接去重删除即可。</li><li>遇到缺失数据，我们在 Spark 平台上，先根据上报的 Performance 数据进行计算补全，如果无法补全的，就直接舍弃掉，不然会出现后续无法入库的情况。</li><li>遇到超出正常范围的数据，如负值或者超过 10 秒以上的数据，把它当作无效数据，直接舍弃掉。</li></ul><blockquote><p>做完数据清洗之后，我们还需要<code>使用 Spark 做数据计算，为可视化展现准备数据</code>。具体需要做以下数据计算：</p></blockquote><ul><li>首屏时间分布的计算，<code>1s ～ 2s</code> 占比多少，<code>2s ～ 4s</code> 占比多少；</li><li>秒开率的计算，首屏时间小于等于 1 秒的数据占比；</li><li>页面瀑布流时间的计算。</li></ul><p>其中，页面瀑布流时间是对首屏时间的细分，<code>包括 DNS 查询、TCP链接、请求耗时、内容传输、资源解析、DOM 解析和资源加载的时间</code>。这些细分时间点，是我们根据 SDK 上报的 Performance 接口数据指标计算出来的，前端工程师根据页面瀑布流时间，可以快速定位性能瓶颈点出现在哪个环节。</p><ol start="3"><li>第三步，准备性能前台所需的可视化数据</li></ol><p>为了完成前台展现，性能平台需要登录功能，还需要做一些用户关注的模块信息，比如前端开发者添加关注的业务模块。我们可以用关系数据库去存储这些数据，具体可以选择 MySQL完成账号权限系统和关注业务模块对应的数据表。</p><p>而性能数据，因为都是单条性能信息，相互之间并没有什么关系，可以用 MongoDB 做存储。具体来说，我们可以用 NodeJS 提供的定时脚本（Node-sechdule）从 Spark 取到数据导入到 MongoDB 中。</p><h3 id="前端数据可视化展示前台"><a href="#前端数据可视化展示前台" class="headerlink" title="前端数据可视化展示前台"></a>前端数据可视化展示前台</h3><p>前端数据可视化展现前台，整体上只有两个页面，大盘页和详情页。</p><p>大盘页包括一个个业务的性能简图。每一个性能简图包括首屏时间、秒开率、采样 PV 数据。点击性能简图上的“进入详情”链接，就可以进入详情页。初次进入大盘页的时候，需要你登录并关注相关的业务，然后就可以在大盘首页看到相关的性能情况。</p><p>详情页的设计的初衷是为了对性能简图做进一步的补充，除了展示对应性能简图的秒开率、性能均值细节、白屏均值细节之外，还会展示终端信息，比如多少比例在IOS端，多少比例在Android端，以方便用户根据不同场景去做优化。</p><p><img src="https://blog.poetries.top/img/static/images/20210503160942.png" alt></p><blockquote><p>同时，为了解秒开率不达标原因或者首屏时间变慢的细节在哪里，我们会给出页面加载瀑布流，前面数据处理阶段已经提到可以使用的数据（包括 DNS 查询、TCP链接、请求耗时、内容传输、资源解析、DOM 解析和资源加载的时间），套用 AntV （阿里巴巴集团的数据可视化方案）的瀑布流模板即可完成数据展现。</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210503161021.png" alt></p><p><strong>那么，大盘页和详情页如何实现的呢？</strong></p><p>首先是前端展示技术栈的选择，对应技术架构图中的淡黄色部分，因为这两个页面都属于 PC 端后台页面，主要给公司前端开发者使用，功能上更多是数据可视化展示，非常适合用 React 技术栈做开发。</p><p>为了更好实现首屏时间、秒开率和采用 PV 的功能效果，我们使用 AntdPro 的模板，相关的配套的数据可视化方案，我推荐 Antv，因为它能够满足我们在首屏时间、秒开率等性能指标的展示需求，用起来比较简单（开箱即用），功能灵活且扩展性强（比如秒开率部分，要自定义一些图形，能够较好满足）。</p><p>大盘页和详情页的数据展示效果比较丰富多样，相应的 CSS 代码逻辑就比较复杂，为了让 CSS代码更容易维护和扩展，CSS 方面可以选用 Less 框架。</p><p>接下来是前后端交互方面，为了让前后台更独立，大盘页、详情页与后端的通信通过 HTTP 接口来实现，使用 nginx 作为 Web Server。为了让传输更高效，我们采用 compression 对 HTTP 传输内容进行 GZip 压缩处理。</p><p>最后是后台服务部分，为了让性能平台开发过程更简单，效率更高，同时平台本身的性能体验更流畅，后台服务方面可以选用 Egg.js（基于 NodeJS 的开发框架）做开发，进行数据处理和存储服务。</p><p>为了解决监控预警的问题，我们借助 <code>Node-schedule</code> 做调度和定时任务的处理，通过 <code>node-mailer</code> 进行邮件报警</p><p><img src="https://blog.poetries.top/img/static/images/20210503161251.png" alt></p><h2 id="六、诊断清单：如何实现监控预警并进行问题诊断"><a href="#六、诊断清单：如何实现监控预警并进行问题诊断" class="headerlink" title="六、诊断清单：如何实现监控预警并进行问题诊断"></a>六、诊断清单：如何实现监控预警并进行问题诊断</h2><h3 id="监控预警"><a href="#监控预警" class="headerlink" title="监控预警"></a>监控预警</h3><p>监控预警部分，我们借助 Node-schedule 做调度和定时任务的处理，通过 node-mailer 进行邮件报警。具体来说我们通过以下几步来实现。</p><p><strong>第一步，准备预警数据</strong></p><p>在做完数据清洗之后，一个分支使用 <code>Spark</code> 做计算，另外一个分支使用 <code>Flink</code> 实时数据计算。这两者的区别在于后者的数据是实时处理的，因为监控预警如果不实时的话，就没有意义了。有关数据的处理，我是这样做的：超过 2s 的数据，或者认定为卡顿的数据，直接标记为预警数据。实际当中你也可以根据情况去定义和处理。</p><p><strong>第二步，我们借助 Node-schedule</strong>，用一批定时任务将预警数据通过 Node.js，拉取数据到 MongoDB 的预警表中。</p><p><strong>第三步，预警的展示流程</strong>。根据预警方式不同，样式展示也不同。具体来说，预警的方式有三种：企业微信报警通知、邮件报警通知、短信报警通知。</p><p>以手机列表页为例，性能标准是首屏时间 1.5s，秒开率 90%，超过这个标准就会在性能平台预警模块展示，按照严重程度倒序排列展示。如果超出 10%，平台上会标红展示，并会发企业微信报警通知；如果超过 20%，会发借助 <code>node-mailer</code> 做邮件报警；如果超出 30%，会发短信报警通知。</p><p>注意，预警通知需要用到通信资源，为了避免数据量太大而浪费资源，一般对 App 首页核心的导航位进行页面监控即可。</p><h3 id="问题诊断"><a href="#问题诊断" class="headerlink" title="问题诊断"></a>问题诊断</h3><p>当预警功能做好后，前端性能平台就可以对重要指标进行实时监督了。当发现性能问题——不论是我们自己发现还是用户反馈，都需要先对问题进行诊断，然后看情况是否需要进一步采取措施。</p><p>一般问题诊断时需要先确认是共性问题还是个例问题。如果是共性问题，那接下来我们就开始诊断和优化；如果是个例问题，是因为偶发性因素导致的（如个人的网络抖动、手机内存占用太多、用户连了代理等），则不需要进行专门优化。</p><p><img src="https://blog.poetries.top/img/static/images/20210503161715.png" alt></p><h2 id="七、优化手段：首屏秒开的-4-重保障"><a href="#七、优化手段：首屏秒开的-4-重保障" class="headerlink" title="七、优化手段：首屏秒开的 4 重保障"></a>七、优化手段：首屏秒开的 4 重保障</h2><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载是性能优化的前头兵。什么叫懒加载呢？懒加载是指在长页面加载过程时，先加载关键内容，延迟加载非关键内容。比如当我们打开一个页面，它的内容超过了浏览器的可视窗口大小，我们可以先加载前端的可视区域内容，剩下的内容等它进入可视区域后再按需加载。</p><p>具体怎么做呢？我们可以先根据手机的可视窗口，估算需要多少条数据，比如京东 App 列表页是 4 条数据，这时候，先从后端拉取 4 条数据进行展现，然后超出首屏的内容，可以在页面下拉或者滚动时再发起加载。</p><p>那么如果首页当中图片比较多，比如搜索引擎产品的首页，如何保证首屏秒开呢？同样也可以采用懒加载。以百度图片列表页为例，可视区域范围内的图片先请求加载，一般会根据不同手机机型估算一个最大数据，比如 ihone12 Pro 屏幕比较大， 4 行 8 条数据，我们就先请求 8 条数据，用来在可视区域展示，其他位置采用占位符填充，在滑动到目标区域位置后，才使用真实的图片填充。这样，通过使用懒加载，可以最大限度降低了数据接口传输阶段的时间。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>如果说懒加载本质是提供首屏后请求非关键内容的能力，那么缓存则是赋予二次访问不需要重复请求的能力。在首屏优化方案中，接口缓存和静态资源缓存起到中流砥柱的作用。</p><h3 id="接口缓存"><a href="#接口缓存" class="headerlink" title="接口缓存"></a>接口缓存</h3><p>接口缓存的实现，如果是端内的话，所有请求都走 Native 请求，以此来实现接口缓存。为什么要这么做呢？</p><p>App 中的页面展现有两种形式，使用 Native 开发的页面展现和使用 H5 开发的页面展现。如果统一使用 Native 做请求的话，已经请求过的数据接口，就不用请求了。而如果使用 H5 请求数据，必须等 WebView 初始化之后才能请求（也就是串行请求），而 Native 请求时，可以在 WebView 初始化之前就开始请求数据（也就是并行请求），这样能有效节省时间。</p><p>那么，如何通过 Native 进行接口缓存呢？<strong>我们可以借助 SDK 封装来实现，即修改原来的数据接口请求方法，实现类似 Axios 的请求方法。</strong>具体来说就是，把包括 post、Get 和 Request 功能的接口，封装进 SDK 中。</p><p>这样，客户端发起请求时，程序会调用 SDK.axios 方法，WebView 会拦截这个请求，去查看 App 本地是否有数据缓存，如果有的话，就走接口缓存，如果没有的话，先向服务端请求数据接口，获取接口数据后存放到 App 缓存中。</p><h3 id="静态资源缓存"><a href="#静态资源缓存" class="headerlink" title="静态资源缓存"></a>静态资源缓存</h3><p>数据接口的请求一般来说较少，只有几个，而静态资源（如 JS、CSS、图片和字体等）的请求就太多了。以京东首页为例，177 个请求中除了 1 个文档和 1 个数据接口外，其余都是静态资源请求。</p><p>那么，如何做静态缓存方案呢？这里有两种情况，一种是静态资源长期不需要修改，还有一种是静态资源修改频繁的</p><p>资源长期不变的话，比如 1 年都不怎么变化，我们可以使用强缓存，如 Cache-Control 来实现。具体来说可以通过设置 Cache-Control:max-age=31536000，来让浏览器在一年内直接使用本地缓存文件，而不是向服务端发出请求。</p><p>至于第二种，<strong>如果资源本身随时会发生改动的，可以通过设置 Etag 实现协商缓存</strong> 具体来说，在初次请求资源时，设置 Etag（比如使用资源的 md5 作为 Etag），并且返回 200 的状态码，之后请求时带上 <code>If-none-match</code> 字段，来询问服务器当前版本是否可用。如果服务端数据没有变化，会返回一个 304 的状态码给客户端，告诉客户端不需要请求数据，直接使用之前缓存的数据即可</p><h3 id="离线化"><a href="#离线化" class="headerlink" title="离线化"></a>离线化</h3><p>离线化是指线上实时变动的资源数据静态化到本地，访问时走的是本地文件的方案。说到这里，你是不是想到了离线包？离线包是离线化的一种方案，是将静态资源存储到 App 本地的方案，不过，在这里，我重点讲的是离线化的另一个方案——把页面内容静态化到本地。</p><p>离线化一般适合首页或者列表页等不需要登录页面的场景，同时能够支持 SEO 功能。那么，如何实现离线化呢？其实，打包构建时预渲染页面，前端请求落到 index.html 上时，已经是渲染过的内容。此时，可以通过 Webpack 的 <code>prerender-spa-plugin</code>来实现预渲染，进而实现离线化。Webpack 实现预渲染的代码示例如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.conf.js</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> PrerenderSpaPlugin = <span class="built_in">require</span>(<span class="string">'prerender-spa-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PrerenderSpaPlugin(</span><br><span class="line">      <span class="comment">// 编译后的html需要存放的路径</span></span><br><span class="line">      path.join(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">      <span class="comment">// 列出哪些路由需要预渲染</span></span><br><span class="line">      [ <span class="string">'/'</span>, <span class="string">'/about'</span>, <span class="string">'/contact'</span> ]</span><br><span class="line">    )</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h3><p>懒加载、缓存和离线化都是在请求本身上下功夫，想尽办法减少请求或者推迟请求，并行化则是在请求通道上功夫，解决请求阻塞问题，进而减少首屏时间。 这就像解决交通阻塞一样，除了限号减少车辆，还可以增加车道数量，我们在处理请求阻塞时，也可以加大请求通道数量——借助于HTTP 2.0 的多路复用方案来解决。</p><p>HTTP 1.1 时代，有两个性能瓶颈点，串行的文件传输和同域名的连接数限制（6个），到了HTTP 2.0 时代，因为提供了多路复用的功能，传输数据不再使用文本传输（文本传输必须按顺序传输，否则接收端不知道字符的顺序），而是采用二进制数据帧和流的方式进行传输。</p><p>其中，帧是数据接收的最小单位，流是连接中的一个虚拟通道，它可以承载双向信息。每个流都会有一个唯一的整数 ID 对数据顺序进行标识，这样接收端收到数据后，可以按照顺序对数据进行合并，不会出现顺序出错的情况。所以，在使用流的情况下，不论多少个资源请求，只要建立一个连接即可。</p><p>文件传输环节问题解决后，同域名连接数限制问题怎么解决呢？以 Nginx 服务器为例，原先因为每个域名有 6 个连接数限制，最大并发就是 100 个请求，采用 HTTP 2.0 之后，现在则可以做到 600，提升了 6倍。</p><p>你一定会问，这不是运维侧要做的事情吗，我们前端开发需要做什么？我们要改变静态文件合并（JS、CSS、图片文件）和静态资源服务器做域名散列这两种开发方式。</p><p>具体来说，使用 HTTP 2.0 多路复用之后，单个文件可以单独上线，不需要再做 JS 文件合并了。因为原先遇到由 A 和 B 组成的 C 文件，其中 A 文件稍微有点修改，整个C 文件就需要重新加载的情况，如今由于没有同域名连接数限制了，也就不需要了。</p><p><img src="https://blog.poetries.top/img/static/images/20210503162414.png" alt></p><h2 id="八、优化手段：白屏-300ms-和界面流畅优化技巧"><a href="#八、优化手段：白屏-300ms-和界面流畅优化技巧" class="headerlink" title="八、优化手段：白屏 300ms 和界面流畅优化技巧"></a>八、优化手段：白屏 300ms 和界面流畅优化技巧</h2><h3 id="白屏优化"><a href="#白屏优化" class="headerlink" title="白屏优化"></a>白屏优化</h3><p>现在我们假设一个场景，有一天你想要在某电商 App 上买个手机，于是你搜索后进入商品列表页，结果屏幕一片空白，过了好久还是没什么内容出现，这时候你是不是会退出来，换另外一个电商 App 呢？这就是白屏时间过长导致用户跳出的情形。</p><p>作为前端开发者，我们遇到这种问题如何解决呢？首先去性能平台上查看白屏时间指标，确认是否是白屏问题。问题确认后，我们可以基于影响白屏时间长短的两个主要因素来解决——DNS 查询和首字符展示。</p><h3 id="DNS-查询优化"><a href="#DNS-查询优化" class="headerlink" title="DNS 查询优化"></a>DNS 查询优化</h3><p>DNS 查询是指浏览器发起请求时，需要将用户输入的域名地址转换为 IP 地址的过程，这个转换时间长短就会影响页面的白屏时间。</p><p>那么如何对 DNS 查询进行优化呢？根据 DNS 查询过程，我们可以从前端和客户端这两部分采取措施。</p><p>前端侧，可以通过在页面中加入 <code>dns-prefetch</code>，在静态资源请求之前对域名进行解析，从而减少用户进入页面的等待时间。如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://s.google.com/&quot; &gt;</span><br></pre></td></tr></table></figure><p>其中第一行中的 <code>x-dns-prefetch-control</code> 表示开启 <code>DNS</code> 预解析功能，第二行 <code>dns-prefetch</code> 表示强制对 <code>s.google.com</code> 的域名做预解析。这样在 <code>s.google.com</code> 的资源请求开始前，<code>DNS</code> 解析完成，后续请求就不需要重复做解析了。不要小看这个标签哦，它可以为你减少 <code>150ms</code> 左右的 DNS 解析时间。</p><p>客户端侧呢？可以在启动 App 时，同步创建一个肉眼不可见的 WebView（例如 1*1 像素的 webview），将常用的静态资源路径写入这个 WebView 中，然后对它做域名解析并放入缓存中。这样后面需要使用 WebView 打开真正所需的页面时，由于已经做过域名解析了，客户端直接从缓存中获取即可。</p><p>当然如果是端外页面，因为没在 App 里面，就没法使用 <code>1*1 WebView</code> 的策略了，我们可以使用 <code>iframe</code> ，也能达到类似效果。</p><p>以上是一个轻量级的方案，通过它可以将 DNS 解析时间控制在 <code>400ms</code> 以内（这个算是比较快的）。如果你想要将耗时进一步压缩，比如控制在 200ms，此时就需要一个重量级的方案了。具体来说，可以采用 IP 直连方式，原来是请求 <code>www.google.com</code>，现在我们通过调用 SDK 进行域名解析，拿到对应的 IP（如 6.6.6.6），然后直接请求这个 IP 地址拿到数据。</p><p>当然，这个实现起来需要避过许多坑，比如，HTTPS 证书和配置文件。</p><p><code>Https</code> 证书是指当客户端使用 IP 直连时，请求 URL 中的 host 会被替换成对应的 IP，所以在证书验证时，会出现 domain 不匹配的情况，导致 SSL/TLS 握手不成功。</p><p>怎么解决呢？在非 SNI（Server Name Indication，表示单 IP多域名）的场景下，可以把证书验证环节独立出来 （如 Hook证书校验环节），然后将 IP 替换为原来的域名。在 SNI 场景下，可以定制 <code>SSLSocketFactory</code>，在 createSocket 时替换为 IP，并进行 SNI/HostNameVerify 配置。</p><p>而配置文件方面，一般在域名只有两三个的情况时，我们可以用到它来做 IP 和域名的映射。但随着机房的扩大，每次扩机器都要升级配置文件，后续会非常麻烦。</p><p>对此我们可以采用 httpDNS 来解决。这是因为 httpDNS 可以准确调度到对应区域的服务器 IP 地址给用户，同时还可以避免运行商 DNS 劫持。具体来说， SDK 会通过发报文（类似系统向 DNS 运营商发的报文）向 httpDNS 做一个 HTTP 请求（也是通过 IP 直接请求），请求通过后拿到对应域名，然后进行 IP 直连，完成资源或者数据接口请求。</p><h3 id="首字符展示优化"><a href="#首字符展示优化" class="headerlink" title="首字符展示优化"></a>首字符展示优化</h3><p>所谓首字符展示，通常我们会在页面加载过程中出现一个 loading 图，用来告诉用户页面内容需要加载，请耐心等待。但这样一个 loading 图既无法让用户感受到页面加载到什么程度，也无法给用户视觉上一个焦点，让人们的注意力集中在上面。</p><p>如何解决这个问题呢？我们可以使用骨架屏。骨架屏（Skeleton Screen）是指在页面数据加载完成前，先给用户展示出页面的大致结构（灰色占位图），告诉用户页面正在渐进式地加载中，然后在渲染出实际页面后，把这个结构替换掉。骨架屏并没有真正减少白屏时间，但是给了用户一个心理预期，让他可以感受到页面上大致有什么内容。</p><p>那么，如何构建骨架屏呢？因为考虑到每次视觉修改或者功能迭代，骨架屏都要配合修改，我建议采用自动化方案，而不是手动骨架屏方案（也就是自己编写骨架屏代码）。骨架屏的实现方法有以下三个步骤。</p><ul><li>步骤一，确定生成规则，遍历所有的 DOM 元素。针对特定区块（如视频、音频）生成相应的代码块，获取原始页面中 DOM 节点的宽度、高度和距离视窗的位置，计算出当前设备快高对应的大小，转换成相应的百分比，然后来适配不同的设备。</li><li>步骤二，基于上述规则结合 CLI 工具可以通过脚手架自动生成骨架屏</li><li>步骤三，将骨架屏自动化注入页面，再利用 Puppeteer 把骨架屏代码注入页面中自动运行。整个过程比较复杂，且有不少坑</li></ul><p>以上就是白屏时间优化方面相关的内容，但即便首屏展示比较快，如果有卡顿的现象，用户操作也会很不流畅，那怎么解决这个问题呢。下面我们就讲聊聊卡顿治理。</p><h3 id="卡顿治理"><a href="#卡顿治理" class="headerlink" title="卡顿治理"></a>卡顿治理</h3><p>卡顿现象，一般可以通过用户反馈或性能平台来发现。比如我们接到用户说某页面比较卡，然后在性能平台上查看卡顿指标后，发现页面出现连续 5 帧超过 50ms ，这就属于严重卡顿。如何处理呢？</p><p>首先也还是问题的定位，先通过 charles 等工具抓包看一下数据接口，如果是和数据相关的问题，找后端同事，或者用数据缓存的方式解决。如果问题出在前端，一般和以下两种情形有关：<code>浏览器的主线程与合成线程调度不合理，以及计算耗时操作</code>。</p><h3 id="浏览器的主线程与合成线程调度不合理"><a href="#浏览器的主线程与合成线程调度不合理" class="headerlink" title="浏览器的主线程与合成线程调度不合理"></a>浏览器的主线程与合成线程调度不合理</h3><p>比如，在某电商 App 页面点击抽奖活动时，遇到一个红包移动的效果，在红包位置变化时，页面展现时特别卡，这就是主线程和合成线程调度的问题。怎么解决呢？</p><p>一般来说，主线程主要负责运行 JavaScript，计算 CSS 样式，元素布局，然后交给合成线程，合成线程主要负责绘制。当使用 height、width、margin、padding 等作为 transition 值时，会让主线程压力很大。此时我们可以使用 transform 来代替直接设置 margin 等操作。</p><p>比如红包元素从 margin-left:-10px 渲染到 margin-left:0，主线程需要计算样式 margin-left:-9px，margin-left:-8px，一直到 margin-left:0，每一次主线程计算样式后，合成线程都需要绘制到 GPU 再渲染到屏幕上，来来回回需要进行 10 次主线程渲染，10 次合成线程渲染，这给浏览器造成很大压力，从而出现卡顿。</p><p>如何解决呢？我们可以利用 transform 来做，比如 tranform:translate(-10px,0) 到 transform:translate(0,0)，主线程只需要进行一次tranform:translate(-10px,0) 到 transform:translate(0,0)，然后合成线程去一次将 -10px 转换到 0px。这样的话，总计 11 次计算，可以减少 9 步操作，假设一次 10ms，将减少 90ms。</p><h3 id="计算耗时操作"><a href="#计算耗时操作" class="headerlink" title="计算耗时操作"></a>计算耗时操作</h3><p>除了主线程和合成线程调度不合理导致的卡顿，还有因为计算耗时过大导致的卡顿。遇到这类问题，一般有两种解法：空间换时间和时间换空间。</p><p>空间换时间方面，比如你需要频繁增加删除很多 DOM 元素，这时候一定会很卡，在对 DOM 元素增删的过程中最好先在 DocumentFragment （DOM文档碎片）上操作，而不是直接在 DOM上操作。只在最后一步操作完成后，将所有 DocumentFragment 的变动更新到 DOM上，从而解决频繁更新 DOM 带来的卡顿问题。</p><p>至于时间换空间，一般是通过将一个复杂的操作细分成一个队列，然后通过多次操作解决复杂操作的问题。</p><p><img src="https://blog.poetries.top/img/static/images/20210503163046.png" alt></p><h2 id="九、JS-SDK-设计"><a href="#九、JS-SDK-设计" class="headerlink" title="九、JS SDK 设计"></a>九、JS SDK 设计</h2><p><img src="https://blog.poetries.top/img/static/images/20210503170316.png" alt></p><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>网站的性能怎么样。不能单单是靠某种工具去检测，就能得出的结果。因为影响它的因素有很多（dns解析、网络、缓存…）</p><blockquote><p><code>Performance</code>是一个做前端性能监控离不开的<code>API</code>，最好在页面完全加载完成之后再使用，因为很多值必须在页面完全加载之后才能得到。最简单的办法是在<code>window.onload</code>事件中读取各种数据。</p></blockquote><p><strong>1. 页面加载</strong></p><blockquote><p>一个页面的请求到响应再到显示出来，需要经过下面一些重要过程，当我们在浏览器输入一个<code>URL</code>或者说点击一个<code>URL</code>开始，会出现如下流程</p></blockquote><ul><li>页面准备</li><li>重定向：在<code>header</code>定义了重定向才会有这个过程，如果没有重定向，不会产生这个过程。</li><li><code>app cache</code>：会先检查这个域名是否有缓存，如果有缓存就不需要DNS解析域名。这里的<code>app</code>是值应用程序<code>application</code>，不指手机<code>app</code>。</li><li><code>DNS</code>解析：把域名解析成<code>IP</code>，如果直接用<code>ip</code>地址访问，不产生这个过程。</li><li><code>TCP</code>连接：<code>http</code>协议是经过<code>TCP</code>来传输的，所以产生一个<code>http</code>请求就会有<code>TCP connect</code>，但是依赖于长连接，不会产生这个过程。</li><li><code>request header</code>：请求头信息。</li><li><code>request body</code>：请求体信息，比如<code>get</code>请求是没有请求体信息的，所以没有这个过程，这就是为什么把头跟体分开写的原因。</li><li><code>response header</code>：响应头信息。</li><li><code>response body</code>：响应体信息。</li><li>解析<code>HTML</code>结构</li><li>加载外部脚本和样式表文件：正常来说<code>JS</code>、<code>css</code>都是外部加载的，当然有不正常的人啊，比如我。</li><li>解析并执行脚本代码</li><li>构建与解析<code>HTML DOM</code>树：这个过程可以去了解下<code>DOM</code>树是怎样的就明白啦。</li><li>加载外部图片</li><li>页面加载完成，显示出来啦</li></ul><p><strong>2. 重定向分析</strong></p><ul><li><code>app cach</code></li><li><code>DNS</code>解析</li><li><code>TCP</code>连接</li><li><code>request header</code></li><li>重定向</li><li><code>app cach</code></li><li><code>DNS</code>解析</li><li><code>TCP</code>连接</li><li><code>request header</code></li></ul><p><strong>3. performance.timing</strong></p><blockquote><p>这个API能帮我们得到整个页面请求的时间，如下图，在<code>Chrome</code>的<code>Console</code>是可以直接运行的</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210503170506.png" alt></p><p>先解释下这些时间都是代表什么</p><p><strong>timing 对象里边的数据比较多，梳理如下几个关键性的节点</strong></p><ul><li><code>fetchStart</code>：发起获取当前文档的时间点，我的理解是浏览器收到发起页面请求的时间点；</li><li><code>domainLookupStart</code>：返回浏览器开始<code>DNS</code>查询的时间，如果此请求没有<code>DNS</code>查询过程，如长连接、资源<code>cache</code>、甚至是本地资源等，那么就返回<code>fetchStart</code>的值；</li><li><code>domainLookupEnd</code>：返回浏览器结束<code>DNS</code>查询的时间，如果没有<code>DNS</code>查询过程，同上；</li><li><code>connectStart</code>：浏览器向服务器请求文档，开始建立连接的时间，如果此连接是一个长连接，或者无需与服务器连接（命中缓存），则返回<code>domainLookupEnd</code>的值；</li><li><code>connectEnd</code>：浏览器向服务器请求文档，建立连接成功的时间；</li><li><code>requestStart</code>：开始请求文档的时间（注意没有<code>requestEnd</code>）;</li><li><code>responseStart</code>：浏览器开始接收第一个字节数据的时间，数据可能来自于服务器、缓存、或本地资源；</li><li><code>unloadEventStart</code>：卸载上一个文档开始的时间；</li><li><code>unloadEventEnd</code>：卸载上一个文档结束的时间；</li><li><code>domLoading</code>：浏览器把<code>document.readyState</code>设置为<code>“loading”</code>的时间点，开始构建<code>dom</code>树的时间点；</li><li><code>responseEnd</code>：浏览器接收最后一个字节数据的时间，或连接被关闭的时间；</li><li><code>domInteractive</code>：浏览器把<code>document.readyState设</code>置为<code>“interactive”</code>的时间点，<code>DOM</code>树创建结束；</li><li><code>domContentLoadedEventStart</code>：文档发生<code>DOMContentLoaded</code>事件的时间；</li><li><code>domContentLoadedEventEnd</code>：文档的<code>DOMContentLoaded</code>事件结束的时间；</li><li><code>domComplete</code>：浏览器把<code>document.readyState</code>设置为<code>“complete”</code>的时间点；</li><li><code>loadEventStart</code>：文档触发<code>load</code>事件的时间；</li><li><code>loadEventEnd</code>：文档出发<code>load</code>事件结束后的时间</li></ul><blockquote><p>再来一张图，表示各阶段的开始与结束对应的时间</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210503170539.png" alt></p><blockquote><p>从以上的分析，我们就可以得到一些时间的计算</p></blockquote><ul><li>准备新页面耗时：<code>fetchStart - navigationStart</code></li><li>重定向时间：<code>redirectEnd - redirectStart</code></li><li><code>App Cache</code>时间：<code>domainLookupStart - fetchStart</code></li><li><code>DNS</code>解析时间：<code>domainLookupEnd -domainLookupStart</code></li><li><code>TCP</code>连接时间：<code>connectEnd - connectStart</code></li><li><code>request</code>时间：<code>responseEnd - requestStart</code>这个计算是代表请求响应加起来的时间</li><li>请求完毕到<code>DOM</code>树加载：<code>domInteractive -responseEnd</code></li><li>构建与解析<code>DOM</code>树，加载资源时间：<code>domCompleter -domInteractive</code></li><li><code>load</code>时间：<code>loadEventEnd - loadEventStart</code></li><li>整个页面加载时间：<code>loadEventEnd -navigationStart</code></li><li>白屏时间：<code>responseStart-navigationStart</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> timing = performance.timing</span><br><span class="line"></span><br><span class="line"><span class="comment">// DNS 解析耗时</span></span><br><span class="line">timing.domainLookupEnd - timing.domainLookupStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP 连接耗时</span></span><br><span class="line">timing.connectEnd - timing.connectStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSL 安全连接耗时</span></span><br><span class="line">timing.connectEnd - timing.secureConnectionStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络请求耗时</span></span><br><span class="line">timing.responseStart - timing.requestStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据传输耗时</span></span><br><span class="line">timing.responseEnd - timing.responseStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM 解析耗时</span></span><br><span class="line">timing.domInteractive - timing.responseEnd</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源加载耗时</span></span><br><span class="line">timing.loadEventStart - timing.domContentLoadedEventEnd </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关键性能指标 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首包时间</span></span><br><span class="line">timing.responseStart - timing.domainLookupStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白屏时间</span></span><br><span class="line">timing.responseStart - timing.navigationStart </span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次可交互时间</span></span><br><span class="line">timing.domInteractive - timing.requestStart </span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML 加载完成时间， 即 DOM Ready 时间</span></span><br><span class="line">timing.domContentLoadedEventEnd - timing.navigationStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面完全加载时间</span></span><br><span class="line">timing.loadEventStart - timing.navigationStart</span><br></pre></td></tr></table></figure><p><strong>4. performance.getEntries()</strong></p><blockquote><p>这个API能帮我们获得资源的请求时间，包括JS、CSS、图片等</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210503170603.png" alt></p><blockquote><p>如上图可以看到这个API请求返回的是一个数组，这个数组包括整个页面所有的资源加载，上图打开了一个其中一个资源，可以看到如下信息</p></blockquote><ul><li><code>entryType</code>：类型为<code>resource</code></li><li><code>name</code>：资源的<code>url</code></li><li><code>initiatorType</code>：资源是<code>link</code></li><li>资源时间：<code>duration</code>的值，是<code>responseEnd - startTime</code>得到的</li></ul><p><strong>performance.memory</strong></p><blockquote><p>这个API主要是得到浏览器内存情况</p></blockquote><ul><li><code>jsHeapSizeLimit</code>：内存大小限制</li><li><code>totalJSHeapSize</code>：可使用的内容</li><li><code>userdJSHeapSize</code>：已使用的内容</li></ul><blockquote><p><code>userdJSHeapSize</code>表示所有被使用的JS堆栈内存，<code>totalJSHeapSize</code>可使用的JS堆栈内存，如果<code>userdJSHeapSize</code>的值大于<code>totalJSHeapSize</code>，就可能出现内存泄漏</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210503170616.png" alt></p><p><strong>5. getEntriesByType</strong></p><p>这个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType" target="_blank" rel="noopener">API</a> 可以让我们通过传入 <code>type</code> 获取一些相应的信息：</p><ul><li>frame：事件循环中帧的时间数据。</li><li>resource：加载应用程序资源的详细网络计时数据</li><li>mark：<code>performance.mark</code> 调用信息</li><li>measure：<code>performance.measure</code> 调用信息</li><li>longtask：长任务（执行时间大于 50ms）信息。这个类型已被废弃（文档未标注，但是在 Chrome 中使用会显示已废弃），我们可以通过别的方式来拿</li><li>navigation：浏览器文档事件的指标的方法和属性</li><li>paint：获取 FP 和 FCP 指标</li></ul><p>最后两个 <code>type</code> 是性能检测中获取指标的关键类型。当然你如果还想分析加载资源相关的信息的话，那可以多加上 <code>resource</code> 类型。</p><p><strong>6. PerformanceObserver</strong></p><p><code>PerformanceObserver</code>也是用来获取一些性能指标的 API，用法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> perfObserver = <span class="keyword">new</span> PerformanceObserver(<span class="function">(<span class="params">entryList</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 信息处理</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 传入需要的 type</span></span><br><span class="line">perfObserver.observe(&#123; <span class="attr">type</span>: <span class="string">'longtask'</span>, <span class="attr">buffered</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>结合 <code>getEntriesByType</code> 以及 <code>PerformanceObserver</code>，我们就能获取到所有需要的指标了。</p></blockquote><h3 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h3><p><strong>js 运行时报错</strong></p><blockquote><p>为了更好的保证网站正常的运行，我们会通过<code>window.onerror</code>捕获，js具体的堆栈信息和错误行和列。一般我们的js都是打包压缩、混淆后上传到cdn的（无法定位到具体错误）。因此在打包时，同时生产<code>.map</code>文件，用 <code>sourcemap</code> js库（nodejs）来还原具体错误信息</p></blockquote><p><strong>资源加载出错</strong></p><blockquote><p>为了防止加载资源失败，而导致网站打不开。一般我们会通过 <code>window.addEventListener(&#39;error&#39;)</code> 对资源加载进行监控。</p></blockquote><p><strong>后端api接口监控</strong></p><blockquote><p>一般对于小公司而言，可能连后端都很少会有接口方面的监控。一旦出现问题，却又不好排查问题，因此我们可以通过对浏览器底层的xhr对象进行拦截，上报相关调用数据和接口耗时。一方面可以检测到接口的实时调用情况，同时也方便后期对接口的数据统计。</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210503175341.png" alt></p><h3 id="数据处理和展示"><a href="#数据处理和展示" class="headerlink" title="数据处理和展示"></a>数据处理和展示</h3><p>用到 <code>es（elasticsearch）</code>来对数据进行实时查询和分析。可是怎么把数据推到es里面呢？这对于前端同学来说，这又是一个难点。别急，“logstash” 了解一下。logstash主要对数据进行采集、分析、过滤的工具，然后推送到es里面。数据既然有了，那么怎么展示呢？这时候 Kibana 出来了，来作为数据展示的承托。这就是后端开源届的日志分析系统“ELK”。</p><p><img src="https://blog.poetries.top/img/static/images/20210503175506.png" alt></p><p>其实对于数据的展示，可以不用kibana或者其他开源的产品进行展示，也可以自己通过es的restful接口，来搭建数据展示</p><p><img src="https://blog.poetries.top/img/static/images/20210503175531.png" alt></p><h2 id="十、前端监控系统实战"><a href="#十、前端监控系统实战" class="headerlink" title="十、前端监控系统实战"></a>十、前端监控系统实战</h2><h3 id="没有前端监控下的痛点有哪些"><a href="#没有前端监控下的痛点有哪些" class="headerlink" title="没有前端监控下的痛点有哪些"></a>没有前端监控下的痛点有哪些</h3><ul><li>用户反馈点击某个按钮没有任何反应。（没办法知道用户点了按钮，为什么没反应呢？是js报错导致，还是其它原因导致？）</li><li>用户反馈打开页面很慢。（没办法感知用户慢在什么地方）</li><li>调用后端api接口出错，无法第一时间感知。（只能被动等待用户告诉和自己去发现）</li><li>网站静态资源加载出错，导致网站打不开。</li><li>上报的js错误信息，怎么反解析出源代码报错位置。</li></ul><p><img src="https://blog.poetries.top/img/static/images/20210503175936.png" alt></p><h3 id="手动搭建一个前端监控系统"><a href="#手动搭建一个前端监控系统" class="headerlink" title="手动搭建一个前端监控系统"></a>手动搭建一个前端监控系统</h3><p>在搭建前端监控系统开始之前，我们先来了解下整个系统的架构是怎么样的。因为你只有了解到流程是怎样走的，才清楚每个步骤我们该做些什么事情。</p><p><img src="https://blog.poetries.top/img/static/images/20210503180034.png" alt></p><h3 id="JS-SDK-功能设计"><a href="#JS-SDK-功能设计" class="headerlink" title="JS SDK 功能设计"></a>JS SDK 功能设计</h3><p><strong>1. 监控js错误信息上报</strong></p><p>通过<code>window.onerror</code>方法，对页面js错误进行监控。上报具体的错误信息和堆栈信息（如下图），利用<code>webpack/gulp打包出来的.map文件</code>，来解析出具体的错误信息。</p><p><img src="https://blog.poetries.top/img/static/images/20210503180112.png" alt></p><p>nodejs通过上传.map文件，解析出具体错误信息。代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sourceMap = <span class="built_in">require</span>(<span class="string">'source-map'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _sourceMap = fs.readFileSync(resolve(<span class="string">`<span class="subst">$&#123;name&#125;</span>`</span>), <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过sourceMap库转换为sourceMapConsumer对象  </span></span><br><span class="line"><span class="keyword">let</span> consumer = <span class="keyword">await</span> <span class="keyword">new</span> sourceMap.SourceMapConsumer(_sourceMap);</span><br><span class="line"><span class="comment">// 传入要查找的行列数，查找到压缩前的源文件及行列数  </span></span><br><span class="line"><span class="keyword">let</span> sm = consumer.originalPositionFor(&#123;</span><br><span class="line">    line: line, <span class="attr">column</span>: column</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩前的所有源文件列表  </span></span><br><span class="line"><span class="keyword">let</span> sources = consumer.sources;</span><br><span class="line"><span class="comment">// 根据查到的source，到源文件列表中查找索引位置  </span></span><br><span class="line"><span class="keyword">let</span> smIndex = sources.indexOf(sm.source);</span><br><span class="line"><span class="comment">// 到源码列表中查到源代码  </span></span><br><span class="line"><span class="keyword">let</span> smContent = consumer.sourcesContent[smIndex];</span><br><span class="line"><span class="comment">// 将源代码串按"行结束标记"拆分为数组形式  </span></span><br><span class="line"><span class="keyword">const</span> rawLines = smContent.split(<span class="regexp">/\r?\n/g</span>);</span><br><span class="line"><span class="comment">// 输出源码行，因为数组索引从0开始，故行数需要-1  </span></span><br><span class="line"><span class="keyword">let</span> errInfo = []</span><br><span class="line">errInfo.push(&#123;</span><br><span class="line">    line: sm.line - <span class="number">2</span>,</span><br><span class="line">    text: rawLines[sm.line - <span class="number">2</span>]</span><br><span class="line">&#125;)</span><br><span class="line">errInfo.push(&#123;</span><br><span class="line">    line: sm.line - <span class="number">1</span>,</span><br><span class="line">    text: rawLines[sm.line - <span class="number">1</span>]</span><br><span class="line">&#125;)</span><br><span class="line">errInfo.push(&#123;</span><br><span class="line">    line: sm.line,</span><br><span class="line">    text: rawLines[sm.line]</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.ctx.body = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  code: <span class="number">1</span>,</span><br><span class="line">  data: errInfo,</span><br><span class="line">  msg: <span class="string">'success'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先在管理后台，上传对应错误js的map文件，最终还原效果图如下：</p><p><img src="https://blog.poetries.top/img/static/images/20210503180234.png" alt></p><p>通过上图，我们可以快速定位错误的具体位置，大大节省了排查错误的时间。</p><p><strong>2. api接口调用请求上报</strong></p><blockquote><p>可能有些朋友会好奇，怎么去实时监听ajax异步接口请求情况呢？其实很简单：首先我们先通过代理XMLHttpRequest对象，来实现对ajax异步请求进行数据劫持。如下图：</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210503180304.png" alt></p><p>通过上图不难发现，我们通过xhr对象的<code>onreadystatechange</code>事件进行劫持，针对后端api接口返回的数据，进行处理上报接口的调用情况，因此达到实时监控接口调用情况，是不是觉得很神奇！</p><p>如有同学想了解这块内容具体的代码，github社区有开源的模块，可自行查看： <a href="https://github.com/wendux/Ajax-hook" target="_blank" rel="noopener">https://github.com/wendux/Ajax-hook</a></p><p>根据需要统计哪些数据进行上报，比如<code>:page query</code>参数、api接口请求数据…方便后续出错，定位问题。如下图：</p><p><img src="https://blog.poetries.top/img/static/images/20210503180352.png" alt></p><p><strong>3. 页面性能数据上报</strong></p><blockquote><p>关于页面性能数据，我们一般通过浏览器<code>performance.timingAPI</code>来进行上报</p></blockquote><p><strong>各阶段耗时图</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210503180431.png" alt></p><p><strong>关键性能指标图</strong></p><p><img src="https://blog.poetries.top/img/static/images/20210503180455.png" alt></p><p><strong>4. 能支持自定义数据上报</strong></p><blockquote><p>上述一般都是自动进行错误采集进行上报，但有些情况是需要我们手动调用进行上报（自定义数据的埋点）。因此sdk的设计，最好支持手动调用上报。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> report = <span class="keyword">new</span> Reort(&#123;</span><br><span class="line">    参数配置...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// get 上报</span></span><br><span class="line">report.getRport(&#123;<span class="attr">xxx</span>: <span class="number">111</span>&#125;, (data) =&gt; &#123;</span><br><span class="line">    Consoel.log(<span class="string">'上报回调的数据：'</span>, data)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// post 上报</span></span><br><span class="line">report.postRport(&#123;<span class="attr">xxx</span>: <span class="number">111</span>&#125;, (data) =&gt; &#123;</span><br><span class="line">    Consoel.log(<span class="string">'上报回调的数据：'</span>, data)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>关于SDK设计的时候，需要注意的以下几点：</strong></p><ul><li>SDK上报采用哪种方式比较好。一般来说采用<code>get</code>（<code>image</code>方式上报，因为它避免的跨域的限制，目前也是业界主流的上报方式）</li><li>在SDK上报方式，最好设计<code>get</code>和<code>post</code>两种方式上报。因为有些复杂的数据结构，采用post上报，在服务端解析会比较方便。</li><li>当网站每天的pv很大时，要支持抽样上报，减少服务器资源。（一般做法，通过每次随机一个数值，来跟预设定的值做比较）</li><li>如有想对一些错误信息不需要上报，要支持排查哪些错误信息上报。</li><li>如果针对<code>get</code>上报时，一般是在<code>xx.gif</code>后带参数，一定要对参数进行转义，不然在某些场景下会报错！</li><li>针对采集<code>page</code>参数时，也要进行<code>encodeURIComponent</code>进行转义，不然在某些场景下会报错！</li><li>要支持站点级别的功能，因为你想要接入不同的项目。就得根据不同的做区分和报警设置。思路很简单通过增加一个站点id值，来作为后续数据的筛选条件。比如：<code>pid</code></li></ul><h3 id="服务端接收数据，并记录日志"><a href="#服务端接收数据，并记录日志" class="headerlink" title="服务端接收数据，并记录日志"></a>服务端接收数据，并记录日志</h3><blockquote><p>sdk设计好了，上报数据也有了。现在我们开始设计服务怎么接收和处理数据。以Nodejs为例：</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210503180707.png" alt></p><blockquote><p>通过上图不难发现，我们通过接收到参数，然后通过decode解析出参数，并对参数进行处理。利用 nodejs <code>file-stream-rotator</code> 这个库，把数据写入本地到日志中。(不过在写入日志的时候，记得对一些数据进行校检。</p></blockquote><p>比如：不存在站点id，不给写入。对于外部网站的接口请求，不给写入。通过实战来看，有些情况，竟然会把UC浏览器部分请求给抓上来，所以需要过滤处理)</p><h3 id="数据收集与过滤"><a href="#数据收集与过滤" class="headerlink" title="数据收集与过滤"></a>数据收集与过滤</h3><blockquote><p>当数据写入日志文件中，通过Logstash监测日志变化，收集到数据并对数据进行格式化和过滤处理，并收集推送到ES（数据存储）。</p></blockquote><p>比如利用<code>geoip</code>和<code>useragent</code>插件，分别对ip和浏览器的UA进行解析，分别得到对应的地理位置信息和浏览器相关距离信息。如下图：</p><p><img src="https://blog.poetries.top/img/static/images/20210503180802.png" alt></p><p>关于<code>logstash</code>的安装和配置，在这里不多说啦，可自行google安装配置。（建议使用docker版本，简单省事）</p><h3 id="数据存储（ES）提供分析和查询能力"><a href="#数据存储（ES）提供分析和查询能力" class="headerlink" title="数据存储（ES）提供分析和查询能力"></a>数据存储（ES）提供分析和查询能力</h3><blockquote><p>通过ES（elasticsearch）提供对应的restful api，手动搭建数据大盘（或者用kibana）。对于es数据管理，前期可以先安装一个es-head的插件，来查看数据情况。</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210503180831.png" alt></p><blockquote><p>关于修改<code>es header 5.0 request content-type</code> 不对的情况。可以对 <code>/usr/src/app/_site/ vendor.js</code> 文件进行修改。以docker镜像为例：</p></blockquote><ol><li>从从镜像<code>copy vendor.js</code>文件出来，如：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp elasticsearch-head:/usr/src/app/_site/vendor.js /Users/duanliang/logstash</span><br></pre></td></tr></table></figure><ol start="2"><li>修改ajax 请求<code>content-type</code></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大约在6886行</span><br><span class="line">/contentType: &quot;application/x-www-form-urlencoded</span><br><span class="line">改成</span><br><span class="line">contentType: &quot;application/json;charset=UTF-8&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>把文件copy回容器</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp /Users/duanliang/logstash/vendor.js elasticsearch-head:/usr/src/app/_site/vendor.js</span><br></pre></td></tr></table></figure><ol start="4"><li>重启镜像</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart elasticsearch-head</span><br></pre></td></tr></table></figure><p>你可能用到的 docker 镜像地址：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">es：docker pull docker.elastic.co/elasticsearch/elasticsearch:6.5.4</span><br><span class="line"></span><br><span class="line">es-headder: docker pull mobz/elasticsearch-head:5 </span><br><span class="line"></span><br><span class="line">logstash: docker.elastic.co/logstash/logstash:6.5.4</span><br></pre></td></tr></table></figure><h3 id="告警配置"><a href="#告警配置" class="headerlink" title="告警配置"></a>告警配置</h3><blockquote><p>通过后台配置自定义报警规则，来告警开发人员。原理：通过nodejs启动定时任务来读取配置表，根据不同的规则去读取es里面的数据（一分钟查询一次），如果有错误，则通知报警。</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210503181001.png" alt></p><p><img src="https://blog.poetries.top/img/static/images/20210503181010.png" alt></p><p><img src="https://blog.poetries.top/img/static/images/20210503181017.png" alt></p><p><img src="https://blog.poetries.top/img/static/images/20210503181025.png" alt></p><p>最终以：首页 Dashboard为例</p><p><img src="https://blog.poetries.top/img/static/images/20210503181035.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、性能优化方法论&quot;&gt;&lt;a href=&quot;#一、性能优化方法论&quot; class=&quot;headerlink&quot; title=&quot;一、性能优化方法论&quot;&gt;&lt;/a&gt;一、性能优化方法论&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://blog.poetries.top/img/st
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="前端监控" scheme="http://blog.poetries.top/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>小程序插件总结</title>
    <link href="http://blog.poetries.top/2021/04/20/wx-weapp-plugin/"/>
    <id>http://blog.poetries.top/2021/04/20/wx-weapp-plugin/</id>
    <published>2021-04-20T12:01:24.000Z</published>
    <updated>2025-03-30T13:54:29.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、小程序插件功能介绍"><a href="#一、小程序插件功能介绍" class="headerlink" title="一、小程序插件功能介绍"></a>一、小程序插件功能介绍</h2><blockquote><p>插件的开发和使用自小程序基础库版本 <code>1.9.6</code> 开始支持</p></blockquote><ul><li>插件是对一组 js 接口、自定义组件或页面的封装，用于嵌入到小程序中使用</li><li>插件不能独立运行，必须嵌入在其他小程序中才能被用户使用</li><li>第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用</li><li>会受到一些限制，如一些 API 无法调用或功能受限。还有个别特殊的接口，虽然插件不能直接调用，但可以使用 插件功能页 来间接实现</li><li>框架会对小程序和小程序使用的每个插件进行数据安全保护，保证它们之间不能窃取其他任何一方的数据（除非数据被主动传递给另一方）。</li></ul><blockquote><p>插件，是可被添加到小程序内直接使用的功能组件。开发者可以像开发小程序一样开发一个插件，供其他小程序使用。同时，小程序开发者可直接在小程序内使用插件，无需重复开发，为用户提供更丰富的服务</p></blockquote><p>插件可以是</p><ul><li>提供查询快递信息的服务</li><li>提供查询天气的服务</li><li>提供打车（滴滴）的服务 - 可以使用滴滴提供的组件，直接嵌入自己的小程序，实现打车功能）</li><li>提供外卖（美团外卖）的服务 - 例如每个餐厅需要的小程序风格都不一样，但他都需要外卖功能，那这时就可以给餐厅都定制一个小程序，在外卖部分的功能可以直接使用美团外卖提供的外卖插件（*后面发现插件居然不能微信支付）</li></ul><blockquote><p>除了可以做这些方面还有很多很多，但小程序插件目前限制了开放范围及服务类目（<a href="https://developers.weixin.qq.com/miniprogram/introduction/plugin.html#%E5%BC%80%E6%94%BE%E8%8C%83%E5%9B%B4%E5%8F%8A%E6%9C%8D%E5%8A%A1%E7%B1%BB%E7%9B%AE" target="_blank" rel="noopener">开放类目</a>）</p></blockquote><p><strong>开放范围</strong>：企业、媒体、政府及其他组织主体</p><p>开发者可选择当前小程序帐号已选类目中的一个，作为插件的服务类目。以下为当前已开放的插件服务类目，将逐步开放更多类目。</p><table><thead><tr><th>一级类目</th><th>二级类目</th><th>特殊说明</th></tr></thead><tbody><tr><td>快递业与邮政</td><td>所有二级类目</td><td></td></tr><tr><td>医疗</td><td>就医服务、互联网医院</td><td>仅医疗类小程序可使用</td></tr><tr><td>政务民生</td><td>所有二级类目</td><td></td></tr><tr><td>金融业</td><td>征信业务</td><td></td></tr><tr><td>出行与交通</td><td>所有二级类目</td><td></td></tr><tr><td>生活服务</td><td>票务、生活缴费</td><td></td></tr><tr><td>IT科技</td><td>所有二级类目</td><td></td></tr><tr><td>餐饮</td><td>点评与推荐、菜谱、餐厅排队、点餐平台、外卖平台</td><td></td></tr><tr><td>旅游</td><td>所有二级类目</td><td></td></tr><tr><td>文娱</td><td>视频、FM/电台、音乐、有声读物、动漫</td><td></td></tr><tr><td>工具</td><td>记账、投票、日历、天气、备忘录、办公、字典、计算类、报价/比价、发票查询、企业管理</td><td></td></tr><tr><td>电商平台</td><td>电商平台</td><td></td></tr><tr><td>商业服务</td><td>招聘/求职</td><td></td></tr><tr><td>汽车</td><td>所有二级类目</td></tr></tbody></table><p><strong>开发小程序插件的流程</strong></p><ol><li>开通入口：<code>小程序管理后台-小程序插件</code></li><li>开通插件功能 条件：企业、媒体、政府及其他组织主体的小程序，个人小程序不行 个数：一个小程序只能开通一个插件</li><li>填写开发信息并开发 限制：填写了小程序插件基本信息和头像就不能修改</li><li>提交审核、发布 限制：在开发类目内才能提交 官方文档说“插件发布后才可以被其他小程序搜索并添加”，但实际上不是，没有发布的也可以搜索到和添加</li></ol><h2 id="二、创建插件项目"><a href="#二、创建插件项目" class="headerlink" title="二、创建插件项目"></a>二、创建插件项目</h2><p>小程序的 AppID 可以创建小程序插件项目，插件是独立于小程序之外的，但是 AppID 是公用的，所以<code>不要使用原有的小程序项目进行插件开发</code>。 在创建项目页面，选择一个空文件夹作为项目路径，可以选择创建小程序插件快速启动模板</p><blockquote><p>没有插件appId的，我们需要去申请一个，用来开发插件</p></blockquote><p><img src="https://blog.poetries.top/img/static/images/20210419092828.png" alt></p><ul><li><code>miniprogram</code> 目录：放置一个小程序，用于调试插件。<ul><li>文件夹是一个普通小程序项目，用来编写小程序插件的使用 Demo，上传插件代码时这个 Demo 会一起上传，并作为小程序插件的发布的审核依据.</li></ul></li><li><code>plugin</code> 文件就是小程序插件项目，用来编写小程序插件的代码。</li><li><code>project.config.json</code> 需要关注 <code>compileType</code> 字段，<code>compileType == &#39;plugin&#39;</code> 时才能正常的使用插件项目。详情</li><li><code>doc 目录</code>：插件文档必须放置在插件项目根目录中的 doc 目录下<ul><li>插件文档的入口文件是 <code>doc/README.md</code>，在 <code>README.md</code> 中引用到的图片资源不能是网络图片，且必须放在这个目录下。</li><li>文档中的链接只能链接到<ul><li>微信开发者社区（developers.weixin.qq.com）</li><li>微信公众平台（mp.weixin.qq.com）</li><li>GitHub（github.com）</li></ul></li><li>编辑 <code>README.md</code> 之后，可以在开发者工具左侧资源管理器的文件栏中右键单击<code>README.md</code>，并选择上传文档。发布上传文档后，文档不会立刻发布。此时可以使用帐号和密码登录 管理后台 ，在 <code>小程序插件 &gt; 基本设置</code> 中预览、发布插件文档</li><li>插件文档<code>总大小不能大于 2M</code>，超过时上传将返回错误码 80051<br><img src="https://blog.poetries.top/img/static/images/20210419093822.png" alt></li></ul></li></ul><h3 id="2-1-插件目录结构"><a href="#2-1-插件目录结构" class="headerlink" title="2.1 插件目录结构"></a>2.1 插件目录结构</h3><p>一个插件可以包含若干个自定义组件、页面，和一组 js 接口。插件的目录内容如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugin</span><br><span class="line">├── components</span><br><span class="line">│   ├── hello-component.js   <span class="comment">// 插件提供的自定义组件文件夹， 中自定义组件可以有多个</span></span><br><span class="line">│   ├── hello-component.json</span><br><span class="line">│   ├── hello-component.wxml</span><br><span class="line">│   └── hello-component.wxss</span><br><span class="line">├── pages</span><br><span class="line">│   ├── hello-page.js        <span class="comment">// 插件提供的页面（可以有多个，自小程序基础库版本 2.1.0 开始支持）</span></span><br><span class="line">│   ├── hello-page.json</span><br><span class="line">│   ├── hello-page.wxml</span><br><span class="line">│   └── hello-page.wxss</span><br><span class="line">├── index.js                 <span class="comment">//  插件入口文件，可以在这里 export 一些 js 接口，供插件使用者使用</span></span><br><span class="line">└── plugin.json              <span class="comment">//  插件的配置文件，主要说明有哪些自定义组件可以供插件外部调用，并标识哪个js文件是插件的js接口文件，默认的配置形式如下：</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"publicComponents"</span>: &#123;</span><br><span class="line">    <span class="string">"list"</span>: <span class="string">"components/list/list"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-插件配置文件"><a href="#2-2-插件配置文件" class="headerlink" title="2.2 插件配置文件"></a>2.2 插件配置文件</h3><blockquote><p>提供给使用者小程序使用的自定义组件必须在配置文件的 publicComponents 段中列出</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"publicComponents"</span>: &#123;</span><br><span class="line">    <span class="attr">"hello-component"</span>: <span class="string">"components/hello-component"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"pages"</span>: &#123;</span><br><span class="line">    <span class="attr">"hello-page"</span>: <span class="string">"pages/hello-page"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置文件将向使用者小程序开放一个自定义组件 <code>hello-component</code>，一个页面 <code>hello-page</code> 和 <code>index.js</code> 下导出的所有 js 接口。</p><h3 id="2-3-插件预览、上传和发布"><a href="#2-3-插件预览、上传和发布" class="headerlink" title="2.3 插件预览、上传和发布"></a>2.3 插件预览、上传和发布</h3><ul><li>插件可以像小程序一样预览和上传，但<code>插件没有体验版</code>。</li><li>插件会同时有多个线上版本，由使用插件的小程序决定具体使用的版本号。</li><li>手机预览和提审插件时，会使用一个特殊的小程序来套用项目中 miniprogram 文件夹下的小程序，从而预览插件。</li></ul><p><strong>在开发版小程序中测试</strong></p><ul><li>通常情况下，可以将 <code>miniprogram</code> 下的代码当做使用插件的小程序代码，来进行插件的调试和测试</li><li>但有时，<code>需要将插件的代码放在实际运行的小程序中进行调试、测试</code>。此时，<code>可以使用开发版的小程序直接引用开发版插件</code>。方法如下：</li></ul><ol><li>在开发者工具的插件项目中上传插件，此时，在上传成功的通知信息中将包含这次上传获得的插件开发版 ID （一个英文、数字组成的随机字符串）；</li><li>点击开发者工具右下角的通知按钮，可以打开通知栏，看到<code>新生成的 ID</code> ；</li><li>在需要使用开发版本插件的小程序项目中，将插件 <code>version</code> 设置为 <code>&quot;version&quot;: &quot;dev-[开发版 ID]&quot;</code> 的形式，如 <code>&quot;version&quot;: &quot;dev-abcdef0123456789abcdef0123456789&quot;</code> 即可。</li></ol><blockquote><p>如果开发版小程序引用了开发版插件，此时这个小程序就不能上传发布了。必须要将插件版本设为正式版本之后，小程序才可以正常上传、发布</p></blockquote><p><strong>注意事项：</strong></p><ul><li><code>每次上传插件所生成的 ID 不一定相同</code>，即使是同一个插件和同一个开发者，<code>多次上传也可能会改变 ID</code>；</li><li>每个开发者在每个插件中只会同时存在一个有效的开发版插件，即只有最新上传的开发版 ID 有效（使用旧的 ID 会提示失效）；</li><li>同一个插件不同开发者上传的开发版互不影响，可以同时有效；</li><li>开发版插件没有时间限制，长期有效。</li></ul><h2 id="三、使用插件"><a href="#三、使用插件" class="headerlink" title="三、使用插件"></a>三、使用插件</h2><ul><li><strong>添加插件</strong><ul><li>在使用插件前，首先要在小程序管理后台的<code>“设置-第三方服务-插件管理”</code>中添加插件。开发者可登录小程序管理后台，通过 appid 查找插件并添加。如果插件无需申请，添加后可直接使用；否则需要申请并等待插件开发者通过后，方可在小程序中使用相应的插件。<br><img src="https://blog.poetries.top/img/static/images/20210416164731.png" alt></li></ul></li><li><p><strong>引入插件代码包</strong></p><ul><li><p>使用插件前，使用者要在 <code>app.json</code> 中声明需要使用的插件，例如</p><ul><li><p><strong>在主包中使用插件</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: &#123;</span><br><span class="line">    <span class="attr">"myPlugin"</span>: &#123;</span><br><span class="line">      <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">      <span class="attr">"provider"</span>: <span class="string">"wxidxxxxxxxxxxxxxxxx"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>plugins</code> 定义段中可以包含多个插件声明，每个插件声明以一个使用者自定义的插件引用名作为标识，并指明插件的 appid 和需要使用的版本号。其中，引用名（如上例中的 myPlugin）由使用者自定义，无需和插件开发者保持一致或与开发者协调。在后续的插件使用中，该引用名将被用于表示该插件</li></ul></li><li><p><strong>在分包内引入插件代码包</strong></p><ul><li><p>如果插件只在一个分包内用到，可以将插件仅放在这个分包内，例如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"subpackages"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"root"</span>: <span class="string">"packageA"</span>,</span><br><span class="line">      <span class="attr">"pages"</span>: [</span><br><span class="line">        <span class="string">"pages/cat"</span>,</span><br><span class="line">        <span class="string">"pages/dog"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"plugins"</span>: &#123;</span><br><span class="line">        <span class="attr">"myPlugin"</span>: &#123;</span><br><span class="line">          <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">          <span class="attr">"provider"</span>: <span class="string">"wxidxxxxxxxxxxxxxxxx"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在分包内使用插件有如下限制：</p><ul><li>仅能在这个分包内使用该插件</li><li>同一个插件不能被多个分包同时引用</li></ul></li></ul></li></ul></li></ul></li></ul><p><strong>使用插件方式</strong></p><blockquote><p>使用插件时，插件的代码对于使用者来说是不可见的。阅读由插件开发者提供的插件开发文档，通过文档来明确插件提供的自定义组件、页面名称及提供的 js 接口规范等。</p></blockquote><ul><li><p><strong>使用插件提供的自定义组件</strong></p><ul><li>使用插件提供的自定义组件，和 使用普通自定义组件 的方式相仿。在 json 文件定义需要引入的自定义组件时，使用 <code>plugin:// 协议指明插件的引用名和自定义组件名</code>，例如</li><li><p>插件跳转到自身页面时， url 应设置为这样的形式：<code>plugin-private://PLUGIN_APPID/PATH/TO/PAGE</code> 。需要跳转到其他插件时，也可以这样设置 url 。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"usingComponents"</span>: &#123;</span><br><span class="line">    <span class="attr">"hello-component"</span>: <span class="string">"plugin://myPlugin/hello-component"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>出于对插件的保护，插件提供的自定义组件在使用上有一定的限制：</p><ul><li>默认情况下，页面中的 <code>this.selectComponent</code> 接口无法获得插件的自定义组件实例对象；</li><li><code>wx.createSelectorQuery</code> 等接口的 &gt;&gt;&gt; 选择器无法选入插件内部</li></ul></li></ul></li><li><p><strong>使用插件提供的页面</strong></p><ul><li>需要跳转到插件页面时，url 使用 <code>plugin:// 前缀</code>，形如 <code>plugin://PLUGIN_NAME/PLUGIN_PAGE</code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"plugin://myPlugin/hello-page"</span>&gt;</span></span><br><span class="line">  Go to pages/hello-page!</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>js 接口</strong></p><ul><li><p>使用插件的 js 接口时，可以使用 <code>requirePlugin</code> 方法。例如，插件提供一个名为 hello 的方法和一个名为 world 的变量，则可以像下面这样调用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myPluginInterface = requirePlugin(<span class="string">'myPlugin'</span>);</span><br><span class="line"></span><br><span class="line">myPluginInterface.hello();</span><br><span class="line"><span class="keyword">var</span> myWorld = myPluginInterface.world;</span><br></pre></td></tr></table></figure></li><li><p>基础库 <code>2.14.0</code> 起，也可以通过<code>插件的 AppID 来获取接口</code>，如：<code>var myPluginInterface = requirePlugin(&#39;wxidxxxxxxxxxxxxxxxx&#39;)</code></p></li></ul></li><li><p><strong>使用插件的小程序可以导出内容到插件中共享</strong></p><ul><li>在声明使用插件时，可以通过 <code>export</code> 字段来指定一个文件<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"myPlugin": &#123;</span><br><span class="line">  "version": "dev",</span><br><span class="line">  "provider": "",</span><br><span class="line">  "export": "exportToPlugin.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://blog.poetries.top/img/static/images/20210419141729.png" alt></p><ul><li>导出的内容可以被这个插件用全局函数获得。例如，在上面的文件中，使用插件的小程序做了如下导出：<br><img src="https://blog.poetries.top/img/static/images/20210419141948.png" alt></li></ul></li></ul><p><strong>为插件提供小程序自定义组件</strong></p><blockquote><p>在插件中可以将一部分区域交给使用的小程序来渲染</p></blockquote><p>给插件名为 <code>plugin-index</code> 的页面中的抽象节点 <code>mp-view</code> 指定小程序的自定义组件 <code>components/comp-from-miniprogram</code> 作为实现的话</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"myPlugin"</span>: &#123;</span><br><span class="line">    <span class="attr">"provider"</span>: <span class="string">"wxAPPID"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">"genericsImplementation"</span>: &#123;</span><br><span class="line">      <span class="attr">"plugin-index"</span>: &#123;</span><br><span class="line">        <span class="attr">"mp-view"</span>: <span class="string">"components/comp-from-miniprogram"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- miniprogram/page/index.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin-view</span> <span class="attr">generic:mp-view</span>=<span class="string">"comp-from-miniprogram"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、插件的一些限制"><a href="#四、插件的一些限制" class="headerlink" title="四、插件的一些限制"></a>四、插件的一些限制</h2><h3 id="4-1-调用-API-的限制"><a href="#4-1-调用-API-的限制" class="headerlink" title="4.1 调用 API 的限制"></a>4.1 调用 API 的限制</h3><ul><li>插件的请求域名列表与小程序相互独立；</li><li>一些 API 不允许插件调用（这些函数不存在于 wx 对象下）。</li><li>有些接口虽然在插件中不能使用，但可以通过插件功能页来达到目的，请参考插件功能页。</li></ul><p><strong>小程序插件中不能使用API</strong></p><table><thead><tr><th>wx.login</th><th>登录</th></tr></thead><tbody><tr><td>wx.getUserInfo</td><td>获取用户信息</td></tr><tr><td>wx.chooseAddress</td><td>获取用户收货地址</td></tr><tr><td>wx.requestPayment</td><td>【发起微信支付】</td></tr><tr><td>wx.addCard</td><td>添加卡券</td></tr><tr><td>wx.openCard</td><td>打开卡券</td></tr><tr><td>wx.saveFile</td><td>保存文件</td></tr><tr><td>wx.getSavedFileList</td><td>获取已保存的文件列表</td></tr><tr><td>wx.getSavedFileInfo</td><td>获取已保存的文件信息</td></tr><tr><td>wx.removeSavedFile</td><td>删除已保存的文件信息</td></tr><tr><td>wx.openDocument</td><td>打开文件</td></tr><tr><td>wx.getStorageInfo</td><td>获取本地缓存的相关信息</td></tr><tr><td>wx.getStorageInfoSync</td><td>获取本地缓存的相关信息</td></tr><tr><td>wx.clearStorage</td><td>清理本地数据缓存</td></tr><tr><td>wx.clearStorageSync</td><td>清理本地数据缓存</td></tr><tr><td>wx.setNavigationBarTitle</td><td>设置当前页面标题</td></tr><tr><td>wx.showNavigationBarLoading</td><td>显示导航条加载动画</td></tr><tr><td>wx.hideNavigationBarLoading</td><td>隐藏导航条加载动画</td></tr><tr><td>wx.navigateTo</td><td>新窗口打开页面</td></tr><tr><td>wx.redirectTo</td><td>原窗口打开页面</td></tr><tr><td>wx.switchTab</td><td>切换到 tabbar 页面</td></tr><tr><td>wx.navigateBack</td><td>退回上一个页面</td></tr><tr><td>wx.stopPullDownRefresh</td><td>停止下拉刷新动画</td></tr></tbody></table><h3 id="4-2-使用组件的限制"><a href="#4-2-使用组件的限制" class="headerlink" title="4.2 使用组件的限制"></a>4.2 使用组件的限制</h3><p>在插件开发中，以下组件不能在插件页面中使用：</p><ul><li>开放能力（open-type）为以下之一的 button： contact（打开客服会话） getPhoneNumber（获取用户手机号） getUserInfo（获取用户信息）</li><li>open-data</li><li>web-view 以下组件的使用对基础库版本有要求</li><li>navigator 需要基础库版本 2.1.0</li><li>live-player 和 live-pusher 需要基础库版本 2.3.0</li></ul><h3 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3 注意事项"></a>4.3 注意事项</h3><ul><li><strong>插件间互相调用</strong><ul><li>插件不能直接引用其他插件。但如果小程序引用了多个插件，插件之间是可以互相调用的。</li><li>一个插件调用另一个插件的方法，与插件调用自身的方法类似。可以使用 <code>plugin-private://APPID 访问插件的自定义组件、页面</code>（暂不能使用 plugin:// ）。</li><li>对于 js 接口，可使用 <code>requirePlugin</code> ，但目前尚不能在文件一开头就使用 <code>requirePlugin</code> ，因为被依赖的插件可能还没有初始化，请考虑在更晚的时机调用 <code>requirePlugin</code> ，如接口被实际调用时、组件 attached 时</li></ul></li></ul><h2 id="五、插件功能页"><a href="#五、插件功能页" class="headerlink" title="五、插件功能页"></a>五、插件功能页</h2><h3 id="5-1-插件功能页"><a href="#5-1-插件功能页" class="headerlink" title="5.1 插件功能页"></a>5.1 插件功能页</h3><p>插件功能页从小程序基础库版本 <code>2.1.0</code> 开始支持。</p><blockquote><p>某些接口不能在插件中直接调用（如 <code>wx.login</code>），但插件开发者可以使用插件功能页的方式来实现功能。目前，插件功能页包括</p></blockquote><ul><li>获取用户信息，包括 <code>openid</code>和昵称等（相当于 <code>wx.login</code> 和 <code>wx.getUserInfo</code>的功能），详见用户信息功能页</li><li>支付（相当于 <code>wx.requestPayment</code>），详见支付功能页；</li><li>获取收货地址（相当于 <code>wx.chooseAddress</code>），详见收货地址功能页。</li></ul><blockquote><p>要使用插件功能页，需要先激活功能页特性，配置对应的功能页函数，再使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/functional-page-navigator.html" target="_blank" rel="noopener">functional-page-navigator</a> 组件跳转到插件功能页，从而实现对应的功能</p></blockquote><ul><li>激活功能页特性<ul><li>要在插件中调用插件功能页，需要先激活插件所有者小程序的功能页特性</li><li><code>app.json</code> 文件中添加 <code>functionalPages</code> 定义段<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"functionalPages"</span>: &#123;</span><br><span class="line">    <span class="attr">"independent"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-2-跳转到功能页"><a href="#5-2-跳转到功能页" class="headerlink" title="5.2 跳转到功能页"></a>5.2 跳转到功能页</h3><blockquote><p>功能页不能使用 <code>wx.navigateTo</code> 来进行跳转，而是需要一个名为 <code>functional-page-navigator</code> 的组件。以获取用户信息为例，可以在插件中放置如下的 <code>functional-page-navigator</code></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">functional-page-navigator</span> <span class="attr">name</span>=<span class="string">"loginAndGetUserInfo"</span> <span class="attr">args</span>=<span class="string">""</span> <span class="attr">version</span>=<span class="string">"develop"</span> <span class="attr">bind:success</span>=<span class="string">"loginSuccess"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录到插件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">functional-page-navigator</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>用户在点击这个 <code>navigator</code> 时，会自动跳转到插件所有者小程序的对应功能页。功能页会提示用户进行登录或其他相应的操作。操作结果会以组件事件的方式返回。</li><li>从小程序基础库版本 2.4.0 开始，支持插件所有者小程序跳转到自己的功能页。在基础库版本低于 2.4.0 时，点击跳转到自己的功能页的 <code>functional-page-navigator</code> 将没有任何反应</li></ul><blockquote><p>注意：<code>functional-page-navigator</code> 的 <code>version=develop</code> 仅用于调试，因此在插件提审前，需要：</p></blockquote><ul><li>确保已发布设置了 <code>&quot;functionalPages&quot;: true</code> 的插件所有者小程序；</li><li>确保所有的 <code>functional-page-navigator</code> 组件属性设置为 <code>version=&quot;release&quot;</code></li></ul><h3 id="5-4-小程序部分功能页"><a href="#5-4-小程序部分功能页" class="headerlink" title="5.4 小程序部分功能页"></a>5.4 小程序部分功能页</h3><p><strong>1. 用户信息功能页</strong></p><blockquote><p>用户信息功能页用于帮助插件获取用户信息，包括 openid 和昵称等，相当于 wx.login 和 wx.getUserInfo 的功能。</p></blockquote><p>此外，自基础库版本 2.3.1 起，用户在这个功能页中授权之后，插件就可以直接调用 <code>wx.login 和 wx.getUserInfo</code> 。无需再次进入功能页获取用户信息。自基础库版本 2.6.3 起，可以使用 <code>wx.getSetting</code> 来查询用户是否授权过</p><p><strong>2. 支付功能页</strong></p><ul><li>支付功能页用于帮助插件完成支付，相当于 <code>wx.requestPayment</code> 的功能。</li><li>需要注意的是：插件使用支付功能，需要进行额外的权限申请，申请位置位于管理后台的<code>“小程序插件 -&gt; 基本设置 -&gt; 支付能力”</code>设置项中。另外，无论是否通过申请，主体为个人小程序在使用插件时，都无法正常使用插件里的支付功能。</li></ul><p><strong>3. 收货地址功能页</strong></p><p>收货地址功能页用于展示用户的收货地址列表，用户可以选择其中的收货地址。自基础库版本 2.4.0 开始支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、小程序插件功能介绍&quot;&gt;&lt;a href=&quot;#一、小程序插件功能介绍&quot; class=&quot;headerlink&quot; title=&quot;一、小程序插件功能介绍&quot;&gt;&lt;/a&gt;一、小程序插件功能介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;插件的开发和使用自小程序基础库版本 &lt;co
      
    
    </summary>
    
      <category term="Front-End" scheme="http://blog.poetries.top/categories/Front-End/"/>
    
    
      <category term="小程序" scheme="http://blog.poetries.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
